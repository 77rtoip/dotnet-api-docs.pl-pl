<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e9d6419b429a43792fc965aa3ddbec68dbfbbdb8" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68398351" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia metody tworzenia, manipulowania, wyszukiwania i sortowania tablic, a tym samym służy jako klasa bazowa dla wszystkich tablic w środowisku uruchomieniowym języka wspólnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa nie jest częścią <xref:System.Collections> przestrzeni nazw. <xref:System.Array> Jednak nadal jest traktowany jako kolekcja, ponieważ jest ona oparta na <xref:System.Collections.IList> interfejsie.  
  
 <xref:System.Array> Klasa jest klasą bazową dla implementacji języka, które obsługują tablice. Jednak tylko system i kompilatory mogą pochodzić jawnie z <xref:System.Array> klasy. Użytkownicy powinni stosować konstrukcje tablicowe udostępniane przez język.  
  
 Element jest wartością w <xref:System.Array>. Długość <xref:System.Array> elementu to całkowita liczba elementów, które może zawierać. Dolna granica <xref:System.Array> jest indeksem jego pierwszego elementu. <xref:System.Array> Może mieć dowolną dolną granicę, ale domyślnie ma dolną granicę równą zero. Podczas tworzenia wystąpienia <xref:System.Array> klasy przy użyciu <xref:System.Array.CreateInstance%2A>elementu można zdefiniować inną dolną granicę. Wielowymiarowe <xref:System.Array> może mieć różne granice dla każdego wymiaru. Tablica może mieć maksymalnie 32 wymiarów.  
  
 W przeciwieństwie do klas w <xref:System.Collections> <xref:System.Array> przestrzeniach nazw ma stałą pojemność. Aby zwiększyć pojemność, należy utworzyć nowy <xref:System.Array> obiekt z wymaganą pojemnością, skopiować elementy ze starego <xref:System.Array> obiektu do nowego i usunąć stary <xref:System.Array>.  

 Rozmiar tablicy jest ograniczony do całkowitej liczby elementów 4 000 000 000 i maksymalny indeks 0X7FEFFFFF w dowolnym wymiarze (0X7FFFFFC7 dla tablic bajtowych i tablic struktur o pojedynczej bajcie).
  
 **Tylko .NET Framework:** Domyślnie maksymalny rozmiar <xref:System.Array> wynosi 2 gigabajty (GB). W środowisku 64-bitowym można uniknąć ograniczenia rozmiaru przez ustawienie `enabled` atrybutu elementu konfiguracji [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) na `true` w środowisku wykonawczym.
  
 Tablice <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>jednowymiarowe implementują interfejsy, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, i <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> . Implementacje są dostarczane do tablic w czasie wykonywania, a w efekcie interfejsy ogólne nie są wyświetlane w składni deklaracji dla <xref:System.Array> klasy. Ponadto nie ma żadnych tematów referencyjnych dla elementów członkowskich interfejsu, które są dostępne tylko przez rzutowanie tablicy do ogólnego typu interfejsu (jawne implementacje interfejsu). Klucz, z którego należy zwrócić uwagę podczas rzutowania tablicy do jednego z tych interfejsów, jest to, że członkowie, którzy dodają, wstawiają <xref:System.NotSupportedException>lub usuwają elementy.  
  
 <xref:System.Type>obiekty zawierają informacje dotyczące deklaracji typu tablicy. <xref:System.Array>obiekty o tym samym typie tablicy współużytkują <xref:System.Type> ten sam obiekt.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType>i <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> mogą nie zwracać oczekiwanych wyników w <xref:System.Array> przypadku, gdy tablica jest rzutowana na typ <xref:System.Array>, wynik jest obiektem, a nie tablicą. Oznacza to, `typeof(System.Array).IsArray` zwraca `false`i `typeof(System.Array).GetElementType` zwraca. `null`  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> Metoda kopiuje elementy nie tylko między tablicami tego samego typu, ale również między standardowymi tablicami różnych typów; obsługuje rzutowanie typu automatycznie.  
  
 Niektóre metody, takie jak <xref:System.Array.CreateInstance%2A> <xref:System.Array.CopyTo%2A>, <xref:System.Array.Copy%2A> <xref:System.Array.GetValue%2A>,, i <xref:System.Array.SetValue%2A>, zapewniają przeciążenia, które akceptują 64-bitowe liczby całkowite jako parametry w celu uwzględnienia tablic dużych pojemności. <xref:System.Array.LongLength%2A>i <xref:System.Array.GetLongLength%2A> Zwróć 64-bitową liczbę całkowitą wskazującą długość tablicy.  
  
 Sortowanie <xref:System.Array> nie jest gwarantowane.  Należy posortować <xref:System.Array> przed wykonaniem operacji (takich jak <xref:System.Array.BinarySearch%2A>), które wymagają <xref:System.Array> posortowania.  
  
 Użycie obiektu wskaźników w kodzie natywnym nie jest obsługiwane i spowoduje <xref:System.NotSupportedException> zgłoszenie do kilku metod. <xref:System.Array>  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Array.Copy%2A?displayProperty=nameWithType> Kopiuje elementy między tablicą typu integer i tablicą typu. <xref:System.Object>  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu tworzy i inicjuje <xref:System.Array> i wyświetla jego właściwości oraz jego elementy.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Ta implementacja nie zapewnia elementu "Synchronized" (bezpieczny wątkowo) <see cref="T:System.Array" />dla elementu, jednak klasy .NET Framework w <see cref="T:System.Array" /> oparciu o dostarczenie własnej synchronizowanej wersji kolekcji przy <see cref="P:System.Array.SyncRoot" /> użyciu właściwości.  
  
Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Tablice (Przewodnik programowania w języku C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Tablice w Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, która może być zawijana w otoki tylko <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> do odczytu.</param>
        <summary>Zwraca otokę tylko do odczytu dla określonej tablicy.</summary>
        <returns>Otoka tylko <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> do odczytu dla określonej tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec modyfikacji tablicy, Uwidocznij tablicę tylko za pomocą tej otoki.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład otacza tablicę w trybie tylko <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>do odczytu.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje jednowymiarowo posortowane <see cref="T:System.Array" /> wartości przy użyciu algorytmu wyszukiwania binarnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanie jednowymiarowe <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje całą jednowymiarową tablicę posortowaną dla określonego elementu przy <see cref="T:System.IComparable" /> użyciu interfejsu zaimplementowanego przez każdy element tablicy i określonego obiektu.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 <xref:System.Array> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest większy niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Każdy element musi implementować <xref:System.IComparable> interfejs, który jest używany do porównywania. `array` `value` Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli`value` nie <xref:System.IComparable> implementuje <xref:System.IComparable> interfejsu, elementy nie sątestowanedlaprzed`array` rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>elementu.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Array.BinarySearch%2A> do lokalizowania określonego obiektu <xref:System.Array>w obiekcie.  
  
> [!NOTE]
>  Tablica zostanie utworzona wraz z jej elementami w kolejności sortowania rosnącej. <xref:System.Array.BinarySearch%2A> Metoda wymaga, aby tablica była posortowana w kolejności rosnącej.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />nie implementuje <see cref="T:System.IComparable" /> interfejsu, a wyszukiwanie napotka element, który nie <see cref="T:System.IComparable" /> implementuje interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanie jednowymiarowe <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer"><see cref="T:System.Collections.IComparer" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Przeszukuje całą jednowymiarową tablicę posortowaną dla wartości przy <see cref="T:System.Collections.IComparer" /> użyciu określonego interfejsu.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 <xref:System.Array> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest większy niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` `array` <xref:System.Collections.IComparer> nie `null`jest, elementy są porównywane z określoną wartością przy użyciu określonej implementacji. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli`comparer` jest `null` ,<xref:System.IComparable> porównywanie odbywa się przy użyciu implementacji dostarczonej przez sam element lub przez określoną wartość. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` <xref:System.IComparable> i nie`value` implementuje interfejsu,`array` elementy nie są testowane dla przed rozpoczęciem wyszukiwania. <xref:System.IComparable> Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>elementu.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" />is <see langword="null" /> <paramref name="array" />i <paramref name="value" /> jest typu, który nie jest zgodny z elementami.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />nie implementuje interfejsu, a wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu. <see cref="T:System.IComparable" /> <see langword="null" /> <paramref name="value" /></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanie jednowymiarowe <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje zakres elementów w jednowymiarowej posortowanej tablicy dla wartości przy użyciu <see cref="T:System.IComparable" /> interfejsu zaimplementowanego przez każdy element tablicy i według określonej wartości.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 <xref:System.Array> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest większy niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Każdy element musi implementować <xref:System.IComparable> interfejs, który jest używany do porównywania. `array` `value` Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `value` nie <xref:System.IComparable> implementuje <xref:System.IComparable> interfejsu, elementy nie sątestowanedlaprzed`array` rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>elementu.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
 <paramref name="value" />jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />nie implementuje <see cref="T:System.IComparable" /> interfejsu, a wyszukiwanie napotka element, który nie <see cref="T:System.IComparable" /> implementuje interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanie jednowymiarowe <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer"><see cref="T:System.Collections.IComparer" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Przeszukuje zakres elementów w jednowymiarowej posortowanej tablicy dla wartości przy użyciu określonego <see cref="T:System.Collections.IComparer" /> interfejsu.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 <xref:System.Array> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest większy niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` `array` <xref:System.Collections.IComparer> nie `null`jest, elementy są porównywane z określoną wartością przy użyciu określonej implementacji. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null` ,<xref:System.IComparable> porównywanie odbywa się przy użyciu implementacji dostarczonej przez sam element lub przez określoną wartość. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` <xref:System.IComparable> i nie`value` implementuje interfejsu,`array` elementy nie są testowane dla przed rozpoczęciem wyszukiwania. <xref:System.IComparable> Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>elementu.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku podczas <xref:System.IComparable>korzystania z programu.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
 <paramref name="comparer" />is <see langword="null" /> <paramref name="array" />i <paramref name="value" /> jest typu, który nie jest zgodny z elementami.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />nie implementuje interfejsu, a wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu. <see cref="T:System.IComparable" /> <see langword="null" /> <paramref name="value" /></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanie jednowymiarowe, od <see cref="T:System.Array" /> zera do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje całą jednowymiarową tablicę posortowaną dla określonego elementu przy <see cref="T:System.IComparable`1" /> użyciu interfejsu ogólnego zaimplementowanego przez każdy element <see cref="T:System.Array" /> i według określonego obiektu.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 Jeśli `array` nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T`musi implementować <xref:System.IComparable%601> interfejs ogólny, który jest używany do porównywania. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable%601> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable%601> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable%601> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> Przeciążenie metody ogólnej <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> i Przeciążenie metody ogólnej. Zostanie utworzona tablica ciągów, w której nie ma określonej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Aby można było użyć metody, <xref:System.Array.BinarySearch%2A> tablice muszą być posortowane.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 Przeciążenie <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> metody ogólnej służy następnie do wyszukiwania dwóch ciągów, jeden, który nie znajduje się w tablicy i jeden. Tablica i wartość <xref:System.Array.BinarySearch%2A> zwracana metody są przenoszone `ShowWhere` do metody generycznej, która wyświetla wartość indeksu, jeśli ciąg zostanie znaleziony i w przeciwnym razie elementy, do których odbędzie się ciąg wyszukiwania, między, jeśli znajdowały się w tablicy. Indeks ma wartość ujemną, jeśli ciąg nie znajduje się w `ShowWhere` tablicy, więc metoda pobiera dopełnienie bitowe (operator ~ w C# i wizualizacja C++, `Xor`-1 w Visual Basic), aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" />nie implementuje <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanie jednowymiarowe, od <see cref="T:System.Array" /> zera do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable`1" /> implementacji każdego elementu.</param>
        <summary>Przeszukuje całą jednowymiarową tablicę posortowaną dla wartości przy <see cref="T:System.Collections.Generic.IComparer`1" /> użyciu określonego interfejsu ogólnego.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 <xref:System.Array> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` `array` <xref:System.Collections.Generic.IComparer%601> nie `null`jest, elementy są porównywane z określoną wartością przy użyciu określonej implementacji interfejsu ogólnego. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null`, porównywanie`T`odbywa się przy użyciu ogólnejimplementacjiinterfejsudostarczonejprzez.<xref:System.IComparable%601> Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable%601> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i`value` nie <xref:System.IComparable%601>implementujeinterfejsu generycznego,elementyniesątestowanedlaprzedrozpoczęciemwyszukiwania.`array` <xref:System.IComparable%601> Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable%601>elementu.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable%601> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable%601> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie metody ogólnej <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i Przeciążenie metody ogólnej.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Aby można było użyć metody, <xref:System.Array.BinarySearch%2A> tablice muszą być posortowane.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 Przeciążenie <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólnej służy następnie do wyszukiwania dwóch ciągów, jeden, który nie znajduje się w tablicy i jeden. Tablica i wartość <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> zwracana metody są przenoszone `ShowWhere` do metody generycznej, która wyświetla wartość indeksu, jeśli ciąg zostanie znaleziony i w przeciwnym razie elementy, do których odbędzie się ciąg wyszukiwania, między, jeśli znajdowały się w tablicy. Indeks ma wartość ujemną, jeśli ciąg nie `ShowWhere` jest n tablicą, więc metoda przyjmuje dopełnienie bitowe (operator ~ w C# i wizualizacja C++, `Xor` -1 w Visual Basic), aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" />is <see langword="null" /> <paramref name="array" />i <paramref name="value" /> jest typu, który nie jest zgodny z elementami.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i <paramref name="T" /> nie implementuje<see cref="T:System.IComparable`1" /> interfejsu generycznego</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanie jednowymiarowe, od <see cref="T:System.Array" /> zera do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje zakres elementów w jednowymiarowej posortowanej tablicy dla wartości przy użyciu <see cref="T:System.IComparable`1" /> ogólnego interfejsu implementowanego przez każdy element <see cref="T:System.Array" /> i według określonej wartości.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 Jeśli tablica nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T`musi implementować <xref:System.IComparable%601> interfejs ogólny, który jest używany do porównywania. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable%601> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable%601> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable%601> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
 <paramref name="value" />jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" />nie implementuje <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanie jednowymiarowe, od <see cref="T:System.Array" /> zera do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable`1" /> implementacji każdego elementu.</param>
        <summary>Przeszukuje zakres elementów w jednowymiarowej posortowanej tablicy dla wartości przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejsu ogólnego.</summary>
        <returns>Indeks określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> został znaleziony; w przeciwnym razie liczba ujemna. Jeśli <paramref name="value" /> nie zostanie znaleziona <paramref name="value" /> i jest mniejsza niż co najmniej jeden element <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie odnaleziony <paramref name="value" /> i jest większy niż wszystkie elementy <paramref name="array" />w, zwracana liczba ujemna jest odwrotnym uzupełnieniem (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z posortowaną <paramref name="array" />, wartość zwracana może być niepoprawna i można zwrócić liczbę ujemną, nawet jeśli <paramref name="value" /> jest obecna w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje wyszukiwania tablic zawierających indeksy ujemne. `array`Należy posortować przed wywołaniem tej metody.  
  
 Jeśli tablica nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w C#, `Not` w Visual Basic) do wyniku negatywnego, aby utworzyć indeks. Jeśli ten indeks jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` `array` <xref:System.Collections.Generic.IComparer%601> nie `null`jest, elementy są porównywane z określoną wartością przy użyciu określonej implementacji interfejsu ogólnego. Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null`, porównywanie`T`odbywa się przy użyciu ogólnejimplementacjiinterfejsupodanejdlatypu.<xref:System.IComparable%601> Elementy elementu `array` muszą być już posortowane w rosnącej wartości zgodnie z porządkiem sortowania zdefiniowanym <xref:System.IComparable%601> przez implementację; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli zawiera więcej niż jeden element `value`równy, metoda zwraca indeks tylko jednego z wystąpień i niekoniecznie pierwszy z nich. <xref:System.Array>  
  
 `null`zawsze można porównać z dowolnym innym typem referencyjnym; w związku z tym `null` porównania z nie generują wyjątku podczas <xref:System.IComparable%601>korzystania z programu.  
  
> [!NOTE]
>  Dla każdego testowanego `value` elementu jest przenoszona do odpowiedniej <xref:System.IComparable%601> implementacji, nawet jeśli `value` jest `null`. Oznacza to, <xref:System.IComparable%601> że implementacja określa sposób porównania danego elementu z `null`.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
 <paramref name="comparer" />is <see langword="null" /> <paramref name="array" />i <paramref name="value" /> jest typu, który nie jest zgodny z elementami.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i <paramref name="T" /> nie implementuje<see cref="T:System.IComparable`1" /> interfejsu generycznego.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, której elementy muszą zostać wyczyszczone.</param>
        <param name="index">Początkowy indeks zakresu elementów do wyczyszczenia.</param>
        <param name="length">Liczba elementów do wyczyszczenia.</param>
        <summary>Ustawia zakres elementów w tablicy na wartość domyślną każdego typu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda resetuje każdy element w tablicy do wartości domyślnej typu elementu. Ustawia elementy typów referencyjnych (w tym <xref:System.String> elementy) do `null`i ustawia elementy typów wartości na wartości domyślne pokazane w poniższej tabeli.  
  
|Typ|Wartość|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Wszystkie typy liczbowe całkowite i zmiennoprzecinkowe|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Inne typy wartości|Wartość domyślna pól typu|  
  
 Zakres wyczyszczonych elementów jest zawijany z wiersza do wiersza w tablicy wielowymiarowej.  
  
 Ta metoda czyści jedynie wartości elementów; nie usuwa samych elementów. Tablica ma stały rozmiar; w związku z tym nie można dodawać ani usuwać elementów.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Array.Clear%2A> metody do resetowania wartości całkowitych w tablicy jednowymiarowej, dwuwymiarowej i trójwymiarowej.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `TimeZoneTime` strukturę, która <xref:System.TimeZoneInfo> zawiera pole i <xref:System.DateTimeOffset> pole. Następnie wywołuje <xref:System.Array.Clear%2A> metodę w celu wyczyszczenia jednego elementu w dwuelementowej `TimeZoneTime` tablicy wartości. Metoda ustawia wartość wyczyszczonego <xref:System.TimeZoneInfo> elementu na wartość domyślną obiektu, co oznacza `null`, i wartość <xref:System.DateTimeOffset> domyślną obiektu, czyli <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.  
  
—lub— 
Suma <paramref name="index" /> i <paramref name="length" /> jest większaniżrozmiar.<paramref name="array" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy skróconą kopię <see cref="T:System.Array" />.</summary>
        <returns>Skrócona kopia <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Replika kopii <xref:System.Array> tylko elementów <xref:System.Array>, niezależnie od tego, czy są to typy odwołań czy typy wartości, ale nie kopiuje obiektów, do których odwołują się odwołania. Odwołania w nowym <xref:System.Array> punkcie do tych samych obiektów, do których odwołują się odwołania w <xref:System.Array> punkcie pierwotnym.  
  
 Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 Klon jest taki sam <xref:System.Type> jak oryginalny. <xref:System.Array>  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu klonuje <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> tablicę i demonstruje zachowanie kopii skróconej.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> Zawiera dane do skopiowania.</param>
        <param name="sourceIndex">32-bitowa liczba całkowita reprezentująca indeks, w <paramref name="sourceArray" /> którym rozpoczyna się kopiowanie.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> , Który odbiera dane.</param>
        <param name="destinationIndex">32-bitowa liczba całkowita reprezentująca indeks, w <paramref name="destinationArray" /> którym rozpoczyna się przechowywanie.</param>
        <param name="length">32-bitowa liczba całkowita reprezentująca liczbę elementów do skopiowania.</param>
        <summary>Kopiuje zakres elementów z elementu <see cref="T:System.Array" /> rozpoczynającego się od określonego indeksu źródłowego i wkleja je do innego <see cref="T:System.Array" /> , rozpoczynając od określonego indeksu docelowego.  Gwarantuje, że wszystkie zmiany są cofnięte, jeśli kopia nie zostanie całkowicie zakończona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceArray` i`destinationArray` muszą mieć taką samą liczbę wymiarów.  Typ musi być taki sam jak lub pochodny `destinationArray` <xref:System.ArrayTypeMismatchException> typu; w przeciwnym razie jest zgłaszany. `sourceArray`  W <xref:System.Array.Copy%2A>przeciwieństwie <xref:System.Array.ConstrainedCopy%2A> do, weryfikuje zgodność typów tablic przed wykonaniem jakiejkolwiek operacji.  
  
 Podczas kopiowania między tablicami wielowymiarowymi, tablica zachowuje się jak długa tablica Jednowymiarowa, gdzie wiersze (lub kolumny) są koncepcyjnie określane jako kompleksowe. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), musi to być `sourceIndex` Górna granica pierwszego wiersza (lub kolumny), a także długość drugiego wiersza (lub kolumny) i dwóch.  
  
 Jeśli `sourceArray` `sourceArray` `destinationArray` i `destinationArray` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości zostały zachowane w tymczasowej lokalizacji przed zastąpieniem.  
  
 [C++]  
  
 Ta metoda jest równoważna z standardową funkcjąC++ `memmove`C/, `memcpy`a nie.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.  Jeśli `sourceArray` <xref:System.Object>i `destinationArray` są tablicami typu odwołania lub są tablicami typu, wykonywana jest kopia na płytki. Kopia <xref:System.Array> skrócona programu jest nowym <xref:System.Array> zawierającym odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, `destinationArray` pozostaje niezmieniona; w <xref:System.Array.ConstrainedCopy%2A> związku z tym może być używana w ograniczonym regionie wykonywania (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają różne Range.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Typ nie jest taki sam jak ani pochodny <paramref name="destinationArray" /> od typu. <paramref name="sourceArray" /></exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie może być rzutowany na <paramref name="destinationArray" />typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />jest mniejsza niż Dolna granica pierwszego wymiaru <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" />jest mniejsza niż Dolna granica pierwszego wymiaru <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" />jest większa niż liczba elementów od <paramref name="sourceIndex" /> do <paramref name="sourceArray" />końca.  
  
—lub— 
 <paramref name="length" />jest większa niż liczba elementów od <paramref name="destinationIndex" /> do <paramref name="destinationArray" />końca.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Typ elementów tablicy źródłowej.</typeparam>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="array">Jednowymiarowa, różna od <see cref="T:System.Array" /> zera, która ma zostać przekonwertowana na typ docelowy.</param>
        <param name="converter">A <see cref="T:System.Converter`2" /> , który konwertuje każdy element z jednego typu na inny typ.</param>
        <summary>Konwertuje tablicę jednego typu na tablicę innego typu.</summary>
        <returns>Tablica typu docelowego zawierającego przekonwertowane elementy z tablicy źródłowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegatem do metody, która konwertuje obiekt na typ docelowy.  Elementy `array` są indywidualnie przenoszone <xref:System.Converter%602>do i konwertowane elementy są zapisywane w nowej tablicy.  
  
 Źródło `array` pozostaje niezmienione.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje metodę o nazwie `PointFToPoint` , która <xref:System.Drawing.PointF> konwertuje strukturę na <xref:System.Drawing.Point> strukturę. <xref:System.Drawing.PointF> Przykład tworzy tablicę struktur,`Converter(Of PointF, Point)` `Converter<PointF, Point>` tworzy delegata (w Visual Basic) do reprezentowania `PointFToPoint` metody i przekazuje delegata do <xref:System.Array.ConvertAll%2A> metody. Metoda przekazuje każdy element listy wejściowej `PointFToPoint` do metody i umieszcza przekonwertowane elementy <xref:System.Drawing.Point> do nowej listy struktur. <xref:System.Array.ConvertAll%2A> Wyświetlane są obie listy.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="converter" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje zakres elementów w jeden <see cref="T:System.Array" /> do drugiego <see cref="T:System.Array" /> i wykonuje rzutowanie typu i opakowanie zgodnie z wymaganiami.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> Zawiera dane do skopiowania.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> , Który odbiera dane.</param>
        <param name="length">32-bitowa liczba całkowita reprezentująca liczbę elementów do skopiowania.</param>
        <summary>Kopiuje zakres elementów od <see cref="T:System.Array" /> początku pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> , zaczynając od pierwszego elementu. Długość jest określana jako 32-bitowa liczba całkowita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceArray` i`destinationArray` muszą mieć taką samą liczbę wymiarów. Ponadto, `destinationArray` należy już mieć wymiar i musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane dane.  
  
 Podczas kopiowania między tablicami wielowymiarowymi tablica zachowuje się jak długa tablica Jednowymiarowa, w której te wiersze (lub kolumny) są koncepcyjnie ustalone na końcu. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` `sourceArray` `destinationArray` i `destinationArray` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości zostały zachowane w tymczasowej lokalizacji przed zastąpieniem.  
  
 [C++]  
  
 Ta metoda jest równoważna z standardową funkcjąC++ `memmove`C/, `memcpy`a nie.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy <xref:System.Object> , jest tworzona do przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości, a przypisanie nie jest możliwe <xref:System.InvalidCastException> , zostanie zgłoszony.  
  
-   Jeśli `sourceArray` <xref:System.Object>i `destinationArray` są tablicami typu odwołania lub są tablicami typu, wykonywana jest kopia na płytki. Kopia <xref:System.Array> skrócona programu jest nowym <xref:System.Array> zawierającym odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest zgłaszany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu zaimplementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję <xref:System.Enum> na i ich typ podstawowy.  
  
 Jeśli każdy element w `sourceArray` wymaga elementu downcast (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu do obiektu), a co najmniej jeden element nie może zostać rzutowany do odpowiedniego typu w `destinationArray`, <xref:System.InvalidCastException> zostanie zgłoszony.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają różne Range.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie może być rzutowany na <paramref name="destinationArray" />typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" />jest większa niż liczba elementów w <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" />jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> Zawiera dane do skopiowania.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> , Który odbiera dane.</param>
        <param name="length">64-bitowa liczba całkowita reprezentująca liczbę elementów do skopiowania. Liczba całkowita musi należeć do zakresu <see cref="F:System.Int32.MaxValue" />od zera do włącznie.</param>
        <summary>Kopiuje zakres elementów od <see cref="T:System.Array" /> początku pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> , zaczynając od pierwszego elementu. Długość jest określana jako 64-bitowa liczba całkowita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceArray` i`destinationArray` muszą mieć taką samą liczbę wymiarów. Ponadto, `destinationArray` należy już mieć wymiar i musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane dane.  
  
 Podczas kopiowania między tablicami wielowymiarowymi tablica zachowuje się jak długa tablica Jednowymiarowa, w której te wiersze (lub kolumny) są koncepcyjnie ustalone na końcu. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` `sourceArray` `destinationArray` i `destinationArray` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości zostały zachowane w tymczasowej lokalizacji przed zastąpieniem.  
  
 [C++]  
  
 Ta metoda jest równoważna z standardową funkcjąC++ `memmove`C/, `memcpy`a nie.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy <xref:System.Object> , jest tworzona do przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości, a przypisanie nie jest możliwe <xref:System.InvalidCastException> , zostanie zgłoszony.  
  
-   Jeśli `sourceArray` <xref:System.Object>i `destinationArray` są tablicami typu odwołania lub są tablicami typu, wykonywana jest kopia na płytki. Kopia <xref:System.Array> skrócona programu jest nowym <xref:System.Array> zawierającym odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest zgłaszany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu zaimplementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję <xref:System.Enum> na i ich typ podstawowy.  
  
 Jeśli każdy element w `sourceArray` wymaga elementu downcast (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu do obiektu), a co najmniej jeden element nie może zostać rzutowany do odpowiedniego typu w `destinationArray`, <xref:System.InvalidCastException> zostanie zgłoszony.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają różne Range.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie może być rzutowany na <paramref name="destinationArray" />typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" />jest mniejsza niż 0 lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" />jest większa niż liczba elementów w <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" />jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> Zawiera dane do skopiowania.</param>
        <param name="sourceIndex">32-bitowa liczba całkowita reprezentująca indeks, w <paramref name="sourceArray" /> którym rozpoczyna się kopiowanie.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> , Który odbiera dane.</param>
        <param name="destinationIndex">32-bitowa liczba całkowita reprezentująca indeks, w <paramref name="destinationArray" /> którym rozpoczyna się przechowywanie.</param>
        <param name="length">32-bitowa liczba całkowita reprezentująca liczbę elementów do skopiowania.</param>
        <summary>Kopiuje zakres elementów z elementu <see cref="T:System.Array" /> rozpoczynającego się od określonego indeksu źródłowego i wkleja je do innego <see cref="T:System.Array" /> , rozpoczynając od określonego indeksu docelowego. Długość i indeksy są określone jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceArray` i`destinationArray` muszą mieć taką samą liczbę wymiarów. Ponadto, `destinationArray` musi być już zwymiarowane i muszą mieć wystarczającą liczbę elementów rozpoczynając `destinationIndex` od pozycji, aby pomieścić skopiowane dane.  
  
 Podczas kopiowania między tablicami wielowymiarowymi, tablica zachowuje się jak długa tablica Jednowymiarowa, gdzie wiersze (lub kolumny) są koncepcyjnie określane jako kompleksowe. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), musi to być `sourceIndex` Górna granica pierwszego wiersza (lub kolumny), a także długość drugiego wiersza (lub kolumny) i dwóch.  
  
 Jeśli `sourceArray` `sourceArray` `destinationArray` i `destinationArray` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości zostały zachowane w tymczasowej lokalizacji przed zastąpieniem.  
  
 [C++]  
  
 Ta metoda jest równoważna z standardową funkcjąC++ `memmove`C/, `memcpy`a nie.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy <xref:System.Object> , jest tworzona do przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości, a przypisanie nie jest możliwe <xref:System.InvalidCastException> , zostanie zgłoszony.  
  
-   Jeśli `sourceArray` <xref:System.Object>i `destinationArray` są tablicami typu odwołania lub są tablicami typu, wykonywana jest kopia na płytki. Kopia <xref:System.Array> skrócona programu jest nowym <xref:System.Array> zawierającym odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest zgłaszany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu zaimplementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję <xref:System.Enum> na i ich typ podstawowy.  
  
 Jeśli każdy element w `sourceArray` wymaga elementu downcast (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu do obiektu), a co najmniej jeden element nie może zostać rzutowany do odpowiedniego typu w `destinationArray`, <xref:System.InvalidCastException> zostanie zgłoszony.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak skopiować z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają różne Range.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie może być rzutowany na <paramref name="destinationArray" />typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />jest mniejsza niż Dolna granica pierwszego wymiaru <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" />jest mniejsza niż Dolna granica pierwszego wymiaru <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" />jest większa niż liczba elementów od <paramref name="sourceIndex" /> do <paramref name="sourceArray" />końca.  
  
—lub— 
 <paramref name="length" />jest większa niż liczba elementów od <paramref name="destinationIndex" /> do <paramref name="destinationArray" />końca.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> Zawiera dane do skopiowania.</param>
        <param name="sourceIndex">64-bitowa liczba całkowita reprezentująca indeks, w <paramref name="sourceArray" /> którym rozpoczyna się kopiowanie.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> , Który odbiera dane.</param>
        <param name="destinationIndex">64-bitowa liczba całkowita reprezentująca indeks, w <paramref name="destinationArray" /> którym rozpoczyna się przechowywanie.</param>
        <param name="length">64-bitowa liczba całkowita reprezentująca liczbę elementów do skopiowania. Liczba całkowita musi należeć do zakresu <see cref="F:System.Int32.MaxValue" />od zera do włącznie.</param>
        <summary>Kopiuje zakres elementów z elementu <see cref="T:System.Array" /> rozpoczynającego się od określonego indeksu źródłowego i wkleja je do innego <see cref="T:System.Array" /> , rozpoczynając od określonego indeksu docelowego. Długość i indeksy są określone jako 64-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceArray` i`destinationArray` muszą mieć taką samą liczbę wymiarów. Ponadto, `destinationArray` musi być już zwymiarowane i muszą mieć wystarczającą liczbę elementów rozpoczynając `destinationIndex` od pozycji, aby pomieścić skopiowane dane.  
  
 Podczas kopiowania między tablicami wielowymiarowymi, tablica zachowuje się jak długa tablica Jednowymiarowa, gdzie wiersze (lub kolumny) są koncepcyjnie określane jako kompleksowe. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), musi to być `sourceIndex` Górna granica pierwszego wiersza (lub kolumny), a także długość drugiego wiersza (lub kolumny) i dwóch.  
  
 Jeśli `sourceArray` `sourceArray` `destinationArray` i `destinationArray` nakładają się, ta metoda zachowuje się tak, jakby oryginalne wartości zostały zachowane w tymczasowej lokalizacji przed zastąpieniem.  
  
 [C++]  
  
 Ta metoda jest równoważna z standardową funkcjąC++ `memmove`C/, `memcpy`a nie.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy <xref:System.Object> , jest tworzona do przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości, a przypisanie nie jest możliwe <xref:System.InvalidCastException> , zostanie zgłoszony.  
  
-   Jeśli `sourceArray` <xref:System.Object>i `destinationArray` są tablicami typu odwołania lub są tablicami typu, wykonywana jest kopia na płytki. Kopia <xref:System.Array> skrócona programu jest nowym <xref:System.Array> zawierającym odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei Szczegółowa kopia elementu <xref:System.Array> Kopiuje elementy i wszystko, bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest zgłaszany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu zaimplementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję <xref:System.Enum> na i ich typ podstawowy.  
  
 Jeśli każdy element w `sourceArray` wymaga elementu downcast (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu do obiektu), a co najmniej jeden element nie może zostać rzutowany do odpowiedniego typu w `destinationArray`, <xref:System.InvalidCastException> zostanie zgłoszony.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak skopiować z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają różne Range.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" />i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie może być rzutowany na <paramref name="destinationArray" />typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />znajduje się poza zakresem prawidłowych indeksów dla <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" />znajduje się poza zakresem prawidłowych indeksów dla <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza niż 0 lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" />jest większa niż liczba elementów od <paramref name="sourceIndex" /> do <paramref name="sourceArray" />końca.  
  
—lub— 
 <paramref name="length" />jest większa niż liczba elementów od <paramref name="destinationIndex" /> do <paramref name="destinationArray" />końca.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje wszystkie elementy bieżącej tablicy jednowymiarowej do określonej jednowymiarowej tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z bieżącej tablicy.</param>
        <param name="index">32-bitowa liczba całkowita reprezentująca indeks, w <paramref name="array" /> którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje wszystkie elementy bieżącej tablicy jednowymiarowej do określonej jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy bieżącego wystąpienia tablicy do `array` tablicy docelowej, rozpoczynając od indeksu. `index` Tablica `array` docelowa musi mieć już wymiar i musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejs. Jeśli implementacja <xref:System.Collections.ICollection?displayProperty=nameWithType> nie jest jawnie wymagana, użyj <xref:System.Array.Copy%2A> , aby uniknąć dodatkowego pośrednika.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Array.Length%2A>. Wykonuje tylko kopię skróconą.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Array> jak skopiować do innego. <xref:System.Array>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak skopiować element <xref:System.Array> do innego <xref:System.Array> z niezerowym ograniczeniem. Należy pamiętać, że kopiowane <xref:System.Array> jest całe źródło, w tym puste elementy, które zastępują istniejące <xref:System.Array>elementy w elemencie docelowym.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
Liczba elementów w tablicy źródłowej jest większa niż dostępna liczba elementów od <paramref name="index" /> do końca miejsca docelowego. <paramref name="array" /></exception>
        <exception cref="T:System.ArrayTypeMismatchException">Nie można automatycznie rzutować <see cref="T:System.Array" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
        <exception cref="T:System.RankException">Tablica źródłowa jest wielowymiarowa.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jednego elementu w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy. <paramref name="array" /></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z bieżącej tablicy.</param>
        <param name="index">64-bitowa liczba całkowita reprezentująca indeks, w <paramref name="array" /> którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje wszystkie elementy bieżącej tablicy jednowymiarowej do określonej jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy bieżącego wystąpienia tablicy do `array` tablicy docelowej, rozpoczynając od indeksu. `index` Tablica `array` docelowa musi mieć już wymiar i musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejs. Jeśli implementacja <xref:System.Collections.ICollection?displayProperty=nameWithType> nie jest jawnie wymagana, użyj <xref:System.Array.Copy%2A> , aby uniknąć dodatkowego pośrednika.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowany.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Array.Length%2A>. Wykonuje tylko kopię skróconą.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Array> jak skopiować do innego. <xref:System.Array>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak skopiować element <xref:System.Array> do innego <xref:System.Array> z niezerowym ograniczeniem. Należy pamiętać, że kopiowane <xref:System.Array> jest całe źródło, w tym puste elementy, które zastępują istniejące <xref:System.Array>elementy w elemencie docelowym.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
Liczba elementów w tablicy źródłowej jest większa niż dostępna liczba elementów od <paramref name="index" /> do końca miejsca docelowego. <paramref name="array" /></exception>
        <exception cref="T:System.ArrayTypeMismatchException">Nie można automatycznie rzutować <see cref="T:System.Array" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
        <exception cref="T:System.RankException">Źródło <see cref="T:System.Array" /> jest wielowymiarowe.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jednego elementu w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy. <paramref name="array" /></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Array" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length">Rozmiar, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <summary>Tworzy jednowymiarową <see cref="T:System.Array" /> określoną <see cref="T:System.Type" /> długość i z indeksowaniem opartym na zero.</summary>
        <returns>Nowe jednowymiarowe <see cref="T:System.Array" /> o <see cref="T:System.Type" /> określonej długości przy użyciu indeksowania opartego na zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować jednowymiarowo <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Tablica 32-bitowych liczb całkowitych reprezentujących rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarową <see cref="T:System.Array" /> określoną <see cref="T:System.Type" /> długość i długości wymiarów przy użyciu indeksowania od zera. Długości wymiarów są określone w tablicy 32-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowy <see cref="T:System.Array" /> określony <see cref="T:System.Type" /> z określoną długością dla każdego wymiaru, przy użyciu indeksowania opartego na zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczbie wymiarów w nowym <xref:System.Array>. Każdy element `lengths` tablicy musi określać długość odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest iloczynem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowy <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w <paramref name="lengths" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Tablica 64-bitowych liczb całkowitych reprezentujących rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia. Każda liczba całkowita w tablicy musi się mieścić w przedziale od 0 do <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Tworzy wielowymiarową <see cref="T:System.Array" /> określoną <see cref="T:System.Type" /> długość i długości wymiarów przy użyciu indeksowania od zera. Długości wymiarów są określone w tablicy 64-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowy <see cref="T:System.Array" /> określony <see cref="T:System.Type" /> z określoną długością dla każdego wymiaru, przy użyciu indeksowania opartego na zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczbie wymiarów w nowym <xref:System.Array>. Każdy element `lengths` tablicy musi określać długość odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest iloczynem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowy <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w <paramref name="lengths" /> jest mniejsza od zera lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszego wymiaru, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <param name="length2">Rozmiar drugiego wymiaru, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <summary>Tworzy dwuwymiarową <see cref="T:System.Array" /> określoną <see cref="T:System.Type" /> długość i długości wymiarów przy użyciu indeksowania od zera.</summary>
        <returns>Nowe dwuwymiarowe <see cref="T:System.Array" /> o <see cref="T:System.Type" /> określonej długości dla każdego wymiaru przy użyciu indeksowania opartego na zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest produktem `length1` i `length2`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować dwuwymiarowy <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="length2" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Tablica Jednowymiarowa, która zawiera rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lowerBounds">Jednowymiarowa tablica, która zawiera dolną granicę (indeks początkowy) każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarowy <see cref="T:System.Array" /> określony <see cref="T:System.Type" /> i długości wymiaru z określonymi dolnymi granicami.</summary>
        <returns>Nowy wielowymiarowy <see cref="T:System.Array" /> określony <see cref="T:System.Type" /> z określoną długością i dolną granicą dla każdego wymiaru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Tablice `lengths` i`lowerBounds` muszą mieć taką samą liczbę elementów. Liczba elementów w `lengths` tablicy musi być równa liczbie wymiarów w nowym <xref:System.Array>.  
  
 Każdy element `lengths` tablicy musi określać długość odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Każdy element `lowerBounds` tablicy musi określać dolną granicę odpowiadającego mu wymiaru w nowym <xref:System.Array>. Ogólnie rzecz biorąc, Biblioteka klas .NET Framework i wiele języków programowania nie obsługują niższych granic.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest iloczynem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowy <xref:System.Array> z określonymi dolnymi granicami.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="lowerBounds" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.  
  
—lub— 
Tablice <paramref name="lengths" /> i<paramref name="lowerBounds" /> nie zawierają tej samej liczby elementów.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w <paramref name="lengths" /> jest mniejsza od zera.  
  
—lub— 
Każda wartość w <paramref name="lowerBounds" /> jest bardzo duża, w taki sposób, aby suma dolnego powiązania wymiaru i długość była większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszego wymiaru, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <param name="length2">Rozmiar drugiego wymiaru, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <param name="length3">Rozmiar trzeciego wymiaru, <see cref="T:System.Array" /> który ma zostać utworzony.</param>
        <summary>Tworzy trójwymiarowe <see cref="T:System.Array" /> wartości określone <see cref="T:System.Type" /> i długości wymiarów przy użyciu indeksowania od zera.</summary>
        <returns>Nowe trzy <see cref="T:System.Array" /> <see cref="T:System.Type" /> wymiary z określoną długością dla każdego wymiaru przy użyciu indeksowania opartego na zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości <xref:System.Array> klas, <xref:System.Array.CreateInstance%2A> zapewnia metodę zamiast konstruktorów publicznych, aby umożliwić dostęp z późnym wiązaniem.  
  
 Elementy typu odwołania są inicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest produktem `length1`, `length2`, i `length3`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować trójwymiarowy <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" />jest nieprawidłowy <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" />nie jest obsługiwana. Na przykład <see cref="T:System.Void" /> nie jest obsługiwana.  
  
—lub— 
 <paramref name="elementType" />jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="length2" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="length3" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <summary>Zwraca pustą tablicę.</summary>
        <returns>Pusta tablica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Definiuje warunki elementów do wyszukania.</param>
        <summary>Określa, czy określona tablica zawiera elementy, które pasują do warunków zdefiniowanych przez określony predykat.</summary>
        <returns><see langword="true" />Jeśli <paramref name="array" /> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do, a przetwarzanie jest przerywane po znalezieniu dopasowania.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie <xref:System.Predicate%601> delegata. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie określono warunki dopasowania dla <xref:System.Array.Exists%2A> metody przy użyciu wyrażeń lambda do sprawdzenia, czy globalnej rozpoczyna się od danej litery, czy też globalnej znajduje się w danej tablicy.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 Poniższy przykład używa metody, <xref:System.Array.Exists%2A> aby wskazać, czy wszystkie nazwy w tablicy ciągów zaczynają się od określonego znaku. Przykład tworzy wystąpienie `StringSearcher` obiektu przez przekazanie ciągu do wyszukiwania do jego konstruktora klasy. Metoda ma ten sam podpis <xref:System.Predicate%601> co delegat. `StringSearcher.StartsWith` Gdy metoda jest wywoływana, każdy element członkowski tablicy jest przenoszona do delegata, dopóki nie zwróci `true` lub przejdzie do iteracji wszystkich elementów w tablicy. <xref:System.Array.Exists%2A>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Można również użyć wyrażenia lambda zamiast jawnie zdefiniować metodę, której podpis odnosi się do obiektu delegowanego. Poniższy przykład zastępuje `StringSearcher` klasę i jej `StartsWith` metodę wyrażeniem lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Wyrażenia lambda (Przewodnik programowania w języku C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambda — Wyrażenia (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, która ma być wyszukiwana.</param>
        <param name="match">Predykat definiujący warunki elementu, który ma zostać wyszukany.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca pierwsze wystąpienie w całości <see cref="T:System.Array" />.</summary>
        <returns>Pierwszy element, który odpowiada warunkom zdefiniowanym przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody lub wyrażeniem lambda, które zwraca `true` , jeśli obiekt przeszedł do niego, dopasowuje warunki zdefiniowane w delegatze lub wyrażeniu lambda. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do, rozpoczynając od pierwszego elementu i kończąc z ostatnim elementem.  Przetwarzanie jest zatrzymane po znalezieniu dopasowania.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie <xref:System.Predicate%601> delegata <xref:System.Array.Find%2A> z metodą generyczną <xref:System.Drawing.Point> w celu przeszukania tablicy struktur. Metoda reprezentowana `ProductGT10`przez delegata zwraca wartość `true` , jeśli iloczyn pól X i Y jest większy niż 100 000. <xref:System.Array.Find%2A> Metoda wywołuje delegata dla każdego elementu tablicy, zwracając pierwszy punkt, który spełnia warunek testu.  
  
> [!NOTE]
>  Visual Basic i C# użytkownicy nie muszą jawnie tworzyć delegatów ani określać argumentu Type metody generycznej. Kompilatory określają wymagane typy z argumentów metody, które dostarczasz.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Zamiast jawnie zdefiniować metodę z niezbędnym podpisem, utworzenie wystąpienia <xref:System.Predicate%601> delegata i przekazanie delegata <xref:System.Array.Find%2A> do metody, jest to niestandardowe użycie wyrażenia lambda. Poniższy przykład jest identyczny z poprzednim, z tą różnicą, że używa wyrażenia lambda jako `match` argumentu.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Definiuje warunki elementów do wyszukania.</param>
        <summary>Pobiera wszystkie elementy, które pasują do warunków zdefiniowanych przez określony predykat.</summary>
        <returns>Zawiera wszystkie elementy, które pasują do warunków określonych przez określony predykat, jeśli zostały znalezione; w przeciwnym razie jest <see cref="T:System.Array" />puste. <see cref="T:System.Array" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do i elementy, które pasują do warunków, są zapisywane w zwracanej tablicy.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę liczb losowych 50 z wartościami, które mogą mieć zakres od 0 do 1 000. Następnie wywołuje <xref:System.Array.FindAll%2A> metodę za pomocą wyrażenia lambda, które zwraca wartości z zakresu od 300 do 600. Zwróć uwagę, że wyrażenie lambda jest przekazaniem `x`parametru o nazwie;  reprezentuje pojedynczy element członkowski tablicy, który jest przesyłany do <xref:System.Predicate%601>. Należy również zauważyć, że `lBound` lokalne `uBound` i zmienne są dostępne w wyrażeniu lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Poniższy przykład kodu demonstruje <xref:System.Array.Find%2A>metody, <xref:System.Array.FindLast%2A>i <xref:System.Array.FindAll%2A> . Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Metoda generyczna przechodzi tablicę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.Find%2A> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Metoda <xref:System.Array.FindLast%2A> generyczna służy do przeszukiwania tablicy wstecz od końca. Znajduje element „Dilophosaurus” w pozycji 5. Metoda <xref:System.Array.FindAll%2A> generyczna służy do zwracania tablicy zawierającej wszystkie elementy, które kończą się na "saurus". Elementy są wyświetlane.  
  
 Przykład kodu demonstruje <xref:System.Array.Exists%2A> <xref:System.Array.TrueForAll%2A> również metody ogólne.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w <see cref="T:System.Array" /> lub jego części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w całości <see cref="T:System.Array" />.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany do przodu, zaczynając od pierwszego elementu i kończąc na ostatnim elemencie.  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzi tablicę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 1.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 2 i do końca tablicy. Znajduje element na pozycji 5. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 2. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów w programie <see cref="T:System.Array" /> , który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany do przodu `startIndex` i kończący się na ostatnim elemencie. <xref:System.Array>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą elementów `array`od `startIndex` do końca.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzi tablicę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 1.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 2 i do końca tablicy. Znajduje element na pozycji 5. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 2. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów <see cref="T:System.Array" /> , który zaczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `startIndex` `startIndex` Program jest przeszukiwany do przodu, rozpoczynając od i kończąc o minus 1, jeśli jest większy niż 0. <xref:System.Array>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzi tablicę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 1.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 2 i do końca tablicy. Znajduje element na pozycji 5. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 2. <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca ostatnie wystąpienie w całości <see cref="T:System.Array" />.</summary>
        <returns>Ostatni element, który jest zgodny z warunkami zdefiniowanymi przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do <xref:System.Array>, przenoszące do tyłu w, rozpoczynając od ostatniego elementu i kończąc na pierwszym elemencie.  Przetwarzanie jest zatrzymane po znalezieniu dopasowania.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Find%2A>metody, <xref:System.Array.FindLast%2A>i <xref:System.Array.FindAll%2A> . Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Metoda generyczna przechodzi tablicę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.Find%2A> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie`Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Metoda <xref:System.Array.FindLast%2A> generyczna służy do przeszukiwania tablicy wstecz od końca. Znajduje element „Dilophosaurus” w pozycji 5. Metoda <xref:System.Array.FindAll%2A> generyczna służy do zwracania tablicy zawierającej wszystkie elementy, które kończą się na "saurus". Elementy są wyświetlane.  
  
 Przykład kodu demonstruje <xref:System.Array.Exists%2A> <xref:System.Array.TrueForAll%2A> również metody ogólne.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w <see cref="T:System.Array" /> lub jego części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w całości <see cref="T:System.Array" />.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany wstecz od ostatniego elementu i kończący się na pierwszym elemencie.  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindLastIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzą tablicę wstecz od końca, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 5.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowania do początku tablicy. Znajduje element na pozycji 1. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 4 i działającej wstecz (czyli elementy 4, 3 i 2). <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> , który rozciąga się od pierwszego elementu do określonego indeksu.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany wstecz od początku `startIndex` i kończąc na pierwszym elemencie. <xref:System.Array>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą `array` elementów od początku do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindLastIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzą tablicę wstecz od końca, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 5.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowania do początku tablicy. Znajduje element na pozycji 1. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 4 i działającej wstecz (czyli elementy 4, 3 i 2). <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">Definiuje warunki elementu, którymazostaćwyszukany.<see cref="T:System.Predicate`1" /></param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> , który zawiera określoną liczbę elementów i kończą się na określony indeks.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `startIndex` `startIndex` Program jest przeszukiwany wstecz od i kończąc od minusa plus 1, jeśli jest większy niż 0. <xref:System.Array>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy przeciążenia <xref:System.Array.FindLastIndex%2A> metody ogólnej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. W przykładzie kodu jest również definiowana Metoda wyszukiwania `EndsWithSaurus`predykatu o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Przeciążenie metody przechodzą tablicę wstecz od końca, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `true` zwraca dla elementu na pozycji 5.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Przeciążenie <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metody służy do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowania do początku tablicy. Znajduje element na pozycji 1. Na koniec Przeciążenie metody służy do przeszukiwania zakresu trzech elementów, zaczynając od pozycji 4 i działającej wstecz (czyli elementy 4, 3 i 2). <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Zwraca wartość-1, ponieważ w tym zakresie nie ma nazw dinozaurów kończących się na "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne <see cref="T:System.Array" /> od zera, dla których elementów należy wykonać akcję.</param>
        <param name="action">Do wykonania na każdym <paramref name="array" />elemencie. <see cref="T:System.Action`1" /></param>
        <summary>Wykonuje określoną akcję dla każdego elementu określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Jest delegatem do metody, która wykonuje akcję na obiekcie, do którego została przeniesiona.  Elementy `array` są indywidualnie przenoszone <xref:System.Action%601>do.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Array.ForEach%2A> do wyświetlania kwadratów każdego elementu w tablicy liczb całkowitych.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="action" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IEnumerator" /> Zwraca wartość<see cref="T:System.Array" />dla.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Dla .<see cref="T:System.Array" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.IEnumerator.Current%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu <xref:System.Collections.IEnumerator.Reset%2A> wywołania metody lub. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji; w związku z tym Wyliczanie za pomocą kolekcji nie jest w sposób bezpieczny dla wątków.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Array.GetEnumerator%2A> do wyświetlania listy elementów tablicy.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Wymiar liczony od zera, <see cref="T:System.Array" /> którego długość musi być określona.</param>
        <summary>Pobiera 32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>32-bitowa liczba całkowita reprezentująca liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem <xref:System.Array.GetLength%2A> jest `GetLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Array.GetLength%2A> do wyświetlania wymiarów dwóch tablic o różnych rangach.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="dimension" />jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Wymiar liczony od zera, <see cref="T:System.Array" /> którego długość musi być określona.</param>
        <summary>Pobiera 64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>64-bitowa liczba całkowita reprezentująca liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem <xref:System.Array.GetLongLength%2A> jest `GetLongLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="dimension" />jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Wymiar liczony od zera tablicy, której indeks początkowy musi zostać określony.</param>
        <summary>Pobiera indeks pierwszego elementu określonego wymiaru w tablicy.</summary>
        <returns>Indeks pierwszego elementu określonego wymiaru w tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)`zwraca początkowy indeks pierwszego wymiaru tablicy, a `GetLowerBound(Rank - 1)` następnie zwraca indeks początkowy ostatniego wymiaru tablicy.  
  
 <xref:System.Array.GetLowerBound%2A> Metoda zawsze zwraca wartość wskazującą indeks dolnej granicy tablicy, nawet jeśli tablica jest pusta.  
  
 Należy zauważyć, że chociaż większość tablic w .NET Framework jest opartych na zero (to oznacza, <xref:System.Array.GetLowerBound%2A> że metoda zwraca zero dla każdego wymiaru tablicy), .NET Framework obsługuje tablice, które nie są oparte na zero. Takie tablice można utworzyć przy użyciu <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> metody i mogą być zwracane z kodu niezarządzanego.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> metod i <xref:System.Array.GetUpperBound%2A> , aby wyświetlić granice tablicy jednowymiarowej i dwuwymiarowej i wyświetlić wartości ich elementów tablicy.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="dimension" />jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Wymiar liczony od zera tablicy, której górne ograniczenie wymaga ustalenia.</param>
        <summary>Pobiera indeks ostatniego elementu określonego wymiaru w tablicy.</summary>
        <returns>Indeks ostatniego elementu określonego wymiaru w tablicy lub-1, jeśli określony wymiar jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)`Zwraca ostatni indeks z pierwszego wymiaru tablicy i `GetUpperBound(Rank - 1)` zwraca ostatni indeks ostatniego wymiaru tablicy.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> metod i <xref:System.Array.GetUpperBound%2A> , aby wyświetlić granice tablicy jednowymiarowej i dwuwymiarowej i wyświetlić wartości ich elementów tablicy.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="dimension" />jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonego elementu w bieżącym <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">32-bitowa liczba całkowita reprezentująca pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość z określonego położenia w jednym wymiarze <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednym wymiarze <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> mogą`index` określać, czy wartość znajduje się poza granicami.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksy określające pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość z podanej pozycji w wielowymiarowym <see cref="T:System.Array" />. Indeksy są określone jako tablica 32-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowym <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` elemencie musi być równa liczbie wymiarów <xref:System.Array>w. Wszystkie elementy w `indices` tablicy muszą zbiorczo określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w. <paramref name="indices" /></exception>
        <exception cref="T:System.IndexOutOfRangeException">Każdy element w <paramref name="indices" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego. <see cref="T:System.Array" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">64-bitowa liczba całkowita reprezentująca pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość z określonego położenia w jednym wymiarze <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednym wymiarze <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> mogą`index` określać, czy wartość znajduje się poza granicami.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksy określające pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość z podanej pozycji w wielowymiarowym <see cref="T:System.Array" />. Indeksy są określone jako tablica 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowym <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` elemencie musi być równa liczbie wymiarów <xref:System.Array>w. Wszystkie elementy w `indices` tablicy muszą zbiorczo określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w. <paramref name="indices" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Każdy element w <paramref name="indices" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego. <see cref="T:System.Array" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu do pobrania.</param>
        <param name="index2">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do pobrania.</param>
        <summary>Pobiera wartość z podanej pozycji w dwuwymiarowym <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowym <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo jest poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index1" /> <paramref name="index2" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu do pobrania.</param>
        <param name="index2">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do pobrania.</param>
        <summary>Pobiera wartość z podanej pozycji w dwuwymiarowym <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowym <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo jest poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index1" /> <paramref name="index2" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu do pobrania.</param>
        <param name="index2">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do pobrania.</param>
        <param name="index3">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> trzeciego elementu, który ma zostać pobrany.</param>
        <summary>Pobiera wartość z podanej pozycji w 3-wymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w podanej pozycji trójwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />lub <paramref name="index2" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index3" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu do pobrania.</param>
        <param name="index2">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do pobrania.</param>
        <param name="index3">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> trzeciego elementu, który ma zostać pobrany.</param>
        <summary>Pobiera wartość z podanej pozycji w 3-wymiarowej <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowe liczby całkowite.</summary>
        <returns>Wartość w podanej pozycji trójwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />lub <paramref name="index2" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index3" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej lub w zakresie elementów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Tablica Jednowymiarowa do przeszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" /> w <paramref name="array" />, jeśli został znaleziony; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje wszystkie elementy tablicy jednowymiarowej dla `value`. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie równości `Equals` przez wywołanie metody każdego elementu do momentu znalezienia dopasowania. Oznacza to, że jeśli element przesłania <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, to zastępowanie jest wywoływane.  
  
 Ponieważ większość tablic ma dolną granicę zero, ta metoda zwykle zwraca wartość-1`value` , jeśli nie zostanie znaleziona. W rzadkich przypadkach Dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie można jej odnaleźć, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Przykład wywołuje następujące trzy przeciążenia <xref:System.Array.IndexOf%2A> metody, aby znaleźć indeks ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "a" w czwarty do ostatniego elementu tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów od elementu, który następuje po ostatnim pomyślnym dopasowaniu do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica Jednowymiarowa do przeszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Początkowy indeks wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks pierwszego wystąpienia. Zakres rozciąga się od określonego indeksu do końca tablicy.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" />, jeśli znajduje się w zakresie elementów w <paramref name="array" /> , który rozciąga się od <paramref name="startIndex" /> do ostatniego elementu; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje tablicę jednowymiarową z elementu pod indeksem `startIndex` do ostatniego elementu. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie `Equals` równości przez wywołanie metody każdego elementu do momentu znalezienia dopasowania. Oznacza to, że jeśli element przesłania <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, to zastępowanie jest wywoływane.  
  
 Ponieważ większość tablic ma dolną granicę zero, ta metoda zwykle zwraca wartość-1 `value` , jeśli nie zostanie znaleziona. W rzadkich przypadkach Dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie można jej odnaleźć, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startIndex` jest <xref:System.Array.Length%2A?displayProperty=nameWithType>równe, metoda zwraca wartość-1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType> <xref:System.ArgumentOutOfRangeException>, metoda zgłasza.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą elementów `array`od `startIndex` do końca.  
  
   
  
## Examples  
 Przykład wywołuje następujące trzy przeciążenia <xref:System.Array.IndexOf%2A> metody, aby znaleźć indeks ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "a" w czwarty do ostatniego elementu tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów od elementu, który następuje po ostatnim pomyślnym dopasowaniu do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica Jednowymiarowa do przeszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Początkowy indeks wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów do wyszukania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks pierwszego wystąpienia IFS. Zakres rozciąga się od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Indeks <paramref name="value" />pierwszego wystąpienia, jeśli znajduje się on <paramref name="array" /> w indeksie <paramref name="startIndex" /> od do <paramref name="startIndex" />  +  <paramref name="count" /> -1; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje elementy jednowymiarowej tablicy `startIndex` z do `startIndex` Plus `count` minus 1, jeśli `count` jest większa niż 0. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie `Equals` równości przez wywołanie metody każdego elementu do momentu znalezienia dopasowania. Oznacza to, że jeśli element przesłania <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodę, to zastępowanie jest wywoływane.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, ta metoda zwykle zwraca wartość `value` -1, gdy nie znaleziono. W rzadkich przypadkach Dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) i `value` nie można jej odnaleźć, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startindex` jest <xref:System.Array.Length%2A?displayProperty=nameWithType>równe, metoda zwraca wartość-1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType> <xref:System.ArgumentOutOfRangeException>, metoda zgłasza.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
   
  
## Examples  
 Przykład wywołuje następujące trzy przeciążenia <xref:System.Array.IndexOf%2A> metody, aby znaleźć indeks ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "a" w czwarty do ostatniego elementu tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "The" w tablicy ciągów od elementu, który następuje po ostatnim pomyślnym dopasowaniu do końca tablicy. Aby określić wartość `count` argumentu, odejmuje górną granicę tablicy od początkowego indeksu i dodaje jeden.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, która ma być wyszukiwana.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="value" /> w całości <paramref name="array" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje wszystkie elementy tablicy jednowymiarowej dla `value`. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie `T.Equals` równości przez wywołanie metody dla każdego elementu. Oznacza to, że `T` Jeśli <xref:System.Object.Equals%2A> przesłania metodę, to zastępowanie jest wywoływane.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy ogólne przeciążenia <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje tablicę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu tablicy i znajduje drugie wystąpienie ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, która ma być wyszukiwana.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks pierwszego wystąpienia. Zakres rozciąga się od określonego indeksu do końca tablicy.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="value" /> w zakresie elementów w programie <paramref name="array" /> , który rozciąga się od <paramref name="startIndex" /> do ostatniego elementu, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje tablicę jednowymiarową z elementu na `startIndex` końcu tablicy. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie `T.Equals` równości przez wywołanie metody dla każdego elementu. Oznacza to, że `T` Jeśli <xref:System.Object.Equals%2A> przesłania metodę, to zastępowanie jest wywoływane.  
  
 Jeśli `startIndex` jest <xref:System.Array.Length%2A>równe, metoda zwraca -1. Jeśli `startIndex` <xref:System.ArgumentOutOfRangeException>jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zgłasza.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą elementów `array`od `startIndex` do końca.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy ogólne przeciążenia <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje tablicę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu tablicy i znajduje drugie wystąpienie ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, która ma być wyszukiwana.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks pierwszego wystąpienia. Zakres rozciąga się od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Indeks (liczony od zera <paramref name="value" /> ) pierwszego wystąpienia elementu w <paramref name="array" /> zakresie, który zaczyna się <paramref name="startIndex" /> od i zawiera liczbę elementów określonych w <paramref name="count" />, jeśli znaleziono; w przeciwnym razie,-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje elementy jednowymiarowej tablicy `startIndex` z do `startIndex` Plus `count` minus 1, jeśli `count` jest większa niż 0. Aby określić, `value` czy istnieje `array`w, Metoda wykonuje porównanie `T.Equals` równości przez wywołanie metody dla każdego elementu. Oznacza to, że `T` Jeśli <xref:System.Object.Equals%2A> przesłania metodę, to zastępowanie jest wywoływane.  
  
 Jeśli `startIndex` jest <xref:System.Array.Length%2A?displayProperty=nameWithType>równe, metoda zwraca wartość-1.  Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType> <xref:System.ArgumentOutOfRangeException>, metoda zgłasza.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy ogólne przeciążenia <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje tablicę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu tablicy i znajduje drugie wystąpienie ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje każdy element typu <see cref="T:System.Array" /> wartości, wywołując Konstruktor bez parametrów typu wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda została zaprojektowana, aby ułatwić kompilatorom obsługę tablic typu wartości; Większość użytkowników nie potrzebuje tej metody. Nie może być używany w tablicach typu referencyjnego.  
  
 Jeśli nie <xref:System.Array>jesttypem wartości lub jeśli typ wartości nie ma konstruktora bez <xref:System.Array> parametrów, nie jest modyfikowany. <xref:System.Array>  
  
 Typ <xref:System.Array> wartości może mieć dowolną dolną granicę i dowolną liczbę wymiarów.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Tej metody można użyć tylko dla typów wartości, które mają konstruktory; jednak typy wartości, które są natywne C# dla nie mają konstruktorów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Array" /> czy ma stały rozmiar.</summary>
        <value>Ta właściwość jest zawsze <see langword="true" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementuje właściwość <xref:System.Array.IsFixedSize%2A> , ponieważ jest wymagana <xref:System.Collections.IList?displayProperty=nameWithType> przez interfejs.  
  
 Tablica o stałym rozmiarze nie zezwala na dodawanie lub usuwanie elementów po utworzeniu tablicy, ale umożliwia modyfikację istniejących elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Array" /> tylko do odczytu.</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementuje właściwość <xref:System.Array.IsReadOnly%2A> , ponieważ jest wymagana <xref:System.Collections.IList?displayProperty=nameWithType> przez interfejs. Tablica, która jest tylko do odczytu, nie zezwala na dodawanie, usuwanie ani modyfikowanie elementów po utworzeniu tablicy.  
  
 Jeśli potrzebujesz kolekcji tylko do odczytu, użyj <xref:System.Collections> klasy, która <xref:System.Collections.IList?displayProperty=nameWithType> implementuje interfejs.  
  
 Jeśli rzutowane lub przekonwertujesz tablicę <xref:System.Collections.IList> do obiektu interfejsu <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> , właściwość zwraca `false`. Jeśli jednak przerzutuje lub przekonwertujesz tablicę <xref:System.Collections.Generic.IList%601> do interfejsu `IsReadOnly` , właściwość zwraca `true`.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Array" /> czy dostęp do elementu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementuje właściwość <xref:System.Array.IsSynchronized%2A> , ponieważ jest wymagana <xref:System.Collections.ICollection?displayProperty=nameWithType> przez interfejs.  
  
 Klasy .NET Framework w oparciu <xref:System.Array> o dostarczenie własnej synchronizowanej wersji kolekcji <xref:System.Array.SyncRoot%2A> przy użyciu właściwości.  
  
 Klasy korzystające z tablic mogą również implementować własne synchronizacje <xref:System.Array.SyncRoot%2A> przy użyciu właściwości. Kod synchronizacji musi wykonywać operacje na `SyncRoot` kolekcji, nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W celu zapewnienia odpowiedniej synchronizacji z innymi wątkami, które mogą jednocześnie modyfikować kolekcję. Należy zauważyć, że niektóre <xref:System.Array.SyncRoot%2A> implementacje mogą <xref:System.Array> zwrócić sam siebie.  
  
 Wyliczanie za pomocą kolekcji nie jest wewnętrznie procedurą bezpiecznego wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Array.SyncRoot%2A> jak zablokować tablicę podczas całego wyliczenia przy użyciu właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks ostatniego wystąpienia wartości w postaci jednowymiarowej <see cref="T:System.Array" /> lub w części. <see cref="T:System.Array" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w całym pojedynczym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w całości <paramref name="array" />, jeśli został znaleziony; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeden wymiar <xref:System.Array> jest przeszukiwany wstecz, zaczynając od ostatniego elementu i kończąc na pierwszym elemencie.  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika), `Equals` implementacja tego typu jest używana.  
  
 Ponieważ większość tablic będzie miała dolną granicę równą zero, ta metoda zwykle zwróci wartość- `value` 1, gdy nie zostanie znaleziona. W rzadkich przypadkach Dolna granica <xref:System.Int32.MinValue?displayProperty=nameWithType> tablicy jest równa i `value` nie można jej odnaleźć. Ta metoda zwraca wartość <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 W .NET Framework w wersji 2,0 Ta metoda <xref:System.Object.Equals%2A> używa metod i <xref:System.Object> <xref:System.IComparable.CompareTo%2A> , <xref:System.Array> aby określić, czy określony `value` parametr istnieje. We wcześniejszych wersjach .NET Framework to ustalenie zostało wykonane przy <xref:System.Object.Equals%2A> użyciu metod <xref:System.IComparable.CompareTo%2A> `value` <xref:System.Object> i.  
  
 <xref:System.IComparable.CompareTo%2A>`item` metody parametru dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określonego elementu w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Początkowy indeks wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednym wymiarze <see cref="T:System.Array" /> , który rozciąga się od pierwszego elementu do określonego indeksu.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> elementów w programie <paramref name="array" /> , który rozciąga się od pierwszego elementu do <paramref name="startIndex" />, jeśli został znaleziony; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowy <xref:System.Array> jest przeszukiwany wstecz `startIndex` od początku i kończąc na pierwszym elemencie.  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika), `Equals` implementacja tego typu jest używana.  
  
 Ponieważ większość tablic będzie miała dolną granicę równą zero, ta metoda zwykle zwróci wartość- `value` 1, gdy nie zostanie znaleziona. W rzadkich przypadkach Dolna granica <xref:System.Int32.MinValue?displayProperty=nameWithType> tablicy jest równa i `value` nie można jej odnaleźć. Ta metoda zwraca wartość <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą `array` elementów od początku do `startIndex`.  
  
 W .NET Framework w wersji 2,0 Ta metoda <xref:System.Object.Equals%2A> używa metod i <xref:System.Object> <xref:System.IComparable.CompareTo%2A> , <xref:System.Array> aby określić, czy określony `value` parametr istnieje. We wcześniejszych wersjach .NET Framework to ustalenie zostało wykonane przy <xref:System.Object.Equals%2A> użyciu metod <xref:System.IComparable.CompareTo%2A> `value` <xref:System.Object> i.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określonego elementu w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Początkowy indeks wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednym wymiarze <see cref="T:System.Array" /> , który zawiera określoną liczbę elementów i kończą się o określonym indeksie.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> elementu w <paramref name="array" /> zakresie, który zawiera liczbę elementów określoną w <paramref name="count" /> i zostaje zakończony w <paramref name="startIndex" />, jeśli został znaleziony; w przeciwnym razie Dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowy <xref:System.Array> jest przeszukiwany do tyłu `startIndex` i kończący `startIndex` się `count` znakiem minus Plus `count` 1, jeśli jest większy niż 0.  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika),`Equals` implementacja tego typu jest używana.  
  
 Ponieważ większość tablic będzie miała dolną granicę równą zero, ta metoda zwykle zwróci wartość- `value` 1, gdy nie zostanie znaleziona. W rzadkich przypadkach Dolna granica <xref:System.Int32.MinValue?displayProperty=nameWithType> tablicy jest równa i `value` nie można jej odnaleźć. Ta metoda zwraca wartość <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
 W .NET Framework w wersji 2,0 Ta metoda <xref:System.Object.Equals%2A> używa metod i <xref:System.Object> <xref:System.IComparable.CompareTo%2A> , <xref:System.Array> aby określić, czy określony `value` parametr istnieje. We wcześniejszych wersjach .NET Framework to ustalenie zostało wykonane przy <xref:System.Object.Equals%2A> użyciu metod <xref:System.IComparable.CompareTo%2A> `value` <xref:System.Object> i.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określonego elementu w tablicy. Należy pamiętać, <xref:System.Array.LastIndexOf%2A> że metoda jest wyszukiwaniem wstecznym; `count` w związku z tym musi być mniejsza lub`startIndex` równa (minus Dolna granica tablicy plus 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w całości <see cref="T:System.Array" />.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia <paramref name="value" /> w całości <paramref name="array" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany wstecz od ostatniego elementu i kończący się na pierwszym elemencie.  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika), `Equals` implementacja tego typu jest używana.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy ogólne przeciążenia <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje całą tablicę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy do tyłu od lokalizacji indeksu 3 i do początku tablicy oraz do znajdowania pierwszego wystąpienia ciągu. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu czterech wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to znaczy przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> , który rozciąga się od pierwszego elementu do określonego indeksu.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w programie <paramref name="array" /> , który rozciąga się od pierwszego elementu do <paramref name="startIndex" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany wstecz od początku `startIndex` i kończąc na pierwszym elemencie. <xref:System.Array>  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika), `Equals` implementacja tego typu jest używana.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą `array` elementów od początku do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy ogólne przeciążenia <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje całą tablicę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy do tyłu od lokalizacji indeksu 3 i do początku tablicy oraz do znajdowania pierwszego wystąpienia ciągu. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu czterech wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to znaczy przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa na podstawie <see cref="T:System.Array" /> wyszukiwania.</param>
        <param name="value">Obiekt, w <paramref name="array" />którym ma zostać zlokalizowany.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> elemencie, który zawiera określoną liczbę elementów i kończą się określonym indeksem.</summary>
        <returns>Indeks (liczony od zera <paramref name="value" /> ) ostatniego wystąpienia elementu w <paramref name="array" /> zakresie, który zawiera liczbę elementów <paramref name="startIndex" />określoną w <paramref name="count" /> i zostaje zakończony w, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `startIndex` `startIndex` Program jest przeszukiwany wstecz od i kończąc od minusa plus 1, jeśli jest większy niż 0. <xref:System.Array>  
  
 Elementy są porównywane z określoną wartością przy użyciu <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typem niewewnętrznym (zdefiniowanym przez użytkownika), `Equals` implementacja tego typu jest używana.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wszystkie trzy ogólne przeciążenia <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> metody przeszukuje całą tablicę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> metody jest używane do przeszukiwania tablicy do tyłu od lokalizacji indeksu 3 i do początku tablicy oraz do znajdowania pierwszego wystąpienia ciągu. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu czterech wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to znaczy przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów <paramref name="array" />dla.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę elementów we wszystkich wymiarach <see cref="T:System.Array" />.</summary>
        <value>Całkowita liczba elementów we wszystkich wymiarach <see cref="T:System.Array" />; zero, jeśli nie ma żadnych elementów w tablicy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, <xref:System.Array.Length%2A> aby pobrać łączną liczbę elementów w tablicy. Używa ona również <xref:System.Array.GetUpperBound%2A> metody do określenia liczby elementów w każdym wymiarze tablicy wielowymiarowej.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Tablica jest wielowymiarowa i zawiera więcej <see cref="F:System.Int32.MaxValue" /> niż elementy.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera 64-bitową liczbę całkowitą reprezentującą łączną liczbę elementów we wszystkich wymiarach <see cref="T:System.Array" />.</summary>
        <value>64-bitowa liczba całkowita reprezentująca całkowitą liczbę elementów we wszystkich wymiarach <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rangę (liczbę wymiarów) <see cref="T:System.Array" />. Na przykład tablica Jednowymiarowa zwraca 1, Dwuwymiarowa tablica zwraca 2 itd.</summary>
        <value>Ranga (liczba wymiarów) <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład kod Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 i C# kod  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Utwórz tablicę trzech wymiarów z <xref:System.Array.Rank%2A> właściwością o wartości 3.  
  
 Tablica nieregularna (tablica tablic) jest tablicą jednowymiarową; wartość <xref:System.Array.Rank%2A> właściwości jest równa 1.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład Inicjuje tablicę jednowymiarową, tablicę dwuwymiarową i tablicę nieregularną, a następnie pobiera <xref:System.Array.Rank%2A> właściwość każdej z nich.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica Jednowymiarowa, od zera do zmiany rozmiaru lub <see langword="null" /> do utworzenia nowej tablicy o określonym rozmiarze.</param>
        <param name="newSize">Rozmiar nowej tablicy.</param>
        <summary>Zmienia liczbę elementów tablicy jednowymiarowej na określony nowy rozmiar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przydziela nową tablicę o określonym rozmiarze, Kopiuje elementy ze starej tablicy do nowej, a następnie zastępuje starą tablicę nową. `array`musi być tablicą jednowymiarową.  
  
 Jeśli `array` jest`null`, ta metoda tworzy nową tablicę o określonym rozmiarze.  
  
 Jeśli `newSize` jest większa niż wartość <xref:System.Array.Length%2A> starej tablicy, przydzielono nową tablicę, a wszystkie elementy są kopiowane ze starej tablicy do nowej.  Jeśli `newSize` wartość jest mniejsza niż <xref:System.Array.Length%2A> w przypadku starej tablicy, przydzielono nową tablicę, a elementy są kopiowane ze starej tablicy do nowego, aż do momentu wypełnienia nowego. Pozostałe elementy w starej tablicy zostaną zignorowane.  Jeśli `newSize` jest taka sama <xref:System.Array.Length%2A> jak w przypadku starej tablicy, ta metoda nie wykonuje żadnych operacji.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `newSize`.  
  
 <xref:System.Array.Resize%2A> Metoda zmienia rozmiar tylko jednowymiarowej tablicy. <xref:System.Array> Klasa nie zawiera metody zmiany rozmiarów wielowymiarowych tablic. W tym celu musisz podać własny kod lub wywołać metodę specjalnego przeznaczenia w bibliotece innej firmy. Poniższy kod ilustruje jedną z możliwych implementacji dla metody, która zmienia rozmiar tablicy *n* wymiarów.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zmiana rozmiarów ma wpływ na tablicę.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w jednym wymiarze <see cref="T:System.Array" /> lub w części. <see cref="T:System.Array" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do odwrócenia.</param>
        <summary>Odwraca sekwencję elementów w całym pojedynczym wymiarze <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `myArray[i]`tej metody element w, gdzie `i` jest dowolnym indeksem w tablicy, przenosi do `myArray[j]`, gdzie `j` Equals równa `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`się.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 Jak pokazano na poniższym przykładzie, <xref:System.Array.Reverse%2A> Metoda może służyć do odwrócenia tablicy nieregularnej. Inicjuje nieregularną tablicę z jednym elementem w każdym miesiącu bieżącego roku w kalendarzu bieżącej kultury. Każdy element zawiera tablicę z dowolną liczbą elementów, co miesiąc. Przykład wyświetla zawartość tablicy, wywołuje <xref:System.Array.Reverse%2A> metodę, a następnie wyświetla zawartość tablicy odwróconej.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak odwrócić sortowanie wartości w <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do odwrócenia.</param>
        <param name="index">Początkowy indeks sekcji do odwrócenia.</param>
        <param name="length">Liczba elementów w sekcji do odwrócenia.</param>
        <summary>Odwraca sekwencję elementów w zakresie elementów w jednym wymiarze <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `myArray[i]`tej metody element w, gdzie `i` jest dowolnym indeksem w tablicy, przenosi do `myArray[j]`, gdzie `j` Equals równa `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`się.  
  
 <xref:System.Array.Reverse%2A> Metoda może służyć do odwracania tablicy nieregularnej.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak odwrócić sortowanie wartości w zakresie elementów w <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia określony element w bieżącym <see cref="T:System.Array" /> do określonej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">32-bitowa liczba całkowita reprezentująca pozycję <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednym wymiarze <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> mogą`index` określać, czy wartość znajduje się poza granicami.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksy określające pozycję elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowym <see cref="T:System.Array" />. Indeksy są określone jako tablica 32-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` elemencie musi być równa liczbie wymiarów <xref:System.Array>w. Wszystkie elementy w `indices` tablicy muszą zbiorczo określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 Metody <xref:System.Array.GetLowerBound%2A> `indices` i <xref:System.Array.GetUpperBound%2A> mogą określać, czy dowolne wartości w tablicy nie są poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w. <paramref name="indices" /></exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Każdy element w <paramref name="indices" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego. <see cref="T:System.Array" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">64-bitowa liczba całkowita reprezentująca pozycję <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednym wymiarze <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> mogą`index` określać, czy wartość znajduje się poza granicami.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksy określające pozycję elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowym <see cref="T:System.Array" />. Indeksy są określone jako tablica 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` elemencie musi być równa liczbie wymiarów <xref:System.Array>w. Wszystkie elementy w `indices` tablicy muszą zbiorczo określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 Metody <xref:System.Array.GetLowerBound%2A> `indices` i <xref:System.Array.GetUpperBound%2A> mogą określać, czy dowolne wartości w tablicy nie są poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w. <paramref name="indices" /></exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Każdy element w <paramref name="indices" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego. <see cref="T:System.Array" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu, który ma zostać ustawiony.</param>
        <param name="index2">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowym <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo jest poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index1" /> <paramref name="index2" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu, który ma zostać ustawiony.</param>
        <param name="index2">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowym <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo jest poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index1" /> <paramref name="index2" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu, który ma zostać ustawiony.</param>
        <param name="index2">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do ustawienia.</param>
        <param name="index3">32-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> trzeciego elementu, który ma zostać ustawiony.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />lub <paramref name="index2" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index3" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> pierwszego wymiaru elementu, który ma zostać ustawiony.</param>
        <param name="index2">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> drugiego wymiaru elementu do ustawienia.</param>
        <param name="index3">64-bitowa liczba całkowita reprezentująca indeks <see cref="T:System.Array" /> trzeciego elementu, który ma zostać ustawiony.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Array.GetLowerBound%2A> i<xref:System.Array.GetUpperBound%2A> mogą określać, czy którykolwiek z indeksów znajduje się poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji <xref:System.Convert>, zobacz.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisania `null` do elementu tablicy typów wartości, wszystkie pola elementu są inicjowane do zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> wartość nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" />nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />lub <paramref name="index2" /> znajduje się poza zakresem prawidłowych indeksów dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />. <paramref name="index3" /></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy w tablicy jednowymiarowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <summary>Sortuje elementy w całości jednowymiarowym <see cref="T:System.Array" /> <see cref="T:System.IComparable" /> przy użyciu implementacji każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `array` musi implementować interfejs <xref:System.IComparable> , aby można było porównań z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sortować wartości <xref:System.Array> przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, która odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie <see cref="T:System.IComparable" /> implementuje interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera klucze do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera elementy, które odpowiadają poszczególnym kluczom <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <see langword="null" />Aby posortować tylko <paramref name="keys" />. <see cref="T:System.Array" /></param>
        <summary>Sortuje parę jednowymiarowych <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> implementacji każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejs, aby można było porównań z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `keys`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak sortować dwie skojarzone tablice, w których pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortowanie odbywa się przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, który odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /> <see cref="T:System.Array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Tablica Jednowymiarowa do sortowania.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Sortuje elementy w jednym wymiarze <see cref="T:System.Array" /> przy użyciu określonego. <see cref="T:System.Collections.IComparer" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` `array` jest `null`, każdy element musi implementować interfejs <xref:System.IComparable> , aby można było porównań z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
 .NET Framework obejmuje wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównanie ciągów bez uwzględniania wielkości liter.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu domyślnej kolejności sortowania typu.|  
  
 Możesz również obsługiwać niestandardowe porównania, dostarczając wystąpienie własnej <xref:System.Collections.IComparer> implementacji `comparer` do parametru. W tym przykładzie jest definiowana `ReverseComparer` Klasa, która odwraca domyślną kolejność sortowania dla wystąpień typu i wykonuje porównanie ciągów bez uwzględniania wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład sortuje wartości w tablicy ciągów przy użyciu domyślnej funkcji porównującej. Definiuje również implementację <xref:System.Collections.IComparer> niestandardową `ReverseComparer` o nazwie, która odwraca domyślny porządek sortowania obiektu podczas wykonywania porównania ciągów bez uwzględniania wielkości liter. Należy zauważyć, że dane wyjściowe mogą się różnić w zależności od bieżącej kultury.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> to <see langword="null" />, a jeden lub więcej elementów w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera klucze do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera elementy, które odpowiadają poszczególnym kluczom <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <see langword="null" />Aby posortować tylko <paramref name="keys" />. <see cref="T:System.Array" /></param>
        <param name="comparer"><see cref="T:System.Collections.IComparer" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Sortuje parę jednowymiarowych <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiadające elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null` ,każdy<xref:System.IComparable> klucz w musiimplementowaćinterfejs,abymożnabyłoporównywaćzkażdyminnymkluczem.<xref:System.Array> `keys`  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework obejmuje wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównanie ciągów bez uwzględniania wielkości liter.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu domyślnej kolejności sortowania typu.|  
  
 Możesz również obsługiwać niestandardowe porównania, dostarczając wystąpienie własnej <xref:System.Collections.IComparer> implementacji `comparer` do parametru. W tym przykładzie jest definiowana <xref:System.Collections.IComparer> implementacja, która odwraca domyślny porządek sortowania i wykonuje Porównywanie ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `keys`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak sortować dwie skojarzone tablice, w których pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortowanie odbywa się przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, który odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i co najmniej jeden element <paramref name="keys" /> <see cref="T:System.Array" /> w nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów w jednym wymiarze <see cref="T:System.Array" /> <see cref="T:System.IComparable" /> przy użyciu implementacji każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element w określonym zakresie elementów w programie `array` musi <xref:System.IComparable> implementować interfejs, aby można było porównywać z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sortować wartości <xref:System.Array> przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, która odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie <see cref="T:System.IComparable" /> implementuje interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera klucze do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera elementy, które odpowiadają poszczególnym kluczom <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <see langword="null" />Aby posortować tylko <paramref name="keys" />. <see cref="T:System.Array" /></param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje zakres elementów w parze jednowymiarowych <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) na podstawie kluczy w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> implementacji każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w określonym zakresie elementów w `keys` <xref:System.Array> musi implementować interfejs, <xref:System.IComparable> aby można było porównywać z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sortować dwie skojarzone tablice, w których pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortowanie odbywa się przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, który odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
 <paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <paramref name="items" /><see langword="null" />nie jest <paramref name="length" /> <see cref="T:System.Array" />, i <paramref name="items" />i nie określaj prawidłowego zakresu w. <paramref name="index" /></exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /> <see cref="T:System.Array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer"><see cref="T:System.Collections.IComparer" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Sortuje elementy w zakresie elementów w jednym wymiarze <see cref="T:System.Array" /> , używając określonego. <see cref="T:System.Collections.IComparer" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` `array` jest `null`, każdy element w określonym zakresie elementów w musi implementować interfejs, <xref:System.IComparable> aby można było porównywać z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework obejmuje wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównanie ciągów bez uwzględniania wielkości liter.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu domyślnej kolejności sortowania typu.|  
  
 Możesz również obsługiwać niestandardowe porównania, dostarczając wystąpienie własnej <xref:System.Collections.IComparer> implementacji `comparer` do parametru. W tym przykładzie jest definiowana `ReverseComparer` Klasa, która odwraca domyślną kolejność sortowania dla wystąpień typu i wykonuje porównanie ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sortować wartości <xref:System.Array> przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, która odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" />jest wielowymiarowych.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> to <see langword="null" />, a jeden lub więcej elementów w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera klucze do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> , która zawiera elementy, które odpowiadają poszczególnym kluczom <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <see langword="null" />Aby posortować tylko <paramref name="keys" />. <see cref="T:System.Array" /></param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer"><see cref="T:System.Collections.IComparer" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć <see cref="T:System.IComparable" /> implementacji każdego elementu.</param>
        <summary>Sortuje zakres elementów w parze jednowymiarowych <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiadające elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` `keys` jest `null`, każdy klucz w określonym <xref:System.Array> zakresie elementów <xref:System.IComparable> w musi implementować interfejs, aby można było porównywać z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework obejmuje wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównanie ciągów bez uwzględniania wielkości liter.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty przy użyciu konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu domyślnej kolejności sortowania typu.|  
  
 Możesz również obsługiwać niestandardowe porównania, dostarczając wystąpienie własnej <xref:System.Collections.IComparer> implementacji `comparer` do parametru. W tym przykładzie jest definiowana implementacja niestandardowa <xref:System.Collections.IComparer> , która odwraca domyślny porządek sortowania i wykonuje Porównywanie ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sortować dwie skojarzone tablice, w których pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortowanie odbywa się przy użyciu domyślnej funkcji porównującej i niestandardowego modułu porównującego, który odwraca porządek sortowania. Zwróć uwagę, że wynik może się różnić w zależności od <xref:System.Globalization.CultureInfo>bieżącej.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie jest <paramref name="keys" /> <paramref name="items" />, a dolna granica jest niezgodna z dolną granicą. <see langword="null" />  
  
—lub— 
 <paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
 <paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <paramref name="items" /><see langword="null" />nie jest <paramref name="length" /> <see cref="T:System.Array" />, i <paramref name="items" />i nie określaj prawidłowego zakresu w. <paramref name="index" />  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i co najmniej jeden element <paramref name="keys" /> <see cref="T:System.Array" /> w nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne <see cref="T:System.Array" /> od zera, do sortowania.</param>
        <summary>Sortuje elementy w całości <see cref="T:System.Array" /> <see cref="T:System.IComparable`1" /> przy użyciu ogólnej implementacji interfejsu każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `array` musi <xref:System.IComparable%601> implementować interfejs ogólny, aby można było porównań z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> Przeciążenie metody ogólnej <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> i Przeciążenie metody ogólnej. Zostanie utworzona tablica ciągów, w której nie ma określonej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 Przeciążenie <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> metody ogólnej służy następnie do wyszukiwania dwóch ciągów, jeden, który nie znajduje się w tablicy i jeden. Tablica i wartość <xref:System.Array.BinarySearch%2A> zwracana metody są przenoszone `ShowWhere` do metody generycznej, która wyświetla wartość indeksu, jeśli ciąg zostanie znaleziony i w przeciwnym razie elementy, do których odbędzie się ciąg wyszukiwania, między, jeśli znajdowały się w tablicy. Indeks ma wartość ujemną, jeśli ciąg nie `ShowWhere` jest n tablicą, więc metoda przyjmuje dopełnienie bitowe (operator ~ w C# i wizualizacja C++, `Xor` -1 w Visual Basic), aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie <see cref="T:System.IComparable`1" /> implementuje interfejsu generycznego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zerowa baza <see cref="T:System.Array" /> do sortowania</param>
        <param name="comparer">Ogólna implementacja interfejsu do użycia podczas porównywania elementów lub <see langword="null" /> do korzystania z <see cref="T:System.IComparable`1" /> ogólnej implementacji interfejsu każdego elementu. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje elementy <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejsu ogólnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` `array` jest ,każdy<xref:System.IComparable%601> element musi implementować interfejs ogólny, aby można było porównań z każdym innym elementem w `array`. `null`  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie metody ogólnej <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i Przeciążenie metody ogólnej.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Aby można było użyć metody, <xref:System.Array.BinarySearch%2A> tablice muszą być posortowane.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 Przeciążenie <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólnej służy następnie do wyszukiwania dwóch ciągów, jeden, który nie znajduje się w tablicy i jeden. Tablica i wartość <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> zwracana metody są przenoszone `ShowWhere` do metody generycznej, która wyświetla wartość indeksu, jeśli ciąg zostanie znaleziony i w przeciwnym razie elementy, do których odbędzie się ciąg wyszukiwania, między, jeśli znajdowały się w tablicy. Indeks ma wartość ujemną, jeśli ciąg nie `ShowWhere` jest n tablicą, więc metoda przyjmuje dopełnienie bitowe (operator ~ w C# i wizualizacja C++, `Xor` -1 w Visual Basic), aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a co najmniej jeden element w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne <see cref="T:System.Array" /> od zera, do sortowania</param>
        <param name="comparison"><see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementy <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu algorytmu Sort (introspektywnego) w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Przeciążenie metody.  
  
 Przykład kodu definiuje alternatywną metodę porównania dla ciągów o nazwie `CompareDinosByLength`. Ta metoda działa w następujący sposób: Najpierw comparands są testowane dla`null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 Tablica ciągów jest tworzona i wypełniana czterema ciągami w określonej kolejności. Lista zawiera również pusty ciąg i odwołanie o wartości null. Zostanie wyświetlona lista, posortowana przy użyciu <xref:System.Comparison%601> ogólnego delegata `CompareDinosByLength` reprezentującego metodę i ponownie wyświetlana.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="comparison" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparison" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne <see cref="T:System.Array" /> od zera, do sortowania</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów <see cref="T:System.Array" /> <see cref="T:System.IComparable`1" /> przy użyciu ogólnej implementacji interfejsu każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element w określonym zakresie elementów w programie `array` musi <xref:System.IComparable%601> implementować interfejs ogólny, aby można było porównywać z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie metody ogólnej <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i Przeciążenie metody ogólnej do sortowania zakresu w tablicy.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów, składającą się z trzech herbivores, po których następują trzy (tyrannosaurids). Przeciążenie <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody ogólnej służy do sortowania ostatnich trzech elementów tablicy, która jest następnie wyświetlana. Przeciążenie metody `ReverseCompare` ogólnej służy do sortowania ostatnich trzech elementów w odwrotnej kolejności. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Starannie pomylić dinozaury są wyświetlane ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie <see cref="T:System.IComparable`1" /> implementuje interfejsu generycznego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne <see cref="T:System.Array" /> od zera, do sortowania.</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">Ogólna implementacja interfejsu do użycia podczas porównywania elementów lub <see langword="null" /> do korzystania z <see cref="T:System.IComparable`1" /> ogólnej implementacji interfejsu każdego elementu. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje elementy w zakresie elementów <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejsu ogólnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` `array` jest `null`, każdy element w określonym zakresie <xref:System.IComparable%601> elementów w musi implementować interfejs ogólny, aby można było porównywać z każdym innym elementem w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie metody ogólnej <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i Przeciążenie metody ogólnej do sortowania zakresu w tablicy.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów, składającą się z trzech herbivores, po których następują trzy (tyrannosaurids). Przeciążenie <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody ogólnej służy do sortowania ostatnich trzech elementów tablicy, która jest następnie wyświetlana. Przeciążenie metody `ReverseCompare` ogólnej służy do sortowania ostatnich trzech elementów w odwrotnej kolejności. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Starannie pomylić dinozaury są wyświetlane ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszego argumentu . Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu w <paramref name="array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a co najmniej jeden element w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejsu ogólnego.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy kluczy.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy Items.</typeparam>
        <param name="keys">Jednowymiarowa, zależna od <see cref="T:System.Array" /> zera, która zawiera klucze do sortowania.</param>
        <param name="items"><see cref="T:System.Array" /> Jednowymiarowa, zależna od zera, która zawiera elementy, które odpowiadają kluczom w <paramref name="keys" /> <paramref name="keys" />, <see langword="null" /> lub do sortowania.</param>
        <summary>Sortuje parę <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> ogólnej implementacji interfejsu każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> interfejs ogólny, aby można było porównań z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>Poniższy przykład kodu demonstruje przeciążenia metody, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> , w celu sortowania par tablic, które reprezentują klucze i wartości.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicę liczb całkowitych reprezentujących maksymalną długość każdej dinozaura w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest używane do sortowania obydwu tablic w kolejności nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie i`ReverseCompare` wystąpienie są używane do odwrócenia kolejności sortowania dla sparowanych tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołania metod ogólnych nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszych dwa argumenty. Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie jest <paramref name="keys" /> <paramref name="items" />, a dolna granica jest niezgodna z dolną granicą. <see langword="null" />  
  
—lub— 
 <paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /> <see cref="T:System.Array" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejsu generycznego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy kluczy.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy Items.</typeparam>
        <param name="keys">Jednowymiarowa, zależna od <see cref="T:System.Array" /> zera, która zawiera klucze do sortowania.</param>
        <param name="items"><see cref="T:System.Array" /> Jednowymiarowa, zależna od zera, która zawiera elementy, które odpowiadają kluczom w <paramref name="keys" /> <paramref name="keys" />, <see langword="null" /> lub do sortowania.</param>
        <param name="comparer">Ogólna implementacja interfejsu do użycia podczas porównywania elementów lub <see langword="null" /> do korzystania z <see cref="T:System.IComparable`1" /> ogólnej implementacji interfejsu każdego elementu. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje parę <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejsu ogólnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null` ,każdy<xref:System.IComparable%601> klucz w musiimplementowaćinterfejsogólny,abymożnabyłoporównywaćzkażdyminnymkluczem.<xref:System.Array> `keys`  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania`n` , ta metoda jest <xref:System.Array.Length%2A> operacją o (log `n`), gdzie `n` jest z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>[\], TValue\<linki XREF: System. Array. Sort% 60% 602% 28% 60% 600% 5B% 5D% 2C% 60% 601% 5B% 5D% 2CSystem. Collections. Generic. IComparer% 7b% 60% 600% 7D% 29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążania metod ogólnych dla sortowania par tablic, które reprezentują klucze i wartości.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicę liczb całkowitych reprezentujących maksymalną długość każdej dinozaura w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest używane do sortowania obydwu tablic w kolejności nazw dinozaurów w pierwszej tablicy.  
  
-   [\], TValue\<linki XREF: System. Array. Sort% 60% 602% 28% 60%.% 5b% 5D%.% 2C%% 601% 5B% 5D% 2CSystem. Collections. Generic. IComparer% 7b% 60% 600% 7D%, > `ReverseCompare` Przeciążenie i wystąpienie są używane do odwrócenia kolejności sortowania z sparowanych tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołania metod ogólnych nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszych dwa argumenty. Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie jest <paramref name="keys" /> <paramref name="items" />, a dolna granica jest niezgodna z dolną granicą. <see langword="null" />  
  
—lub— 
 <paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i co najmniej jeden element <paramref name="keys" /> <see cref="T:System.Array" /> w nie implementuje <see cref="T:System.IComparable`1" /> interfejsu generycznego.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy kluczy.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy Items.</typeparam>
        <param name="keys">Jednowymiarowa, zależna od <see cref="T:System.Array" /> zera, która zawiera klucze do sortowania.</param>
        <param name="items"><see cref="T:System.Array" /> Jednowymiarowa, zależna od zera, która zawiera elementy, które odpowiadają kluczom w <paramref name="keys" /> <paramref name="keys" />, <see langword="null" /> lub do sortowania.</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje zakres elementów w parze <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiadające elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> uniwersalnej implementacji interfejsu każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w określonym zakresie elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> interfejs ogólny, aby można było porównywać z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<linki XREF: System. Array. Sort% 60% 602% 28% 60% 600% 5B% 5D% 2C% 60% 601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 29 > i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metod ogólnych dla sortowania par tablic, które reprezentują klucze i wartości.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>` implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicę liczb całkowitych reprezentujących maksymalną długość każdej dinozaura w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest używane do sortowania obydwu tablic w kolejności nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie i`ReverseCompare` wystąpienie są używane do odwrócenia kolejności sortowania dla sparowanych tablic.  
  
-   [\], TValue\<linki XREF: System. Array. Sort% 60% 602% 28% 60% 600% 5B% 5D% 2C% 3% 601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 29 > Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołania metod ogólnych nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszych dwa argumenty. Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie jest <paramref name="keys" /> <paramref name="items" />, a dolna granica jest niezgodna z dolną granicą. <see langword="null" />  
  
—lub— 
 <paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
 <paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <paramref name="items" /><see langword="null" />nie jest <paramref name="length" /> <see cref="T:System.Array" />, i <paramref name="items" />i nie określaj prawidłowego zakresu w. <paramref name="index" /></exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /> <see cref="T:System.Array" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejsu generycznego.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy kluczy.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy Items.</typeparam>
        <param name="keys">Jednowymiarowa, zależna od <see cref="T:System.Array" /> zera, która zawiera klucze do sortowania.</param>
        <param name="items"><see cref="T:System.Array" /> Jednowymiarowa, zależna od zera, która zawiera elementy, które odpowiadają kluczom w <paramref name="keys" /> <paramref name="keys" />, <see langword="null" /> lub do sortowania.</param>
        <param name="index">Początkowy indeks zakresu, który ma zostać posortowany.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">Ogólna implementacja interfejsu do użycia podczas porównywania elementów lub <see langword="null" /> do korzystania z <see cref="T:System.IComparable`1" /> ogólnej implementacji interfejsu każdego elementu. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje zakres elementów w parze <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiadające elementy) w oparciu o klucze w pierwszej kolejności <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejsu ogólnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `keys` klucz w <xref:System.Array> ma odpowiadający element w `items` <xref:System.Array>. Gdy klucz jest zmieniany podczas sortowania, odpowiadający element w `items` <xref:System.Array> jest podobnie zmieniany. W związku z `items` tym, <xref:System.Array> jest sortowany według układu odpowiednich kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` `keys` jest `null`, każdy klucz w określonym <xref:System.Array> zakresie elementów <xref:System.IComparable%601> w musi implementować interfejs ogólny, aby można było porównywać z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które nie mają odpowiednich kluczy, nie zostaną posortowane. Nie można sortować, jeśli istnieje więcej kluczy niż elementy; spowoduje to <xref:System.ArgumentException>wyrzucanie.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) .  
  
-   Jeśli liczba partycji przekracza 2 * log<sup>N</sup>, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu [sortowania](https://en.wikipedia.org/wiki/Quicksort) .  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 W przypadku tablic, które są sortowane przy użyciu algorytmów kopcowanie i sortowania, ta metoda jest`n` operacją o (log `n`), gdzie `n` is `length`.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>\],,\<, i [, TValue linki XREF: System. Array. Sort% 60% 602% 28% 60% 600% 5B% 5D% 2C% 60% 601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 2CSystem. Collections. Generic. IComparer% 7B% 60% 600%, wy>o przeciążenia metod ogólnych, do sortowania par tablic, które reprezentują klucze i wartości.  
  
 Przykład kodu definiuje alternatywną funkcję porównującą dla ciągów o `ReverseCompare`nazwie, która `IComparer<string>`implementuje interfejs`IComparer(Of String)` ogólny (w `IComparer<String^>` Visual Basic w C++języku Visual). Funkcja porównująca wywołuje <xref:System.String.CompareTo%28System.String%29> metodę, odwracając kolejność comparands, tak aby ciągi były sortowane od wysokich do niskiego poziomu, a nie jako niskiego poziomu.  
  
 Przykładowy kod tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicę liczb całkowitych reprezentujących maksymalną długość każdej dinozaura w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest używane do sortowania obydwu tablic w kolejności nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie i`ReverseCompare` wystąpienie są używane do odwrócenia kolejności sortowania dla sparowanych tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest używane do sortowania ostatnich trzech elementów obu tablic.  
  
-   [\], TValue\<linki XREF: System. Array. Sort% 60% 602% 28% 60% 600% 5B% 5D% 2C% 3% 601% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Collections. Generic. IComparer% 7b% 60% 600%% 29 > Przeciążenie jest używane do sortowania ostatnich trzech elementy obu tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołania metod ogólnych nie wyglądają inaczej od wywołań do ich nieogólnych odpowiedników, ponieważ Visual Basic, C#i C++ wywnioskowania typu parametru typu ogólnego z typu pierwszych dwa argumenty. Jeśli używasz [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania języka pośredniego firmy Microsoft (MSIL), możesz zobaczyć, że metody ogólne są wywoływane.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż Dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" />nie jest <paramref name="keys" /> <paramref name="items" />, a dolna granica jest niezgodna z dolną granicą. <see langword="null" />  
  
—lub— 
 <paramref name="items" />nie <see langword="null" />jest, a <paramref name="keys" /> długość jest <paramref name="items" />większa niż długość.  
  
—lub— 
 <paramref name="index" />i <paramref name="length" /> nie określaj prawidłowego zakresu <paramref name="keys" /> <see cref="T:System.Array" />w.  
  
—lub— 
 <paramref name="items" /><see langword="null" />nie jest <paramref name="length" /> <see cref="T:System.Array" />, i <paramref name="items" />i nie określaj prawidłowego zakresu w. <paramref name="index" />  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />i co najmniej jeden element <paramref name="keys" /> <see cref="T:System.Array" /> w nie implementuje <see cref="T:System.IComparable`1" /> interfejsu generycznego.</exception>
        <block subset="none" type="usage"><para>W .NET Framework 4 i starszych wersjach użyto tylko algorytmu sortowania. Sortowania identyfikuje nieprawidłowe porównanie w niektórych sytuacjach, w których operacja sortowania zgłasza <see cref="T:System.IndexOutOfRangeException" /> wyjątek, i <see cref="T:System.ArgumentException" /> zgłasza wyjątek do obiektu wywołującego. Począwszy od <see cref="T:System.ArgumentException" /> , możliwe jest, że operacje sortowania, które wcześniej wygenerowały nie spowodują wygenerowania wyjątku, ponieważ algorytmy sortowania i kopcowanie wstawiania nie wykrywają nieprawidłowej metody porównującej. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] W większości przypadków ma to zastosowanie do tablic zawierających mniej niż 16 elementów.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość implementuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejs.  
  
 Klasy .NET Framework w oparciu <xref:System.Array> o dostarczenie własnej synchronizowanej wersji kolekcji <xref:System.Array.SyncRoot%2A> przy użyciu właściwości.  
  
 Klasy korzystające z tablic mogą również implementować własne synchronizacje <xref:System.Array.SyncRoot%2A> przy użyciu właściwości. Kod synchronizacji musi wykonywać operacje na `SyncRoot` kolekcji, nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W celu zapewnienia odpowiedniej synchronizacji z innymi wątkami, które mogą jednocześnie modyfikować kolekcję. Należy zauważyć, że niektóre <xref:System.Array.SyncRoot%2A> implementacje mogą <xref:System.Array> zwrócić sam siebie.  
  
 Wyliczanie za pomocą kolekcji nie jest wewnętrznie procedurą bezpiecznego wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Array.SyncRoot%2A> jak zablokować tablicę podczas całego wyliczenia przy użyciu właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Array" />.</summary>
        <value>Liczba elementów zawartych w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.ICollection> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Array" /> elementu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value>ma wartość true, jeśli <see cref="T:System.Array" /> dostęp do programu jest synchronizowany (bezpieczny wątkowo); w przeciwnym razie, FAŁSZ.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać dodany do <see cref="T:System.Collections.IList" />.</param>
        <summary>Wywołanie tej metody zawsze zgłasza <see cref="T:System.NotSupportedException" /> wyjątek.</summary>
        <returns>Dodawanie wartości do tablicy nie jest obsługiwane. Nie jest zwracana żadna wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> Zwykle implementacja dodaje element członkowski do kolekcji. Jednak ponieważ tablice mają stały rozmiar ( <xref:System.Array.IsFixedSize%2A> Właściwość zawsze zwraca wartość `true`), <xref:System.NotSupportedException> ta metoda zawsze zgłasza wyjątek.  
  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.IList" /> tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać zlokalizowany na bieżącej liście. Element do zlokalizowania może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Określa, <see cref="T:System.Collections.IList" />czy element znajduje się w.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> znajduje się <see cref="T:System.Collections.IList" />w; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać zlokalizowany na bieżącej liście.</param>
        <summary>Określa indeks określonego elementu w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks wartości, jeśli znajduje się na liście; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks, w którym <paramref name="value" /> należy wstawić.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> obiektu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.IList" /> tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" />ma odwołanie o wartości null <see cref="T:System.Collections.IList" />w elemencie.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Array" /> ma stały rozmiar.</summary>
        <value><see cref="T:System.Array" /> ma wartość true, jeśli ma stały rozmiar; w przeciwnym razie, FAŁSZ.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest tylko <see cref="T:System.Array" /> do odczytu.</summary>
        <value>ma wartość true <see cref="T:System.Array" /> , jeśli jest tylko do odczytu; w przeciwnym razie, FAŁSZ.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu, który ma zostać pobrany lub ustawiony.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest równa lub większa niż <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Bieżąca <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać usunięty <see cref="T:System.Collections.IList" />z.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.IList" /> tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu, który ma zostać usunięty.</param>
        <summary><see cref="T:System.Collections.IList" /> Usuwa element o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IList> do interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">indeks nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Jest <see cref="T:System.Collections.IList" /> tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który porównuje bieżący obiekt i <paramref name="other" />.</param>
        <summary>Określa, czy bieżący obiekt kolekcji poprzedza, występuje w tym samym położeniu co lub w kolejności sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje związek bieżącego obiektu kolekcji z innym, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> -1 
 </term><description> Bieżące wystąpienie poprzedza <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> Bieżące wystąpienie i <paramref name="other" /> jest równe.  
  
 </description></item><item><term> 1 
 </term><description> Bieżące wystąpienie jest następujące <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralComparable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który określa, czy bieżące wystąpienie i <paramref name="other" /> jest równe.</param>
        <summary>Określa, czy obiekt jest równy bieżącemu wystąpieniu.</summary>
        <returns><see langword="true" />Jeśli dwa obiekty są równe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt, który oblicza wartość skrótu bieżącego obiektu.</param>
        <summary>Zwraca kod skrótu dla bieżącego wystąpienia.</summary>
        <returns>Kod skrótu dla bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Array> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowe, zależne od <see cref="T:System.Array" /> zera, do sprawdzenia warunków.</param>
        <param name="match">Predykat, który definiuje warunki do sprawdzenia względem elementów.</param>
        <summary>Określa, czy każdy element w tablicy odpowiada warunkom zdefiniowanym przez określony predykat.</summary>
        <returns><see langword="true" />Jeśli każdy element w <paramref name="array" /> jest zgodny z warunkami zdefiniowanymi przez określony predykat; <see langword="false" />w przeciwnym razie. Jeśli tablica nie zawiera żadnych elementów, wartość zwracana to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca`true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy `array` są indywidualnie przenoszone <xref:System.Predicate%601>do, a przetwarzanie jest przerywane, gdy delegat zwraca `false` dla dowolnego elementu.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ostatni znak każdego elementu w tablicy ciągów jest liczbą. Tworzy dwie tablice ciągów. Pierwsza tablica zawiera ciągi kończące się znakami alfabetycznymi i ciągami kończącymi się znakami liczbowymi. Druga tablica zawiera tylko ciągi kończące się znakami liczbowymi. W przykładzie zdefiniowano również `EndWithANumber` metodę, której sygnatura <xref:System.Predicate%601> jest zgodna z delegatem. Przykład przekazuje każdą tablicę do <xref:System.Array.TrueForAll%2A> metody wraz z delegatem, który `EndsWithANumber` reprezentuje metodę.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Poniższy przykład jest podobny do pierwszego, z tą różnicą, że przekazuje tablicę ciągów do <xref:System.Array.TrueForAll%2A> metody wraz z wyrażeniem lambda, które określa, czy określony element tablicy kończy się ciągiem reprezentujący liczbę.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 W obu przypadkach <xref:System.Array.TrueForAll%2A> Metoda zwraca `false` się zaraz po napotkaniu pierwszego elementu tablicy, który nie kończy się liczbą. W przeciwnym razie zwraca `true` po wykonaniu iteracji wszystkich elementów w tablicy.  
  
> [!NOTE]
>  Jak w obu przykładach pokazano C# , w i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
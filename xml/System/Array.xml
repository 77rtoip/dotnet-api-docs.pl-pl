<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e84e497cc9b3a9531978b8704b5e107ac8cfda55" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36435088" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody tworzenia, modyfikowania, wyszukiwania i sortowania tablic, w tym samym służy jako klasa podstawowa dla wszystkich tablic w środowisko uruchomieniowe języka wspólnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Klasa nie jest częścią <xref:System.Collections> przestrzeni nazw. Jednak nadal uważa się kolekcji, ponieważ jest on oparty na <xref:System.Collections.IList> interfejsu.  
  
 <xref:System.Array> Klasa jest klasą podstawową dla implementacji języka, które obsługują tablic. Jednak tylko systemu i kompilatory można jawnie pochodzi od <xref:System.Array> klasy. Użytkownicy powinny zostać konstrukcje tablicy udostępniane przez język.  
  
 Element ma wartość <xref:System.Array>. Długość <xref:System.Array> jest to całkowita liczba elementów może zawierać. Dolna granica <xref:System.Array> jest indeks pierwszego elementu. <xref:System.Array> Może mieć żadnych dolna granica, ale ma dolna granica zero domyślnie. Podczas tworzenia wystąpienia można zdefiniować dolną granicą inną <xref:System.Array> przy użyciu <xref:System.Array.CreateInstance%2A>. Wielowymiarowe <xref:System.Array> może mieć różne granic dla każdego wymiaru. Tablica może mieć maksymalnie 32 wymiarów.  
  
 W odróżnieniu od klasy w <xref:System.Collections> przestrzeni nazw, <xref:System.Array> ma stały pojemność. Aby zwiększyć pojemność, należy utworzyć nowy <xref:System.Array> obiektów z wymaganą pojemnością, skopiować elementy ze starego <xref:System.Array> do nowego obiektu, a następnie usuń stare <xref:System.Array>.  
  
 Domyślnie maksymalny rozmiar <xref:System.Array> 2 gigabajty (GB). W środowisku 64-bitowym ograniczenie rozmiaru można uniknąć, ustawiając `enabled` atrybutu [gcallowverylargeobjects —](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) element konfiguracji do `true` w środowisku czasu wykonywania. Jednak tablicy nadal będzie ograniczona, łączną liczbę elementów 4 miliardy oraz maksymalny indeks 0X7FEFFFFF w dowolnym danym wymiarze (0X7FFFFFC7 tablice typu byte i tablice struktur jednobajtowe).  
  
 Tablice jednowymiarowe zaimplementować <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> i <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfejsach. Implementacje są dostarczane do tablic w czasie wykonywania, a w związku z tym interfejsy ogólne nie są wyświetlane w Składnia deklaracji <xref:System.Array> klasy. Ponadto nie ma żadnych tematy dokumentacji dla członków interfejsu, które są dostępne tylko przez rzutowanie tablicy typu ogólnego interfejsu (jawne implementacje interfejsu). Klucza jest, aby mieć świadomość podczas rzutowania tablicy do jednej z tych interfejsów jest elementów członkowskich, które dodają, Wstaw lub usuń elementy throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> obiekty zawierają informacje dotyczące deklaracje typu tablicy. <xref:System.Array> obiekty z tym samym typem tablicy współużytkują takie same <xref:System.Type> obiektu.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> i <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> nie może zwrócić oczekiwanych rezultatów przy <xref:System.Array> ponieważ jeśli tablica jest rzutowany na typ <xref:System.Array>, wynikiem jest obiekt nie tablicy. Oznacza to `typeof(System.Array).IsArray` zwraca `false`, i `typeof(System.Array).GetElementType` zwraca `null`.  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> Metoda kopiuje elementy nie tylko między macierzami z tego samego typu, ale również między standardowe tablice o różnych typach; obsługiwane są automatycznie rzutowanie typów.  
  
 Niektóre metody, takie jak <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, i <xref:System.Array.SetValue%2A>, podaj przeciążenia, które akceptują 64-bitowych liczb całkowitych jako parametry, aby pomieścić tablice dużej pojemności. <xref:System.Array.LongLength%2A> i <xref:System.Array.GetLongLength%2A> zwraca 64-bitowych liczb całkowitych wskazującą długości tablicy.  
  
 <xref:System.Array> Nie jest gwarantowana ma zostać posortowana.  Należy sortować <xref:System.Array> przed wykonaniem operacji (takich jak <xref:System.Array.BinarySearch%2A>), które wymagają <xref:System.Array> ma zostać posortowana.  
  
 Przy użyciu <xref:System.Array> obiektu wskaźniki w kodzie natywnym nie jest obsługiwana i zgłosi <xref:System.NotSupportedException> dla kilku metod.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Array.Copy%2A?displayProperty=nameWithType> kopiuje elementy między tablicą typu integer i tablicy typu <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu tworzy i inicjuje <xref:System.Array> i wyświetla jego właściwości i jej elementów.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  Ta implementacja nie zapewnia zsynchronizowany otoki (wielowątkowość) dla <see cref="T:System.Array" />, jednak na podstawie klasy .NET Framework <see cref="T:System.Array" /> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <see cref="P:System.Array.SyncRoot" /> właściwości.  Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do zakodowania w tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki.</param>
        <summary>Zwraca tylko do odczytu otoki dla określonej tablicy.</summary>
        <returns>Tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki dla określonej tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wszelkie zmiany w tablicy, ujawnia tablicy tylko za pośrednictwem tej otoki.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład otacza tablicy tylko do odczytu <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje jednowymiarowa sortowane <see cref="T:System.Array" /> wartości, przy użyciu algorytmu wyszukiwania binarnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanych jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Wyszukiwanie jako całą jednowymiarowa sortowane tablicy dla określonego elementu, za pomocą <see cref="T:System.IComparable" /> interfejsu zaimplementowanego przez każdy element tablicy i określonego obiektu.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Albo `value` lub każdy element `array` musi implementować <xref:System.IComparable> interfejs, który jest używany do porównania. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli`value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Array.BinarySearch%2A> można znaleźć określonego obiektu w <xref:System.Array>.  
  
> [!NOTE]
>  Tablica jest tworzony z jego elementów w kolejności rosnącej. <xref:System.Array.BinarySearch%2A> Metoda wymaga tablicy mają być sortowane w kolejności rosnącej.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Typ nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotkał element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanych jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Wyszukiwanie jako całą jednowymiarowa sortowane tablicy wartości przy użyciu określonego <see cref="T:System.Collections.IComparer" /> interfejsu.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie jest `null`, elementy `array` są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.IComparer> implementacji. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli`comparer` jest `null`, porównanie wykonuje się za pomocą <xref:System.IComparable> implementacja elementu lub określonej wartości. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotkał element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanych jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje zakresu elementów tablicą jednowymiarową posortowane wartości, przy użyciu <see cref="T:System.IComparable" /> interfejsu zaimplementowanego przez każdy element tablicy i określonej wartości.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Albo `value` lub każdy element `array` musi implementować <xref:System.IComparable> interfejs, który jest używany do porównania. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotkał element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowanych jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Przeszukuje tablicą jednowymiarową posortowane wartości, korzystając z określonego zakresu elementów <see cref="T:System.Collections.IComparer" /> interfejsu.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie jest `null`, elementy `array` są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.IComparer> implementacji. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null`, porównanie wykonuje się za pomocą <xref:System.IComparable> implementacja elementu lub określonej wartości. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek, korzystając z <xref:System.IComparable>.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotkał element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanych jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Wyszukiwanie jako całą jednowymiarowa sortowane tablicy dla określonego elementu, za pomocą <see cref="T:System.IComparable`1" /> ogólny interfejs implementowany przez każdy element <see cref="T:System.Array" /> i określonego obiektu.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli `array` nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T` musi implementować <xref:System.IComparable%601> interfejs ogólny, który służy do porównania. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable%601> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable%601> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> przeciążenia metody rodzajowej i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> przeciążenia metody rodzajowej. Tablica ciągów jest tworzony w określonej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być posortowane w celu użycia <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który. Tablica i wartość zwracaną <xref:System.Array.BinarySearch%2A> metody są przekazywane do `ShowWhere` ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy. Indeks jest liczbą ujemną, jeśli ciąg nie jest w tablicy, więc `ShowWhere` metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor`-1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż wyszukiwanie str w toku.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanych jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> stosowania dla każdego elementu.</param>
        <summary>Wyszukiwanie jako całą jednowymiarowa sortowane tablicy wartości przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie jest `null`, elementy `array` są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacją ogólnego interfejsu. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null`, porównanie wykonuje się za pomocą <xref:System.IComparable%601> implementacji interfejsu ogólnego pochodzącymi `T`. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable%601> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable%601> interfejs ogólny, elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable%601> przed rozpoczęciem wyszukiwania. Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <xref:System.IComparable%601>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable%601> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być posortowane w celu użycia <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który. Tablica i wartość zwracaną <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody są przekazywane do `ShowWhere` ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy. Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs ogólny</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanych jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Przeszukuje zakresu elementów tablicą jednowymiarową posortowane wartości, przy użyciu <see cref="T:System.IComparable`1" /> ogólny interfejs implementowany przez każdy element <see cref="T:System.Array" /> i podaną wartość.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli macierz nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T` musi implementować <xref:System.IComparable%601> interfejs ogólny, który służy do porównania. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable%601> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable%601> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowanych jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> stosowania dla każdego elementu.</param>
        <summary>Przeszukuje tablicą jednowymiarową posortowane wartości, korzystając z określonego zakresu elementów <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <returns>Określony indeks <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> zostanie odnaleziony; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest mniejszy niż jeden lub więcej elementów w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie można odnaleźć i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1). Jeśli ta metoda jest wywoływana z innych niż — sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy. `array` muszą być posortowane przed wywołaniem tej metody.  
  
 Jeśli macierz nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operator dopełnienia bitowego można zastosować (~ w języku C# `Not` w języku Visual Basic) do negatywny wynik do tworzenia indeksu. Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż `value` w tablicy. W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie jest `null`, elementy `array` są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacją ogólnego interfejsu. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez `comparer`; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Jeśli `comparer` jest `null`, porównanie wykonuje się za pomocą <xref:System.IComparable%601> implementacji ogólny interfejs dostarczony dla typu `T`. Elementy `array` już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <xref:System.IComparable%601> implementacji; w przeciwnym razie wynik może być nieprawidłowy.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równa `value`, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.  
  
 `null` zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z `null` nie generują wyjątek, korzystając z <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Dla każdego elementu przetestowane `value` jest przekazywany do odpowiedniego <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to <xref:System.IComparable%601> wdrożenia Określa jak porównuje danego elementu `null`.  
  
 Ta metoda jest O (dziennika `n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica której elementy muszą zostać wyczyszczone.</param>
        <param name="index">Indeks początkowy zakresu elementów, aby wyczyścić.</param>
        <param name="length">Liczba elementów, aby wyczyścić.</param>
        <summary>Określa zakres elementów w tablicy na wartość domyślną każdego typu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje zresetowanie każdego elementu w tablicy, wartość domyślna typu elementu. Ustawia elementy Typy odwołań (łącznie z <xref:System.String> elementy) do `null`i ustawia elementy typów wartości do wartości domyślnych, które przedstawiono w poniższej tabeli.  
  
|Typ|Wartość|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Wszystkie typy liczbowe punktu całkowitych i zmiennoprzecinkowych|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Inne typy wartości|Domyślna wartość pola typu|  
  
 Zakres wyczyszczone zawijania elementy wiersz po wierszu w tablicy wielowymiarowej.  
  
 Ta metoda usuwa tylko wartości elementów; nie są usuwane ze sobą elementy. Tablica ma stały rozmiar; w związku z tym elementów nie można dodać ani usunąć.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.Clear%2A> metodę, aby zresetować wartości całkowite w tablicy jednowymiarowa dwuwymiarowa i trójwymiarowych.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `TimeZoneTime` struktury zawierającej <xref:System.TimeZoneInfo> pola i <xref:System.DateTimeOffset> pola. Następnie wywołuje <xref:System.Array.Clear%2A> metodę, aby wyczyścić jeden element w tablicy dwuelementową `TimeZoneTime` wartości. Metoda ustawia wartość elementu wyczyszczone, wartość domyślna wynosząca <xref:System.TimeZoneInfo> obiektu, który jest `null`i wartość domyślną <xref:System.DateTimeOffset> obiektu, który jest <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.  - lub - sumę <paramref name="index" /> i <paramref name="length" /> jest większy niż rozmiar <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną <see cref="T:System.Array" />.</summary>
        <returns>Kopia pobieżna <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopia pobieżna <xref:System.Array> kopiuje elementy ze <xref:System.Array>, czy znajdują się odwołania typy lub wartości, ale nie kopiuje obiektów, które dotyczą odwołania. Odwołań w nowym <xref:System.Array> wskazują ten sam obiekty, które odwołań w oryginalnym <xref:System.Array> wskaż.  
  
 Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 Klon jest taka sama <xref:System.Type> jak oryginał <xref:System.Array>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Poniższy kod przykładowy klony <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> tablicy i prezentuje działanie kopia pobieżna.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">32-bitową liczbę całkowitą, która reprezentuje indeks w <c>Tablica_źródłowa</c> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Odbierająca danych.</param>
        <param name="destinationIndex">32-bitową liczbę całkowitą, która reprezentuje indeks w <c>destinationArray</c> od przechowywania, która rozpoczyna się.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Array" /> począwszy od indeksu określone źródło i wkleja je do innego <see cref="T:System.Array" /> począwszy od indeksu do określonej lokalizacji docelowej.  Gwarantuje, że wszystkie zmiany zostaną cofnięte, jeśli kopiowanie nie powiedzie się całkowicie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametry muszą mieć taką samą liczbę wymiarów.  `sourceArray` Typu musi być taka sama jak lub pochodny `destinationArray` typu; w przeciwnym razie <xref:System.ArrayTypeMismatchException> jest generowany.  W odróżnieniu od <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> sprawdza zgodność typy tablic, przed wykonaniem każdej operacji.  
  
 Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), `sourceIndex` musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości `sourceArray` zostały zachowane w tymczasowej lokalizacji przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest odpowiednikiem standardowego funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.  Jeśli `sourceArray` i `destinationArray` są obie tablic typu odwołania lub obu tablic typu <xref:System.Object>, jest wykonywana kopia pobieżna. Kopia pobieżna <xref:System.Array> to nowa <xref:System.Array> zawierające odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, `destinationArray` pozostaje niezmieniona; w związku z tym <xref:System.Array.ConstrainedCopy%2A> znajdują się w regionie ograniczonego wykonania (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  - lub - <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> ma różnym stopniu.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> Typu nie jest ani taka sama jak ani nie pochodzi od <paramref name="destinationArray" /> typu.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> jest mniejsza niż dolna granica pierwszym wymiarze <paramref name="sourceArray" />.  - lub - <paramref name="destinationIndex" /> jest mniejsza niż dolna granica pierwszym wymiarze <paramref name="destinationArray" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  - lub - <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Typ elementów tablicy źródłowej.</typeparam>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> można przekonwertować na typ docelowy.</param>
        <param name="converter">A <see cref="T:System.Converter`2" /> konwertująca każdy element z jednego typu do innego typu.</param>
        <summary>Konwertuje tablicę jednego typu na tablicę innego typu.</summary>
        <returns>Tablica zawierająca elementy przekonwertowany z tablicy źródłowej na typ docelowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegowany do metody, która konwertuje obiektu na typ docelowy.  Elementy `array` indywidualnie są przekazywane do <xref:System.Converter%602>, i przekonwertowane elementy są zapisywane w nowej tablicy.  
  
 Źródło `array` pozostaje niezmieniona.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metodę o nazwie `PointFToPoint` konwertująca <xref:System.Drawing.PointF> struktury do <xref:System.Drawing.Point> struktury. Następnie tworzony tablicę <xref:System.Drawing.PointF> struktury, tworzy `Converter<PointF, Point>` delegować (`Converter(Of PointF, Point)` w języku Visual Basic) do reprezentowania `PointFToPoint` metody i przekazuje delegata do <xref:System.Array.ConvertAll%2A> — metoda. <xref:System.Array.ConvertAll%2A> Metoda przekazuje każdy element na liście wejściowej, aby `PointFToPoint` — metoda i umieszcza przekonwertowanego elementy do nowej listy <xref:System.Drawing.Point> struktury. Zarówno listy są wyświetlane.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="converter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje zakresu elementów w jednym <see cref="T:System.Array" /> do innego <see cref="T:System.Array" /> i wykonuje typu rzutowania i konwersja boxing zgodnie z wymaganiami.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Odbierająca danych.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Array" /> zaczynając od pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> zaczynając od pierwszego elementu. Długość jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametry muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowanych danych.  
  
 Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie określone są pełne. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości `sourceArray` zostały zachowane w tymczasowej lokalizacji przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest odpowiednikiem standardowego funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <xref:System.InvalidCastException> jest generowany.  
  
-   Jeśli `sourceArray` i `destinationArray` są obie tablic typu odwołania lub obu tablic typu <xref:System.Object>, jest wykonywana kopia pobieżna. Kopia pobieżna <xref:System.Array> to nowa <xref:System.Array> zawierające odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest niezgodny z <xref:System.Object> i typu interfejsu implementowanych przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawnej konwersji <xref:System.Enum> i ich typ podstawowy.  
  
 Jeśli wartość każdego elementu w `sourceArray` wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w `destinationArray`, <xref:System.InvalidCastException> jest generowany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  - lub - <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> ma różnym stopniu.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów w <paramref name="sourceArray" />.  - lub - <paramref name="length" /> jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Odbierająca danych.</param>
        <param name="length">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania. Liczba całkowita należy do zakresu od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Array" /> zaczynając od pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> zaczynając od pierwszego elementu. Długość jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametry muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowanych danych.  
  
 Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie określone są pełne. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości `sourceArray` zostały zachowane w tymczasowej lokalizacji przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest odpowiednikiem standardowego funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <xref:System.InvalidCastException> jest generowany.  
  
-   Jeśli `sourceArray` i `destinationArray` są obie tablic typu odwołania lub obu tablic typu <xref:System.Object>, jest wykonywana kopia pobieżna. Kopia pobieżna <xref:System.Array> to nowa <xref:System.Array> zawierające odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest niezgodny z <xref:System.Object> i typu interfejsu implementowanych przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawnej konwersji <xref:System.Enum> i ich typ podstawowy.  
  
 Jeśli wartość każdego elementu w `sourceArray` wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w `destinationArray`, <xref:System.InvalidCastException> jest generowany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  - lub - <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> ma różnym stopniu.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza niż 0 lub większą niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów w <paramref name="sourceArray" />.  - lub - <paramref name="length" /> jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">32-bitową liczbę całkowitą, która reprezentuje indeks w <c>Tablica_źródłowa</c> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Odbierająca danych.</param>
        <param name="destinationIndex">32-bitową liczbę całkowitą, która reprezentuje indeks w <c>destinationArray</c> od przechowywania, która rozpoczyna się.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Array" /> począwszy od indeksu określone źródło i wkleja je do innego <see cref="T:System.Array" /> począwszy od indeksu do określonej lokalizacji docelowej. Długość i indeksy są określone jako 32-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametry muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów od `destinationIndex` pozycji, aby pomieścić skopiowanych danych.  
  
 Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), `sourceIndex` musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości `sourceArray` zostały zachowane w tymczasowej lokalizacji przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest odpowiednikiem standardowego funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <xref:System.InvalidCastException> jest generowany.  
  
-   Jeśli `sourceArray` i `destinationArray` są obie tablic typu odwołania lub obu tablic typu <xref:System.Object>, jest wykonywana kopia pobieżna. Kopia pobieżna <xref:System.Array> to nowa <xref:System.Array> zawierające odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest niezgodny z <xref:System.Object> i typu interfejsu implementowanych przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawnej konwersji <xref:System.Enum> i ich typ podstawowy.  
  
 Jeśli wartość każdego elementu w `sourceArray` wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w `destinationArray`, <xref:System.InvalidCastException> jest generowany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  - lub - <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> ma różnym stopniu.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> jest mniejsza niż dolna granica pierwszym wymiarze <paramref name="sourceArray" />.  - lub - <paramref name="destinationIndex" /> jest mniejsza niż dolna granica pierwszym wymiarze <paramref name="destinationArray" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  - lub - <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">64-bitową liczbę całkowitą, która reprezentuje indeks w <c>Tablica_źródłowa</c> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Odbierająca danych.</param>
        <param name="destinationIndex">64-bitową liczbę całkowitą, która reprezentuje indeks w <c>destinationArray</c> od przechowywania, która rozpoczyna się.</param>
        <param name="length">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania. Liczba całkowita należy do zakresu od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Array" /> począwszy od indeksu określone źródło i wkleja je do innego <see cref="T:System.Array" /> począwszy od indeksu do określonej lokalizacji docelowej. Długość i indeksy są określone jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametry muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów od `destinationIndex` pozycji, aby pomieścić skopiowanych danych.  
  
 Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), `sourceIndex` musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości `sourceArray` zostały zachowane w tymczasowej lokalizacji przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest odpowiednikiem standardowego funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <xref:System.InvalidCastException> jest generowany.  
  
-   Jeśli `sourceArray` i `destinationArray` są obie tablic typu odwołania lub obu tablic typu <xref:System.Object>, jest wykonywana kopia pobieżna. Kopia pobieżna <xref:System.Array> to nowa <xref:System.Array> zawierające odwołania do tych samych elementów jak oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Z kolei bezpośrednich kopię <xref:System.Array> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest niezgodny z <xref:System.Object> i typu interfejsu implementowanych przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawnej konwersji <xref:System.Enum> i ich typ podstawowy.  
  
 Jeśli wartość każdego elementu w `sourceArray` wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w `destinationArray`, <xref:System.InvalidCastException> jest generowany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  - lub - <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> ma różnym stopniu.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="sourceArray" />.  - lub - <paramref name="destinationIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="destinationArray" />.  - lub - <paramref name="length" /> jest mniejsza niż 0 lub większą niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  - lub - <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje wszystkie elementy tablicy jednowymiarowej bieżącej do określonej tablicy jednowymiarowej tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z bieżącej tablicy.</param>
        <param name="index">32-bitową liczbę całkowitą, która reprezentuje indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy bieżącego tablicy jednowymiarowej do określonej tablicy jednowymiarowej tablicy, zaczynając od indeksu tablicy w określonej lokalizacji docelowej. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy do bieżącego wystąpienia tablicy `array` docelowej tablicy, zaczynając od indeksu `index`. `array` Tablicy docelowej musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu. W przypadku implementowania <xref:System.Collections.ICollection?displayProperty=nameWithType> jest jawnie nie jest to wymagane, użyj <xref:System.Array.Copy%2A> Aby uniknąć dodatkowych pośrednie.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A>. Wykonuje kopię pobieżną tylko.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array> z dolną granicą różną od zera. Należy pamiętać, że cały źródła <xref:System.Array> jest kopiowana, włączając puste elementy, które zastąpić istniejące elementy w celu <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  - lub - liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Typ źródła <see cref="T:System.Array" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Źródłowa tablica jest wielowymiarowa.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z bieżącej tablicy.</param>
        <param name="index">64-bitową liczbę całkowitą, która reprezentuje indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy bieżącego tablicy jednowymiarowej do określonej tablicy jednowymiarowej tablicy, zaczynając od indeksu tablicy w określonej lokalizacji docelowej. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy do bieżącego wystąpienia tablicy `array` docelowej tablicy, zaczynając od indeksu `index`. `array` Tablicy docelowej musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu. W przypadku implementowania <xref:System.Collections.ICollection?displayProperty=nameWithType> jest jawnie nie jest to wymagane, użyj <xref:System.Array.Copy%2A> Aby uniknąć dodatkowych pośrednie.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A>. Wykonuje kopię pobieżną tylko.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array> z dolną granicą różną od zera. Należy pamiętać, że cały źródła <xref:System.Array> jest kopiowana, włączając puste elementy, które zastąpić istniejące elementy w celu <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  - lub - liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Typ źródła <see cref="T:System.Array" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Źródło <see cref="T:System.Array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Array" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length">Rozmiar <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy jednowymiarowa <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i długości z indeksowania liczony od zera.</summary>
        <returns>Nowy jednowymiarowa <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości, przy użyciu indeksowania liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania jednowymiarowa <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">32-bitowych liczb całkowitych, które reprezentują rozmiar każdego wymiaru tablicy <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiarów długości z indeksowania liczony od zera. Długości wymiaru są określone w tablicy 32-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczby wymiarów w nowym <xref:System.Array>. Każdy element `lengths` określić długości odpowiedniego wymiaru tablicy w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  - lub - <paramref name="lengths" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.  - lub - <paramref name="lengths" /> tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">64-bitowych liczb całkowitych, które reprezentują rozmiar każdego wymiaru tablicy <see cref="T:System.Array" /> do utworzenia. Każdy całkowitą w tablicy musi wynosić od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiarów długości z indeksowania liczony od zera. Długości wymiaru są określone w tablicy 64-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczby wymiarów w nowym <xref:System.Array>. Każdy element `lengths` określić długości odpowiedniego wymiaru tablicy w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  - lub - <paramref name="lengths" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.  - lub - <paramref name="lengths" /> tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza niż zero lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszym wymiarze <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length2">Rozmiar drugiego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy dwuwymiarowa <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiarów długości z indeksowania liczony od zera.</summary>
        <returns>Nowy dwuwymiarowa <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest produktem `length1` i `length2`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania dwuwymiarowa <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> jest mniejsza od zera.  - lub - <paramref name="length2" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Jednowymiarowa tablica, która zawiera rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lowerBounds">Jednowymiarowa tablica, która zawiera dolna granica (indeks początkowy) każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiarów długości z określonym dolne granice tablicy.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> z określoną długość i dolną granicę każdego wymiaru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 `lengths` i `lowerBounds` tablice muszą mieć taką samą liczbę elementów. Liczba elementów w `lengths` tablicy musi być równa liczby wymiarów w nowym <xref:System.Array>.  
  
 Każdy element `lengths` określić długości odpowiedniego wymiaru tablicy w nowym <xref:System.Array>.  
  
 Każdy element `lowerBounds` określić dolna granica odpowiedniego wymiaru tablicy w nowym <xref:System.Array>. Ogólnie rzecz biorąc Biblioteka klas programu .NET Framework i wielu języków programowania nie obsługują niezerową dolne granice tablicy.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <xref:System.Array> z określonym dolne granice tablicy.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  - lub - <paramref name="lengths" /> jest <see langword="null" />.  - lub - <paramref name="lowerBounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.  - lub - <paramref name="lengths" /> tablica zawiera mniej niż jeden element.  - lub - <paramref name="lengths" /> i <paramref name="lowerBounds" /> tablice nie zawierają tę samą liczbę elementów.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza od zera.  - lub - dowolna wartość <paramref name="lowerBounds" /> jest bardzo duży, w taki sposób, że suma dolna granica wymiaru i jego długość jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszym wymiarze <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length2">Rozmiar drugiego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length3">Rozmiar wymiaru innych <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy trójwymiarowy <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiarów długości z indeksowania liczony od zera.</summary>
        <returns>Nowy trójwymiarowy <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klasy <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.  
  
 Elementy typu odwołania są zainicjowane do `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operację, której `n` jest produktem `length1`, `length2`, i `length3`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania trójwymiarowy <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłową <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  - lub - <paramref name="elementType" /> jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> jest mniejsza od zera.  - lub - <paramref name="length2" /> jest mniejsza od zera.  - lub - <paramref name="length3" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <summary>Zwraca pustą tablicę.</summary>
        <returns>Zwraca pustą <see cref="T:System.Array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Określa, czy określona tablica zawiera elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="array" /> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>, i przetwarzania jest zatrzymana po znalezieniu dopasowania.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie <xref:System.Predicate%601> jawnie delegowanie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie warunki dopasowania <xref:System.Array.Exists%2A> wyrażenia usinglambda metody do sprawdzenia, czy planety zaczynał się literą danego lub czy świecie znajduje się w podanej tablicy.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 W poniższym przykładzie użyto <xref:System.Array.Exists%2A> metodę, aby wskazać, czy wszystkie nazwy w tablicy ciągów zaczynają się od określonego znaku. Przykład tworzy `StringSearcher` obiektu przez przekazywanie ciągu wyszukiwania dla jego konstruktora klasy. `StringSearcher.StartsWith` Metoda ma takiego samego podpisu jak <xref:System.Predicate%601> delegowanie. Gdy <xref:System.Array.Exists%2A> metoda jest wywoływana, każdy element członkowski tablicy jest przekazywana do delegata, dopóki zwróci `true` lub iteracji wszystkich elementów w tablicy.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Można również użyć wyrażenia lambda zamiast jawnie definiować metody, której sygnatura odpowiada do tego delegata. W poniższym przykładzie `StringSearcher` klasy i jej `StartsWith` metody za pomocą wyrażenia lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</param>
        <param name="match">Predykat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca pierwsze wystąpienie w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Pierwszy element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody lub wyrażenie lambda, które zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegat lub wyrażenie lambda.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>, rozpoczynając od pierwszego elementu i kończąc ostatnim elemencie.  Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Predicate%601> delegat <xref:System.Array.Find%2A> metody ogólnej wyszukiwania tablicę <xref:System.Drawing.Point> struktury. Reprezentuje delegata, Metoda `ProductGT10`, zwraca `true` Jeśli produkt pola X i Y jest większa niż 100 000. <xref:System.Array.Find%2A> Metoda wywołuje delegata dla każdego elementu w tablicy, zwracając pierwszego punktu, który spełnia warunek testu.  
  
> [!NOTE]
>  Visual Basic i C# użytkowników ma utworzyć delegat jawnie lub określić argument typu metody ogólnej. Kompilatory ustalić wymagane typy z podane argumenty metody.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Zamiast jawnie definiowanie metody podpisem konieczne utworzenie wystąpienia <xref:System.Predicate%601> delegować i przekazywanie delegata do <xref:System.Array.Find%2A> metody jest zwyczajowe można użyć wyrażenia lambda. Poniższy przykład jest taki sam jak poprzedni, z wyjątkiem tego, że używa wyrażenia lambda jako `match` argumentu.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Pobiera wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>
          <see cref="T:System.Array" /> Zawierający wszystkie elementy zgodnych warunki zdefiniowane przez określony predykat, jeśli je znaleziono; w przeciwnym razie, pustą <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>, i elementy, które spełniają podane są zapisywane w zwróconej tablicy.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę 50 liczb losowych wartości, które mogą należeć do zakresu od 0 do 1000. Następnie wywołuje <xref:System.Array.FindAll%2A> metody za pomocą wyrażenia lambda, która zwraca wartości zakresu od 300 do 600. Należy pamiętać, że wyrażenie lambda jest przekazywany parametr o nazwie `x`;  Ta pozycja reprezentuje poszczególnych element członkowski, który jest przekazywany do <xref:System.Predicate%601>. Należy również zauważyć, że lokalna `lBound` i `uBound` zmienne są dostępne w wyrażeniu lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Poniższy przykład kodu pokazuje <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, i <xref:System.Array.FindAll%2A> metody ogólne. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.Find%2A> Metoda rodzajowa jest przesyłany tablicy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLast%2A> Metoda ogólna służy do wyszukiwania do tyłu na końcu tablicy. Znajduje element „Dilophosaurus” w pozycji 5. <xref:System.Array.FindAll%2A> Metoda ogólna służy do zwracania tablica zawierająca wszystkie elementy, które kończą się "saurus". Elementy są wyświetlane.  
  
 Przykład kodu pokazuje, również <xref:System.Array.Exists%2A> i <xref:System.Array.TrueForAll%2A> metody ogólne.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w <see cref="T:System.Array" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w obrębie całej <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest do przodu zaczynając od pierwszego elementu i końcowy z ostatniego elementu.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy. Wyszukiwany element na pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest do przodu zaczynając od `startIndex` i kończąc na ostatnim elemencie.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy. Wyszukiwany element na pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> rozpoczyna się od określonego indeksu i zawiera określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest do przodu zaczynając od `startIndex` i kończący się na `startIndex` plus `count` pomniejszonej o 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy. Wyszukiwany element na pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca ostatnie wystąpienie w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Ostatni element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>, przenoszenie z poprzednimi wersjami w <xref:System.Array>, zaczynając od ostatniego elementu i kończąc pierwszego elementu.  Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, i <xref:System.Array.FindAll%2A> metody ogólne. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.Find%2A> Metoda rodzajowa jest przesyłany tablicy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie`Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLast%2A> Metoda ogólna służy do wyszukiwania do tyłu na końcu tablicy. Znajduje element „Dilophosaurus” w pozycji 5. <xref:System.Array.FindAll%2A> Metoda ogólna służy do zwracania tablica zawierająca wszystkie elementy, które kończą się "saurus". Elementy są wyświetlane.  
  
 Przykład kodu pokazuje, również <xref:System.Array.Exists%2A> i <xref:System.Array.TrueForAll%2A> metody ogólne.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks w ciągu ostatniego wystąpienia <see cref="T:System.Array" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w obrębie całej <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy. Wyszukiwany element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończącego się na pierwszym elementem.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od początku `array` do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy. Wyszukiwany element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> czy zawiera określoną liczbę elementów i kończy się na określony indeks.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończący się na `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy. Wyszukiwany element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> dla elementów, których ma być wykonywane działania.</param>
        <param name="action">
          <see cref="T:System.Action`1" /> Do wykonania na każdym elemencie <c>tablicy</c>.</param>
        <summary>Wykonuje określoną akcję na każdym elemencie określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Delegowany do metody, która wykonuje akcję na obiekcie przekazywanych do niej.  Elementy `array` indywidualnie są przekazywane do <xref:System.Action%601>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Array.ForEach%2A> do wyświetlenia kwadratów każdego elementu w tablicy liczby całkowitej.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="action" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> dla <see cref="T:System.Array" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Dla <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Array.GetEnumerator%2A> do listy elementów tablicy.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiaru <see cref="T:System.Array" /> którego długość musi można określić.</param>
        <summary>Pobiera 32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykład <xref:System.Array.GetLength%2A> jest `GetLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Array.GetLength%2A> do wyświetlenia wymiary dwie tablice o różnym stopniu.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza od zera.  - lub - <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiaru <see cref="T:System.Array" /> którego długość musi można określić.</param>
        <summary>Pobiera 64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykład <xref:System.Array.GetLongLength%2A> jest `GetLongLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza od zera.  - lub - <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiar tablicy, którego indeks początkowy trzeba określić.</param>
        <summary>Pobiera indeks pierwszego elementu określonego wymiaru tablicy.</summary>
        <returns>Indeks pierwszego elementu obiektu określonego wymiaru tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Zwraca indeks początkowy pierwszego wymiaru tablicy, i `GetLowerBound(Rank - 1)` zwraca indeks początkowy ostatniego wymiaru tablicy.  
  
 <xref:System.Array.GetLowerBound%2A> Metoda zawsze zwraca wartość wskazującą, indeks dolna granica tablicy, nawet jeśli tablica jest pusta.  
  
 Należy zauważyć, że chociaż większość tablic w programie .NET Framework jest liczony od zera (to znaczy <xref:System.Array.GetLowerBound%2A> metoda zwraca zero dla każdego wymiaru tablicy), programu .NET Framework obsługuje tablic, które nie są liczony od zera. Takie tablice można tworzyć za pomocą <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> metody, a także mogą być zwracane z kodem niezarządzanym.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metody do wyświetlania granice tablicy jednowymiarowej tablicy i dwuwymiarowa i wyświetlanie ich elementów tablicy wartości.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza od zera.  - lub - <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiar tablicy, w których górna granica trzeba określić.</param>
        <summary>Pobiera indeks ostatnim elementem określonego wymiaru tablicy.</summary>
        <returns>Indeks ostatniego elementu określonego wymiaru tablicy lub -1, jeśli określony wymiar jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Zwraca ostatni indeks w pierwszym wymiarze tablicy i `GetUpperBound(Rank - 1)` zwraca ostatni indeks ostatniego wymiaru tablicy.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metody do wyświetlania granice tablicy jednowymiarowej tablicy i dwuwymiarowa i wyświetlanie ich elementów tablicy wartości.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza od zera.  - lub - <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonego elementu w bieżącym <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">32-bitową liczbę całkowitą, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksów określający pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />. Indeksy są określone jako tablicę 32-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">64-bitową liczbę całkowitą, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksów określający pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />. Indeksy są określone jako tablicę 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index3">32-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie trzy wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index3">64-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie trzy wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej tablicy lub zakresu elementów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicą jednowymiarową.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" /> w <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje wszystkie elementy jednowymiarowa arrayfor `value`. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując każdy element `Equals` metody do momentu znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, tego zastąpienia.  
  
 Ponieważ większość tablice dolna granica zero, tej metody zwykle zwraca -1, jeśli`value` nie zostanie odnaleziony. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie zostanie odnaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia w tablicy ciągów indeksu ciągu:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Indeks początkowy wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks jego pierwszego wystąpienia. Z zakresu od określonego indeksu do końca tablicy.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" />, jeśli został znaleziony, w ramach zakresu elementów <paramref name="array" /> rozciąga się od <paramref name="startIndex" /> do ostatniego elementu; w przeciwnym razie wartość dolnej granicy tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyszukuje tablicą jednowymiarową z elementu o indeksie `startIndex` do ostatniego elementu. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `Equals` metody każdego elementu, aż do znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, tego zastąpienia.  
  
 Ponieważ większość tablice dolna granica zero, tej metody zwykle zwraca -1, jeśli `value` nie zostanie odnaleziony. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie zostanie odnaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startIndex` jest równe <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia w tablicy ciągów indeksu ciągu:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Indeks początkowy wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów do wyszukiwania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks ifs pierwszego wystąpienia. Z zakresu od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" />, jeśli został znaleziony w <paramref name="array" /> z indeksu <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> - 1, a w przeciwnym razie dolna granica tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje elementy jednowymiarowa arrayfrom `startIndex` do `startIndex` plus `count` pomniejszonej o 1, jeśli `count` jest większa niż 0. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `Equals` metody każdego elementu, aż do znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%2A?displayProperty=nameWithType> wywoływana jest metoda, tego zastąpienia.  
  
 Tablice Becausemost ma dolna granica zero, ta metoda zwraca wartość-1 w przypadku `value` nie zostanie odnaleziony. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) i `value` nie zostanie odnaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startindex` jest równe <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia w tablicy ciągów indeksu ciągu:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy. Aby określić wartość `count` argumentu, odejmuje górna granica tablicy z indeks początkowy i dodaje jeden.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicą jednowymiarową.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w całej <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje wszystkie elementy tablicy jednowymiarowej dla `value`. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, tego zastąpienia.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów Jednowymiarowa tablica i zwraca indeks jego pierwszego wystąpienia. Z zakresu od określonego indeksu do końca tablicy.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> rozciąga się od <paramref name="startIndex" /> do ostatniego elementu, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyszukuje tablicą jednowymiarową z elementu `startIndex` do końca tablicy. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, tego zastąpienia.  
  
 Jeśli `startIndex` jest równe <xref:System.Array.Length%2A>, metoda zwraca - 1.If `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks jego pierwszego wystąpienia. Z zakresu od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> który rozpoczyna się od <paramref name="startIndex" /> i zawiera liczbę elementów określonych w <paramref name="count" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody elementy searchesthe tablicy jednowymiarowej z `startIndex` do `startIndex` plus `count` pomniejszonej o 1, jeśli `count` jest większa niż 0. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, tego zastąpienia.  
  
 Jeśli `startIndex` jest równe <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1.  Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje każdy element na wartość typu <see cref="T:System.Array" /> przez wywołanie konstruktora domyślnego typu wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma na celu kompilatory obsługuje tablic typu wartość; Większość użytkowników nie muszą tej metody. Nie należy go w tablicach Typ odwołania.  
  
 Jeśli <xref:System.Array> nie jest typem wartości <xref:System.Array> lub jeśli typ wartości nie ma konstruktora domyślnego <xref:System.Array> nie jest modyfikowany.  
  
 Typ wartości <xref:System.Array> może mieć żadnych dolna granica i dowolną liczbę wymiarów.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Tej metody można użyć tylko dla typów wartości, które mają konstruktorów; typy wartości, które są natywne dla C# nie mają jednak konstruktorów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Array" /> ma stały rozmiar.</summary>
        <value>Ta właściwość jest zawsze <see langword="true" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsFixedSize%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu.  
  
 Tablicy o ustalonym rozmiarze nie zezwala na dodawanie i usuwanie elementów po utworzeniu tablicy, ale umożliwia modyfikowanie istniejących elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Array" /> jest tylko do odczytu.</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsReadOnly%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu. Tablica, która jest tylko do odczytu nie zezwala na dodanie, usunięcie lub modyfikowania elementów po utworzeniu tablicy.  
  
 Jeśli potrzebujesz kolekcji tylko do odczytu, użyj <xref:System.Collections> klasa implementująca <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu.  
  
 Jeśli rzutowania lub konwersji tablicy do <xref:System.Collections.IList> obiektu interfejsu <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> zwraca właściwość `false`. Jednak jeśli rzutowania lub konwersji tablicy do <xref:System.Collections.Generic.IList%601> interfejsu `IsReadOnly` zwraca właściwość `true`.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Array" /> jest synchronizowane (wielowątkowość).</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsSynchronized%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 Na podstawie klasy .NET framework <xref:System.Array> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 Klasy korzystające tablice można też wdrożyć za pomocą ich własnych synchronizacji <xref:System.Array.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje `SyncRoot` kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji. Należy pamiętać, że niektóre implementacje <xref:System.Array.SyncRoot%2A> może zwrócić <xref:System.Array> samej siebie.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można zablokować tablicy podczas wyliczania całego przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks ostatniego wystąpienia wartości w jednowymiarowa <see cref="T:System.Array" /> lub w części <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w obrębie całej jednowymiarowa <see cref="T:System.Array" />.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w obrębie całej <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowa <xref:System.Array> przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), `Equals` implementacji tego typu jest używana.  
  
 Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku `value` nie znaleziono. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 W programie .NET Framework w wersji 2.0, ta metoda używa <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określonego przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> samej siebie.  
  
 <xref:System.IComparable.CompareTo%2A> metody `item` parametrów dla obiektów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Indeks początkowy wyszukiwania do tyłu.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowej tablicy <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> który rozciąga się od pierwszego elementu <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowa <xref:System.Array> jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończącego się na pierwszym elementem.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), `Equals` implementacji tego typu jest używana.  
  
 Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku `value` nie znaleziono. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od początku `array` do `startIndex`.  
  
 W programie .NET Framework w wersji 2.0, ta metoda używa <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określonego przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> samej siebie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Indeks początkowy wyszukiwania do tyłu.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowej tablicy <see cref="T:System.Array" /> zawierający określoną liczbę elementów i kończy się w określonym indeksie.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> zawiera liczbę elementów określonych w <paramref name="count" /> i kończy się na <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowa <xref:System.Array> jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończący się na `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika),`Equals` implementacji tego typu jest używana.  
  
 Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku `value` nie znaleziono. W rzadkich przypadkach, że dolna granica tablicy wynosi <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, ta metoda zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, która jest `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
 W programie .NET Framework w wersji 2.0, ta metoda używa <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określonego przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> samej siebie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy. Należy pamiętać, że <xref:System.Array.LastIndexOf%2A> metoda jest wyszukiwania do tyłu; w związku z tym `count` musi być mniejsze niż lub równe (`startIndex` minus dolna granica tablicy plus 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w obrębie całej <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w obrębie całej <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), `Equals` implementacji tego typu jest używana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> który rozciąga się od pierwszego elementu <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończącego się na pierwszym elementem.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), `Equals` implementacji tego typu jest używana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest liczba elementów od początku `array` do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <c>tablicy</c>.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> zawierający określoną liczbę elementów i kończy się w określonym indeksie.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> zawiera liczbę elementów określonych w <paramref name="count" /> i kończy się na <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończący się na `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Elementy są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), `Equals` implementacji tego typu jest używana.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <paramref name="array" />.  - lub - <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę elementów w wszystkie wymiary <see cref="T:System.Array" />.</summary>
        <value>Całkowita liczba elementów w wszystkie wymiary <see cref="T:System.Array" />; zero, jeśli w tablicy nie ma elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.Length%2A> właściwości do pobrania łączna liczba elementów w tablicy. Ponadto użyto <xref:System.Array.GetUpperBound%2A> metodę, aby określić liczbę elementów w każdego wymiaru tablicy wielowymiarowej.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Tablica jest wielowymiarowa i zawiera więcej niż <see cref="F:System.Int32.MaxValue" /> elementów.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera 64-bitową liczbę całkowitą, reprezentujący łączna liczba elementów w wszystkie wymiary <see cref="T:System.Array" />.</summary>
        <value>64-bitową liczbę całkowitą, reprezentujący łączna liczba elementów w wszystkie wymiary <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję (liczba wymiarów) <see cref="T:System.Array" />. Na przykład tablicą jednowymiarową zwraca wartość 1, jest tablicą dwuwymiarową zwraca 2 i tak dalej.</summary>
        <value>Rangę (liczba wymiarów) <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład kod Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 i kodu C#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Utwórz tablicę trzech wymiarów z <xref:System.Array.Rank%2A> właściwości, którego wartość to 3.  
  
 Tablicy nieregularnej (tablicy tablic) jest tablicą jednowymiarową; wartość jego <xref:System.Array.Rank%2A> właściwość jest 1.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie inicjuje tablicą jednowymiarową tablicą dwuwymiarową i tablicy nieregularnej i pobiera <xref:System.Array.Rank%2A> właściwości każdego z nich.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowa, liczony od zera do zmiany rozmiaru, lub <see langword="null" /> do utworzenia nowej tablicy o określonym rozmiarze.</param>
        <param name="newSize">Rozmiar nowej tablicy.</param>
        <summary>Zmiany liczby elementów tablicy jednowymiarowej z określonym rozmiarem nowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przydziela nowej tablicy o określonym rozmiarze, kopiuje elementy z tablicy starego do nowego i zastąpi stare tablicy nowym. `array` musi być tablicą jednowymiarową.  
  
 Jeśli `array` jest `null`, ta metoda tworzy nowy tablicy o określonym rozmiarze.  
  
 Jeśli `newSize` jest większa niż <xref:System.Array.Length%2A> starego tablicy jest przydzielany nowej tablicy i wszystkie elementy są kopiowane z tablicy starego do nowego.  Jeśli `newSize` jest mniejsza niż <xref:System.Array.Length%2A> starego tablicy jest przydzielany nowej tablicy i są kopiowane elementy z tablicy starego do nowego dopóki nowym jest wypełniony; pozostałe elementy w tablicy stare są ignorowane.  Jeśli `newSize` jest równa <xref:System.Array.Length%2A> starego tablicy, ta metoda nie działa.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `newSize`.  
  
 <xref:System.Array.Resize%2A> Metody zmienia rozmiar tylko tablicą jednowymiarową. <xref:System.Array> Klasa nie ma metody do zmiany rozmiaru tablic wielowymiarowych. Aby to zrobić, należy zapewnić swoim własnym kodem lub wywołanie metody specjalnych w bibliotece innych firm. Poniższy kod przedstawia możliwe jedna implementacja metody, która zmienia rozmiar tablicy *n* wymiarów.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zmiana rozmiaru wpływa na tablicy.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w jednowymiarowa <see cref="T:System.Array" /> lub w części <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> Aby odwrócić.</param>
        <summary>Odwraca kolejność elementów w całej jednowymiarowa <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody elementu `myArray[i]`, gdzie `i` żadnych indeks w tablicy, przenosi do `myArray[j]`, gdzie `j` jest równe `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 Jak pokazano na poniższym przykładzie, <xref:System.Array.Reverse%2A> metody można użyć do odwracania tablicą nieregularną. Tablicy nieregularnej o jeden element jest inicjowana w każdym miesiącu w bieżącym roku w kalendarzu bieżącej kultury. Każdy element zawiera tablicę z dowolną liczbę elementów, ponieważ dni miesiąca. W przykładzie przedstawiono zawartości tablicy, wywołania <xref:System.Array.Reverse%2A> metody, a następnie wyświetla zawartość tablicę wycofane.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób sortowania wartości w odwrotnej <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> Aby odwrócić.</param>
        <param name="index">Indeks początkowy sekcji, aby odwrócić.</param>
        <param name="length">Liczba elementów w sekcji, aby odwrócić.</param>
        <summary>Odwraca kolejność elementów w zakresie elementów w jednowymiarowej tablicy <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody elementu `myArray[i]`, gdzie `i` żadnych indeks w tablicy, przenosi do `myArray[j]`, gdzie `j` jest równe `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 <xref:System.Array.Reverse%2A> Metody można użyć do odwracania tablicą nieregularną.  
  
 Ta metoda jest O (`n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób Odwróć kolejność sortowania wartości zakresu elementów w <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia określony element w bieżącym <see cref="T:System.Array" /> z podaną wartością.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">32-bitową liczbę całkowitą, która reprezentuje pozycję <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksów, określając położenie elementu można ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />. Indeksy są określone jako tablicę 32-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy dowolna z wartości w `indices` tablicy jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">64-bitową liczbę całkowitą, która reprezentuje pozycję <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednowymiarowej tablicy <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksów, określając położenie elementu można ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowe <see cref="T:System.Array" />. Indeksy są określone jako tablicę 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy dowolna z wartości w `indices` tablicy jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index2">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index2">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowa <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index2">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index3">32-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie trzy wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index2">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <see cref="T:System.Array" /> element, aby ustawić.</param>
        <param name="index3">64-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <see cref="T:System.Array" /> element, aby ustawić.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowy <see cref="T:System.Array" />. Indeksy są określone jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można ustalić, czy dowolny z indeksów jest poza zakresem.  
  
 Aby uzyskać więcej informacji na temat konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używana do przypisywania `null` do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie trzy wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ elementu bieżącego <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy z tablicą jednowymiarową.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <summary>Sortuje elementów w całej jednowymiarowa <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> stosowania dla każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `array` musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób posortować wartości w <xref:System.Array> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> zawiera elementy, które odpowiadają każdej z kluczy w <c>klucze</c><see cref="T:System.Array" />.  - lub - <see langword="null" /> sortowania tylko <c>klucze</c><see cref="T:System.Array" />.</param>
        <summary>Sortuje pary jednowymiarowa <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> stosowania dla każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `keys`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  - lub - <paramref name="items" /><see cref="T:System.Array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, aby posortować.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Sortuje elementy w jednowymiarowa <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element `array` musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <xref:System.Collections.IComparer> wykonania `comparer` parametru. Przykład robi to poprzez definiowanie `ReverseComparer` klasy, która Odwraca kolejność sortowania domyślnego wystąpienia typu i wykonuje porównania ciągów bez uwzględniania wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład sortuje wartości arrayby ciągu, przy użyciu domyślna funkcja porównująca. Definiuje również niestandardowego <xref:System.Collections.IComparer> wdrożenia o nazwie `ReverseComparer` który Odwraca kolejność sortowania domyślnego obiektu podczas wykonywania porównania ciągów bez uwzględniania wielkości liter. Należy pamiętać, że dane wyjściowe mogą się różnić w zależności od bieżącej kultury.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> zawiera elementy, które odpowiadają każdej z kluczy w <c>klucze</c><see cref="T:System.Array" />.  - lub - <see langword="null" /> sortowania tylko <c>klucze</c><see cref="T:System.Array" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Sortuje pary jednowymiarowa <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <xref:System.Collections.IComparer> wykonania `comparer` parametru. Przykład robi to poprzez definiowanie <xref:System.Collections.IComparer> implementacji Odwraca kolejność sortowania domyślnego, który wykonuje porównania ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `keys`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  - lub - <paramref name="items" /><see cref="T:System.Array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], istnieje możliwość, który sortowanie previouslythrew tej operacji <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów w jednowymiarowa <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> stosowania dla każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element określonego zakresu elementów w `array` musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób posortować wartości w <xref:System.Array> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> zawiera elementy, które odpowiadają każdej z kluczy w <c>klucze</c><see cref="T:System.Array" />.  - lub - <see langword="null" /> sortowania tylko <c>klucze</c><see cref="T:System.Array" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Zakres elementów w parze jednowymiarowa <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> stosowania dla każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Każdy klucz określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  - lub - <paramref name="items" /><see cref="T:System.Array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="keys" /><see cref="T:System.Array" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Sortuje elementy w zakresie elementów w jednowymiarowa <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element określonego zakresu elementów w `array` musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <xref:System.Collections.IComparer> wykonania `comparer` parametru. Przykład robi to poprzez definiowanie `ReverseComparer` klasy, która Odwraca kolejność sortowania domyślnego wystąpienia typu i wykonuje porównania ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób posortować wartości w <xref:System.Array> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowa <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa <see cref="T:System.Array" /> zawiera elementy, które odpowiadają każdej z kluczy w <c>klucze</c><see cref="T:System.Array" />.  - lub - <see langword="null" /> sortowania tylko <c>klucze</c><see cref="T:System.Array" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania <see cref="T:System.IComparable" /> stosowania dla każdego elementu.</param>
        <summary>Zakres elementów w parze jednowymiarowa <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <xref:System.Collections.IComparer> wykonania `comparer` parametru. Przykład robi to poprzez Definiowanie niestandardowego <xref:System.Collections.IComparer> implementacji Odwraca kolejność sortowania domyślnego, który wykonuje porównania ciągów bez uwzględniania wielkości liter.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania. Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  - lub - <paramref name="items" /><see cref="T:System.Array" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />oraz dolną granicę <paramref name="keys" /> jest niezgodny z dolną granicę <paramref name="items" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="keys" /><see cref="T:System.Array" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="items" /><see cref="T:System.Array" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do sortowania.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdy element <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `array` musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> przeciążenia metody rodzajowej i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> przeciążenia metody rodzajowej. Tablica ciągów jest tworzony w określonej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który. Tablica i wartość zwracaną <xref:System.Array.BinarySearch%2A> metody są przekazywane do `ShowWhere` ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy. Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, zero-base <see cref="T:System.Array" /> do sortowania</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element `array` musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być posortowane w celu użycia <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który. Tablica i wartość zwracaną <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody są przekazywane do `ShowWhere` ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy. Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> sortowania</param>
        <param name="comparison">
          <see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu introspective sortowania (introsort) w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenie metody.  
  
 Przykładowy kod definiuje metodę porównywania alternatywne ciągi, o nazwie `CompareDinosByLength`. Ta metoda działa w następujący sposób: najpierw comparandsare sprawdzane pod kątem`null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 Tablica ciągów jest tworzony i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Lista zawiera także pustego ciągu i odwołanie o wartości null. Zostanie wyświetlona lista sortowane przy użyciu <xref:System.Comparison%601> Delegat ogólny reprezentujący `CompareDinosByLength` metody i ponownie wyświetlone.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="comparison" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparison" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> sortowania</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdy element <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element określonego zakresu elementów w `array` musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody rodzajowej i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej sortowania zakresu w tablicy.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka, składające się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia metody rodzajowej jest używane do sortowania ostatnie trzy elementy tablicy, która jest następnie wyświetlana. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody rodzajowej jest używany z `ReverseCompare` w odwrotnej kolejności sortowania ostatnie trzy elementy. Dokładnie mylić dinozaurów są wyświetlane ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element określonego zakresu elementów w `array` musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdego innego elementu w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody rodzajowej i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej sortowania zakresu w tablicy.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka, składające się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia metody rodzajowej jest używane do sortowania ostatnie trzy elementy tablicy, która jest następnie wyświetlana. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody rodzajowej jest używany z `ReverseCompare` w odwrotnej kolejności sortowania ostatnie trzy elementy. Dokładnie mylić dinozaurów są wyświetlane ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="array" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawiera elementy, które muszą być w <c>klucze</c>, lub <see langword="null" /> sortowania tylko <c>klucze</c>.</param>
        <summary>Sortuje para <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości). Tablice są następnie wyświetlania i sortowania kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` służą do odwracania kolejności sortowania par tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />oraz dolną granicę <paramref name="keys" /> jest niezgodny z dolną granicę <paramref name="items" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawiera elementy, które muszą być w <c>klucze</c>, lub <see langword="null" /> sortowania tylko <c>klucze</c>.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje para <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości). Tablice są następnie wyświetlania i sortowania kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > przeciążenia i wystąpienie `ReverseCompare` służą do odwracania kolejności sortowania sparowanego tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />oraz dolną granicę <paramref name="keys" /> jest niezgodny z dolną granicę <paramref name="items" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawiera elementy, które muszą być w <c>klucze</c>, lub <see langword="null" /> sortowania tylko <c>klucze</c>.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Zakres elementów w parze <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Każdy klucz określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości). Tablice są następnie wyświetlania i sortowania kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` służą do odwracania kolejności sortowania par tablic.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />oraz dolną granicę <paramref name="keys" /> jest niezgodny z dolną granicę <paramref name="items" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="keys" /><see cref="T:System.Array" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> zawiera elementy, które muszą być w <c>klucze</c>, lub <see langword="null" /> sortowania tylko <c>klucze</c>.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <see langword="null" /> do używania <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Zakres elementów w parze <see cref="T:System.Array" /> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie ponownie. W związku z tym `items` <xref:System.Array> jest sortowana według rozmieszczenia odpowiadające im klucze w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs umożliwiać porównania z każdym innym kluczem.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa [sortowania wstawiania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * dziennika<sup>N</sup>, gdzie *N* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operację, której `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, a [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7D%29 > przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Przykładowy kod definiuje alternatywny porównania ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>`(`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołania <xref:System.String.CompareTo%28System.String%29> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości). Tablice są następnie wyświetlania i sortowania kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` służą do odwracania kolejności sortowania par tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > przeciążenia jest używane do sortowania ostatnich trzech oba elementy stałych w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  - lub - <paramref name="length" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />oraz dolną granicę <paramref name="keys" /> jest niezgodny z dolną granicę <paramref name="items" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  - lub - <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="keys" /><see cref="T:System.Array" />.  - lub - <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie zostanie określony prawidłowy zakres w <paramref name="items" /><see cref="T:System.Array" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie implementują <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort. Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątku i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] jest możliwe, że sortowanie operacji poprzednio zwrócił <see cref="T:System.ArgumentException" /> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków dotyczy tablic o mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Array" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość implementuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 Na podstawie klasy .NET framework <xref:System.Array> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 Klasy korzystające tablice można też wdrożyć za pomocą ich własnych synchronizacji <xref:System.Array.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje `SyncRoot` kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji. Należy pamiętać, że niektóre implementacje <xref:System.Array.SyncRoot%2A> może zwrócić <xref:System.Array> samej siebie.  
  
 Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można zablokować tablicy podczas wyliczania całego przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Array" />.</summary>
        <value>Liczba elementów zawartych w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dodania do <see cref="T:System.Collections.IList" />.</param>
        <summary>Wywołanie tej metody zawsze zwraca <see cref="T:System.NotSupportedException" /> wyjątku.</summary>
        <returns>Dodanie wartości do tablicy nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementacji dodaje element członkowski do kolekcji. Jednak ponieważ tablice o stałym rozmiarze ( <xref:System.Array.IsFixedSize%2A> właściwość zawsze zwraca `true`), ta metoda zawsze zwraca <xref:System.NotSupportedException> wyjątku.  
  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do zlokalizowania w bieżącej listy. Element, aby zlokalizować może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> znajduje się w <see cref="T:System.Collections.IList" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do zlokalizowania w bieżącej listy.</param>
        <summary>Określa indeks konkretny element w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks wartości Jeśli znaleziona na liście; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks, w którym <c>wartość</c> powinien zostać wstawiony.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  - lub - <see cref="T:System.Collections.IList" /> ma stały rozmiar.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> to odwołanie o wartości null w <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Array.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do pobrania lub ustawienia.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.  - lub - <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Bieżące <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do usunięcia z <see cref="T:System.Collections.IList" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  - lub - <see cref="T:System.Collections.IList" /> ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia.</param>
        <summary>Usuwa <see cref="T:System.Collections.IList" /> element pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  - lub - <see cref="T:System.Collections.IList" /> ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który porównuje bieżący obiekt i <c>innych</c>.</param>
        <summary>Określa, czy bieżący obiekt kolekcji poprzedza, odbywa się w tym samym miejscu czy następuje z innym obiektem w kolejności sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje relację bieżącego obiektu kolekcji do innych, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> -1 </term><description> poprzedza bieżącego wystąpienia <paramref name="other" />.  </description></item><item><term> 0 </term><description> bieżącego wystąpienia i <paramref name="other" /> są takie same.  </description></item><item><term> 1 </term><description> zgodny z bieżącym wystąpieniem <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IStructuralComparable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który określa, czy bieżące wystąpienie i <c>innych</c> są takie same.</param>
        <summary>Określa, czy obiekt jest taki sam, jak bieżące wystąpienie.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa obiekty są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IStructuralEquatable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt, który oblicza wartość skrótu bieżącego obiektu.</param>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowane na <xref:System.Collections.IStructuralEquatable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowa, liczony od zera <see cref="T:System.Array" /> sprawdzania zgodności z warunkami.</param>
        <param name="match">Predykat definiujący warunki sprawdzania zgodności elementy.</param>
        <summary>Określa, czy każdy element tablicy pasuje do warunków zdefiniowanych przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość każdego elementu w <paramref name="array" /> pasuje do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />. Jeśli w tablicy nie ma elementów, jest zwracana wartość <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca`true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy `array` indywidualnie są przekazywane do <xref:System.Predicate%601>, i przetwarzania jest zatrzymana, gdy zwraca delegata `false` dla każdego elementu.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ostatni znak każdego elementu w tablicy ciągów jest liczbą. Tworzy dwie tablice ciągu. Pierwszy arrayincludes ciągi, które kończą się alfabetu i ciągi, które kończą się cyfr. Druga tablica zawiera tylko ciągi, które kończyć się znakami liczbowych. Definiuje również przykładzie `EndWithANumber` metody, których Podpis pasuje do <xref:System.Predicate%601> delegowanie. Przykład przekazuje każdej macierzy do <xref:System.Array.TrueForAll%2A> metody wraz z delegata, który reprezentuje `EndsWithANumber` metody.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Poniższy przykład jest podobny do pierwszej, z wyjątkiem przekazaniem do tablicy ciągów <xref:System.Array.TrueForAll%2A> metody wraz z wyrażenia lambda, określająca, czy element określonej tablicy kończy się liczbą reprezentację ciągu.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 W obu przypadkach <xref:System.Array.TrueForAll%2A> metoda zwraca `false` zaraz po napotkaniu pierwszy element tablicy, która nie kończy się liczbą. W przeciwnym razie zwraca `true` po Iterowanie wszystkich elementów w tablicy.  
  
> [!NOTE]
>  Zgodnie z obu przykładach w C# i Visual Basic nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  - lub - <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
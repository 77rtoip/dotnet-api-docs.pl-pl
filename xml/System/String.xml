<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="044cd3ac9d4e4074756923f284acebf10b70fd09" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52246712" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje tekst jako sekwencja jednostki kodu UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ciąg jest sekwencyjną kolekcją znaków, który jest używany do reprezentowania tekstu. A <xref:System.String> obiektu to kolejny zbiór <xref:System.Char?displayProperty=nameWithType> obiekty reprezentujące ciąg; <xref:System.Char?displayProperty=nameWithType> obiekt odpowiada jednostkę kodu UTF-16. Wartość <xref:System.String> obiekt znajduje się odpowiednia zawartość sekwencyjne kolekcji <xref:System.Char?displayProperty=nameWithType> obiektów i że wartość jest niezmienne (oznacza to, jest tylko do odczytu). Aby uzyskać więcej informacji na temat niezmienności ciągów zobacz [niezmienność i klasa StringBuilder](#Immutability) w dalszej części tego tematu. Maksymalny rozmiar <xref:System.String> obiektu w pamięci to 2 GB lub około 1 miliard znaków.  
  
 W tej sekcji:  
  
 [Utworzenie wystąpienia obiektu String](#Instantiation)   
 [Obiekty CHAR i znaki Unicode](#Characters)   
 [Ciągi i Unicode Standard](#Unicode)   
 [Ciągi i osadzone znaki o wartości null](#EmbeddedNulls)   
 [Ciągi i indeksy](#Indexes)   
 [Ciągi zerowe i puste ciągi](#Nulls)   
 [Niezmienność i klasa StringBuilder](#Immutability)   
 [Operacje porządkowe vs. operacje zależne od kultury](#CultureSensitive)   
 [Normalizacja](#Normalization)   
 [Operacje na ciągach według kategorii](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Utworzenie wystąpienia obiektu String  
 Można utworzyć wystąpienie <xref:System.String> obiektu w następujący sposób:  
  
-   Przypisując literału ciągu na <xref:System.String> zmiennej. Jest to najczęściej stosowana metoda do tworzenia ciągu. W poniższym przykładzie użyto przypisania, aby utworzyć kilka ciągów. Należy pamiętać, że w języku C#, ponieważ ukośnik odwrotny (\\) jest znakiem ucieczki, należy użyć znaków ucieczki literału ukośników odwrotnych w ciągu lub cały ciąg musi być @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Przez wywołanie metody <xref:System.String> konstruktora klasy. Poniższy przykład tworzy wystąpienie ciągów, wywołując kilka konstruktorów klas. Należy pamiętać, że niektóre z konstruktorów obejmują wskaźniki do tablic znak lub bajt oznaczony tablic jako parametrów. Visual Basic nie obsługuje wywołania tych konstruktorów. Aby uzyskać szczegółowe informacje na temat <xref:System.String> konstruktorów, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Za pomocą operatora łączenia ciągu (+ w języku C# i & lub + w języku Visual Basic) do utworzenia pojedynczego ciągu z dowolnej kombinacji <xref:System.String> wystąpień i literałami ciągów. Poniższy przykład ilustruje użycie operatora łączenia ciągów.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Trwa pobieranie właściwości lub wywołanie metody, która zwraca wartość typu ciąg. W poniższym przykładzie użyto metody <xref:System.String> klasy do wyodrębniania podciągu z dłuższym ciągu.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Przez wywołanie metody formatowania, aby przekonwertować wartość lub obiektu na jego reprezentację ciągu. W poniższym przykładzie użyto [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) funkcję, aby osadzić ciąg reprezentujący dwa obiekty w ciąg.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Obiekty char i znaki Unicode  
 Każdy znak w ciągu jest definiowana przez wartość skalarna Unicode, nazywanych również punkt kodu Unicode (numeryczne) wartości porządkowej znaków Unicode. Każdy punkt kodu jest zaszyfrowana przy użyciu kodowania UTF-16 i wartości liczbowej każdego elementu kodowania jest reprezentowany przez <xref:System.Char> obiektu.  
  
> [!NOTE]
>  Należy zauważyć, że ponieważ <xref:System.String> wystąpienia składa się z sekwencyjną kolekcją jednostki kodu UTF-16, istnieje możliwość tworzenia <xref:System.String> obiekt, który nie jest poprawnie sformułowany ciąg Unicode. Na przykład istnieje możliwość tworzenia ciągu zawierającym znak zastępczy niskiego poziomu bez odpowiedniego. Mimo że niektóre metody, takie jak metody kodowania i dekodowania obiektów w <xref:System.Text> przestrzeni nazw, może wykonuje testy, aby upewnić się, że ciągi są poprawnie sformułowany <xref:System.String> elementów członkowskich klasy nie upewnij się, czy ciąg jest poprawnie sformułowany.  
  
 Pojedynczy <xref:System.Char> obiektu zazwyczaj reprezentuje pojedynczy punkt kodowy, czyli wartość liczbową <xref:System.Char> jest równa punkt kodu. Na przykład punkt kodowy "znak a" jest 0061 U +. Punkt kodu mogą jednak wymagać więcej niż jeden element zakodowany (więcej niż jeden <xref:System.Char> obiektu). W standardzie Unicode definiuje dwa typy znaków, które odnoszą się do wielu <xref:System.Char> obiektów: graphemes i punkty dodatkowego kodu Unicode, które odpowiadają znaków Unicode płaszczyzn dodatkowych.  
  
-   Grafemów jest reprezentowany przez podstawowego znak następuje jeden lub więcej znaków łączenie. Na przykład znak ä jest reprezentowany przez element <xref:System.Char> obiektu, którego punkt kodu jest U + 0061 następuje a <xref:System.Char> obiektu, którego punkt kodu jest 0308 U +. Ten znak można także definiować przez jeden <xref:System.Char> obiekt, który ma punkt kodu 00E4 U +. Jak pokazano na poniższym przykładzie, zależne od kultury porównanie równości, wskazuje, te dwa oświadczenia są takie same, mimo że zwykłych porównania porządkowego nie. Jednak jeśli dwa ciągi są znormalizowane, porównanie porządkowe również wskazuje, że są równe. (Aby uzyskać więcej informacji na temat normalizowanie ciągi, zobacz [normalizacji](#Normalization) sekcji.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode punkt kodowy dodatkowych (para zastępcza) jest reprezentowany przez <xref:System.Char> następuje obiekt, którego punkt kodu jest znakiem zastępczym wysokiego poziomu <xref:System.Char> obiektu, którego punkt kodu jest znak zastępczy niskiego poziomu. Jednostki kodu wysokiej surogatów z zakresu od U + D800 do U + DBFF. Jednostki kodu niskie surogatów z zakresu od U + DC00 do U + DFFF. Pary zastępcze są używane do reprezentowania znaków w płaszczyzn dodatkowych 16 Unicode. Poniższy przykład tworzy znaków zastępczych i przekazuje go do <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metodę pozwala ustalić, czy jest to para zastępcza.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Ciągi i Unicode Standard  
 Znaki w ciągu są reprezentowane przez jednostki kodu UTF-16 zakodowane, które odnoszą się do <xref:System.Char> wartości.  
  
 Każdy znak w ciągu ma skojarzone znak kategorii Unicode, która jest reprezentowana w programie .NET przez <xref:System.Globalization.UnicodeCategory> wyliczenia. Można określić kategorię znak lub parę zastępczą, wywołując <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> metody.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Ponadto .NET obsługuje porównywania ciągów i sortowania oparte na standardzie Unicode. W wersjach programu .NET Framework za pomocą [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework zachowuje własną tabelę danych ciągu. Dotyczy to również wersji programu .NET Framework, począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] systemem Windows 7. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] systemem Windows 8 i nowszych wersjach systemu operacyjnego Windows, delegatów środowiska uruchomieniowego ciągu, porównywanie i sortowanie operacji do systemu operacyjnego. Na platformie .NET Core porównywania ciągu i sortowanie informacji są dostarczane przez [składniki międzynarodowego standardu Unicode](http://site.icu-project.org/) bibliotek. W poniższej tabeli wymieniono wersje platformy .NET i wersji standardu Unicode na znak, który opierają się porównywanie i sortowanie.  
  
|Wersja platformy .NET|Wersja Unicode Standard|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Standard Unicode wersji 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] i nowsze, Windows 7|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszy dla Windows 8 i nowszych systemach operacyjnych Windows|[Standard Unicode wersji wersji 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET core (wszystkie wersje)|Zależy od wersji standardu Unicode obsługiwanych przez system operacyjny.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Ciągi i osadzone znaki o wartości zerowej  
 Na platformie .NET <xref:System.String> obiektu może zawierać osadzone znaki null, co jest liczone jako część długość ciągu. Jednak w niektórych językach, takich jak C i C++, znak null oznacza koniec ciąg. go nie jest uważany za część ciągu i nie jest liczony jako część długość ciągu. Oznacza to, że następujące typowe założeń, które w programowaniu w języku C i C++ i bibliotek napisanych w języku C lub C++ może spowodować, że temat ciągów nie musi być prawidłową, w przypadku zastosowania do <xref:System.String> obiektów:  
  
-   Wartość zwrócona przez obiekt `strlen` lub `wcslen` funkcji nie musi być równa <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Ciąg utworzony przez `strcpy_s` lub `wcscpy_s` functions nie jest zawsze taka sama jak ciąg powstały <xref:System.String.Copy%2A?displayProperty=nameWithType> metody.  
  
 Należy upewnić się, tym natywnego kodu C i C++, która tworzy wystąpienie <xref:System.String> obiektów i kod, który jest przekazywany <xref:System.String> obiekty za pośrednictwem platformy wywołania, nie wolno zakładać, że osadzony znak null oznacza koniec ciągu.  
  
 Osadzone znaki o wartości null w ciągu są także traktowane inaczej, gdy ciąg sortowania (lub w porównaniu) i gdy jest przeszukiwany ciąg. Znaki null są ignorowane, podczas wykonywania zależne od kultury porównanie dwóch ciągów, w tym porównania przy użyciu niezmiennej kultury. Są traktowane jako tylko do porównania liczb porządkowych porządkowe lub bez uwzględniania wielkości liter. Z drugiej strony, osadzone znaki null są zawsze traktowane jako podczas wyszukiwania ciągu za pomocą metod, takich jak <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, i <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Ciągi i indeksy  
 Indeks znajduje się pozycja <xref:System.Char> obiektu (nie znak Unicode) w <xref:System.String>. Indeks jest liczony od zera, nieujemna liczba, która rozpoczyna się od pierwszego pozycji w ciągu, który ma indeks zero. Liczba metod wyszukiwania takie jak <xref:System.String.IndexOf%2A> i <xref:System.String.LastIndexOf%2A>, zwróć indeks znaku lub podciągu w wystąpieniu ciągu.  
  
 <xref:System.String.Chars%2A> Właściwość pozwala uzyskiwać dostęp do poszczególnych <xref:System.Char> obiekty według ich pozycji indeksu ciągu. Ponieważ <xref:System.String.Chars%2A> właściwość jest właściwością domyślną (w języku Visual Basic) lub indeksatora (w języku C#), możesz uzyskać dostęp osoby <xref:System.Char> obiektów w ciągu przy użyciu następującego kodu. Ten kod wyszukuje biały znak lub znaki interpunkcyjne w ciągu, aby określić, ile wyrazów, które zawiera ciąg.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Ponieważ <xref:System.String> klasy implementuje <xref:System.Collections.IEnumerable> interfejsu, można również wykonać iterację <xref:System.Char> obiektów w ciągu przy użyciu `foreach` konstrukcji, co ilustruje poniższy przykład.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Wartości następujących po sobie indeksu nie może odpowiadać następujących po sobie znaków Unicode, ponieważ Unicode znak może być zakodowany jako więcej niż jeden <xref:System.Char> obiektu. W szczególności ciąg może zawierać wielu znaków jednostek tekstu, które są utworzone przez podstawowego znak stosowana przez jeden lub więcej znaków łączenie lub znaki dwuskładnikowe. Do pracy ze znakami Unicode zamiast <xref:System.Char> obiekty, używają <xref:System.Globalization.StringInfo?displayProperty=nameWithType> i <xref:System.Globalization.TextElementEnumerator> klasy. Poniższy przykład ilustruje różnicę między kodem, który współdziała z <xref:System.Char> obiektów i kod, który współdziała ze znakami Unicode. Porównuje liczbę znaków lub elementy tekstowe każdego wyrazu w zdaniu. Ciąg zawiera dwie sekwencje znaków podstawowej następuje znak łączenie.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Ten przykład działa przy użyciu elementów tekstowych przy użyciu <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> metody i <xref:System.Globalization.TextElementEnumerator> klasy można wyliczyć wszystkie elementy tekst w ciągu. Możesz również pobrać tablicę, która zawiera wartość początkowa indeksu dla każdego elementu tekst, wywołując <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat pracy z jednostkami tekstu, a nie poszczególnych <xref:System.Char> wartości, zobacz <xref:System.Globalization.StringInfo> klasy.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Ciągi zerowe i puste ciągi  
 Ciąg, który został zadeklarowany, ale nie zostanie przypisana wartość jest `null`. Próba wywołania metody w tym ciągu zgłasza <xref:System.NullReferenceException>. Pusty ciąg jest inny niż pustym ciągiem, czyli ciąg tekstowy, którego wartością jest "" lub <xref:System.String.Empty?displayProperty=nameWithType>. W niektórych przypadkach przekazując ciąg o wartości null lub pusty ciąg jako argument w wywołaniu metody zgłasza wyjątek. Na przykład, przekazując ciąg pusty, aby <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metoda zgłasza wyjątek <xref:System.ArgumentNullException>i przekazanie pustego ciągu zgłasza <xref:System.FormatException>. W innych przypadkach argumentu metody może być ciągiem o wartości null ani być pustym ciągiem. Na przykład, jeśli udostępniasz <xref:System.IFormattable> implementacji klasy, którą chcesz porównywania ciągów o wartości null i pusty ciąg przy użyciu specyfikatora formatu ogólnego ("G").  
  
 <xref:System.String> Klasy zawiera następujące metody dwóch wygody, umożliwiających testowanie, czy ciąg `null` lub jest pusty:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, która wskazuje, czy ciąg jest `null` lub jest równe <xref:System.String.Empty?displayProperty=nameWithType>. Ta metoda eliminuje konieczność użycia kodu, takie jak następujące:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, która wskazuje, czy ciąg `null`, jest równa <xref:System.String.Empty?displayProperty=nameWithType>, lub składa się wyłącznie ze znaków odstępu. Ta metoda eliminuje konieczność użycia kodu, takie jak następujące:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 W poniższym przykładzie użyto <xref:System.String.IsNullOrEmpty%2A> method in Class metoda <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementacji niestandardowego `Temperature` klasy. Metoda obsługuje ciągi formatu "G", "C", "F" i "K". Jeśli to ciąg pusty format lub formatu ciągu, którego wartość jest `null` jest przekazywany do metody, jego wartość jest zmieniana na ciąg formatu "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Niezmienność i klasa StringBuilder  
 A <xref:System.String> obiekt jest nazywany niezmienne (tylko do odczytu), ponieważ nie można zmodyfikować jego wartości, po jego utworzeniu. Metody, które pojawiają się w celu zmodyfikowania <xref:System.String> obiekt, w rzeczywistości zwracają nowe <xref:System.String> obiekt, który zawiera zmiany.  
  
 Ponieważ ciągów są niezmienne, procedury manipulowania ciągu, które wykonują powtórzony, dodawania i usuwania do wyświetlanych jako pojedynczy ciąg można dokładnie spadek istotnie poprawiającą wydajność. Na przykład poniższy kod używa generator liczb losowych do utworzenia ciągu z 1000 znaków w zakresie 0x0001 do 0x052F. Mimo że kod wygląda używania ciągów można dołączyć nowego znaku do istniejących parametrów o nazwie `str`, faktycznie tworzy nową <xref:System.String> obiektu dla każdej operacji łączenia.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Możesz użyć <xref:System.Text.StringBuilder> klasy zamiast <xref:System.String> klasy dla operacji, które zmiany wielu wartości ciągu. W odróżnieniu od wystąpień <xref:System.String> klasy <xref:System.Text.StringBuilder> obiekty są modyfikowalną; podczas łączenia, Dołącz lub usuwania podciągów z ciągu operacje są wykonywane na jeden ciąg. Po zakończeniu, zmieniając wartość <xref:System.Text.StringBuilder> obiektu, można wywołać jej <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować na ciąg. Poniższy przykład zastępuje <xref:System.String> używane w poprzednim przykładzie do łączenia 1000 losowo wybranych znaków w zakresie do 0x0001 do 0x052F z <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Operacje porządkowe vs. operacje zależne od kultury  
 Elementy członkowskie <xref:System.String> klasy wykonywać porządkowe lub zależne od kultury operacje (językowej) <xref:System.String> obiektu. Numer porządkowy operacja działa na wartości liczbowej każdego <xref:System.Char> obiektu. Operacja wrażliwość na ustawienia kulturowe działa na wartość <xref:System.String> obiektu i wielkość liter w wyrazie przyjmuje specyficzne dla kultury, sortowanie, formatowania i pod uwagę podczas analizowania reguły. Wrażliwość na ustawienia kulturowe operacje są wykonywane w kontekście zadeklarowany w sposób jawny kultury lub niejawne bieżącej kultury. Dwa rodzaje operacji może tworzyć różne wyniki, gdy są wykonywane względem tego samego ciągu.  
  
.NET obsługuje również operacje niewrażliwość na ustawienia kulturowe ciąg językowej przy użyciu niezmiennej kultury (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), która jest luźno oparta na ustawienia kultury w języku angielskim niezależnie od regionu. W odróżnieniu od innych <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> ustawienia i ustawienia Niezmienna kultura są gwarantowane chcesz zachować spójność na pojedynczym komputerze z system do systemu i różnych wersji programu .NET. Niezmienna kultura może być wyświetlany jako rodzaj czarne pole, który zapewnia stabilność porównań ciągów i sortowania we wszystkich kulturach.  
  
> [!IMPORTANT]
>  Jeśli aplikacja podejmuje decyzję zabezpieczeń symboliczne identyfikatora, takie jak nazwa pliku lub nazwany potok lub o utrwalonych danych, takich jak dane na podstawie tekstu w pliku XML, operacja powinna użyć porównania porządkowego zamiast porównanie zależne od kultury. Jest to spowodowane porównanie zależne od kultury może przynieść w efekcie różne wyniki w zależności od kultury porównanie porządkowe zależy wyłącznie na wartość binarną w porównaniu znaków.  
  
> [!IMPORTANT]
>  Większość metod, które wykonują operacje na ciągach obejmują przeciążenia, które ma parametr typu <xref:System.StringComparison>, który pozwala na określenie, czy metoda wykonuje operację porządkowe lub zależne od kultury. Ogólnie rzecz biorąc należy wywołać tego przeciążenia się celem metodę wywołania Wyczyść. Aby uzyskać najlepsze rozwiązania i wskazówki dotyczące używania operacje porządkowe i kultury na ciągi, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operacje dotyczące [wielkość liter w wyrazie](#casing), [formatowanie i analizowanie](#parsing), [porównywanie i sortowanie](#comparison), i [testowanie pod kątem równości](#equality) może być albo liczba porządkowa lub zależne od kultury. W poniższych sekcjach omówiono każdego z tych operacji.  
  
> [!TIP]
>  Zawsze powinna wywołać przeciążenie metody, która sprawia, że celem metodę wywołania Wyczyść. Na przykład, zamiast wywoływać metodę <xref:System.String.Compare%28System.String%2CSystem.String%29> metodę w celu kultury porównanie dwóch ciągów przy użyciu konwencji bieżącej kultury, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody z wartością <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> dla `comparisonType` argument. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  

Możesz pobrać [tabele wagi sortowania](https://www.microsoft.com/en-us/download/details.aspx?id=10921), zbiór plików tekstowych, które zawierają informacje o wagi znaku w operacjach sortowania i porównywania dla systemów operacyjnych Windows, a [domyślne Unicode Tabela elementów sortowania](https://www.unicode.org/Public/UCA/latest/allkeys.txt), tabeli wagi sortowania dla systemów Linux i macOS.

<a name="casing"></a>   
### <a name="casing"></a>Wielkość znaków  
 Wielkość liter w wyrazie reguły określają, jak zmienić wielkość liter znak Unicode; na przykład z małe litery na wielkie litery. Często wielkość liter w wyrazie jest wykonywane przed porównania ciągów. Na przykład ciąg może być przekonwertowany na wielkie litery, tak, aby można porównać na inny ciąg na wielkie litery. Można przekonwertować znaków w ciągu na małe litery, wywołując <xref:System.String.ToLower%2A> lub <xref:System.String.ToLowerInvariant%2A> metody, na które można konwertować na wielkie litery, wywołując <xref:System.String.ToUpper%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. Ponadto można użyć <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metodę, aby przekonwertować ciąg wielkimi literami.  
  
 Operacje dotyczące wielkości znaków może być na podstawie reguł bieżącej kultury, określonej kultury lub niezmiennej kultury. Ponieważ mapowanie przypadków mogą się różnić w zależności od używanej kultury, wynik operacji wielkość liter w wyrazie może zależeć od kultury. Rzeczywiste różnic w wielkości liter są trzy typy:  
  
-   Różnice w przypadku mapowania LATIN CAPITAL LETTER i (U + 0049), ŁACIŃSKI małe litery I (U + 0069), LATIN CAPITAL LETTER I z DOT powyżej (U + 0130) i ŁACIŃSKI małej litery bez KROPEK I (U + 0131). Tr-TR (turecki (Turcja)) i kultur az-Latn-AZ (łaciński, Azerbejdżan), a także w tr az i kultury neutralnej az-Latn litery odpowiednikiem LATIN CAPITAL LETTER I jest alfabetu ŁACIŃSKIEGO małej litery bez KROPEK I i jest odpowiednikiem wielkie litery alfabetu ŁACIŃSKIEGO małe litery I WIELKA LITERA I Z DOT POWYŻEJ. W przypadku wszystkich innych języków w tym kultury niezmiennej, ŁACIŃSKI małe litery I i LATIN CAPITAL LETTER I są odpowiedniki małe i wielkie.  
  
     W poniższym przykładzie pokazano sposób porównywania ciągów, zaprojektowane do uniemożliwić dostęp do systemu plików może zakończyć się niepowodzeniem, jeśli zależy od wielkości liter kultury porównanie. (Wielkość liter w wyrazie Konwencji niezmiennej kultury powinny były używane.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Różnice w przypadku mapowania między Niezmienna kultura i wszystkich innych kultur. W takich przypadkach przy użyciu reguł stosowania wielkości liter kultury niezmiennej, aby zmienić znaków na wielkie lub małe litery, zwraca takiego samego znaku. Dla wszystkich innych języków zwraca innego znaku. Niektórych znaków, których to dotyczy, są wymienione w poniższej tabeli.  
  
    |Znak|Jeśli zmieniono na|Zwraca|  
    |---------------|-------------------|-------------|  
    |MICRON SIGN (U + 00B5)|Wielkie litery|GRECKI LITERA MU (U +-39C)|  
    |WIELKA LITERA I Z DOT POWYŻEJ (U + 0130)|Małe litery|MAŁA LITERA I (U + 0069)|  
    |MAŁA LITERA BEZ KROPEK I (U + 0131)|Wielkie litery|WIELKA LITERA I (U + 0049)|  
    |MAŁA LITERA S DŁUGI (U + 017F)|Wielkie litery|S WIELKA LITERA (U + 0053)|  
    |WIELKA LITERA D Z MAŁA LITERA Z ODWRÓCONYM DASZKIEM (U + 01C 5)|Małe litery|DZ MAŁA LITERA Z ODWRÓCONYM DASZKIEM (U + 01C 6)|  
    |ŁĄCZENIE YPOGEGRAMMENI GRECKI (U + 0345)|Wielkie litery|IOTA GRECKIM WIELKIEJ LITERY (U + 0399)|  
  
-   Różnice w mapowanie przypadków dwuliterowych pary wielkie litery w zakresie znaków ASCII. W większości kultur parę wielkie litery dwuliterowych jest równy dwuliterowych równoważne parę wielkich i małych liter. Nie jest to wartość true dla następujących par dwuliterowych w następujących kultur, ponieważ w każdym przypadku są porównywane, aby dwuznak:  
  
    -   "arkusza finansowego" i "Jork" w kultury hr-HR (Chorwacki (Chorwacja)).  
  
    -   "cH" cs-CZ (czeski (Czechy)) i kultur sk-SK (Słowacki (Słowacja)).  
  
    -   "aA" w kulturze da-DK (duński (Dania)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "BR" i "zS" w kulturze hu-HU (węgierski (Węgry)).  
  
    -   "cH" i "lL" w kulturze es-ES_tradnl (Hiszpański (Hiszpania, sortowanie tradycyjne)).  
  
    -   "cH", "gI", "kH", "nG" "nH", "ciąg", "kwerendy", "tH" i "tR" w kulturze vi-VN (Wietnamski (Wietnam)).  
  
     Jest jednak rzadko wystąpić sytuacja, w którym kultury porównanie tych par stwarza problemy, ponieważ te pary jest nietypowy w przypadku stałych ciągów lub identyfikatorów.  
  
 Poniższy przykład ilustruje niektóre różnice w reguł stosowania wielkości liter kultury podczas konwersji ciągów na wielkie litery.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Formatowanie i analizowanie  
 Formatowanie i analizowanie to odwrotny operacje. Reguły formatowania określić sposób konwertowania wartości, takich jak daty i godziny lub liczbą, na jego reprezentację ciągu, natomiast podczas analizowania reguły określają, jak przekonwertować ciąg reprezentujący wartość daty i godziny. Formatowanie i podczas analizowania reguły są zależne od Konwencji kultury. Poniższy przykład ilustruje niejednoznaczności, które mogą wystąpić przy interpretowaniu ciąg daty specyficzne dla kultury. Bez znajomości Konwencji kultury, który został użyty do utworzenia ciągu daty, nie jest możliwe, należy wiedzieć, czy 03/01/2011 i 3/1/2011, 03/01/2011 reprezentują 3 stycznia 2011 lub 1 marca 2011 r.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Podobnie jak pokazano na poniższym przykładzie, pojedynczy ciąg może tworzyć różne daty, w zależności od kultury, której konwencje są używane w operacji analizowania.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Porównanie ciągów i sortowanie  
 Konwencje dotyczące porównywania i sortowania ciągów różnią się w kulturze kultury. Na przykład kolejność sortowania może być na podstawie fonetyka lub wizualnej reprezentacji znaków. W językach wschodnioazjatyckich znaki są posortowane według obrysu i istotnych z ideogramami. Sortowanie zależy również od języków kolejności i kultur na użytek alfabetu. Na przykład w języku duńskim ma znak "Ć", która sortuje po "Z" alfabetu. Ponadto porównania mogą być uwzględniana wielkość liter lub bez uwzględniania wielkości liter, a w niektórych przypadkach reguł stosowania wielkości liter różnią się także od kultury. Porównanie porządkowe, z drugiej strony, używa punkty kodowe Unicode pojedynczych znaków w ciągu podczas porównywania i sortowania ciągów.  
  
 Reguły sortowania określa kolejności alfabetycznej według znaków Unicode i jak dwa ciągi porównać ze sobą. Na przykład <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metoda porównuje dwa ciągi na podstawie <xref:System.StringComparison> parametru. Jeśli wartość parametru jest <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, jeśli wartość parametru jest metoda wykonuje lingwistyczne porównanie, który używa konwencji bieżącej kultury; <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, metoda wykonuje porównanie porządkowe. W związku z tym co ilustruje poniższy przykład, jeśli bieżąca kultura jest US Angielski, pierwsze wywołanie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> — metoda (przy użyciu kultury porównanie) uwzględnia "" większe niż "A", ale drugie wywołanie do tej samej metody (przy użyciu porównania porządkowego) traktuje "a" większe niż "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET wspomaga wyrazów, ciągów i reguły porządkowe sortowania:  
  
-   Sortowanie słów wykonuje zależne od kultury Porównanie ciągów, w których niektóre znaki niealfanumeryczne Unicode mogą mieć specjalnie przypisane im wagi. Na przykład łącznik (-) może być bardzo małą wagę, przypisane do niego, aby "coop" oraz "co-OP będą" wyświetlane obok siebie w posortowanej listy. Aby uzyskać listę <xref:System.String> metody porównania dwóch ciągów przy użyciu reguł sortowania wyrazów, zobacz [ciągu operacje według kategorii](#ByCategory) sekcji.  
  
-   Sortowanie ciągu oraz wykonuje porównanie zależne od kultury. Jest on podobny do sortowania słów, z tą różnicą, że istnieją żadne specjalne przypadki i wszystkie symbole inny niż alfanumeryczny występować przed wszystkimi alfanumerycznymi znakami Unicode. Można porównać dwóch ciągów przy użyciu reguł sortowania ciąg przez wywołanie metody <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> przeciążenia metody, które mają `options` parametr, który jest podana wartość <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Należy pamiętać, że jest jedyną metodą, która .NET zapewnia do porównywania dwóch ciągów przy użyciu reguł sortowania ciągów.  
  
-   Porządkowe sortowanie porównuje ciągi na podstawie wartości liczbowych poszczególnych <xref:System.Char> obiektu w ciągu. Porównanie porządkowe jest automatycznie uwzględniana wielkość liter, ponieważ wersje małe i wielkie litery, znaku mają punkty inny kod. Jednak w przypadku nie jest ważna, można określić porównanie porządkowe, które ignoruje wielkość liter. Jest to równoważne do konwersji ciągu na wielkie litery, przy użyciu niezmiennej kultury, a następnie wykonuje porównanie porządkowe na wynik. Aby uzyskać listę <xref:System.String> metody porównania dwóch ciągów przy użyciu reguł sortowania porządkowego, zobacz [ciągu operacje według kategorii](#ByCategory) sekcji.  
  
 Porównanie zależne od kultury jest każde porównanie, które jawnie lub niejawnie używa <xref:System.Globalization.CultureInfo> obiektu, z uwzględnieniem kultury niezmiennej, który jest określony przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości. Niejawne kultura jest bieżąca kultura, która jest określona przez <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Istnieje znaczne zmiany w kolejności sortowania znaków alfabetu (czyli znaków, dla którego <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> właściwość zwraca `true`) różnych kultur. Można określić porównanie zależne od kultury, które używa Konwencji określonej kultury poprzez dostarczenie <xref:System.Globalization.CultureInfo> obiekt do metody porównania ciągów, takich jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Można określić porównanie zależne od kultury, które używa konwencji bieżącej kultury, podając <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, lub dowolny element członkowski <xref:System.Globalization.CompareOptions> wyliczenie innych niż <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> lub <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> do odpowiedniej przeciążenia <xref:System.String.Compare%2A> metody. Porównanie zależne od kultury jest zazwyczaj sortowania nie jest porównanie porządkowe. Porównania porządkowego ogólnie przydaje się do określania, czy dwa ciągi są równe (oznacza to, że podczas ustalania tożsamości) nie jest porównanie zależne od kultury.  
  
 Poniższy przykład ilustruje różnicę między porównanie zależne od kultury i porządkowych. Przykład ocenia trzy ciągi "Apple", "Æble" i "AEble", przy użyciu porównanie porządkowe i Konwencji kultury da DK i en US (z których każdy jest domyślną kulturą w czasie <xref:System.String.Compare%2A> wywoływana jest metoda). Ponieważ języku duńskim traktuje znak "Ć" jako jednej litery i sortuje je po "Z" alfabetu, ciąg "Æble" jest większy niż "Apple". Jednak "Æble" jest nie uważany za równoważny "AEble" tak "Æble" również jest większa niż "AEble". Kultury en US nie zawierają litery "Ć", ale traktuje je jako odpowiednik "AE", która wyjaśnia, dlaczego "Æble" jest mniej niż "Apple", ale równa "AEble". Porównanie porządkowe, z drugiej strony, uwzględnia "Apple" jest mniejsza niż "Æble" i "Æble" powinien być większy niż "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Aby wybrać odpowiednią metodę porównywania sortowania lub ciąg, należy użyć ogólne wytyczne:  
  
-   Jeśli ciągi, które należy zamówić ma zależności od kultury użytkownika, należy je oparte na Konwencji bieżącej kultury zamówienia. Jeśli zmieni się kultury użytkownika, kolejności posortowanej ciągi zmienią odpowiednio. Na przykład aplikacja tezaurusa, zawsze należy sortowania słów, na podstawie kultury użytkownika.  
  
-   Chcąc ciągi, które należy zamówić oparte na konwencjach określonej kultury, należy zamówić je poprzez dostarczenie <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę do metody porównania. Na przykład w aplikacji przeznaczonej do zapoznaj studentów danego języka, ma ciągów do zamówienia oparte na konwencjach kultur, w których występuje ten język.  
  
-   Chcąc kolejności ciągów niepochodzącym różnych kultur, możesz uporządkować je oparte na Konwencji niezmiennej kultury lub użyj porównania porządkowego. Na przykład możesz użyć sortowania porządkowego do organizowania nazwy plików, procesy i muteksy lub nazwanych potoków.  
  
-   Dla porównania, która obejmuje decyzja dotycząca zabezpieczeń (na przykład tego, czy nazwa użytkownika jest prawidłowy), należy zawsze wykonuj porządkowe testowanie równości poprzez wywołanie przeciążenia <xref:System.String.Equals%2A> metody.  
  
> [!NOTE]
>  Wrażliwość na ustawienia kulturowe, sortowanie i wielkość liter reguł używanych w porównania ciągów są zależne od wersji programu .NET. W .NET Framework 4.5 i nowsze wersje systemem [!INCLUDE[win8](~/includes/win8-md.md)] systemu operacyjnego, sortowanie, wielkości liter, normalizacji i informacji o znakach Unicode jest zgodny ze standardem Unicode 6.0. W innych systemach operacyjnych Windows działa zgodnie z ich standard Unicode 5.0. Na platformie .NET Core to zależy od wersji standardu Unicode obsługiwanych przez system operacyjny. 
  
 Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i reguły porządkowe sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tematu. Dodatkowe zalecenia dotyczące kiedy należy używać każdej reguły, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Zazwyczaj nie wywołasz parametry metody porównania, takie jak <xref:System.String.Compare%2A> bezpośrednio do określenia kolejności sortowania ciągów. Zamiast tego metody porównania są wywoływane przez sortowanie metod, takich jak <xref:System.Array.Sort%2A?displayProperty=nameWithType> lub <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. Poniższy przykład wykonuje czterech różnych operacji sortowania (przy użyciu bieżącej kultury sortowania słów, przy użyciu niezmiennej kultury, sortowania porządkowego i sortowanie ciągów przy użyciu niezmiennej kultury sortowania słów) bez jawnego wywołania metody porównania ciągów Mimo że określają typ porównania do użycia. Należy pamiętać, że każdy typ sortowania generuje unikatowy porządkowania ciągów w swojej tablicy.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Wewnętrznie .NET używa kluczy sortowania do obsługi porównywania ciągów kulturalnie poufnych. Każdy znak w ciągu znajduje się kilka kategorii wagi sortowania, włącznie z alfabetycznym, wielkości liter i znaków diakrytycznych. Klucz sortowania, reprezentowane przez <xref:System.Globalization.SortKey> klasy alokowania elastycznego, wyświetla te wagi repozytorium dla określonego ciągu. Jeśli Twoja aplikacja wykonuje dużej liczby wyszukiwanie i sortowanie operacje na ten sam zestaw ciągów, można zwiększyć jej wydajność przez generowanie i przechowywanie kluczy sortowania dla wszystkich ciągów, z których korzysta. Gdy wymagana jest operacją sortowania lub porównywania, używasz kluczy sortowania zamiast ciągów. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.SortKey> klasy.  
  
 Jeśli nie określisz Konwencji porównania ciągów, sortowanie metody takie jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> przeprowadzania wrażliwość na ustawienia kulturowe, wielkość liter sortowania ciągów. W poniższym przykładzie pokazano, jak bieżąca kultura wpływają kolejności posortowanej ciągów w tablicy. Tworzy tablicę trzy ciągi. Najpierw ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwość en US i wywołania <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> metody. Wynikowy kolejność sortowania jest oparty na sortowanie Konwencji kultury angielski (Stany Zjednoczone). Następnie w przykładzie `System.Threading.Thread.CurrentThread.CurrentCulture` właściwości da DK i wywołania <xref:System.Array.Sort%2A?displayProperty=nameWithType> ponownie metodą. Zwróć uwagę, jak kolejność sortowania wynikowy różni się od wyników en US, ponieważ używa ona konwencji sortowania na potrzeby duński (Dania).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Jeśli Twoje głównym celem w porównywanie ciągów ma na celu określenie, czy są równe, należy wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metody. Zazwyczaj, należy użyć <xref:System.String.Equals%2A> do wykonania porównania porządkowego. <xref:System.String.Compare%2A?displayProperty=nameWithType> Metoda jest przeznaczona głównie do sortowania ciągów.  
  
 Ciąg wyszukiwania metod, takich jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, również można wykonać porównania ciągów zależne od kultury lub liczbą porządkową. Poniższy przykład ilustruje różnice między porównania porządkowego i wrażliwe na ustawienia kulturowe, przy użyciu <xref:System.String.IndexOf%2A> metody. Wyszukiwanie wrażliwość na ustawienia kulturowe, w którym bieżąca kultura jest angielski (Stany Zjednoczone) uwzględnia podciągu "oe", aby dopasować ligatury "o". Ponieważ (U + 00AD) nietrwały jest znakiem zerowej szerokości, wyszukiwanie traktuje nietrwały jako odpowiednik <xref:System.String.Empty> i znajduje dopasowanie na początku ciągu. Wyszukiwanie porządkowe, z drugiej strony, nie znajdzie dopasowania w obu przypadkach.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Wyszukiwanie ciągów  
 Ciąg wyszukiwania metod, takich jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, można również wykonać wrażliwość na ustawienia kulturowe lub porównań ciągach porządkowych do określenia, czy znak lub podciąg znajduje się w określonym ciągu.  
  
 Wyszukaj metody w <xref:System.String> klasę, która Wyszukaj pojedynczy znak, takich jak <xref:System.String.IndexOf%2A> metody lub jednym z zestawów znaków, takich jak <xref:System.String.IndexOfAny%2A> metody, wszystkie wykonać wyszukiwanie porządkowe. Aby przeprowadzić wyszukiwanie zależne od kultury znak, należy wywołać <xref:System.Globalization.CompareInfo> metody takie jak <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> lub <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Należy zauważyć, że wyniki wyszukiwania dla znaków, przy użyciu porównanie porządkowe i wrażliwe na ustawienia kulturowe mogą być bardzo różnią się. Na przykład wyszukiwanie złożony znak Unicode, takie jak ligatury "Ć" (U + 00 C 6) mogą być zgodne z dowolne wystąpienie, z jego składników w odpowiedniej kolejności, takie jak "AE" (U + 041U + 0045), w zależności od kultury. Poniższy przykład ilustruje różnicę między <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> i <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> metody podczas szukania pojedynczy znak. Ligatury "ć" (U + 00E6) znajduje się w ciągu "powietrza" przy użyciu konwencji kultury en US, ale nie wtedy, gdy za pomocą Konwencji kultury da DK lub wykonując porównanie porządkowe.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Z drugiej strony <xref:System.String> metody, które wyszukaj ciąg, a nie znakiem wykonać wyszukiwanie zależne od kultury, jeśli opcje wyszukiwania nie są jawnie określone przez parametr typu klasy <xref:System.StringComparison>. Jedynym wyjątkiem jest <xref:System.String.Contains%2A>, który przeprowadza wyszukiwanie porządkowe.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testowanie pod kątem równości  
 Użyj <xref:System.String.Compare%2A?displayProperty=nameWithType> metodę pozwala ustalić relacji dwa ciągi w porządku sortowania. Zazwyczaj jest to operacja zależne od kultury. Z kolei wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metody do testowania pod kątem równości. Ponieważ test pod kątem równości zwykle porównuje dane wejściowe użytkownika przy użyciu niektóre znane parametrów, takich jak prawidłową nazwę użytkownika, hasła lub ścieżka systemu plików, zwykle jest operacją porządkowych.  
  
> [!WARNING]
>  Istnieje możliwość testowania pod kątem równości, wywołując <xref:System.String.Compare%2A?displayProperty=nameWithType> metody i ustalania, czy wartość zwracana jest wartość zero. Taka praktyka nie jest zalecane. Aby ustalić, czy dwa ciągi są równe, należy wywołać jednego z przeciążeń <xref:System.String.Equals%2A?displayProperty=nameWithType> metody. Preferowany przeciążenia do wywołania jest albo wystąpienie <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> lub metody statycznej <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody, ponieważ obie metody obejmują <xref:System.StringComparison?displayProperty=nameWithType> parametr, który jawnie określa typ porównania.  
  
 Poniższy przykład ilustruje niebezpieczeństwo wykonywania zależne od kultury porównanie dla równości, podczas których jeden należy w zamian używać numeru porządkowego. W tym przypadku celem kod jest uniemożliwiają dostęp do systemu plików z adresów URL, które zaczynają się od "FILE://" lub "file://", wykonując porównanie bez uwzględniania wielkości liter początku adresu URL z ciągiem "FILE://". Jednak jeśli wykonywane jest porównanie zależne od kultury, przy użyciu kultury turecki (Turcja) na adres URL, który rozpoczyna się od "file://", porównanie dla równości kończy się niepowodzeniem, ponieważ lira wielkie litery odpowiednikiem małe litery "i" jest "İ" zamiast "I". W wyniku przypadkowo jest dozwolony dostęp do systemu plików. Z drugiej strony jeśli wykonywane jest porównanie porządkowe, porównanie dla równości zakończy się powodzeniem, a odmowa dostępu do systemu plików.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalizacja  
 Niektóre znaki Unicode mają wiele reprezentacji. Na przykład dowolne z następujących punktów kod reprezentuje literę "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Wiele reprezentacji dla pojedynczego znaku skomplikować wyszukiwanie, sortowanie, dopasowanie i inne operacje na ciągach.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną dla dowolnego z jego równoważnych reprezentacji binarnych znaku Unicode. Normalizacja można użyć wielu algorytmów, nazywanych formularzami normalizacji, które należy wykonać różne reguły. .NET wspomaga form normalizacji Unicode C, D, KC i KD. Ciągi mają zostać znormalizowane do tego samego formularza normalizacji, można można porównać przy użyciu porównania porządkowego.  
  
 Porównanie porządkowe jest porównanie binarne wartości skalarne Unicode odpowiadające <xref:System.Char> obiektów w każdym ciągu. <xref:System.String> Klasy zawiera szereg metod, które można wykonać porównanie porządkowe, w tym następujące:  
  
-   Wszystkie przeciążenia <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, i <xref:System.String.LastIndexOf%2A> metody, które obejmuje <xref:System.StringComparison> parametru. Metoda wykonuje porównanie porządkowe, jeśli podana wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase> dla tego parametru.  
  
-   Przeciążenia <xref:System.String.CompareOrdinal%2A> metody.  
  
-   Metody używające porównania porządkowego domyślnie, takich jak <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, i <xref:System.String.Split%2A>.  
  
-   Metody, które Wyszukaj <xref:System.Char> wartość lub elementów w <xref:System.Char> tablicy w wystąpieniu ciągu. Metody te zawierają <xref:System.String.IndexOf%28System.Char%29> i <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Można określić, czy ciąg jest znormalizować do formularza normalizacji C, wywołując <xref:System.String.IsNormalized?displayProperty=nameWithType> można wywołać metody lub <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodę pozwala ustalić, czy ciąg jest znormalizować do formularza normalizacji określony. Można również wywołać <xref:System.String.Normalize?displayProperty=nameWithType> może wywołać metodę, aby przekonwertować ciąg do formularza normalizacji C lub <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodę, aby przekonwertować ciąg do formularza normalizacji określony. Aby uzyskać szczegółowe informacje na temat normalizowanie i porównywanie ciągów, zobacz <xref:System.String.Normalize> i <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metody.  
  
 W poniższym przykładzie prostego pokazano normalizacji ciągów. Określa literę "ố" na trzy różne sposoby w trzy różne ciągi i używa porównania porządkowego pod kątem równości, aby określić, że każdy ciąg znaków różni się od dwóch ciągów. Następnie konwertuje każdy ciąg formularzami normalizacji obsługiwanych i ponownie wykonuje porównanie porządkowe każdego ciągu w postaci określonego normalizacji. W każdym przypadku drugi test pod kątem równości pokazuje, że ciągi są równe.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Aby uzyskać więcej informacji na temat normalizacji i formularzami normalizacji, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, jak również [Unicode Standard załącznika 15: form normalizacji Unicode](https://unicode.org/reports/tr15/) i [normalizacji — często zadawane pytania](https://www.unicode.org/faq/normalization.html) na stronie Unicode.org witryny sieci Web.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operacje na ciągach według kategorii  
 <xref:System.String> Klasa oferuje elementy członkowskie do porównywania ciągów, testowanie ciągów pod kątem równości, znajdowanie znaków lub podciągów w ciągu modyfikacji ciągu, wyodrębnianie podciągów z ciągu, łączenie ciągów, formatowania wartości ciągu, kopiowanie i normalizowanie ciągu.  
  
### <a name="comparing-strings"></a>Porównywanie ciągów  
 Można porównać ciągi, aby określić ich względne położenie w kolejności sortowania, używając następujących <xref:System.String> metody:  
  
-   <xref:System.String.Compare%2A> Zwraca liczbę całkowitą, który określa relację jednego ciągu, aby drugi ciąg w porządku sortowania.  
  
-   <xref:System.String.CompareOrdinal%2A> Zwraca liczbę całkowitą, który określa relację jednego ciągu, aby drugi ciąg na podstawie porównania punkty w kodzie.  
  
-   <xref:System.String.CompareTo%2A> Zwraca liczbę całkowitą, który określa relację bieżące wystąpienie ciągu drugiego ciągu w porządku sortowania. <xref:System.String.CompareTo%28System.String%29> Metoda zapewnia <xref:System.IComparable> i <xref:System.IComparable%601> niedotyczące <xref:System.String> klasy.  
  
### <a name="testing-strings-for-equality"></a>Testowanie ciągów pod kątem równości  
 Należy wywołać <xref:System.String.Equals%2A> metodę pozwala ustalić, czy dwa ciągi są równe. Wystąpienie <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> i statyczne <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> przeciążenia pozwalają określać, czy wynikiem porównania jest wrażliwe na ustawienia kulturowe lub porządkowy i tego, czy przypadek jest uważany za lub zignorować. Większość testów dla równości są porządkowe i porównania dla równości, które określają dostęp do zasobu systemu (na przykład do obiektu systemu plików) powinna zawsze być porządkowe.  
  
### <a name="finding-characters-in-a-string"></a>Znajdowanie znaków w ciągu  
 <xref:System.String> Klasa zawiera dwa rodzaje metod wyszukiwania:  
  
-   Metody, które zwracają <xref:System.Boolean> wartości, aby wskazać, czy podciąg określoną znajduje się w wystąpieniu ciągu. Obejmują one <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, i <xref:System.String.StartsWith%2A> metody.  
  
-   Metody, które wskazują pozycję początkową podciągu w wystąpieniu ciągu. Obejmują one <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, i <xref:System.String.LastIndexOfAny%2A> metody.  
  
> [!WARNING]
>  Jeśli chcesz wyszukać ciąg dla określonego wzorca zamiast określonych podciąg, należy użyć wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz [wyrażeń regularnych programu .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modyfikowanie ciągu  
 <xref:System.String> Klasa zawiera następujących metod, które pojawiają się do modyfikowania wartości ciągu:  
  
-   <xref:System.String.Insert%2A> Wstawia ciąg do bieżącego <xref:System.String> wystąpienia.  
  
-   <xref:System.String.PadLeft%2A> Wstawia jedną lub więcej wystąpień określony znak na początku ciągu.  
  
-   <xref:System.String.PadRight%2A> Wstawia jedną lub więcej wystąpień określony znak na końcu ciągu.  
  
-   <xref:System.String.Remove%2A> Usuwa podciąg z bieżącej <xref:System.String> wystąpienia.  
  
-   <xref:System.String.Replace%2A> zastępuje podciąg inny podciąg w bieżącym <xref:System.String> wystąpienia.  
  
-   <xref:System.String.ToLower%2A> i <xref:System.String.ToLowerInvariant%2A> konwersji wszystkich znaków w ciągu na małe litery.  
  
-   <xref:System.String.ToUpper%2A> i <xref:System.String.ToUpperInvariant%2A> konwersji wszystkich znaków w ciągu na wielkie litery.  
  
-   <xref:System.String.Trim%2A> Usuwa wszystkie wystąpienia znaku od początku i końca ciągu.  
  
-   <xref:System.String.TrimEnd%2A> Usuwa wszystkie wystąpienia znaków od końca ciągu.  
  
-   <xref:System.String.TrimStart%2A> Usuwa wszystkie wystąpienia znaku od początku ciągu.  
  
> [!IMPORTANT]
>  Wszystkie parametry modyfikacji metody zwracają nowe <xref:System.String> obiektu. Nie mogą modyfikować wartości bieżącego wystąpienia.  
  
### <a name="extracting-substrings-from-a-string"></a>Wyodrębnianie podciągów z ciągu znaków  
 <xref:System.String.Split%2A?displayProperty=nameWithType> Metoda oddziela pojedynczego ciągu do wielu ciągów. Przeciążenia metody umożliwiają określenie wiele ograniczników, aby określić maksymalną liczbę podciągów wyodrębnia metodę i określić, czy puste ciągi (które są wykonywane w przypadku ograniczniki sąsiadujące) są dołączane ciągi zwrócone.  
  
### <a name="combining-strings"></a>Łączenie ciągów  
 Następujące <xref:System.String> metody może służyć do ciągów:  
  
-   <xref:System.String.Concat%2A> łączy podciągów co najmniej w jednym ciągu.  
  
-   <xref:System.String.Join%2A> łączy podciągów co najmniej jeden do jednego elementu i dodaje znak oddzielający każdego podciągu.  
  
### <a name="formatting-values"></a>Formatowanie wartości  
 <xref:System.String.Format%2A?displayProperty=nameWithType> Metoda wykorzystuje funkcję formatowania złożonego zastąpić co najmniej jeden symbole zastępcze w ciągu reprezentację niektórych obiektów lub wartość. <xref:System.String.Format%2A> Metoda jest często używana do wykonaj następujące czynności:  
  
-   Aby osadzić ciąg reprezentujący wartość liczbową w ciągu.  
  
-   Aby osadzić ciąg reprezentujący wartość daty i godziny w ciągu.  
  
-   Aby osadzić ciąg reprezentujący wartość wyliczenia w ciągu.  
  
-   Aby osadzić ciąg reprezentujący jakiegoś obiektu, który obsługuje <xref:System.IFormattable> interfejsu w ciągu.  
  
-   Wyjustuj do prawej lub lewej podciągu w polu w dłuższym ciągu.  
  
 Aby uzyskać szczegółowe informacje na temat formatowania, operacje i przykłady, zobacz <xref:System.String.Format%2A> przeciążenia podsumowanie.  
  
### <a name="copying-a-string"></a>Kopiowanie ciągu  
 Możesz wywołać następujące <xref:System.String> metody w celu dokonania kopię ciągu:  
  
-   <xref:System.String.Clone%2A> Zwraca odwołanie do istniejącego <xref:System.String> obiektu.  
  
-   <xref:System.String.Copy%2A> Tworzy kopię istniejącego ciągu.  
  
-   <xref:System.String.CopyTo%2A> kopiuje fragment ciągu do tablicy znaków.  
  
### <a name="normalizing-a-string"></a>Normalizowanie ciągu  
 W formacie Unicode pojedynczy znak może mieć wiele punktów kodu. Normalizacja konwertuje te znaki równoważne na tej samej reprezentacji binarnej. <xref:System.String.Normalize%2A?displayProperty=nameWithType> Metoda wykonuje normalizacji i <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> Metoda określa, czy ciąg jest znormalizować.  
  
 Aby uzyskać więcej informacji i obejrzeć przykład, zobacz [normalizacji](#Normalization) wcześniej w tym temacie.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Sortowanie wagi tabel dla Windows, systemów operacyjnych</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Domyślne Unicode sortowania Elemeent tabeli dla systemów Linux i macOS</related>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Najlepsze praktyki używania ciągów w programie .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
 [Przeciążona składnia konstruktora](#Syntax)   
 [Parametry](#Params)   
 [Wyjątki](#Exceptions)   
 [Która metoda zostanie wywołana?](#Tasks)   
 [Tworzenie ciągów](#Creating_Strings)   
 [Obsługa powtarzających się ciągów](#Repetitive)   
 Przykłady tworzenia wystąpienia ciągów:   
 [Zastosowanie przypisania ciągu](#Ctor1_Example)  
 [Przy użyciu tablicy znaków](#Ctor2_Example)  
 [Wykorzystanie części tablicy znaków i powtarzanie pojedynczego znaku](#Ctor3_Example)  
 [Za pomocą wskaźnika do tablicy znaków](#Ctor4_Example)  
 [Za pomocą wskaźnika i zakresu tablicy](#Ctor5_Example)  
 [Za pomocą wskaźnika na podpisanej tablicy bajtowej](#Ctor6_Example)  
[Informacje o wersji](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Przeciążona składnia konstruktora  
 Konstruktory ciągu można podzielić na dwie kategorie: użytkownicy bez parametry wskaźnika, a także z parametrami wskaźnika. Konstruktory, które używają wskaźników nie są zgodne ze specyfikacją CLS. Ponadto Visual Basic nie obsługuje użycia wskaźników i C# wymaga kod, który używa wskaźników do uruchamiania w niebezpiecznym kontekście. Aby uzyskać więcej informacji, zobacz [niebezpieczne](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Aby uzyskać dodatkowe wskazówki dotyczące wyboru przeciążenia, zobacz [która metoda zostanie wywołana?](#Tasks)  
  
 `String(Char[] value)`  
 Inicjuje nowe wystąpienie wartości wskazywane przez tablicę znaków Unicode. Ten konstruktor kopiuje znaków Unicode ([przykład](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicjuje nowe wystąpienie wartości wskazywane przez tablicę znaków Unicode, począwszy od pozycji znaku w ciągu tej tablicy, a długość ([przykład](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicjuje nowe wystąpienie wartości wskazywane przez określony znak Unicode powtórzone określoną liczbę razy ([przykład](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Niezgodne ze specyfikacją CLS)**  Inicjuje nowe wystąpienie wartości wskazywane przez wskaźnik do tablicy znaków Unicode, który jest zakończony znakiem null (U + 0000 lub '\0'). ([przykład](#Ctor4_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Niezgodne ze specyfikacją CLS)**  Inicjuje nowe wystąpienie wartości wskazywane przez wskaźnik do tablicy znaków Unicode, począwszy od pozycji znaku w tę tablicę i długości. Konstruktor kopiuje znaki Unicode z `value` zaczynając od indeksu `startIndex` a kończąc na indeks `startIndex`  +  `length` – 1 ([przykład](#Ctor5_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value)`  
 **(Niezgodne ze specyfikacją CLS)**  Inicjuje nowe wystąpienie wartości wskazywane przez wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitowych. Tablica jest zakłada się, że reprezentują ciąg zakodowany przy użyciu bieżącej stronie kodowej systemu (czyli kodowanie określone przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaków ze zbioru `value` od lokalizacji określonej przez wskaźnik, aż do osiągnięcia znaku null (0x00) ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Niezgodne ze specyfikacją CLS)**  Inicjuje nowe wystąpienie wartości wskazywane przez wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitową, pozycja początkowa w ramach tę tablicę i długości.  Tablica jest zakłada się, że reprezentują ciąg zakodowany przy użyciu bieżącej stronie kodowej systemu (czyli kodowanie określone przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaki z wartości, zaczynając `startIndex` i kończące się wierszem `startIndex`  +  `length` – 1 ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Niezgodne ze specyfikacją CLS)**  Inicjuje nowe wystąpienie wartości wskazywane przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycja początkowa w ramach tej tablicy o długości i <xref:System.Text.Encoding> obiektu.  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametry  
 Oto Pełna lista parametrów używanych przez <xref:System.String> konstruktorów, które nie zawierają parametru wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Tablica znaków Unicode.|  
|`c`|<xref:System.Char>|Znak Unicode.|  
|`startIndex`|<xref:System.Int32>|Pozycja początkowa w `value` pierwszego wystąpienia znaku w ciągu nowych.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba znaków w `value` do uwzględnienia w nowy ciąg.<br /><br /> Wartość domyślna: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Liczba razy znak `c` jest powtarzany w nowy ciąg. Jeśli `count` wynosi zero, wartość nowy obiekt jest <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Oto Pełna lista parametrów używanych przez <xref:System.String> konstruktorów, które zawierają parametr wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> —lub—<br /><br /> <xref:System.SByte>\*|Wskaźnik do tablicy znaków Unicode zakończony wartością null lub tablicy liczb całkowitych ze znakiem 8-bitowych. Jeśli `value` jest `null` lub pusta tablica wartości nowy ciąg <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Indeks elementu tablicy, który określa pierwszy znak w ciągu nowych.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba elementów tablicy można użyć do utworzenia nowego ciągu znaków. Jeśli długość wynosi zero, Konstruktor tworzy ciąg, którego wartością jest <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Wartość domyślna: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Obiekt, który określa sposób, w jaki `value` tablicy jest zaszyfrowana.<br /><br /> Wartość domyślna: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, lub systemu w bieżącej stronie kodowej ANSI|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Wyjątki  
 Oto lista wyjątków zgłaszanych przez konstruktory, które nie zawierają parametry wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` jest `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, lub `count` jest mniejsza niż zero.<br /><br /> —lub—<br /><br /> Suma `startIndex` i `length` jest większa niż liczba elementów w `value`.<br /><br /> —lub—<br /><br /> `count` jest mniejsza niż zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Oto lista wyjątków zgłaszanych przez konstruktorów, które zawierają parametry wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Określa tablicę, która zawiera nieprawidłowy znak Unicode.<br /><br /> —lub—<br /><br /> `value` lub `value`  +  `startIndex` Określa adres który jest mniej niż 64 KB.<br /><br /> —lub—<br /><br /> Nowy <xref:System.String> wystąpienie nie zostało zainicjalizowane z `value` tablicy bajtów, ponieważ `value` nie używa domyślnego kodu strony kodowania.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.ArgumentNullException>|`value` ma wartość null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Bieżący proces nie ma dostępu do odczytu do wszystkich zaadresowane znaków.<br /><br /> —lub—<br /><br /> `startIndex` lub `length` jest mniejsza niż zero, `value`  +  `startIndex` spowodować przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich zaadresowane znaków.<br /><br /> —lub—<br /><br /> Długość nowego ciągu znaków jest zbyt duży, aby przydzielić.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.AccessViolationException>|`value`, lub `value`  +  `startIndex`  +  `length` – 1, określa nieprawidłowy adres.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Zadanie|Wywołania lub użycia|  
|--------|-----------------|  
|Tworzenie ciągu.|Przypisanie z literału ciągu lub istniejących parametrów ([przykład](#Ctor1_Example))|  
|Tworzenie ciągu z tablicy całego znaku.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([przykład](#Ctor2_Example))|  
|Tworzenie ciągu z części tablicy znaków.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([przykład](#Ctor3_Example))|  
|Utwórz ciąg, który powtarza się wielokrotnie takiego samego znaku.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([przykład](#Ctor3_Example))|  
|Utwórz ciąg ze wskaźnika do tablicy znaków dwubajtowych lub Unicode.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Tworzenie ciągu z części Unicode lub znaków dwubajtowych tablicy przy użyciu swojego wskaźnika.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Tworzenie ciągu z C++ `char` tablicy.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> —lub—<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Tworzenie ciągu z zestawu znaków ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Tworzenie ciągów  
 Najczęściej używane techniki programowe tworzenie ciągów jest przypisanie proste, jak pokazano w [w tym przykładzie](#Ctor1_Example). <xref:System.String> Klasa zawiera także cztery rodzaje przeciążeń konstruktora, które pozwalają na tworzenie ciągów z następujących wartości:  
  
-   Z tablicy znaków (tablicę algorytmem UTF-16 znaków). Można utworzyć nową <xref:System.String> obiektu ze znaków w macierz w całości lub części. <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiuje wszystkie znaki w tablicy do nowego ciągu znaków. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor kopiuje znaki z indeksu `startIndex` do indeksu `startIndex`  +  `length` – 1 do nowego ciągu znaków. Jeśli `length` wynosi zero, wartość nowy ciąg <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Jeśli Twój kod tworzy wielokrotnie ciągów, które mają taką samą wartość, może poprawić wydajność aplikacji przy użyciu alternatywny sposób Tworzenie ciągów. Aby uzyskać więcej informacji, zobacz [obsługa powtarzających się ciągów](#Repetitive).  
  
-   Z jednej oznacza to znak zduplikowane wartości zero, jeden, lub więcej razy, używając <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> konstruktora. Jeśli `count` wynosi zero, wartość nowy ciąg <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Ze wskaźnika do tablicy znaków zakończony znakiem null, za pomocą <xref:System.String.%23ctor%28System.Char%2A%29> lub <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> konstruktora. Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Konstruktor kopiuje sekwencji znaków Unicode, uruchamianie z określonym wskaźnika lub określony wskaźnik znaku plus `startIndex` i przechodzić do końca tablicy, lub dla `length` znaków. Jeśli `value` jest pustym wskaźnikiem lub `length` wynosi zero, Konstruktor tworzy ciąg, którego wartością jest <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli operacja kopiowania przechodzi do końca tablicy, a tablica nie jest zakończony znakiem null, zachowanie konstruktora jest zależna od systemu. Taki stan może spowodować naruszenie zasad dostępu.  
  
     Jeśli tablica zawiera osadzone znaki o wartości null (U + 0000 lub '\0') i <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> przeciążenie jest wywoływana, wystąpienie ciągu zawiera `length` znaków, wraz ze wszystkimi osadzone wartości null. W poniższym przykładzie pokazano, co się stanie, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null jest przekazywany do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest początku tablicy, a wszystkie elementy w tablicy, które mają być dodawane do ciągu, Konstruktor tworzy ciąg zawierający dziesięć znaków, w tym dwóch osadzone wartości. Z drugiej strony, jeśli w tej samej tablicy jest przekazywany do <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora, wynik jest ciągiem czterech znaków, który nie zawiera pierwszy znak null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Tablica musi zawierać znaki Unicode. W języku C++, oznacza to, że tablicy znaków musi być zdefiniowana jako zarządzany <xref:System.Char>[] typu lub niezarządzaną`wchar_t`[] typu.  
  
     Jeśli <xref:System.String.%23ctor%28System.Char%2A%29> wywołać przeciążenia i Tablica nie jest zakończony znakiem null, lub jeśli <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> wywołać przeciążenia i `startIndex`  +  `length`-1 obejmuje zakres, który go poza pamięci przydzielonych do sekwencji znaków, zachowanie konstruktora jest zależna od systemu, a naruszenie zasad dostępu mogą wystąpić. Ponadto na procesorze Intel Itanium wywołania <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor może zgłaszać <xref:System.DataMisalignedException> wyjątku. W takim przypadku należy wywołać <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> zamiast tego.  
  
-   Ze wskaźnika na podpisanej tablicy bajtowej. Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Sekwencja bajtów może być interpretowana za pomocą domyślną stronę kodową kodowania lub kodowania można określić w wywołaniu konstruktora. Jeśli Konstruktor podejmie próbę utworzenia wystąpienia ciągu z całej tablicy, który nie jest zakończony znakiem null, lub zakres tablicy od `value`  +  `startIndex` do `value`  +  `startIndex`  +  `length` -1 znajduje się poza ilość pamięci przydzielonej dla tablicy, zachowanie tego konstruktora jest zależna od systemu i może wystąpić naruszenie zasad dostępu.  
  
     Trzy konstruktory, które obejmują na podpisanej tablicy bajtowej jako parametr są przeznaczone głównie w celu konwersji C++ `char` tablicy na ciąg, jak pokazano w poniższym przykładzie:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Jeśli tablica zawiera wszystkie znaki null (\0) lub bajtów, którego wartość jest równa 0 i <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> przeciążenie jest wywoływana, wystąpienie ciągu zawiera `length` znaków, wraz ze wszystkimi osadzone wartości null. W poniższym przykładzie pokazano, co się stanie, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null jest przekazywany do <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest początku tablicy, a wszystkie elementy w tablicy, które mają być dodawane do ciągu, Konstruktor tworzy ciąg zawierający dziesięć znaków, w tym dwóch osadzone wartości. Z drugiej strony, jeśli w tej samej tablicy jest przekazywany do <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora, wynik jest ciągiem czterech znaków, który nie zawiera pierwszy znak null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Ponieważ <xref:System.String.%23ctor%28System.SByte%2A%29> i <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> interpretacji konstruktory `value` za pomocą domyślną stronę kodową ANSI, wywoływanie tych konstruktorów z tablic bajtowych identyczne może tworzyć ciągów, które mają różne wartości w różnych systemach.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Obsługa powtarzających się ciągów  
 Aplikacje, analizować lub często dekodowania strumienie tekstu, które używają <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora lub <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby przekonwertować sekwencji znaków w ciągu. Wielokrotnie tworzenie nowych ciągów z taką samą wartość, zamiast tworzenia i ponowne użycie jednego ciągu marnuje pamięci. Jeśli jesteś mogących utworzyć taką samą wartość ciągu wielokrotnego przez wywołanie metody <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora, nawet jeśli nie wiesz, w wcześniejsze, co może być tych identyczne ciągi, można użyć tabeli odnośników.  
  
 Załóżmy na przykład, należy przeczytać i przeanalizować strumienia znaków z pliku, który zawiera znaczniki i atrybuty XML. Podczas analizy strumienia wielokrotnie występują pewne tokeny (czyli sekwencji znaków, które mają znaczenie symboliczne). Tokeny równoważne do ciągów "0", "1", "true" i "false" prawdopodobnie często występują w strumień XML.  
  
 Zamiast konwertowania każdy token na nowe parametry, można utworzyć <xref:System.Xml.NameTable?displayProperty=nameWithType> obiekt do przechowywania najczęściej występujące ciągów. <xref:System.Xml.NameTable> Obiektu zwiększa wydajność, ponieważ pobiera przechowywaną ciągi bez przydziału pamięci tymczasowej. W przypadku wystąpienia tokenu, użyj <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby pobrać token z tabeli. Jeśli token istnieje, metoda zwraca odpowiedni ciąg. Jeśli token nie istnieje, użyj <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby wstawić token do tabeli i pobrać odpowiedni ciąg.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Przykład 1: Zastosowanie przypisania ciągu  
 Poniższy przykład tworzy nowy ciąg, przypisując literału ciągu. Tworzy drugi ciąg przez przypisywanie wartość ciągu pierwszego. Są to dwie najbardziej typowych sposobów tworzenia wystąpienia nowego <xref:System.String> obiektu.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Przykład 2: Zastosowanie tablicy znaków  
 Poniższy przykład pokazuje, jak utworzyć nową <xref:System.String> obiekt z tablicy znaków.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Przykład 3: Wykorzystanie części tablicy znaków i powtarzanie pojedynczego znaku  
 Poniższy przykład pokazuje, jak utworzyć nową <xref:System.String> obiektu z części tablicy znaków oraz sposób tworzenia nowego <xref:System.String> obiekt, który zawiera wiele wystąpień jednego znaku.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Przykład 4: Wykorzystywanie wskaźnika na tablicy znaków  
 Poniższy przykład pokazuje, jak utworzyć nową <xref:System.String> obiekt ze wskaźnika do tablicy znaków. Przykład C#, muszą być skompilowane przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Przykład 5: Utworzenie wystąpienia ciągu ze wskaźnika i zakresu tablicy  
 Poniższy przykład sprawdza, czy elementy tablicy znaków dla kropką ani znakiem wykrzyknika. Jeśli nie zostanie znalezione, tworzy wystąpienie ciągu ze znaków w tablicy, które poprzedzają symbolem interpunkcji. W przeciwnym razie metoda tworzy ciąg zawierający całą zawartość tablicy. Przykład języka C# musi być skompilowana przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Przykład 6: Utworzenie wystąpienia ciągu ze wskaźnika na podpisanej tablicy bajtowej  
 W poniższym przykładzie pokazano, jak utworzyć wystąpienie <xref:System.String> klasy <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informacje o wersji  
 .NET Framework  
 Wszystkie przeciążenia są obsługiwane w wersjach: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Wszystkie przeciążenia są obsługiwane w wersjach: 4, 3.5 z dodatkiem SP1  
  
 Biblioteka klas przenośnych  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane.  
  
 Środowisko .NET dla aPLikacji do Sklepu Windows  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane w programie: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode zakończony wartością null.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez określony wskaźnik do tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżący proces nie ma dostępu do odczytu do wszystkich zaadresowane znaków.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Określa tablicę, która zawiera nieprawidłowy znak Unicode, lub <paramref name="value" /> Określa adres, mniej niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez tablicę znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicą zakończoną znakiem null liczb całkowitych ze znakiem 8-bitowych. Liczby całkowite są interpretowane przy użyciu bieżącego systemu kodu strony kodowania (czyli kodowanie określone przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany w formacie ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość nowego ciągu znaków do zainicjowania, który zależy od znaku null zakończenie <paramref name="value" />, jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> Określa nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode.</param>
        <param name="count">Ile razy <paramref name="c" /> występuje.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez określony znak Unicode powtórzone określoną liczbę razy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode.</param>
        <param name="startIndex">Pozycja początkowa w ramach <paramref name="value" />.</param>
        <param name="length">Liczba znaków w ramach <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> znaków klasy na wartość wskazaną przez określony wskaźnik do tablicy znaków Unicode, począwszy od pozycji znaku w tę tablicę i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero, <paramref name="value" />  +  <paramref name="startIndex" /> spowodować przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich zaadresowane znaków.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Określa tablicę, która zawiera nieprawidłowy znak Unicode, lub <paramref name="value" />  +  <paramref name="startIndex" /> Określa adres, mniej niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <param name="startIndex">Pozycja początkowa w ramach <paramref name="value" />.</param>
        <param name="length">Liczba znaków w ramach <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> znaków klasy na wartość wskazaną przez tablicę znaków Unicode, począwszy od pozycji znaku w tę tablicę i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
Suma <paramref name="startIndex" /> i <paramref name="length" /> jest większa niż liczba elementów w <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitowych. Liczby całkowite są interpretowane przy użyciu bieżącego systemu kodu strony kodowania (czyli kodowanie określone przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Pozycja początkowa w ramach <paramref name="value" />.</param>
        <param name="length">Liczba znaków w ramach <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez określony wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitową, pozycja początkowa w ramach tej tablicy, a długość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
Adres podany przez <paramref name="value" />  +  <paramref name="startIndex" /> jest zbyt duży dla bieżącej platformy; oznacza to, że nastąpiło przepełnienie obliczanie adresu.  
  
—lub— 
Długość nowego ciągu znaków, aby zainicjować jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Adres podany przez <paramref name="value" />  +  <paramref name="startIndex" /> jest mniej niż 64 KB.  
  
—lub— 
Nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany w formacie ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, i <paramref name="length" /> wspólnie określać nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy liczb całkowitych ze znakiem 8-bitowych.</param>
        <param name="startIndex">Pozycja początkowa w ramach <paramref name="value" />.</param>
        <param name="length">Liczba znaków w ramach <paramref name="value" /> do użycia.</param>
        <param name="enc">Obiekt, który określa, jak tablica odwołuje się <paramref name="value" /> jest zaszyfrowana. Jeśli <paramref name="enc" /> jest <see langword="null" />, zakłada, że kodowania ANSI.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy na wartość wskazaną przez określony wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycja początkowa w ramach tej tablicy o długości i <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksową informacją na temat tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> podsumowanie dotyczące konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
Adres podany przez <paramref name="value" />  +  <paramref name="startIndex" /> jest zbyt duży dla bieżącej platformy; oznacza to, że nastąpiło przepełnienie obliczanie adresu.  
  
—lub— 
Długość nowego ciągu znaków, aby zainicjować jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Adres podany przez <paramref name="value" />  +  <paramref name="startIndex" /> jest mniej niż 64 KB.  
  
—lub— 
Nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany zgodnie z określonym <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, i <paramref name="length" /> wspólnie określać nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w ciągu bieżącej.</param>
        <summary>Pobiera <see cref="T:System.Char" /> obiekt na określonej pozycji w bieżącym <see cref="T:System.String" /> obiektu.</summary>
        <value>Obiekt w położeniu <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Ta właściwość zwraca <xref:System.Char> obiektu w miejscu określonym przez `index` parametru. Jednak znak Unicode może być reprezentowany przez więcej niż jedną <xref:System.Char>. Użyj <xref:System.Globalization.StringInfo?displayProperty=nameWithType> klasy do pracy z Unicode znaki zamiast <xref:System.Char> obiektów. Aby uzyskać więcej informacji, zobacz sekcję "Char obiektów i znaków Unicode" w <xref:System.String> klasa — Przegląd.  
  
 W języku C# <xref:System.String.Chars%2A> właściwość ma indeksatora. W języku Visual Basic jest domyślna właściwość <xref:System.String> klasy. Każdy <xref:System.Char> obiektu w ciągu jest możliwy przy użyciu następującego kodu.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można użyć ten indeksator w procedurze do sprawdzania ciągu.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest większe niż lub równa długości tego obiektu lub mniejsze niż zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>To wystąpienie <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana nie jest niezależnej kopi to wystąpienie; jest po prostu inny widok tych samych danych. Użyj <xref:System.String.Copy%2A> lub <xref:System.String.CopyTo%2A> metodę, aby utworzyć oddzielną <xref:System.String> obiektu z taką samą wartość jak to wystąpienie.  
  
 Ponieważ <xref:System.String.Clone%2A> metoda po prostu zwraca istniejącego wystąpienia ciągu, Brak wyboru wywołują go bezpośrednio.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie przeciążenia <xref:System.String.Compare%2A> zwracany przez metodę całkowita 32-bitowych wskazująca relację między dwa atrybuty porównania.  
  
|Wartość|Warunek|  
|-----------|---------------|  
|Mniej niż zero|Pierwszego podciągu poprzedza drugiego podciągu w porządku sortowania.|  
|Zero|Podciągów występują w tej samej pozycji w porządku sortowania lub `length` wynosi zero.|  
|Większe od zera|Pierwszego podciągu następuje drugiego podciągu w porządku sortowania.|  
  
> [!WARNING]
>  Jeśli to możliwe, należy wywołać przeciążenie <xref:System.String.Compare%2A> metodę, która obejmuje <xref:System.StringComparison> parametru. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Najlepsze praktyki używania ciągów w programie .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> odbywa się w tym samym położeniu co <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.String.Compare%28System.String%2CSystem.String%29> metodę, aby porównać trzy rodzaje ciągów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 W poniższym przykładzie `ReverseStringComparer` klasy pokazuje, jak można ocenić dwa ciągi przy użyciu <xref:System.String.Compare%2A> metody.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Na przykład poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub nowszej, porównanie zależne od kultury "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika nietrwałego lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  
  
[! code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! kodu vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Aby rozpoznać znaki do pominięcia w porównania ciągów, należy wywołać <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metody i dostarczyć wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla `comparisonType` parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów, zostanie zignorowana lub zapewniane w ich przypadku i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> odbywa się w tym samym położeniu co <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, że <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> metodą jest równoważne użyciu <xref:System.String.ToUpper%2A> lub <xref:System.String.ToLower%2A> podczas porównywania ciągów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Na przykład poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub nowszej, porównanie wrażliwość na ustawienia kulturowe, bez uwzględniania wielkości liter "zwierzę" z "Ani nieprawidłowo" (przy użyciu łącznika nietrwałego lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  
  
[! code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! kodu vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Aby rozpoznać znaki do pominięcia w porównania ciągów, należy wywołać <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metody i dostarczyć wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa reguły służące do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów za pomocą określonych reguł i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> w tym samym położeniu co <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie bieżącej lub niezmiennej kultury, uznaje ignorowanie wielkości liter argumentów porównawczych lub użyć programu word (wrażliwe na ustawienia kulturowe) lub reguły porządkowe (niewrażliwość na ustawienia kulturowe) sortowania.  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jednakże jeśli dwa porównywane ciągi są równe do końca jednego ciągu, a drugi ciąg ma jeszcze pozostałe znaki, ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Poniższy przykład porównuje trzy wersje litery "I". Wyniki są zagrożone wyboru kultury, czy wielkość liter jest ignorowana oraz czy wykonywane jest porównanie porządkowe.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> nie jest obsługiwane.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Aby rozpoznaje znaki do pominięcia w porównanie, należy podać wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Obiekt, który dostarcza informacje dotyczące porównania specyficznego dla kultury.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów, zostanie zignorowana lub zapewniane w ich przypadku i przy użyciu informacji specyficznych dla kultury do wywierania wpływu na porównanie i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> odbywa się w tym samym położeniu co <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy i porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak kultury mogą wpływać na porównanie. W Czeski — Republika Czeska kultury, "ch" jest pojedynczy znak, który jest większy niż "d". Jednak w języku angielskim — kultury Stanów Zjednoczonych "ch" składa się z dwóch znaków i "c" jest mniejsza niż "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Na przykład poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub nowszej, porównanie bez uwzględniania wielkości liter "zwierzę" z "Ani nieprawidłowo" (przy użyciu łącznika nietrwałego lub U + 00AD) przy użyciu niezmiennej kultury wskazuje, czy dwa ciągi są równoważne.  
  
[! code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! kodu vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Aby rozpoznać znaki do pominięcia w porównania ciągów, należy wywołać <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metody i dostarczyć wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="culture">Kultura, który dostarcza informacje dotyczące porównania specyficznego dla kultury.</param>
        <param name="options">Opcje do użycia podczas przeprowadzania porównania (takie jak ignorowanie symboli lub przypadek).</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów przy użyciu opcje porównywania określonej i informacje specyficzne dla kultury, do wywierania wpływu na porównanie i zwraca liczbę całkowitą, wskazującą związek ze sobą dwa ciągi w porządku sortowania.</summary>
        <returns>32-bitowa liczba całkowita wskazująca relację między <paramref name="strA" /> i <paramref name="strB" />, jak pokazano w poniższej tabeli 
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> odbywa się w tym samym położeniu co <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy i porządkiem alfabetycznym poszczególnych znaków. Na przykład określonej kultury można określić, że niektóre kombinacje znaków być traktowane jako pojedynczy znak, że wielkie i małe litery mają być porównywane w określony sposób, lub że kolejność sortowania znaków zależy od znaków, poprzedzających lub następnych.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest przeznaczona głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Nie można stosować, kiedy głównym celem wywołania metody które ma na celu określenie, czy dwa ciągi są równoważne (to znaczy, gdy wywołanie metody ma na celu testowania zwracana wartość wynosząca zero). Aby ustalić, czy dwa ciągi są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Porównanie, które może być dodatkowo określony przez `options` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.CompareOptions> wyliczenia. Jednakże, ponieważ ta metoda ma na celu przeprowadzenia porównania ciągów zależne od kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> wartości nie mają wpływu.  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym <xref:System.String.Empty?displayProperty=nameWithType>, porównuje większa niż odwołanie o wartości null i dwa odwołania zerowe są sobie równe do siebie nawzajem.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jednakże jeśli dwa porównywane ciągi są równe do końca jednego ciągu, a drugi ciąg ma jeszcze pozostałe znaki, ciąg z pozostałymi znakami uznaje się za większy.  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa ciągi na trzy różne sposoby: za pomocą porównania dla kultury en US; za pomocą językowej porównania uwzględniającego wielkość liter dla kultury en US; i według porównania porządkowego. Przykład ilustruje sposób trzy metody porównania wygenerować trzy różne wyniki.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest <see cref="T:System.Globalization.CompareOptions" /> wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Aby rozpoznaje znaki do pominięcia w porównanie, należy podać wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Położenie podciągu w obrębie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Położenie podciągu w obrębie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowych całkowita wskazująca relację między dwa atrybuty porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągów występują w tej samej pozycji w porządku sortowania lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągach do porównania Rozpocznij w `strA` na `indexA` i `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera, czyli pierwszy znak w `strA` i `strB` znajduje się na pozycji zero. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza od długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metody, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie porównano dwóch podciągów.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  
  
—lub— 
Albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa niż zero.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Metody nie traktuje te znaki, gdy wykonuje porównanie pod względem językowym lub zależne od kultury. Aby rozpoznać znaki do pominięcia w porównanie, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metody i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Położenie podciągu w obrębie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Położenie podciągu w obrębie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiektów, zostanie zignorowana lub zapewniane w ich przypadku i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągów występują w tej samej pozycji w porządku sortowania lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągach do porównania Rozpocznij w `strA` na `indexA`, a następnie w `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera, czyli pierwszy znak w `strA` i `strB` znajduje się na pozycji zero. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza od długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metody, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md).  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Nazwa ścieżki musi być porównywane w sposób niezmienna. Poprawny kod, aby to zrobić to w następujący sposób.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Poniższy przykład wykonuje dwa porównania dwóch podciągów, które różnią się tylko w przypadku. Pierwszy porównanie, ignoruje wielkość liter, a drugi porównanie uwzględnia przypadek.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  
  
—lub— 
Albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa niż zero.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Metody nie traktuje te znaki, gdy wykonuje porównanie pod względem językowym lub zależne od kultury. Aby rozpoznać znaki do pominięcia w porównanie, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metody i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Położenie podciągu w obrębie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Położenie podciągu w obrębie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa reguły służące do porównania.</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiektów za pomocą określonych reguł i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągów występują w tej samej pozycji w porządku sortowania lub <paramref name="length" /> parametr ma wartość zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> follllows podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągach do porównania Rozpocznij w `strA` na `indexA` i `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera, czyli pierwszy znak w `strA` i `strB` jest w pozycji zero, nie jednej pozycji. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza od długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 `comparisonType` Parametr wskazuje, czy porównanie bieżącej lub niezmiennej kultury, uznaje ignorowanie wielkości liter argumentów porównawczych lub użyć programu word (wrażliwe na ustawienia kulturowe) lub reguły porządkowe (niewrażliwość na ustawienia kulturowe) sortowania.  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jednakże jeśli dwa porównywane ciągi są równe do końca jednego ciągu, a drugi ciąg ma jeszcze pozostałe znaki, ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 W poniższym przykładzie porównano dwóch podciągów.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  
  
—lub— 
Albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Metody nie traktuje te znaki, gdy wykonuje porównanie pod względem językowym lub zależne od kultury. Aby rozpoznaje znaki do pominięcia w porównanie, należy podać wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Położenie podciągu w obrębie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Położenie podciągu w obrębie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Obiekt, który dostarcza informacje dotyczące porównania specyficznego dla kultury.</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiektów, zostanie zignorowana lub zapewniane w ich przypadku i przy użyciu informacji specyficznych dla kultury do wywierania wpływu na porównanie i zwraca liczbę całkowitą, wskazującą ich względne położenie w kolejności sortowania.</summary>
        <returns>Liczba całkowita wskazująca relację między dwa atrybuty porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągów występują w tej samej pozycji w porządku sortowania lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągach do porównania Rozpocznij w `strA` na `indexA`, a następnie w `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera, czyli pierwszy znak w `strA` i `strB` jest w pozycji zero, nie jednej pozycji. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza od długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy i porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Jeden lub oba atrybuty porównania mogą mieć `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 W poniższym przykładzie porównano dwa podciągi przy użyciu różnych kultur i ignoruje wielkość liter podciągów. Wybór kultury, który wpływa na sposób litery "I" jest porównywany.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  
  
—lub— 
Albo <paramref name="strA" /> lub <paramref name="strB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa niż zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Metody nie traktuje te znaki, gdy wykonuje porównanie pod względem językowym lub zależne od kultury. Aby rozpoznać znaki do pominięcia w porównanie, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metody i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja początkowa podciągu w ramach <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja początkowa podciągu w ramach <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="culture">Obiekt, który dostarcza informacje dotyczące porównania specyficznego dla kultury.</param>
        <param name="options">Opcje do użycia podczas przeprowadzania porównania (takie jak ignorowanie symboli lub przypadek).</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiektów przy użyciu opcje porównywania określonej i informacje specyficzne dla kultury, do wywierania wpływu na porównanie i zwraca liczbę całkowitą, wskazującą, związek dwóch podciągów ze sobą w porządek sortowania.</summary>
        <returns>Liczba całkowita wskazująca relację pomiędzy podciągami dwa, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągów występują w tej samej pozycji w porządku sortowania lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w porządku sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągach do porównania Rozpocznij w `strA` w położeniu `indexA` i `strB` w położeniu `indexB`. Długość pierwszego podciągu jest długością `strA` minus `indexA`. Długość drugiego podciągu jest długością `strB` minus `indexB`.  
  
 Liczba znaków do porównania jest mniejsza od długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy i porządkiem alfabetycznym poszczególnych znaków. Na przykład określonej kultury można określić, że niektóre kombinacje znaków być traktowane jako pojedynczy znak, że wielkie i małe litery mają być porównywane w określony sposób, lub że kolejność sortowania znaków zależy od znaków, poprzedzających lub następnych.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest przeznaczona głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Nie można stosować, kiedy głównym celem wywołania metody które ma na celu określenie, czy dwa podciągi są równoważne (to znaczy, gdy wywołanie metody ma na celu testowania zwracana wartość wynosząca zero). Aby ustalić, czy dwa ciągi są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Jeden lub oba `strA` i `strB` może być `null`. Według definicji dowolny ciąg, w tym <xref:System.String.Empty?displayProperty=nameWithType>, porównuje większa niż odwołanie o wartości null i dwa odwołania zerowe są sobie równe do siebie nawzajem.  
  
 Porównanie, które może być dodatkowo określony przez `options` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia. Jednakże, ponieważ ta metoda ma na celu przeprowadzenia porównania ciągów zależne od kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> wartości nie mają wpływu.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jednakże jeśli dwa porównywane ciągi są równe do końca jednego ciągu, a drugi ciąg ma jeszcze pozostałe znaki, ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodę, aby porównać nazwiska dwie osoby. Go następnie wyświetla je w kolejności alfabetycznej.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest <see cref="T:System.Globalization.CompareOptions" /> wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" /><see langword=".Length" />.  
  
—lub— 
 <paramref name="indexB" /> jest większa niż <paramref name="strB" /><see langword=".Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  
  
—lub— 
Albo <paramref name="strA" /> lub <paramref name="strB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa niż zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metody nie traktuje te znaki, gdy wykonuje porównanie pod względem językowym lub zależne od kultury. Aby rozpoznaje znaki do pominięcia w porównanie, należy podać wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa <see cref="T:System.String" /> obiektów wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
        <returns>Liczba całkowita wskazująca relację między dwa atrybuty porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /> jest mniejsza niż <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> i <paramref name="strB" /> są takie same.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" /> jest większa niż <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównania uwzględniającego wielkość liter, przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Do wykonania porównania bez uwzględniania wielkości liter, przy użyciu reguły porządkowe sortowania, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody z `comparisonType` argument wartość <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest statycznej metody `strA` i `strB` może być `null`. Jeśli obie wartości są `null`, metoda zwróci wartość 0 (zero), co oznacza, że `strA` i `strB` są takie same. Jeśli jedna z wartości jest tylko `null`, metoda uwzględnia większą wartość inną niż null.  
  
   
  
## Examples  
 Poniższy przykład wykonuje i porównanie porządkowe dwóch ciągów, które różnią się tylko w przypadku.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Indeks początkowy podciągu w <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Indeks początkowy podciągu w <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągów z dwóch określonych <see cref="T:System.String" /> obiektów wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdej podciąg.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> jest mniejszy niż podciąg w <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi są takie same lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> jest większy niż podciąg w <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`, `indexB`, I `length` parametry muszą być nieujemna.  
  
 Liczba znaków w porównaniu jest mniejsza od długości `strA` mniej `indexA`, długość `strB` mniej `indexB`, i `length`.  
  
 Ta metoda wykonuje porównania uwzględniającego wielkość liter, przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Do wykonania porównania bez uwzględniania wielkości liter, przy użyciu reguły porządkowe sortowania, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metody z `comparisonType` argument wartość <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest statycznej metody `strA` i `strB` może być `null`. Jeśli obie wartości są `null`, metoda zwróci wartość 0 (zero), co oznacza, że `strA` i `strB` są takie same. Jeśli jedna z wartości jest tylko `null`, metoda uwzględnia większą wartość inną niż null.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, że <xref:System.String.CompareOrdinal%2A> i <xref:System.String.Compare%2A> Użyj innego sortowania.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> nie jest <see langword="null" /> i <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="strB" /> nie jest <see langword="null" /> i <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie z określonym obiektem lub <see cref="T:System.String" /> i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tym samym miejscu w kolejności sortowania określonego obiektu lub <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba przeciążenia <xref:System.String.CompareTo%2A> metoda wykonać porównanie jest rozróżniana kultura oraz wielkość liter. Nie można użyć tej metody do wykonania porównania niewrażliwość na ustawienia kulturowe lub liczbą porządkową. Czystości kodu zaleca się unikanie <xref:System.String.CompareTo%2A> metody i wywołania <xref:System.String.Compare%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który daje w wyniku <see cref="T:System.String" />.</param>
        <summary>Porównuje to wystąpienie z określonym <see cref="T:System.Object" /> i wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tej samej pozycji w porządku sortowania określonych <see cref="T:System.Object" />.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tej samej pozycji w kolejności sortowania, co <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie poprzedza <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie ma tej samej pozycji w kolejności sortowania, co <paramref name="value" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie następuje po <paramref name="value" />.  
  
—lub— 
 <paramref name="value" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` musi być <xref:System.String> obiektu.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metodę zaprojektowano głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Nie można stosować, kiedy głównym celem wywołania metody które ma na celu określenie, czy dwa ciągi są równoważne. Aby ustalić, czy dwa ciągi są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji dotyczących zachowania tej metody, zobacz sekcję Uwagi <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.CompareTo%2A> metody z <xref:System.Object>. Ponieważ próbuje porównać <xref:System.String> wystąpienia do `TestClass` obiektu, metoda zgłasza <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.CompareTo(System.Object)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Na przykład poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika nietrwałego lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  
  
[! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! kodu vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Aby rozpoznać znaki do pominięcia w porównania ciągów, należy wywołać <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metody.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Porównuje to wystąpienie z określonym <see cref="T:System.String" /> obiektu i wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tym samym miejscu w kolejności sortowania określonego ciągu.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem wskazuje, czy to wystąpienie poprzedza, następuje po lub pojawia się w tej samej pozycji w kolejności sortowania, co <paramref name="strB" /> parametru.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie poprzedza <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie ma tej samej pozycji w kolejności sortowania, co <paramref name="strB" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie następuje po <paramref name="strB" />.  
  
—lub— 
 <paramref name="strB" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metodę zaprojektowano głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Nie można stosować, kiedy głównym celem wywołania metody które ma na celu określenie, czy dwa ciągi są równoważne. Aby ustalić, czy dwa ciągi są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Aby uzyskać więcej informacji dotyczących zachowania tej metody, zobacz sekcję Uwagi <xref:System.String.Compare%28System.String%2CSystem.String%29> metody.  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepiej niż <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> metody, ponieważ nie trzeba ustalić, czy `strB` argument jest typem wartości modyfikowalne, który musi zostać opakowany, a nie ma rzutowanie jego Parametr z <xref:System.Object> do <xref:System.String>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.CompareTo%2A> metody do porównania z bieżącym wystąpieniu ciągu innym ciągiem.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 W poniższym przykładzie pokazano ogólnych i nieogólnych wersje CompareTo — metoda dla kilku typów wartości i odwołań.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.CompareTo(System.String)" /> Metody nie należy wziąć pod uwagę takie znaki, gdy wykonuje porównanie zależne od kultury. Na przykład poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika nietrwałego lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  
  
[! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! kodu vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Aby rozpoznać znaki do pominięcia w porównania ciągów, należy wywołać <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metody.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Co najmniej jedno z łączy <see cref="T:System.String" />, lub <see cref="T:System.String" /> reprezentujących wartości z jednego lub większej liczby wystąpień <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Obiekt kolekcji, która implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> i którego argument typu ogólnego jest <see cref="T:System.String" />.</param>
        <summary>Łączy elementy członkowskie skonstruowany <see cref="T:System.Collections.Generic.IEnumerable`1" /> Kolekcja typu <see cref="T:System.String" />.</summary>
        <returns>Połączonych ciągów w <paramref name="values" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="values" /> jest pustym <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników. Do określenia ogranicznika między każdym członku `values`, wywołaj <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego elementu o wartości null w `values`.  
  
 Jeśli `values` jest pustym `IEnumerable(Of String)`, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `values` jest `null`, metoda zgłasza <xref:System.ArgumentNullException> wyjątku.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> jest to wygodna metoda, która umożliwia łączenia każdego elementu w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów do tablicy ciągów. Jest to szczególnie przydatne w przypadku wyrażenia zapytań Language-Integrated Query (LINQ). Poniższy przykład przekazuje `List(Of String)` obiekt, który zawiera małe i wielkie litery alfabetu do wyrażenia lambda, która wybiera litery, który jest równy lub większy od określonej litery (czyli, w tym przykładzie "M"). `IEnumerable(Of String)` Kolekcji, który jest zwracany przez <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> metoda jest przekazywana do <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę, aby wyświetlić wynik jako pojedynczy ciąg.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, które są następnie przekazywane do <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Obiekt reprezentujący, lub <see langword="null" />.</param>
        <summary>Tworzy reprezentację określonego obiektu.</summary>
        <returns>Ciąg reprezentujący wartość <paramref name="arg0" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="arg0" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29> Metody reprezentująca `arg0` jako ciąg przez wywołanie jego bez parametrów `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów zawierająca elementy do łączenia.</param>
        <summary>Łączy ciągów reprezentujących elementy w określonej <see cref="T:System.Object" /> tablicy.</summary>
        <returns>Połączonych ciągów reprezentujących wartości elementów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `args` przez wywołanie metody bez parametrów `ToString` metody tego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast dowolnego obiektu o wartości null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.String.Concat%2A> metody z <xref:System.Object> tablicy.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda nie jest wywoływana przez kod języka C++. Kompilator języka C++ jest rozpoznawana jako wywołania <see cref="Overload:System.String.Concat" /> które mają co najmniej cztery parametry obiektów jako wywołanie <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Tablica wystąpienia ciągu.</param>
        <summary>Łączy elementy określonego <see cref="T:System.String" /> tablicy.</summary>
        <returns>Połączone elementy <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu o wartości null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.String.Concat%2A> metody z <xref:System.String> tablicy.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <summary>Łączy ciągów reprezentujących dwa określone obiekty.</summary>
        <returns>Połączonych ciągów reprezentujących wartości <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0` i `arg1` przez wywołanie metody bez parametrów `ToString` metody `arg0` i `arg1`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast dowolnego argumentu null.  
  
 Jeśli wartość argumentów jest odwołaniem do tablicy, metoda łączy ciąg reprezentujący tablicy, a nie jej elementów członkowskich (na przykład "System.String[]").  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <summary>Łączy dwa określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" /> i <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0` i `str1`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągów dla danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby łączenie ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu null.  
  
   
  
## Examples  
 Poniższy przykład łączy nazwę pierwszego, drugie imię i nazwisko osoby.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <param name="arg2">Trzeci obiekt do połączenia.</param>
        <summary>Łączy ciągów reprezentujących trzy określonych obiektów.</summary>
        <returns>Połączonych ciągów reprezentujących wartości <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0`, `arg1`, i `arg2` przez wywołanie metody bez parametrów `ToString` metoda każdego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast dowolnego argumentu null.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <param name="str2">Trzeci ciąg do łączenia.</param>
        <summary>Łączy trzy wystąpienia określonego <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" />, <paramref name="str1" />, i <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`, i `str2`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągów dla danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby łączenie ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu null.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Concat%2A> metodę, aby złączyć trzy ciągi i wyświetla wynik.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <param name="arg2">Trzeci obiekt do połączenia.</param>
        <param name="arg3">Czwarty obiekt do połączenia.</param>
        <summary>Łączy ciągów reprezentujących cztery określone obiekty i wszystkie obiekty określone na liście parametrów opcjonalnych o zmiennej długości.</summary>
        <returns>Reprezentacja ciągu połączonych każdej wartości na liście parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze specyfikacją CLS to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Metoda łączy każdy obiekt na liście parametrów, wywołując jej bez parametrów `ToString` metody; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast dowolnego argumentu null.  
  
> [!NOTE]
>  Ostatni parametr <xref:System.String.Concat%2A> metodą jest opcjonalna rozdzielana przecinkami lista jednego lub więcej dodatkowych obiektów do łączenia.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody do łączenia się z listą parametrów zmiennych. W tym przypadku metoda jest wywoływana z dziewięciu parametrami.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest oznaczona za pomocą <see langword="vararg" /> — słowo kluczowe, co oznacza, że obsługuje ona zmienną liczbę parametrów. Metoda może być wywoływana z Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory C# i Visual Basic rozwiązać wywołania do <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> jako wywołania <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <param name="str2">Trzeci ciąg do łączenia.</param>
        <param name="str3">Czwarty łączenie ciągów.</param>
        <summary>Łączy cztery określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, i <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`, `str2`, i `str3`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągów dla danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby łączenie ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu o wartości null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę czterech — litery słowa i ich poszczególne listy na tablicę ciągów są przechowywane w celu szyfrują je. Następnie wywołuje <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodę, aby ponownie połączyć zaszyfrowaną słów.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <paramref name="values" />.</typeparam>
        <param name="values">Obiekt kolekcji, która implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> interfejsu.</param>
        <summary>Łączy elementy członkowskie <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementacji.</summary>
        <returns>W połączonych elementów członkowskich <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> jest to wygodna metoda, która umożliwia łączenia każdego elementu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania elementy do ciągów. Jest szczególnie przydatne w przypadku wyrażenia zapytań Language-Integrated Query (LINQ), tak jak pokazano w przykładzie. Reprezentacja ciągu każdego obiektu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest tworzony przez wywołanie metody tego obiektu `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano bardzo prosty `Animal` klasę, która zawiera nazwę zwierzę i kolejności, do której należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiektu zawiera szereg `Animal` obiektów. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> — Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiekty, których `Order` właściwości jest równa "Gryzoń". Wynik jest przekazywany do <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody i wyświetlana w konsoli.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Zwraca wartość wskazującą, czy określony podciąg występuje w ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru występuje w tym ciągu lub jeśli <paramref name="value" /> jest pustym ciągiem (""); w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe). Wyszukiwanie rozpoczyna się od pierwszego pozycji znaku tego ciągu i jest kontynuowane przy użyciu ostatniej pozycji znaku.  
  
 Aby określić, czy ciąg zawiera podciąg określony za pomocą coś innego niż porównanie porządkowe (na przykład porównanie zależne od kultury, lub porządkowego porównania bez uwzględniania wielkości liter), można utworzyć niestandardową metodę. W poniższym przykładzie pokazano jedno z podejść. Definiuje on <xref:System.String> metodę rozszerzenia, która obejmuje <xref:System.StringComparison> parametru i wskazuje, czy ciąg zawiera podciąg, korzystając z podanym formularzu porównywania ciągów.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Poniższy przykład następnie wywołuje `Contains` metodę rozszerzenia, aby określić, czy podciąg znajduje się w ciągu, korzystając z porównanie porządkowe i porównania porządkowego bez uwzględniania wielkości liter.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Jeśli interesuje Cię położenie podciągu `value` w bieżącym wystąpieniu, można wywołać <xref:System.String.IndexOf%2A> może wywołać metodę, aby uzyskać początkową jej pierwszego wystąpienia, lub <xref:System.String.LastIndexOf%2A> metodę, aby uzyskać początkowy pozycji z jego ostatnie wystąpienie. Przykład zawiera wywołanie <xref:System.String.IndexOf%28System.String%29> metody, jeśli ciąg zostanie znaleziony w wystąpieniu ciągu.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg "fox" jest podciągiem znanych oferty. Jeśli "szorty" znajduje się w ciągu, jest również wyświetlana jego pozycja początkowa.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do skopiowania.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.String" /> z taką samą wartość jak określonego <see cref="T:System.String" />.</summary>
        <returns>Nowy ciąg z taką samą wartość jak <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A> Metoda zwraca <xref:System.String> obiekt, który ma taką samą wartość jak oryginalny ciąg znaków, ale reprezentuje odwołanie do innego obiektu. Różni się od operatora przypisania, który przypisuje istniejącej relacji ciąg do zmiennej obiektu dodatkowe. W przykładzie pokazano różnicę.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa obiekty ciągu z różnymi wartościami. Kiedy wywołuje <xref:System.String.Copy%2A> metodę, aby przypisać pierwsza wartość do drugiego ciągu dane wyjściowe wskazują, ciągi reprezentują odwołania do innego obiektu, mimo że ich wartości, teraz są równe. Z drugiej strony Jeśli pierwszy ciąg jest przypisana do drugiego ciągu, dwa ciągi ma takie same wartości reprezentują one odwołanie do tego samego obiektu.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Indeks pierwszego znaku, w tym wystąpieniu do skopiowania.</param>
        <param name="destination">Tablica znaków Unicode, do których są kopiowane znaki w tym wystąpieniu.</param>
        <param name="destinationIndex">Indeks w <paramref name="destination" /> od którego rozpoczyna się operacja kopiowania.</param>
        <param name="count">Liczba znaków w celu skopiowania do tego wystąpienia <paramref name="destination" />.</param>
        <summary>Kopiuje określoną liczbę znaków od określonej pozycji w tym wystąpieniu do określonej pozycji w tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje `count` znaków z `sourceIndex` położenie tego wystąpienia `destinationIndex` pozycji `destination` tablicy znaków. Ta metoda nie zmienia rozmiaru `destination` tablicy znaków; musi mieć wystarczającą liczbę elementów do uwzględnienia kopiowane znaki lub metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` i `destinationIndex` zaczynają się od zera.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.CopyTo%2A> metody.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" /> jest liczbą ujemną 
—lub— 
 <paramref name="sourceIndex" /> nie identyfikuje pozycji w ramach bieżącego wystąpienia.  
  
—lub— 
 <paramref name="destinationIndex" /> nie określa prawidłowego indeksu w <paramref name="destination" /> tablicy.  
  
—lub— 
 <paramref name="count" /> jest większa niż długość podciągu z <paramref name="sourceIndex" /> na końcu tego wystąpienia 
—lub— 
 <paramref name="count" /> jest większa niż długość podtablica z <paramref name="destinationIndex" /> na końcu <paramref name="destination" /> tablicy.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pusty ciąg. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest ciągiem o zerowej długości, "".  
  
 W kodzie aplikacji to pole jest najczęściej używane w przypisaniach można zainicjować zmiennej ciągu na pusty ciąg. Aby sprawdzić, czy wartość ciągu jest albo `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, użyj <xref:System.String.IsNullOrEmpty%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z podciągu na końcu tego wystąpienia.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> pasuje do końca tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` do podciągu na końcu tego wystąpienia, która jest równa długości `value`i zwraca wskazanie, czy są równe. Równy, `value` musi być odwołaniem do tego samego wystąpienia lub odpowiadać na końcu tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy każdego ciągu w tablicy kończy się kropką (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `StripEndTags` metody, która używa <xref:System.String.EndsWith%28System.String%29> metodę, aby usunąć znacznikami końcowymi HTML z końca wiersza. Należy pamiętać, że `StripEndTags` metoda jest wywoływana cyklicznie, aby się upewnić, że wiele znacznikami końcowymi HTML na końcu wiersza.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby ustalić, czy ciąg kończy się podciągiem określoną za pomocą reguł porównywania ciągów bieżącej kultury, należy wywołać <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z podciągu na końcu tego wystąpienia.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa, jak te parametry i <paramref name="value" /> są porównywane.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z przy użyciu opcji porównania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru pasuje do końca tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> Metoda porównuje `value` parametr podciągu na końcu tego ciągu i zwraca wartość wskazującą, czy są równe. Równy, `value` musi być odwołaniem do tego samego ciągu, musi być ciągiem pustym (""), lub musi pasować do końca tego ciągu. Typ porównania wykonywane przez <xref:System.String.EndsWith%2A> metoda zależy od wartości `comparisonType` parametru.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg kończy się określonym podciąg. Wyniki są zagrożone wyboru kultury, czy wielkość liter jest ignorowana oraz czy wykonywane jest porównanie porządkowe.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z podciągu na końcu tego wystąpienia.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Informacje dotyczące kultury, która określa, jak to wystąpienie i <paramref name="value" /> są porównywane. Jeśli <paramref name="culture" /> jest <see langword="null" />, bieżąca kultura jest wykorzystywana.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z przy użyciu określonej kultury.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru pasuje do końca tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` podciągu na końcu tego ciągu, która jest równa długości parametru `value`i zwraca wartość wskazującą, czy są równe. Równy, `value` musi być odwołaniem do tego samego wystąpienia lub dopasowuje koniec ciągu.  
  
 Ta metoda wykonuje porównanie (wrażliwe na ustawienia kulturowe) programu word za pomocą określonego wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na końcu innego ciągu. <xref:System.String.EndsWith%2A> Metoda jest wywoływana kilka razy, używając rozróżnianie wielkości liter, ignorowanie wielkości liter i różnych kultur, które mają wpływ na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa <see cref="T:System.String" /> obiekty mają taką samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie oraz określony obiekt musi być także <see cref="T:System.String" /> obiektów, mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest <see cref="T:System.String" /> i jego wartość jest taka sama, jak to wystąpienie; w przeciwnym razie <see langword="false" />.  Jeśli <paramref name="obj" /> jest <see langword="null" />, metoda zwraca <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie, a drugi określony <see cref="T:System.String" /> obiekt ma taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="value" /> parametru jest taka sama jak wartość tego wystąpienia; w przeciwnym razie <see langword="false" />. Jeśli <paramref name="value" /> jest <see langword="null" />, metoda zwraca <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody. Porównuje tytułu — z uwzględnieniem wielkości liter słowo "File" równoważne słowa, równoważnik małe litery, równoważnik wielkie litery i słowa zawierającego ŁACIŃSKI małej litery bez KROPEK I (U + 0131) zamiast ŁACIŃSKI małe litery I (U + 0069). Ponieważ <xref:System.String.Equals%28System.String%29> metoda wykonuje porównanie porządkowe, zwraca tylko porównania identyczne wyrazami `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.String" /> obiekty mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> jest taka sama jak wartość <paramref name="b" />; w przeciwnym razie <see langword="false" />. Jeśli oba <paramref name="a" /> i <paramref name="b" /> są <see langword="null" />, metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z tym wystąpieniem.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa, jak można porównać ciągi.</param>
        <summary>Określa, czy ten ciąg i określonego <see cref="T:System.String" /> obiekt ma taką samą wartość. Parametr określa kultury, wielkości liter i reguł sortowania używanych do porównania.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="value" /> parametru jest taki sam jak ten ciąg; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie bieżącej lub niezmiennej kultury, uznaje Ignoruj wielkość liter dwa porównywane ciągi lub użyć programu word lub reguły porządkowe sortowania.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę ciągów, składający się z wielkiej litery "I" małe "i" i bez kropki "ı". Następnie wywołuje <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metody porównania ich przy użyciu każdego możliwe <xref:System.StringComparison> wartość wyliczenia.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 W poniższym przykładzie porównano cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.  Porównania używać konwencji kultur Lapoński (Szwecja górny) i angielski (Stany Zjednoczone). Należy pamiętać, że ciągi "wartości" i "encyklopedii" są uważane za równoważne w kulturze en US, ale nie w kulturze Lapoński (Szwecja Północna).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa reguły do porównania.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.String" /> obiekty mają taką samą wartość. Parametr określa kultury, wielkości liter i reguł sortowania używanych do porównania.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> parametr jest równy wartości <paramref name="b" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie bieżącej lub niezmiennej kultury, uznaje Ignoruj wielkość liter dwa porównywane ciągi lub użyć programu word lub reguły porządkowe sortowania.  
  
   
  
## Examples  
 W poniższym przykładzie porównano cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.  Porównania używać konwencji kultur Lapoński (Szwecja górny) i angielski (Stany Zjednoczone). Należy pamiętać, że ciągi "wartości" i "encyklopedii" są uważane za równoważne w kulturze en US, ale nie w kulturze Lapoński (Szwecja Północna).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość obiektów na ciągi formatów określony w oparciu i wstawia je do innego ciągu.  
  
Jeśli dopiero zaczynasz korzystać z `String.Format` metody, zobacz [wprowadzenie metody String.Format](#Starting) sekcji, aby uzyskać szybki przegląd.  
  
Zobacz [uwagi](#remarks-top) sekcji ogólna dokumentacja dotycząca `String.Format` metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 W tej sekcji:  
  
 [Rozpoczynanie pracy z usługą String.Format — metoda](#Starting)   
 [Która metoda zostanie wywołana?](#FTaskList)   
 [Metoda formatowania w skrócie](#Format_Brief)   
 [Element formatu](#FormatItem)   
 [Sposób formatowania argumentów](#HowFormatted)   
 [Elementy formatu o tym samym indeksie](#SameIndex)   
 [Formatowanie i kultura](#Format_Culture)   
 [Niestandardowe formatowanie operacji](#Format_Custom)   
 [String.Format pytań i odpowiedzi](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Rozpoczynanie pracy z usługą String.Format — metoda  
 Użyj <xref:System.String.Format%2A?displayProperty=nameWithType> Jeśli potrzebujesz do wstawienia wartości obiektu, zmiennej lub wyrażenia do innego ciągu. Na przykład, można wstawić wartość <xref:System.Decimal> wartość na ciąg w celu wyświetlenia go użytkownikowi jako pojedynczy ciąg:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 I można także kontrolować sposób formatowania tę wartość:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Oprócz formatowania, możesz również kontrolować wyrównanie i odstępy.  
  
 ### <a name="inserting-a-string"></a>Wstawianie ciąg  

 <xref:System.String.Format%2A?displayProperty=nameWithType> rozpoczyna się od ciągu formatu, następuje obiektów lub wyrażeń, które zostaną przekonwertowane na ciągi i wstawiany w określonym miejscu w ciągu formatu. Na przykład:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` w formacie ciągu jest element formatu. `0` jest indeksem obiektu, którego wartość ciągu zostanie wstawiony na tej pozycji. (Indeksy rozpoczynają się od 0). Jeśli obiekt do wstawienia nie jest ciągiem, jego `ToString` metoda jest wywoływana, aby przekonwertować go na jeden przed jego wstawieniem, w ciągu wynikowym.  
  
 Oto inny przykład, który używa dwóch elementów formatu i dwa obiekty na liście obiektów:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Może mieć dowolną liczbę elementów formatu i dowolną liczbę obiektów na liście obiektów, jak chcesz, dopóki indeks każdy element formatu ma pasującego obiektu na liście obiektów. Możesz również nie musi się martwić o przeciążenia, które wywołujesz; Kompilator wybierze odpowiednią dla Ciebie.  
  
 ### <a name="controlling-formatting"></a>Kontrolowanie formatowania  
 Możesz wykonać indeksu w elemencie formatu z ciągiem formatu, aby kontrolować sposób formatowania obiektu. Na przykład `{0:d}` dotyczy ciąg formatu "d" pierwszy obiekt na liście obiektów. Oto przykład z pojedynczym obiektem i formatowanie dwóch elementów:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Numer pomocy technicznej typy formatowania ciągów, w tym wszystkich typów liczbowych (zarówno [standardowa](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md) ciągi formatujące), wszystkie daty i godziny (zarówno [standardowa](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ciągi formatujące) i przedziały czasu (zarówno [standardowa](~/docs/standard/base-types/standard-timespan-format-strings.md) i [niestandardowe](~/docs/standard/base-types/custom-timespan-format-strings.md) ciągi formatujące), wszystkie typy wyliczeniowe [Typy wyliczeniowe ](~/docs/standard/base-types/enumeration-format-strings.md), i [identyfikatorów GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Można również dodać obsługę ciągów formatu, do własnych typów.  
  
 ### <a name="controlling-spacing"></a>Kontrolowanie odstępy  
 Można zdefiniować szerokość ciąg, który jest wstawiany do ciągu wynikowego przy użyciu składni, takich jak `{0,12}`, który wstawia ciąg 12 znaków. W tym przypadku ciąg reprezentujący pierwszy obiekt jest wyrównany do prawej w polu 12 znaków.  (Jeśli ciąg reprezentujący pierwszy obiekt jest więcej niż 12 znaków długości, jednak szerokość pola preferowane jest ignorowana, a cały ciąg jest wstawiany do ciągu wynikowego.)  
  
 W poniższym przykładzie zdefiniowano pola 6 znaków, aby pomieścić ciąg "Year" i niektóre ciągi roku, a także pole 15-znakową zawierającą ciąg "Populacji" i niektóre dane dotyczące populacji. Należy pamiętać, że znaki są wyrównane do prawej w polu.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Kontrolowanie wyrównania  
 Domyślnie ciągi są wyrównane do prawej w polu ich w przypadku określenia szerokości pola. Aby wyrównać po lewej stronie ciągów w polu, poprzedzony szerokość pola znakiem minus, takich jak `{0,-12}` Aby zdefiniować pole wyrównane do lewej 12 znaków.  
  
 Poniższy przykład jest podobny do poprzedniego, z tą różnicą, że go po lewej stronie wyrównuje zarówno etykiet, jak i dane.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> wykorzystuje funkcję formatowania złożonego. Aby uzyskać więcej informacji, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Zadanie|Wywołania|  
|--------|----------|  
|Formatowanie wielu obiektów przy użyciu konwencji bieżącej kultury.|Z wyjątkiem przeciążenia, które obejmują `provider` parametru, pozostałe <xref:System.String.Format%2A> przeciążenia zawierają <xref:System.String> parametru następuje jeden lub więcej parametrów obiektu. W związku z tym nie trzeba określić, które <xref:System.String.Format%2A> przeciążenia, które chcesz wywołać. Kompilator języka wybiera odpowiednie przeciążenie spośród przeciążenia, które nie mają `provider` parametru, na podstawie tej listy argumentów. Na przykład, jeśli lista argumentów obejmuje pięciu argumentów, kompilator wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody.|  
|Formatuj jeden lub więcej obiektów przy użyciu Konwencji określonej kultury.|Każdy <xref:System.String.Format%2A> przeciążenia, które zaczyna się od `provider` parametr jest poprzedzony <xref:System.String> parametru i co najmniej jeden obiekt parametrów. W związku z tym nie trzeba określić, której <xref:System.String.Format%2A> przeciążenia, które chcesz wywołać. Kompilator języka wybiera odpowiednie przeciążenie spośród przeciążenia, które mają `provider` parametru, na podstawie tej listy argumentów. Na przykład, jeśli lista argumentów obejmuje pięciu argumentów, kompilator wywołuje <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody.|  
|Niestandardowe formatowanie operacji wykonywania, albo za pomocą <xref:System.ICustomFormatter> implementacji lub <xref:System.IFormattable> implementacji.|Jedną z czterech przeciążeń z `provider` parametru. Kompilator wybiera odpowiednie przeciążenie spośród przeciążenia, które mają `provider` parametru, na podstawie tej listy argumentów.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Metoda formatowania w skrócie 

 Każdy przeciążenia <xref:System.String.Format%2A> metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) obejmujący liczony od zera indeksowanymi symbolami zastępczymi o nazwie *formatowanie elementów*, w ciągu formatu złożonego. W czasie wykonywania każdy element formatu jest zastępowany ciągiem reprezentującym odnośnego argumentu na liście parametrów. Jeśli wartość argumentu jest `null`, element formatu jest zastępowany <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład, następujące wywołanie do <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metoda zawiera ciąg formatu, z trzema elementami formatu, {0}, {1}, i {2}i z trzema elementami listy argumentów.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Element formatu  
 Element formatu ma następującą składnię:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Nawiasy kwadratowe oznaczają elementy opcjonalne. Otwierające i zamykające nawiasy klamrowe są wymagane. (Aby dołączyć literał otwierającego lub zamykający nawias klamrowy w ciągu formatu, zobacz [anulowania zapewnianego element nawiasów klamrowych](~/docs/standard/base-types/composite-formatting.md#escaping-braces) sekcji [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) artykułu.)  
  
 Na przykład element formatu, aby sformatować wartość waluty może pojawić się następująco:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Element formatu ma następujące elementy:  
  
 *index*  
 Liczony od zera indeks argumentu, którego reprezentacja ciągu ma zostać uwzględnione w tym miejscu w ciągu. Jeśli ten argument jest `null`, ciągiem pustym zostaną uwzględnione w tym miejscu w ciągu.  
  
 *Wyrównanie*  
 Opcjonalna. Liczba całkowita ze znakiem wskazująca całkowita długość pola, do której zostanie wstawiona argumentu oraz czy jest wyrównany do prawej (dodatnia liczba całkowita) lub wyrównane do lewej (ujemną liczbę całkowitą). Jeżeli pominięto *wyrównanie*, ciąg reprezentujący odpowiadający argument jest wstawiany w polu, bez spacji wiodących i końcowych.  
  
 Jeśli wartość *wyrównanie* jest mniejsza niż długość argumentu, który ma zostać wstawiony *wyrównanie* jest ignorowany i długość ciągu reprezentującego argument jest używany jako szerokość pola.  
  
 *formatString*  
 Opcjonalna. Ciąg, który określa format ciągu wynikowego odnośnego argumentu. Jeżeli pominięto *formatString*, odpowiadający argument użytkownika bez parametrów `ToString` metoda jest wywoływana w celu wygenerowania jego reprezentację ciągu. Jeśli określisz *formatString*, argument odwołuje się element formatu musi implementować <xref:System.IFormattable> interfejsu. Typy, które obsługują ciągi formatu:  
  
-   Wszystkie typy całkowite i zmiennoprzecinkowe. (Zobacz [standardowe ciągi formatujące liczby](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> i <xref:System.DateTimeOffset>. (Zobacz [ciągi formatu standardowego daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowa data i godzina ciągi formatujące](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Wszystkie typy wyliczeniowe. (Zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan> wartości. (Zobacz [standardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) i [niestandardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Zobacz <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> metody.)  
  
 Należy jednak zauważyć, że można wdrożyć dowolny typ niestandardowy <xref:System.IFormattable> lub rozszerzyć istniejący typ <xref:System.IFormattable> implementacji.  
  
 W poniższym przykładzie użyto `alignment` i `formatString` argumenty, aby wygenerować sformatowane wyniki.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Sposób formatowania argumentów  
 Elementy formatu są przetwarzane sekwencyjnie od początku ciągu. Każdy element formatu ma indeks, który odnosi się do obiektu na liście argumentów metody. <xref:System.String.Format%2A> Metoda pobiera argument i jego reprezentację ciągu wywodzi się w następujący sposób:  
  
-   Jeśli argument jest `null`, metoda wstawia <xref:System.String.Empty?displayProperty=nameWithType> do ciągu wynikowego. Nie trzeba zajmować się obsługa <xref:System.NullReferenceException> dla argumentów o wartości null. 
  
-   Jeśli wywołasz <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> przeciążenia i `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementacja zwraca inną niż null <xref:System.ICustomFormatter> implementacji, argument jest przekazywany do jego <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody. Jeśli element formatu zawiera *formatString* argument przekazywana jako pierwszy argument do metody. Jeśli <xref:System.ICustomFormatter> implementacja jest dostępna i tworzy ciągiem niepustym, ciąg jest zwracana jako reprezentację ciągu argumentu; w przeciwnym razie wykonuje następnego kroku.  
  
-   Jeśli argument implementuje <xref:System.IFormattable> interfejsu, jego <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> nosi nazwę wdrożenia.  
  
-   Argument użytkownika bez parametrów `ToString` metody, która zastępuje lub dziedziczy z implementacji klasy podstawowej, jest wywoływana.  
  
 Aby uzyskać przykład, który przechwytuje wywołania <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> metody i pozwala zobaczyć, jakie informacje <xref:System.String.Format%2A> metoda przekazuje do metody formatowania dla każdego elementu formatu w ciągu formatu złożonego, zobacz [przykład: intercept provider i Program formatujący cyfry rzymskie](#Format7_Example).  

 Aby uzyskać więcej informacji, zobacz [kolejność przetwarzania](~/docs/standard/base-types/composite-formatting.md##processing-order) sekcji [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) artykułu.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementy formatu o tym samym indeksie  
 <xref:System.String.Format%2A> Metoda zgłasza wyjątek <xref:System.FormatException> wyjątek, jeśli indeks elementu w indeksie jest większa niż lub równa liczbie argumenty na liście argumentów. Jednak `format` może zawierać więcej elementów formatu, niż argumentów, tak długo, jak wiele elementów formatu mają tego samego indeksu. W wywołaniu <xref:System.String.Format%28System.String%2CSystem.Object%29> metoda w poniższym przykładzie lista argumentów ma jeden argument, ale ciąg formatu zawiera dwa elementy w formacie: jeden Wyświetla wartość dziesiętną liczby oraz innych jego wartości szesnastkowej.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatowanie i kultura  
 Ogólnie rzecz biorąc, obiekty na liście argumentów są konwertowane na ich reprezentacji ciągu przy użyciu konwencji bieżącej kultury, która jest zwracana przez <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Można kontrolować to zachowanie, wywołując jedną z przeciążeń <xref:System.String.Format%2A> zawierającej `provider` parametru. `provider` Parametr <xref:System.IFormatProvider> implementację, która dostarcza niestandardowej i specyficzne dla kultury informacje o formatowaniu, używanej do umiarkowanego formatowanie przetwarzania.  
  
 <xref:System.IFormatProvider> Interfejs ma jeden element członkowski <xref:System.IFormatProvider.GetFormat%2A>, która jest odpowiedzialna za zwrócenie obiektu, który dostarcza informacje o formatowaniu. Platformy .NET ma trzy <xref:System.IFormatProvider> implementacji, które zapewniają formatowanie specyficzne dla kultury:  
  
-   <xref:System.Globalization.CultureInfo>. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwróci wartość specyficzne dla kultury <xref:System.Globalization.NumberFormatInfo> obiektu do formatowania wartości numerycznych oraz specyficzne dla kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu do formatowania wartości daty i godziny.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, która jest użyta specyficzne dla kultury formatowanie wartości daty i godziny. Jego <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> metoda zwraca samą siebie.  
  
-   <xref:System.Globalization.NumberFormatInfo>, która jest użyta specyficzne dla kultury formatowania wartości numerycznych. Jego <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> właściwość zwraca samą siebie. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Niestandardowe formatowanie operacji  
 Można również wywołać z przeciążeń <xref:System.String.Format%2A> metodę, która ma `provider` parametr typu <xref:System.IFormatProvider> wykonywanie niestandardowych operacji formatowania. Na przykład można sformatować liczby całkowitej jako numer identyfikacyjny lub numer telefonu. Aby wykonać niestandardowe formatowanie usługi `provider` argument należy zaimplementować obu <xref:System.IFormatProvider> i <xref:System.ICustomFormatter> interfejsów. Gdy <xref:System.String.Format%2A> metody jest przekazywana <xref:System.ICustomFormatter> implementacji jako `provider` argument, <xref:System.String.Format%2A> wywołania metody jego <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementacji i żąda obiektu typu <xref:System.ICustomFormatter>. Następnie wywołuje zwracanego <xref:System.ICustomFormatter> obiektu <xref:System.ICustomFormatter.Format%2A> przekazany metodę, aby sformatować każdy element formatu ciągu złożonego.  
  
 Aby dowiedzieć się więcej o zapewnieniu niestandardowe rozwiązania formatowania, zobacz [porady: definiowanie i dostawców formatu liczbowego niestandardowego użyj](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) i <xref:System.ICustomFormatter>. Na przykład, który konwertuje wartości całkowitych na sformatowane niestandardowe liczby, zobacz [przykład: niestandardowe formatowanie operacji](#Format6_Example). Na przykład, który konwertuje bajtów bez znaku cyfry rzymskie, zobacz [przykład: intercept provider i program formatujący cyfry rzymskie](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Przykład: Niestandardowe formatowanie operacji  
 W tym przykładzie definiuje dostawcę formatu, które formatuje wartość całkowitą jako liczba konta klienta w postaci x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Przykład: Intercept provider i program formatujący cyfry rzymskie  
 Ten przykład definiuje dostawcę formatu niestandardowego, który implementuje <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsów, aby wykonać dwie czynności:  
  
-   Wyświetla parametry przekazane do jego <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementacji. Pozwala to nam wyświetlić parametry <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metoda przechodzi do niestandardowych implementacji formatowania dla każdego obiektu, który próbuje sformatować. Może to być przydatne podczas debugowania aplikacji.  
  
-   Jeśli obiekt do sformatowania wartości bajtów bez znaku, który jest formatowana przy użyciu ciągu formatu standardowego "R", niestandardowy program formatujący formatuje wartość numeryczną jako cyfry rzymskie.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format pytań i odpowiedzi  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Dlaczego polecisz Interpolacja ciągów za pośrednictwem wywołania `String.Format` metody?

Interpolacja ciągów jest:

- Bardziej elastyczne. Może służyć w dowolnym ciągiem bez konieczności wywołanie metody, która obsługuje formatowanie złożone. W przeciwnym razie trzeba wywoływać <xref:System.String.Format%2A> metody lub innej metody, która obsługuje złożone formatowanie, takie jak <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Bardziej czytelne. Ponieważ wyrażenie do wstawienia do ciągu pojawia się w wyrażenia interpolowanego, a nie na liście argumentów, ciągi interpolowane są znacznie łatwiejsze do kodu i do odczytu. Ze względu na ich czytelność większa ciągów interpolowanych zastępują nie tylko wywołania metody formatowania złożonego, ale ich można również w przypadku operacji łączenia ciągów do tworzenia bardziej zwięzły, skierowany do bardziej zrozumiały kodu. 

Porównanie poniższe dwa przykłady kodu ilustruje wysokiej jakości ciągów interpolowanych przez łączenie ciągów i wywołania metody formatowania złożonego. Korzystanie z wielu operacji łączenia ciągów w poniższym przykładzie generuje kod, pełne i twardych do odczytu.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Z kolei użycia ciągów interpolowanych w poniższym przykładzie generuje znacznie bardziej zrozumiały, bardziej zwięzły widok kodu niż instrukcji konkatenacji ciągów i wywołania <xref:System.String.Format%2A> metody w poprzednim przykładzie.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Gdzie mogę znaleźć listę ciągów wstępnie zdefiniowany format, które mogą być używane z elementami formatu  
  
-   Dla wszystkich typów całkowitych i zmiennoprzecinkowych, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać wartości wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać <xref:System.TimeSpan> wartości, zobacz [standardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) i [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Aby uzyskać <xref:System.Guid> wartości, zobacz sekcję Uwagi <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> odwołania do stron.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Jak kontrolować wyrównanie ciągi wynikowe, które zastępują elementy formatu?  
 Ogólna składnia element formatu jest następująca:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 gdzie *wyrównanie* jest liczbą całkowitą ze znakiem, który definiuje szerokość pola. Jeśli ta wartość jest ujemna, tekst w polu jest wyrównany do lewej. Jeśli jest dodatnia, tekst jest wyrównany do prawej.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Jak kontrolować liczbę cyfr po separatorze dziesiętnym?  
 Wszystkie [standardowe ciągi formatujące liczby](~/docs/standard/base-types/standard-numeric-format-strings.md) z wyjątkiem "D" (która jest używana przy użyciu tylko liczby całkowite), "G", "R" i "X" Zezwalaj na Specyfikator dokładności, który definiuje liczbę cyfr dziesiętnych w ciągu wynikowym. W poniższym przykładzie użyto ciągów standardowego formatu liczb, aby kontrolować liczbę miejsc dziesiętnych w ciągu wynikowym.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Jeśli używasz [ciąg niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md), użyć specyfikatora formatu "0", aby kontrolować liczbę cyfr dziesiętnych w ciągu wynikowym, co ilustruje poniższy przykład.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Jak kontrolować liczbę cyfr liczby całkowitej?  
 Domyślnie operacji formatowania wyświetlane tylko cyfry całkowite od zera. W przypadku formatowania liczb całkowitych, można użyć Specyfikator dokładności, "D" i "X" ciągi w standardowym formacie kontrolować liczbę cyfr.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Można dodać tworzy ciąg wyniku zawierający określoną liczbę cyfr liczby całkowitej, za pomocą "0", liczbą całkowitą lub zmiennoprzecinkową zerami wiodącymi [specyfikatora niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md), jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Ile elementów może zawierać na liście format?  
 Nie ma żadnego limitu praktyczne. Drugi parametr <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody jest oznaczane <xref:System.ParamArrayAttribute> atrybut, który umożliwia dołączanie rozdzielanej listy lub tablicy obiektów jako format listy.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Jak dołączyć nawiasów klamrowych literału ("{" i "}") w ciągu wynikowym?  
 Na przykład, jak można zapobiec następujące wywołanie metody z zgłaszanie <xref:System.FormatException> wyjątek?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Otwierający i zamykający nawias klamrowy zawsze jest interpretowany jako początek lub koniec elementu formatu. Interpretowany dosłownie, muszą być wyjściowym. Znak ucieczki nawiasu klamrowego, dodając inny nawias klamrowy ("{{" i "}}" zamiast "{" i "}"), jak w poniższym wywołaniu metody:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Jednak nawet o zmienionym znaczeniu nawiasy klamrowe są łatwo misinterpreted. Firma Microsoft zaleca zawierają nawiasy klamrowe w formacie listy, a następnie użyć elementów formatu wstawić je w ciągu wynikowym, co ilustruje poniższy przykład.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Dlaczego moja wywołanie metody String.Format zgłosić wyjątek FormatException?  
 Najczęstszą przyczyną tego wyjątku to, że indeks elementu formatu nie odpowiadają obiektowi na liście formatu. Zwykle oznacza to, że zostały misnumbered indeksy elementów formatu lub pamiętasz uwzględnić obiekt na liście formatu. Próby dołączenia o niezmienionym znaczeniu lewego lub prawego nawiasu klamrowego znak również zgłasza <xref:System.FormatException>. Czasami wyjątek jest wynikiem błąd pisowni; na przykład, Typowa błędu jest błędnie "[" (lewy nawias kwadratowy) zamiast "{" (lewy nawias klamrowy).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Jeśli metoda Format(System.IFormatProvider,System.String,System.Object[]) obsługuje tablice parametrów, dlaczego mój kod wyjątku podczas korzystania z tablicą?  
 Na przykład, poniższy kod zgłasza <xref:System.FormatException> wyjątek:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Jest to problem z przeciążeń z późnym. Ponieważ kompilator nie może przekonwertować tablicę liczb całkowitych na tablicę obiektów, traktuje tablicy liczb całkowitych jako pojedynczy argument, dzięki czemu wywoływanych przez nią <xref:System.String.Format%28System.String%2CSystem.Object%29> metody. Wyjątek jest zgłaszany, ponieważ istnieją cztery elementy formatu, ale tylko pojedynczy element na liście formatu.  
  
 Ponieważ Visual Basic ani C# można przekonwertować tablicę liczb całkowitych na tablicę obiektów, konieczne jest przeprowadzenie konwersji samodzielnie przed wywołaniem <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody. W poniższym przykładzie przedstawiono jedna implementacja.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Liczne przykłady, które wywołują <xref:System.String.Format%2A> rozmieszczonymi za pośrednictwem metody [uwagi](#remarks) dalszej części tego artykułu.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Możesz również pobrać kompletny zestaw `String.Format` przykłady, które są zawarte [projektu .NET Core 2.0 dla języka C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) i [projektu .NET Core 2.0 dla języka Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), z [dotnet / repozytorium GitHub Samples](https://github.com/dotnet/samples).

Poniżej przedstawiono przykłady zawarte w artykule:

### <a name="create-a-format-string"></a>Utwórz ciąg formatu

[Wstawianie ciąg](#inserting-a-string)  
[Element formatu](#the-format-item)  
[Elementy formatu o tym samym indeksie](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Kontrolka sformatowane dane wyjściowe

[Kontrolowanie formatowania](#controlling-formatting)  
[Kontrolowanie odstępy](#controlling-spacing)  
[Kontrolowanie wyrównania](#controlling-alignment)  
[Kontrolowanie liczbę cyfr liczby całkowitej](#how-do-i-control-the-number-of-integral-digits)  
[Kontrolowanie liczbę cyfr po separatorze dziesiętnym](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[W tym nawiasów klamrowych literału ciągu wynikowego](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Wprowadzić ciągi formatu wrażliwość na ustawienia kulturowe

[Wrażliwość na ustawienia kulturowe, formatowanie](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Dostosowywanie operacji formatowania

[Niestandardowe formatowanie operacji](#example-a-custom-formatting-operation)  
[Intercept provider i program formatujący cyfry rzymskie](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Zastępuje co najmniej jeden element formatu w ciągu reprezentację określonego obiektu.</summary>
        <returns>Kopię <paramref name="format" /> format wszystkie elementy są zastępowane przez ciąg reprezentujący <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości wyrażenia na jego reprezentację ciągu i osadza tę reprezentację w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Przykład: Formatowanie jednego argumentu  
 
 W poniższym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%29> metodę, aby osadzić wieku osoby w środku ciągu.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Element formatu w <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie wynosi zero.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia element formatu ciągu określonego ciągu reprezentującego odpowiedniego obiektu w określonej tablicy.</summary>
        <returns>Kopię <paramref name="format" /> w którym elementów formatu zostały zastąpione reprezentację ciągu z odpowiednimi obiektami w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości co najmniej cztery wyrażeń do ich reprezentacji ciągu i osadzić te reprezentacje w ciągu. Ponieważ `args` parametr jest oznaczony przy użyciu <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atrybut, można przekazać obiekty do metody jako oddzielne argumenty lub <xref:System.Object> tablicy. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Przykład: Formatowanie więcej niż trzech argumentów  
 
 Ten przykład tworzy ciąg, który zawiera dane dotyczące temperatury wysoki i niski w określonym dniu. Ciąg formatu złożonego zawiera pięć elementów formatu w przykładzie C# i sześć w przykładzie w języku Visual Basic. Zdefiniuj dwóch elementów formatu szerokość ich odpowiednich wartości ciągu reprezentującego i pierwszy element formatu zawiera również standardowy daty i ciąg formatu godziny.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Można również przekazać obiektów do sformatowania jako tablicę, a nie listy argumentów.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest większa niż zero, lub większa niż długość <paramref name="args" /> tablicy.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Zamienia ciąg reprezentujący odpowiadający mu obiekt elementu formatu lub elementów określonego ciągu. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> w którym element formatu lub elementy zostały zastąpione przez ciąg reprezentujący <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości wyrażenia na jego reprezentację ciągu i osadza tę reprezentację w ciągu. Wykonywanie konwersji, metoda używa formatowania kultury lub niestandardowego elementu formatującego. Metoda ta konwertuje `arg0` na jego reprezentację ciągu, przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu, wywołując jego **ToString ( String, IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie wynosi zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia pozycje formatu w ciągu ciągów reprezentujących odpowiednimi obiektami w określonej tablicy. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> w którym elementów formatu zostały zastąpione reprezentację ciągu z odpowiednimi obiektami w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wyrażenia co najmniej cztery do ich reprezentacji ciągu i osadzić te reprezentacje w ciągu. Wykonywanie konwersji, metoda używa formatowania kultury lub niestandardowego elementu formatującego. Metoda ta konwertuje każdy <xref:System.Object> argument na jego reprezentację ciągu, przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu, przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Przykład: Wrażliwe na ustawienia kulturowe formatowania  
 W tym przykładzie użyto <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodę, aby wyświetlić reprezentację niektórych wartości daty i godziny oraz wartości liczbowych przy użyciu kilku różnych kultur.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest większa niż zero, lub większa niż długość <paramref name="args" /> tablicy.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia pozycje formatu w ciągu reprezentację dwóch określonych obiektów.</summary>
        <returns>Kopię <paramref name="format" /> w formacie, które elementy są zastępowane przez ciąg reprezentujący <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) do konwertowania wartości dwóch wyrażeń do ich reprezentacji ciągu i osadzić te reprezentacje w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Przykład: Formatowanie dwóch argumentów  
 
 W tym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metodę w celu wyświetlenia czasu i temperatury — dane przechowywane w ogólnej metodzie <xref:System.Collections.Generic.Dictionary%602> obiektu. Należy pamiętać, że ciąg formatu, który ma trzy elementy formatu, mimo że istnieją tylko dwa obiektów do sformatowania. Jest to spowodowane pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy w formacie: pierwszy wyświetla element formatu czasu, a drugi Wyświetla datę.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest zero lub jeden.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia pozycje formatu w ciągu reprezentację dwóch określonych obiektów. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> w formacie, które elementy są zastępowane przez ciąg reprezentujący <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) przekonwertować ich ciągów reprezentujących dwa wyrażenia i osadzić te reprezentacje w ciągu. Wykonywanie konwersji, metoda używa formatowania kultury lub niestandardowego elementu formatującego. Metoda ta konwertuje każdy <xref:System.Object> argument na jego reprezentację ciągu, przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu, przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest zero lub jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia pozycje formatu w ciągu reprezentację ciągu trzech określonych obiektów.</summary>
        <returns>Kopię <paramref name="format" /> w którym elementów formatu zostały zastąpione ciągów reprezentujących <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości z trzech wyrażeń do ich reprezentacji ciągu i osadzić te reprezentacje w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Przykład: Formatowanie trzech argumentów  
 
 W tym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodę, aby utworzyć ciąg, który ilustruje wynik atrybut typu wartość logiczna `And` operację, używając dwóch wartości całkowitych. Należy pamiętać, ciąg formatu zawiera sześć elementów formatu, że metoda ma tylko trzy elementy w liście parametrów, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od zera, lub większa niż dwa.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">A [ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia pozycje formatu w ciągu reprezentację ciągu trzech określonych obiektów. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> w którym elementów formatu zostały zastąpione ciągów reprezentujących <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) przekonwertować trzech wyrażeń do ich reprezentacji ciągu i osadzić te reprezentacje w ciągu. Wykonywanie konwersji, metoda używa formatowania kultury lub niestandardowego elementu formatującego. Metoda ta konwertuje każdy <xref:System.Object> argument na jego reprezentację ciągu, przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu, przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od zera, lub większa niż dwa.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który można wykonać iterację pojedynczych znaków w ciągu.</summary>
        <returns>Obiekt modułu wyliczającego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Zamiast wywoływania <xref:System.String.GetEnumerator%2A> metodę, która pobierze <xref:System.CharEnumerator> obiektu, że zostaną następnie użyte do wyliczenia ciągu, należy w zamian użyć konstrukcji iteracji danego języka (w języku C#, w języku C + +/ CLR, a w języku Visual Basic). [Instrukcja foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) w języku C# [dla każdego](/cpp/dotnet/for-each-in) w języku C + +/ CLR, i [dla każdego](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) w języku Visual Basic).
  
 Ta metoda umożliwia iteracyjne pojedynczych znaków w ciągu. Na przykład Visual Basic `For Each` i C# `foreach` instrukcji wywołać tę metodę, aby zwrócić <xref:System.CharEnumerator> obiekt, który można zapewnić dostęp tylko do odczytu do znaków w tym wystąpieniu ciągu.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację znaków w kilku ciągach i wyświetla informacje o ich pojedynczych znaków. Używa konstrukcji języka iteracji, a nie po wywołaniu <xref:System.String.GetEnumerator%2A> metody.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego ciągu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie <xref:System.String.GetHashCode%2A> jest zależna od implementacji, które mogą ulec zmianie z jednej wersji środowiska uruchomieniowego języka wspólnego do innego. Powód, dlaczego tak się zdarzyć się poprawić wydajność <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Jeśli dwa obiekty parametry są równe, <xref:System.String.GetHashCode%2A> metoda zwraca identycznych wartości. Jednakże nie istnieje wartość Kod skrótu unikatowy dla każdej wartości unikatowego ciągu. Różne ciągi może zwrócić tę samą wartość skrótu.  
>   
>  Sam kod skrótu nie musi być stała. Kody skrótów dla identyczne ciągi mogą się różnić w różnych implementacji .NET między wersjami .NET oraz na platformach .NET (na przykład 32-bitowych i 64-bitowych) dla jednej wersji programu .NET. W niektórych przypadkach może nawet różnią się one domeny aplikacji. Oznacza to, że dwóch kolejnych uruchomień ten sam program może zwracać różne wartości skrótów.  
>   
>  Jako wynik wyznaczania wartości skrótu, który nigdy nie powinny być używane kody spoza domeny aplikacji, w którym zostały utworzone, nigdy nie powinny być używane jako pola klucza w kolekcji, a nigdy nie powinny zostać utrwalone.  
>   
>  Ponadto nie należy używać skrótu zamiast wartości zwracane przez kryptograficznych funkcji skrótu, jeśli potrzebujesz silną kryptograficznie wyznaczania wartości skrótu. Klasy pochodzącej od użytku skróty kryptograficzne <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> klasy.  
>   
>  Aby uzyskać więcej informacji na temat kodów wartości skrótu, zobacz <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 W aplikacjach komputerowych, można użyć [ \<userandomizedstringhashalgorithm — > element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) generować kody unikatowy skrót na poszczególnych domen aplikacji. Może to zmniejszyć liczbę konfliktów i zwiększa ogólną wydajność wstawienia i wyszukiwania, które tabele skrótów. Poniższy przykład pokazuje, jak używać [ \<userandomizedstringhashalgorithm — > element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definiuje, aby wygenerować kody unikatowy skrót na poszczególnych domen aplikacji. Może to zmniejszyć liczbę konfliktów i zwiększa ogólną wydajność wstawienia i wyszukiwania, które tabele skrótów. Poniższy przykład przedstawia sposób użycia. Definiuje on `DisplayString` klasę zawierającą prywatną stałą typu ciąg, `s`, którego wartość jest "Jest ciąg". Obejmuje również `ShowStringHashCode` metoda, która wyświetla wartości ciągu i jego kod skrótu wraz z nazwą domeny aplikacji, w którym metoda jest wykonywaay.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Po uruchomieniu przykładu bez podawania pliku konfiguracji, wyświetla dane wyjściowe podobne do następujących. Należy zauważyć, że kody mieszania dla ciągu są identyczne w dwóch domenach aplikacji.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Jeśli dodasz następujący plik konfiguracji do katalogu w tym przykładzie, a następnie uruchomisz przykład, kody skrótów dla tego samego ciągu będą różne według domeny aplikacji.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Gdy plik konfiguracji jest obecny, przykładzie są wyświetlane następujące dane wyjściowe:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Kody mieszania są używane do wstawiania i pobieranie obiektów kluczem z tabel skrótów, efektywnie. Jednak kodów wartości skrótu nie jednoznacznie identyfikują ciągów. Identyczne ciągi mają równe skrótu, ale środowisko uruchomieniowe języka wspólnego może również przypisać tę samą wartość skrótu do różnych parametrów. Ponadto kody skrótów mogą się różnić, przez wersję platformy .NET, platform, w ramach jednej wersji i domeny aplikacji. W związku z tym nie należy serializacji lub zachować wartości Kod skrótu ani nie należy używać ich jako klucze w tabeli wyznaczania wartości skrótu lub słownika.  
  
 Aby uzyskać dodatkowe informacje o używaniu kody skrótów i `GetHashCode` metody, zobacz <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.GetHashCode%2A> metody przy użyciu różnych danych wejściowych ciągów.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Wartość zwrócona przez obiekt <see cref="M:System.String.GetHashCode" /> jest zależna od platformy. Różni się w 32-bitowych i 64-bitowych wersjach programu .NET Framework. On również mogą się różnić między wersjami programu .NET Framework i .NET Core.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;Userandomizedstringhashalgorithm —&gt; — Element</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla klasy <see cref="T:System.String" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla <xref:System.TypeCode> Stała wyliczeniowa dla <xref:System.String> typu.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode lub ciąg znaków w ciągu tego wystąpienia. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode w tym ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli znak ten zostanie znaleziony, lub wartość -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak możesz wyszukiwać <xref:System.String> dla znaków za pomocą <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od pierwszego pozycji znaku tego wystąpienia i jest kontynuowane do ostatniej pozycji znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.IndexOf%28System.String%29> metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%29> metoda jest używana do znajdowania trzy podciągów (nietrwały (U + 00AD), nietrwały, a następnie "n" i nietrwały, a następnie "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ nietrwały jest znakiem do pominięcia, wynik jest taki sam, jakby łącznika nietrwałego nie znalazły się w `value`. Aby wyszukać tylko łącznika nietrwałego, metoda zwraca wartość 0 (zero), aby wskazać, że Znaleziono dopasowanie na początku ciągu.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład wyszukiwanie "n" u"". Ponieważ indeksy ciąg zaczyna się na zero, a nie z nich <xref:System.String.IndexOf%28System.String%29> metody oznacza, że "n" na pozycji 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 W poniższym przykładzie użyto <xref:System.String.IndexOf%2A> metodę, aby ustalić położenie początkowe zwierząt nazwy w zdaniu. Następnie używa tej pozycji do wstawienia przymiotnikiem, opisujący zwierzę w zdaniu.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby znaleźć pierwszego indeksu podciągu w wystąpieniu ciągu za pomocą reguł porównywania bieżącej kultury, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego `comparisonType` parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode w tym ciągu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku ciągu, jeśli znak ten zostanie znaleziony, lub -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od 0. `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 Wyszukiwanie zakresu od `startIndex` do końca ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Znak do wyszukania.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego occurrrence z specxified znak Unicode w tym ciągu. Parametr określa typ wyszukiwania do użycia dla określonego znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli znak ten zostanie znaleziony, lub wartość -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Indeks numerowania rozpoczyna się od zera.  
  
`comparisonType` Parametr jest <xref:System.StringComparison> składowej wyliczenia, która określa, czy wyszukiwanie `value` argument używa bieżącej lub niezmiennej kultury, jest rozróżniana wielkość liter lub bez uwzględniania wielkości liter lub korzysta z programu word lub reguł porównania porządkowego.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku bieżącego wystąpienia, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana jest wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od 0. `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od `startIndex` znak położenie tego wystąpienia i jest powtarzany do momentu ostatniej pozycji znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metoda jest używana, aby znaleźć położenie nietrwały (U + 00AD), a po nim "m" w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Poniższy przykład wyszukuje wszystkie wystąpienia określonego ciągu w ciągu docelowym.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość ciągu.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby znaleźć pierwszego indeksu podciągu, który występuje po pozycji znaku określonej za pomocą reguł porównywania bieżącej kultury, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego `comparisonType` parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiektu. Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Pozycja indeksu parametru <paramref name="value" /> parametru, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana to 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano trzech przeciążeń <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="comparisonType" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metoda jest używana do znajdowania trzy podciągów (nietrwały (U + 00AD), nietrwały, a następnie "n" i nietrwały, a następnie "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ nietrwały jest znakiem do pominięcia, wyszukiwanie zależne od kultury zwraca tę samą wartość, która zwróci, jeśli łącznika nietrwałego nie zostały uwzględnione w wyszukiwanym ciągu. Pomyślnie wyszukiwanie porządkowe, jednak znajduje łącznika nietrwałego w jeden ciąg i zgłasza, że jest nieobecny z drugiego ciągu.  
  
[! code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! kodu vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego znaku, w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i sprawdza, czy określona liczba pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku ciągu, jeśli znak ten zostanie znaleziony, lub -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Indeks numerowania rozpoczyna się od 0 (zero). `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" /> jest większa niż długość ciągu.  
  
—lub— 
 <paramref name="count" /> jest większa niż długość ciągu minus <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i sprawdza, czy określona liczba pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku bieżącego wystąpienia, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana jest wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od 0 (zero). `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda jest używana do znajdowania położenie nietrwały (U + 00AD) następuje od innych za pomocą szóstego pozycje znaku w dwa ciągi "m". Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie indeksu wszystkie wystąpienia ciągu "he" w ramach podciąg z innego ciągu. Należy pamiętać, że liczba znaków, które mają być wyszukiwane należy obliczyć ponownie dla każdej iteracji wyszukiwania.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" /> jest większa niż długość ciągu.  
  
—lub— 
 <paramref name="count" /> jest większa niż długość ciągu minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby użyć reguł porównanie bieżącej kultury do wykonania tej operacji, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego `comparisonType` parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiektu. Parametry określają pozycja początkowa wyszukiwania w bieżącej ciągu i typu wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> parametr od początku bieżącego wystąpienia, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana jest wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od 0. `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
   
  
## Examples  
 Przeciążenia exampledemonstrates następujące trzy <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość ciągu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="comparisonType" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metoda jest używana, aby znaleźć położenie nietrwały (U + 00AD), a po nim "m" począwszy od trzeciego pozycja znaku w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! kodu vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiektu. Parametry określają pozycja początkowa wyszukiwania w bieżącej ciąg, liczba znaków w bieżącym ciąg do wyszukania i typu wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> parametr od początku bieżącego wystąpienia, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana jest wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od 0 (zero). `startIndex` Parametr może wynosić od 0 do długości wystąpienia ciągu.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
   
  
## Examples  
 Przeciążenia exampledemonstrates następujące trzy <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" /> jest większa od długości tego wystąpienia.  
  
—lub— 
 <paramref name="count" /> jest większa niż długość ciągu minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="comparisonType" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania położenie nietrwały (U + 00AD) następuje od innych za pomocą szóstego pozycje znaku w dwa ciągi "m". Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Gdy wykonuje porównanie porządkowe, jednak znajduje podciąg tylko w pierwszym ciągu. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim "m", metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie zależne od kultury. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! kodu vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Wyszukaj `anyOf` jest uwzględniana wielkość liter. Jeśli `anyOf` jest pusta tablica, metoda napotka dopasowanie na początku ciągu (czyli na indeks zero).  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie pierwszy samogłosek w ciągu.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametru należą do zakresu od 0 do mniejszej o jeden od długości wystąpienia ciągu.  
  
 Wyszukiwanie zakresu od `startIndex` do końca ciągu.  
  
 Wyszukaj `anyOf` jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wystąpienia dowolnego znaku w ciągu "to" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ma wartość ujemną.  
  
—lub— 
 <paramref name="startIndex" /> jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i sprawdza, czy określona liczba pozycji znaku.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametru należą do zakresu od 0 do mniejszej o jeden od długości wystąpienia ciągu.  
  
 Wyszukaj `anyOf` jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie indeks wystąpienia dowolnego znaku ciągu "pomoc" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="count" /> + <paramref name="startIndex" /> jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera indeks wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Zwraca nowy ciąg, w którym określony ciąg jest wstawiany w położeniu określonego indeksu, w tym wystąpieniu.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale z <paramref name="value" /> wstawione w miejscu <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `startIndex` jest równa długości tego wystąpienia `value` jest dołączany na końcu tego wystąpienia.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w którym `value` są wstawiane do bieżącego wystąpienia.  
  
 Na przykład, wartość zwracana przez `"abc".Insert(2, "XYZ")` jest "abXYZc".  
  
   
  
## Examples  
 Poniższy przykład Wstawia znak spacji w czwartej pozycji znaku (znak pod indeksem 3) w ciągu.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Następująca aplikacja konsoli monit o wprowadzenie co najmniej jeden określeniem do opisania dwóch zwierząt. Następnie wywołuje <xref:System.String.Insert%2A> metodę, aby wstawić tekst wprowadzony przez użytkownika w ciągu.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest ujemna ani większa od długości tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli serii.</param>
        <summary>Pobiera odwołanie do systemu na określonym <see cref="T:System.String" />.</summary>
        <returns>Odwołanie do systemu do <paramref name="str" />, jeśli jest on interned; w przeciwnym razie nowe odwołanie do ciągu z wartością <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego oszczędza ciągu magazynu dzięki przechowywaniu tabelę o nazwie puli serii, który zawiera jedno odwołanie do każdego unikatowy ciąg literału zadeklarowane lub utworzony w programie. W związku z tym wystąpienie literału ciągu przy użyciu określonej wartości istnieje tylko jeden raz w systemie.  
  
 Na przykład Jeśli przypiszesz ten sam ciąg literału do kilku zmiennych środowiska uruchomieniowego pobiera samo odwołanie do literału z puli serii i przypisuje go do każdej zmiennej.  
  
 <xref:System.String.Intern%2A> Metoda używa puli serii do wyszukania ciągu równa wartości `str`. Jeśli istnieje taki ciąg, zwracany jest odwołanie, puli serii. Jeśli ciąg nie istnieje, odwołanie do `str` zostanie dodany do puli serii, zwracana jest tego odwołania.  
  
 W poniższym przykładzie s1 ciąg, który ma wartość "Test", jest już interned, ponieważ jest literałem, w programie. <xref:System.Text.StringBuilder?displayProperty=nameWithType> Generuje nowy obiekt ciągu, który ma taką samą wartość jak s1. Odwołanie do tego ciągu jest przypisany do warstwy s2. <xref:System.String.Intern%2A> Metoda wyszukuje ciąg, który ma taką samą wartość jak s2. Ponieważ istnieje taki ciąg, metoda zwraca tego samego odwołania, która jest przypisana do s1. Czy odwołanie jest przypisywany do s3. Odwołania do warstwy s1 i s2 porównania nierówne, ponieważ odnoszą się do różnych obiektów; odwołania w wersjach s1 i s3 sobie równe, ponieważ odnoszą się do tego samego ciągu.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Porównaj tę metodę w celu <xref:System.String.IsInterned%2A> metody.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> metoda wraca do swojego zachowania w .NET Framework 1.0 i 1.1 w odniesieniu do wewnętrzne przygotowanie pusty ciąg. W poniższym przykładzie zmienna `str1` przypisano odwołanie do <xref:System.String.Empty>, a zmienna `str2` przypisano odwołanie do <xref:System.String.Empty> , jest zwracany przez wywołanie metody <xref:System.String.Intern%2A> metody konwersji <xref:System.Text.StringBuilder>obiektu, którego wartość jest <xref:System.String.Empty> na ciąg. Odwołania do zawartych w `str1` i `str2` są porównywane pod kątem równości.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 W [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], i [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` i `str2` są takie same. W [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] i [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` i `str2` nie są takie same.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli chcesz ograniczyć łączną ilość pamięci przydziela aplikacji, należy pamiętać, że wewnętrzne przygotowanie ciągu ma dwa niepożądane skutki uboczne. Po pierwsze, pamięć przydzielona dla interned <xref:System.String> obiektów prawdopodobnie nie mogą być wprowadzane do momentu zakończenia działania środowisko uruchomieniowe języka wspólnego (CLR). Przyczyną jest fakt, że odwołania CLR do interned <xref:System.String> obiekt przetrwają aplikacji lub nawet domenę aplikacji, kończy się. Po drugie aby intern ciągu, należy najpierw utworzyć ciąg. Pamięć użyta przez <xref:System.String> obiektu musi nadal można przydzielić, nawet jeśli pamięć będzie ostatecznie bezużyteczne.  
  
 .NET Framework w wersji 2.0 wprowadzono <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> element członkowski wyliczenia. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Na tym etapie zestawu jako niewymagające wewnętrzne przygotowanie literał ciągu. Można zastosować <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> do zestawu przy użyciu <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atrybutu. Ponadto, jeśli używasz [Ngen.exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) do kompilowania zestawu wyprzedzeniem o czasie wykonywania, ciągi nie są interned we wszystkich modułach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto trzy ciągi, które są takie same wartości, aby określić, czy ciąg nowo utworzony i ciągiem interned są takie same.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli serii.</param>
        <summary>Pobiera odwołanie do określonego <see cref="T:System.String" />.</summary>
        <returns>Odwołanie do <paramref name="str" /> Jeśli wspólnego języka środowiska uruchomieniowego serii puli; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego automatycznie przechowuje tabelę o nazwie puli serii, która zawiera jedno wystąpienie każdego stałej unikatowy ciąg literału zadeklarowanych w program, a także wszelkie unikatowego wystąpienia <xref:System.String> Dodaj programowo przez wywołanie metody <xref:System.String.Intern%2A> metody.  
  
 Pula serii oszczędza Magazyn ciągów. Jeśli przypiszesz stałym ciągiem literału o kilku zmiennych, każda zmienna jest ustawiona na odwoływać się do tej samej stałej w puli serii zamiast odwoływać się do kilku różnych wystąpieniach <xref:System.String> , ma takie same wartości.  
  
 Metoda ta wyszukuje `str` w puli serii. Jeśli `str` został już interned, odwołanie do tego wystąpienia jest zwracana; w przeciwnym razie `null` jest zwracana.  
  
 Porównaj tę metodę w celu <xref:System.String.Intern%2A> metody.  
  
 Ta metoda nie zwraca wartość logiczną. Jeśli metoda jest wywołana, ponieważ ma wartość logiczną, wskazującą, czy określony ciąg jest interned, służy poniższy kod.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Począwszy od programu .NET Framework w wersji 2.0, można zastąpić użycie puli serii gdy używasz [Ngen.exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) instalować zestawów w pamięci podręcznej obrazów natywnych na komputerze lokalnym. Aby uzyskać więcej informacji, zobacz zagadnienia dotyczące wydajności w sekcję Spostrzeżenia, aby <xref:System.String.Intern%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, czy ciągi tekstowe są interned automatycznie przez kompilator.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest w szczególności normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten ciąg w postaci normalizacji Unicode C.</summary>
        <returns>
          <see langword="true" /> Jeśli ten ciąg ma postać normalizacji C; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Aby uzyskać opis obsługiwanych form normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg jest pomyślnie znormalizowane do różnych normalizacje formularzy.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego znaku nieznormalizowanego w ciągu. W związku z tym, jeśli ciąg zawiera nieznormalizowane znaki nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> mimo że <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formuła normalizacji Unicode.</param>
        <summary>Wskazuje, czy ten ciąg jest w określonej normalizacji Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli ten ciąg jest w określonej przez formularz normalizacji <paramref name="normalizationForm" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Aby uzyskać opis obsługiwanych form normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IsNormalized%2A> i <xref:System.String.Normalize%2A> metody.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego znaku nieznormalizowanego w ciągu. W związku z tym, jeśli ciąg zawiera nieznormalizowane znaki nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> mimo że <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do testowania.</param>
        <summary>Wskazuje, czy określony ciąg jest <see langword="null" /> ani być pustym ciągiem ("").</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr jest <see langword="null" /> ani być pustym ciągiem (""); w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> jest to wygodna metoda, który umożliwia jednoczesne testowanie czy <xref:System.String> jest `null` lub jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>. Odpowiada to następującemu kodowi:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Możesz użyć <xref:System.String.IsNullOrWhiteSpace%2A> metodę, aby sprawdzić, czy ciąg `null`, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>, lub zawiera tylko białe znaki.  
  
## <a name="what-is-a-null-string"></a>Co to jest ciąg pusty?  
 Ciąg jest `null` Jeśli go nie przypisano wartości (w języku C++ i Visual Basic) lub jawnie przypisano wartości `null`. Mimo że [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) funkcji można bezpiecznie obsługiwać ciąg pusty, co ilustruje poniższy przykład próby wywołania jednej, jeśli jego członków zgłasza <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Co to jest ciągiem pustym?  
 Ciąg jest pusty, jeśli nie zostanie jawnie przypisana ciąg pusty ("") lub <xref:System.String.Empty?displayProperty=nameWithType>. Jest ciągiem pustym <xref:System.String.Length%2A> 0.  Poniższy przykład tworzy pusty ciąg i wyświetla jego wartość i jego długość.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład sprawdza trzy ciągi i określa, czy każdy ciąg ma wartość, jest pustym ciągiem lub jest `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do testowania.</param>
        <summary>Wskazuje, czy określony ciąg jest <see langword="null" />, pusta lub zawiera tylko białe znaki.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr jest <see langword="null" /> lub <see cref="F:System.String.Empty" />, lub jeśli <paramref name="value" /> składa się wyłącznie ze znaków odstępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> jest to wygodna metoda, która jest podobny do poniższego kodu, z tą różnicą, że zapewnia ona doskonałą wydajność:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Znaki odstępu są zdefiniowane w standardzie Unicode. <xref:System.String.IsNullOrWhiteSpace%2A> Metoda interpretuje dowolny znak, który zwraca wartość `true` kiedy jest przekazywana do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodę jako znak odstępu.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę ciągów, a następnie przekazuje każdego elementu tablicy, aby <xref:System.String.IsNullOrWhiteSpace%2A> metody.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy elementy określonej tablicy lub elementów członkowskich kolekcji przy użyciu określonego separatora od każdego elementu lub elementu członkowskiego.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator.<paramref name="separator" /> znajduje się w zwracanym ciągu tylko wtedy, gdy <paramref name="values" /> ma więcej niż jeden element.</param>
        <param name="values">Kolekcja, która zawiera ciągi do łączenia.</param>
        <summary>Łączy elementy członkowskie skonstruowany <see cref="T:System.Collections.Generic.IEnumerable`1" /> Kolekcja typu <see cref="T:System.String" />, przy użyciu określonego separatora od każdego elementu członkowskiego.</summary>
        <returns>Ciąg, który składa się z elementów członkowskich <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> nie ma elementów członkowskich, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null`, ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>) jest używana zamiast tego. Jeśli dowolny element członkowski `values` jest `null`, zamiast tego jest używany pusty ciąg.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> jest to wygodna metoda, która umożliwia łączenia każdego elementu w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów do tablicy ciągów. Jest to szczególnie przydatne w przypadku wyrażenia zapytań Language-Integrated Query (LINQ). Poniższy przykład przekazuje `List(Of String)` obiekt, który zawiera małe i wielkie litery alfabetu do wyrażenia lambda, która wybiera litery, który jest równy lub większy od określonej litery (czyli, w tym przykładzie "M"). `IEnumerable(Of String)` Kolekcji zwróconej przez <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> metoda jest przekazywana do <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę, aby wyświetlić wynik jako pojedynczy ciąg.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, które są następnie przekazywane do <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" /> znajduje się w zwracanym ciągu tylko wtedy, gdy <paramref name="values" /> ma więcej niż jeden element.</param>
        <param name="values">Tablica, która zawiera elementy do łączenia.</param>
        <summary>Łączy elementy tablicy obiektu, przy użyciu określonego separatora między elementami.</summary>
        <returns>Ciąg, który składa się z elementów <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> jest pusta tablica, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null` lub w przypadku jakiegokolwiek elementu w `values` innych niż pierwszy element jest `null`, ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>) jest używana zamiast tego. Zobacz uwagi dotyczące obiektów wywołujących sekcję, jeśli pierwszy element `values` jest `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> to wygodna metoda, która umożliwia łączenia każdego elementu w tablicy obiektu bez jawnej konwersji jej elementów na ciągi. Ciąg reprezentujący każdego z obiektów w tablicy jest tworzony przez wywołanie metody tego obiektu `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do tablicy liczby całkowitej, które są następnie przekazywane do <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> metody.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jeśli pierwszy element <paramref name="values" /> jest <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> metoda łącz elementy w <paramref name="values" /> , ale zamiast tego zwraca <see cref="F:System.String.Empty" />. Dostępnych jest szereg obejścia tego problemu. To najprostsza można przypisać wartość <see cref="F:System.String.Empty" /> do pierwszego elementu tablicy, w poniższym przykładzie pokazano.  
  
[! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! kodu vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" /> znajduje się w zwracanym ciągu tylko wtedy, gdy <paramref name="value" /> ma więcej niż jeden element.</param>
        <param name="value">Tablica, która zawiera elementy do łączenia.</param>
        <summary>Łączy wszystkie elementy tablicy ciągów przy użyciu określonego separatora między elementami.</summary>
        <returns>Ciąg, który składa się z elementów w <paramref name="value" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="value" /> jest pusta tablica, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i elementy `value` "apple", "orange", "gronowego" i "Gruszki" `Join(separator, value)` zwraca "apple, orange, gronowego, gruszki".  
  
 Jeśli `separator` jest `null`, ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>) jest używana zamiast tego. Jeśli dowolny element w `value` jest `null`, zamiast tego jest używany pusty ciąg.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Join%2A> metody.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" /> znajduje się w zwracanym ciągu tylko wtedy, gdy <paramref name="value" /> ma więcej niż jeden element.</param>
        <param name="value">Tablica, która zawiera elementy do łączenia.</param>
        <param name="startIndex">Pierwszy element w <paramref name="value" /> do użycia.</param>
        <param name="count">Liczba elementów <paramref name="value" /> do użycia.</param>
        <summary>Łączy określonych elementów w tablicy ciągów przy użyciu określonego separatora między elementami.</summary>
        <returns>Ciąg, który składa się z ciągów <paramref name="value" /> rozdzielone <paramref name="separator" /> ciągu.  
  
—lub— 
 <see cref="F:System.String.Empty" /> Jeśli <paramref name="count" /> wynosi zero, <paramref name="value" /> nie ma żadnych elementów lub <paramref name="separator" /> i wszystkie elementy <paramref name="value" /> są <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i elementy `value` "apple", "orange", "gronowego" i "Gruszki" `Join(separator, value, 1, 2)` zwraca "orange, gronowego".  
  
 Jeśli `separator` jest `null`, ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>) jest używana zamiast tego. Jeśli dowolny element w `value` jest `null`, zamiast tego jest używany pusty ciąg.  
  
   
  
## Examples  
 Poniższy przykład łączy dwa elementy z tablicy nazwy owocu.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejszy niż 0.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="count" /> jest większa niż liczba elementów w <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <paramref name="values" />.</typeparam>
        <param name="separator">Ciąg używany jako separator.<paramref name="separator" /> znajduje się w zwracanym ciągu tylko wtedy, gdy <paramref name="values" /> ma więcej niż jeden element.</param>
        <param name="values">Kolekcja, która zawiera obiekty, do łączenia.</param>
        <summary>Łączy elementy członkowskie kolekcji przy użyciu określonego separatora od każdego elementu członkowskiego.</summary>
        <returns>Ciąg, który składa się z elementów członkowskich <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> nie ma elementów członkowskich, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null`, ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>) jest używana zamiast tego. Jeśli dowolny element członkowski `values` jest `null`, zamiast tego jest używany pusty ciąg.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jest to wygodna metoda umożliwiająca łączenia każdego elementu członkowskiego <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania ich do ciągów. Reprezentacja ciągu każdego obiektu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest tworzony przez wywołanie metody tego obiektu `ToString` metody.  
  
 Ta metoda jest w szczególności przydatne w przypadku wyrażenia zapytań Language-Integrated Query (LINQ). Na przykład, poniższy kod definiuje bardzo prosty `Animal` klasę, która zawiera nazwę zwierzę i kolejności, do której należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, który zawiera szereg `Animal` obiektów. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> — Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiekty, których `Order` właściwości jest równa "Gryzoń". Wynik jest przekazywany do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> obiektu typu Integer, które są następnie przekazywane do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty pozycji indeksu zaczynającego się od zera, ostatniego wystąpienia określony znak Unicode lub ciąg znaków w ciągu tego wystąpienia. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera, ostatniego wystąpienia określony znak Unicode w tym wystąpieniu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli znak ten zostanie znaleziony, lub wartość -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Ta metoda rozpoczyna się wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przeprowadzane w kierunku początku do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ExtractFilename` metody, która używa <xref:System.String.LastIndexOf%28System.Char%29> metoda znajdować ostatnim znakiem separatora katalogu w ciągu i wyodrębnić nazwy pliku parametrów. Jeśli plik istnieje, metoda zwraca nazwę pliku bez ścieżki.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przeprowadzane w kierunku początku do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.LastIndexOf%28System.String%29> metoda zawsze zwraca <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, który reprezentuje ostatniej pozycji indeksu w ramach bieżącego wystąpienia. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%29> metoda jest używana do znajdowania trzy podciągów (nietrwały (U + 00AD), nietrwały, a następnie "n" i nietrwały, a następnie "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ nietrwały jest znakiem do pominięcia, wynik jest taki sam, jakby łącznika nietrwałego nie znalazły się w `value`. Aby wyszukać tylko łącznika nietrwałego, metoda zwraca 6 i 5. Te wartości odpowiadają indeks ostatniego znaku w dwóch ciągów.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład usuwa otwierające i zamykające znaczniki HTML ciąg zaczyna się znaczniki i na końcu ciągu. Jeśli ciąg kończy się zamykającym dopasowywanie znak (">"), w przykładzie użyto <xref:System.String.LastIndexOf%2A> metodą lokalizowania początek tagu końcowego.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby znaleźć ostatni indeks podciągu w wystąpieniu ciągu za pomocą reguł porównywania bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera, ostatniego wystąpienia określony znak Unicode w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli znak ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> -1. Ta metoda rozpoczyna się wyszukiwanie `startIndex` znak położenie tego wystąpienia i przychody ze starszymi wersjami w kierunku początku bieżącego wystąpienia do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatniego znaku w ciągu na początku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie indeksu wszystkie wystąpienia znaku w ciągu, rozpoczynając od końca ciągu do początku ciągu.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż zero lub większa niż równy długości tego wystąpienia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ciąg ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejszy od <paramref name="startIndex" /> a ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak położenie tego wystąpienia i przychody ze starszymi wersjami w kierunku początku do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatniego znaku w ciągu na początku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metoda jest używana do wyszukiwania podciągu, który zawiera nietrwały (U + 00AD) i które poprzedza lub końcowe "m" w ciągu. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznika nietrwałego w wyszukiwanym ciągu są ignorowane, podczas wywoływania metody do znalezienia podciągu, który składa się z łącznika nietrwałego i "m" zwraca pozycję "m" w ciągu, należy je w celu znalezienia substrin wywoływania g, który składa się z łącznika nietrwałego i "n" zwraca pozycję "n". Jeśli ciąg wyszukiwania zawiera tylko łącznika nietrwałego, Metoda ta zwraca indeks "m", który reprezentuje wartość `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie indeksu wszystkie wystąpienia ciągu w ciągu docelowym, rozpoczynając od końca ciągu docelowego do początku ciągu docelowego.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza od zera lub większa niż długość bieżącego wystąpienia.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż -1 lub większa od zera.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby znaleźć indeks podciągu, który poprzedza pozycji znaku określonej za pomocą reguł porównywania bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określonego ciągu w bieżącej <see cref="T:System.String" /> obiektu. Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ciąg ten zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przeprowadzane w kierunku początku do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku.  
  
   
  
## Examples  
 Przeciążenia exampledemonstrates następujące trzy <xref:System.String.LastIndexOf%2A> metodę, która Znajdź ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="options" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metoda zawsze zwraca <see cref="P:System.String.Length" /> – 1, który reprezentuje ostatniej pozycji indeksu w ramach bieżącego wystąpienia.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metoda jest używana do znajdowania trzy podciągów (nietrwały (U + 00AD), nietrwały, a następnie "n" i nietrwały, a następnie "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ nietrwały jest znakiem do pominięcia, wyszukiwanie zależne od kultury zwraca tę samą wartość, która zwróci, jeśli łącznika nietrwałego nie zostały uwzględnione w wyszukiwanym ciągu. Pomyślnie wyszukiwanie porządkowe, jednak znajduje łącznika nietrwałego w jeden ciąg i zgłasza, że jest nieobecny z drugiego ciągu.  
  
[! code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! kodu vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera ostatniego wystąpienia określony znak Unicode w podciągu wewnątrz tego wystąpienia. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przeprowadzane w kierunku początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli znak ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Ta metoda rozpoczyna wyszukiwanie `startIndex` znaku, położenie i przychody ze starszymi wersjami w kierunku początku tego wystąpienia do momentu `value` zostanie znaleziony lub `count` pozycji znaku zostały zbadane. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatniego znaku w ciągu. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkie wystąpienia znaku w podciąg, Praca z końcem podciągu na początku podciąg.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż zero lub większa niż równy długości tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" />  -  <paramref name="count" /> + 1 jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przeprowadzane w kierunku początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ciąg ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejszy od <paramref name="startIndex" /> a ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak położenie tego wystąpienia i przychody ze starszymi wersjami w kierunku początku do momentu `value` zostanie znaleziony lub `count` pozycji znaku zostały zbadane. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatniego znaku w ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu wrażliwość na ustawienia kulturowe Jeśli `value` zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli `value` składa się tylko z co najmniej jeden znak do pominięcia <xref:System.String.LastIndexOf%2A> metoda zawsze zwraca `startIndex`, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%2A> metoda jest używana do znajdowania pozycja nietrwały (U + 00AD) w dwa znaki, które poprzedzają final "m" dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkie wystąpienia ciągu w podciąg, Praca z końcem podciągu na początku podciąg.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ma wartość ujemną.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa od długości tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" />  -  <paramref name="count" />+ 1 określa położenie, który nie znajduje się w tym wystąpieniu.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsza niż -1 lub większa od zera.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większa niż 1.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby wykonać tę operację za pomocą reguł porównywania bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określonego ciągu w bieżącej <see cref="T:System.String" /> obiektu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków. Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ciąg ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejszy od <paramref name="startIndex" /> a ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znaku, położenie i przychody ze starszymi wersjami, do momentu `value` znajduje się lub zostało zbadane pozycji pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatniego znaku w ciągu na początku.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
   
  
## Examples  
 Przeciążenia exampledemonstrates następujące trzy <xref:System.String.LastIndexOf%2A> metodę, która Znajdź ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza od zera lub większa niż długość bieżącego wystąpienia.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż -1 lub większa od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="comparisonType" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania położenie nietrwały (U + 00AD), a po nim "m", począwszy od końcowe "m", która znajduje się w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! kodu vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przeprowadzane w kierunku początku ciągu określoną liczbę pozycji znaku. Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ciąg ten zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejszy od <paramref name="startIndex" /> a ostatnia pozycja indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, pierwszy znak w ciągu przy indeksie jest zero, a ostatnim jest <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znaku, położenie i przychody ze starszymi wersjami, do momentu `value` zostanie znaleziony lub `count` pozycji znaku zostały zbadane. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatniego znaku w ciągu.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametru przy użyciu kultury bieżącej lub niezmiennej, przy użyciu wyszukiwania wielkość liter lub nie oraz za pomocą programu word lub reguł porównania porządkowego.  
  
   
  
## Examples  
 Przeciążenia exampledemonstrates następujące trzy <xref:System.String.LastIndexOf%2A> metodę, która Znajdź ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ma wartość ujemną.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa od długości tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> + 1 - <paramref name="count" /> Określa położenie, który nie znajduje się w tym wystąpieniu.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsza niż -1 lub większa od zera.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większa niż 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W polu wyszukiwania wrażliwość na ustawienia kulturowe (to znaczy, jeśli <paramref name="comparisonType" /> nie <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny wyszukiwaniu po usunięciu tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jeden znak do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, czyli pozycja znaku, od której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania położenie nietrwały (U + 00AD), a po nim "m" we wszystkich, ale przed końcowym znakiem "m" pozycji pierwszego znaku w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład zostanie uruchomiony na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwały jest znakiem do pominięcia, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie zależne od kultury. Gdy wykonuje porównanie porządkowe, jednak znajduje podciąg tylko w pierwszym ciągu. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim "m", metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie zależne od kultury. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! kodu vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</summary>
        <returns>Indeks ostatniego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna się wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przeprowadzane w kierunku początku aż do znaków w `anyOf` znajduje się lub zostało zbadane pozycji pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "to" w innym ciągu.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Indeks ostatniego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony, czy bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie `startIndex` położenie tego wystąpienia i przychody ze starszymi wersjami w kierunku początku aż znak w znaku `anyOf` znajduje się lub został zbadany pozycji pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "to" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> Określa położenie, który nie znajduje się w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <paramref name="startIndex" /> kierunku początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przeprowadzane w kierunku początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Indeks ostatniego wystąpienia w tym przypadku, gdy dowolny znak z <paramref name="anyOf" /> został znaleziony; -1, jeśli żaden znak w <paramref name="anyOf" /> został znaleziony, czy bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie `startIndex` położenie tego wystąpienia i przychody ze starszymi wersjami w kierunku początku aż znak w znaku `anyOf` znajduje się lub `count` pozycji znaku zostały zbadane. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie zależne od kultury, należy użyć <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentujący znak złożony, takich jak ligatury "Ć" (U + 00 C 6), może być uważany za równoważny dowolne wystąpienie w postaci składników w Popraw sekwencję, na przykład "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie indeks ostatniego wystąpienia dowolnego znaku w ciągu "pomoc" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> minus <paramref name="count" /> + 1 jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaków w bieżącym <see cref="T:System.String" /> obiektu.</summary>
        <value>Liczba znaków w ciągu bieżącej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> Właściwość zwraca liczbę <xref:System.Char> obiektów w tym wystąpieniu, nie liczbę znaków Unicode. Przyczyną jest to, że znak Unicode, może być reprezentowany przez więcej niż jedną <xref:System.Char>. Użyj <xref:System.Globalization.StringInfo?displayProperty=nameWithType> klasy do pracy z każdego znaku Unicode, zamiast każdego <xref:System.Char>.  
  
 W przypadku niektórych języków, takich jak C i C++ znak null oznacza koniec ciągu. Na platformie .NET znak null, mogą być osadzone w ciągu. Jeśli ciąg zawiera co najmniej jeden znak null, są one uwzględnione w długość ciągu całkowitej. Na przykład w następujący ciąg podciągi, które "abc" i "def" są oddzielone znakiem null. <xref:System.String.Length%2A> Właściwość zwraca 7, co oznacza, że zawiera sześć znaków alfabetu, a także znaku null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Length%2A> właściwości.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, którego reprezentacja binarna jest w szczególności normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna jest normalizacji Unicode C.</summary>
        <returns>Nowy, znormalizowane ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna ma postać normalizacji C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Na przykład dowolne z następujących punktów kod reprezentuje literę "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET wspomaga cztery normalizacji formularzy (C, D, KC i KD), które są zdefiniowane w standardzie Unicode. Gdy dwa ciągi są przedstawione w tym samym formularzu normalizacji, porovnat za pomocą porównania porządkowego.  
  
 Aby znormalizować i porównuje dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągi, które można porównać ze źródła danych wejściowych, na przykład pliku lub urządzenia do danych wejściowych użytkownika.  
  
2.  Wywołaj <xref:System.String.Normalize> metody NORMALIZUJ ciągi do formularza normalizacji C.  
  
3.  Do porównywania dwóch ciągów, należy wywołać metodę, która obsługuje porównywania ciągów porządkowe, takie jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę i podaj wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argumentu. Aby posortować tablicę ciągów znormalizowany, należy przekazać `comparer` wartość <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiednich przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągów w danych wyjściowych posortowane w kolejności wskazanej w poprzednim kroku.  
  
 Aby uzyskać opis obsługiwanych form normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularzami normalizacji, potwierdzi ten ciąg został znormalizować do formularza normalizacji w określony, a następnie wyświetla punkty kodowe w ciągu znormalizowana.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego znaku nieznormalizowanego w ciągu. W związku z tym, jeśli ciąg zawiera nieznormalizowane znaki nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> mimo że <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formuła normalizacji Unicode.</param>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna jest w określonej normalizacji Unicode.</summary>
        <returns>Nowy ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna jest określony przez formularz normalizacji <paramref name="normalizationForm" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET wspomaga cztery normalizacji formularzy (C, D, KC i KD), które są zdefiniowane w standardzie Unicode. Gdy dwa ciągi są przedstawione w tym samym formularzu normalizacji, porovnat za pomocą porównania porządkowego.  
  
 Aby znormalizować i porównuje dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągi, które można porównać ze źródła danych wejściowych, na przykład pliku lub urządzenia do danych wejściowych użytkownika.  
  
2.  Wywołaj <xref:System.String.Normalize%28System.Text.NormalizationForm%29> NORMALIZUJ ciągi do formularza normalizacji określonej metody.  
  
3.  Do porównywania dwóch ciągów, należy wywołać metodę, która obsługuje porównywania ciągów porządkowe, takie jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę i podaj wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argumentu. Aby posortować tablicę ciągów znormalizowany, należy przekazać `comparer` wartość <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiednich przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągów w danych wyjściowych posortowane w kolejności wskazanej w poprzednim kroku.  
  
 Aby uzyskać opis obsługiwanych form normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularzami normalizacji, potwierdzi ten ciąg został znormalizować do formularza normalizacji w określony, a następnie wyświetla punkty kodowe w ciągu znormalizowana.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego znaku nieznormalizowanego w ciągu. W związku z tym, jeśli ciąg zawiera nieznormalizowane znaki nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> metoda może zgłaszać <see cref="T:System.ArgumentException" /> mimo że <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone ciągi mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> jest taka sama jak wartość <paramref name="b" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.String> klasy. Dzięki temu kod taki jak pokazano w sekcji przykład. Operator, z kolei wywołuje statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> metody, która wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
> [!NOTE]
>  Kompilator Visual Basic nie jest rozpoznawany jako wywołanie operatora równości <xref:System.String.op_Equality%2A> metody. Zamiast tego operatora równości zawija wywołanie do <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano operatora równości.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone ciągi mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> różni się od wartości <paramref name="b" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.String> klasy.   Dzięki temu kod taki jak pokazano w sekcji przykładów.  
  
 <xref:System.String.op_Inequality%2A> Operatora z kolei wywołuje statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> metody, która wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
> [!NOTE]
>  Kompilator Visual Basic nie jest rozpoznawany jako wywołanie operator nierówności <xref:System.String.op_Inequality%2A> metody. Zamiast tego operator nierówności zawija wywołanie do <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano operator nierówności.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym początku bieżącego ciągu są dopełniane z miejsc do magazynowania lub określony znak Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który prawy wyrównuje znaków w tym wystąpieniu dopełniając spacji z lewej strony, dla określonego całkowita długość.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i dopełniana po lewej stronie, o tyle miejsca do magazynowania zgodnie z potrzebami, aby utworzyć o długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równy długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spacji Unicode jest zdefiniowany jako 0x0020 szesnastkowe.  
  
 <xref:System.String.PadLeft%28System.Int32%29> Metoda dopełnia początku zwracanego ciągu. Oznacza to, że w przypadku użycia z językami od prawej do lewej, dopełnia Prawy fragment ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadLeft%2A> metoda dopełnia bieżącego wystąpienia znakami odstępu, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest dopełniana wiodących biały znak, tak, aby jego całkowita długość `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadLeft%2A> metody.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Znak dopełnienia Unicode.</param>
        <summary>Zwraca nowy ciąg, który prawy wyrównuje znaków w tym wystąpieniu dopełniając po lewej stronie do określonego znaku Unicode, całkowita określonej długości.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i dopełniana po lewej stronie, o tyle <paramref name="paddingChar" /> znaków potrzebne do utworzenia długość <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równy długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Metoda dopełnia początku zwracanego ciągu. Oznacza to, że w przypadku użycia z językami od prawej do lewej, dopełnia Prawy fragment ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadLeft%2A> metoda dopełnia bieżącego wystąpienia znakami odstępu, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest dopełniana wiodących `paddingChar` znaków tak, aby jego całkowita długość `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadLeft%2A> metody.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym końca bieżącego ciągu są dopełniane z miejsc do magazynowania lub określony znak Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który lewy wyrównuje znaków w tym ciągu dopełniając spacji po prawej stronie dla określonego całkowita długość.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównane do lewej i dopełniana po prawej stronie, o tyle miejsca do magazynowania zgodnie z potrzebami, aby utworzyć o długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równy długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spacji Unicode jest zdefiniowany jako 0x0020 szesnastkowe.  
  
 <xref:System.String.PadRight%28System.Int32%29> Metoda dopełnia koniec zwracanego ciągu. Oznacza to, że w przypadku użycia z językami od prawej do lewej, dopełnia część po lewej stronie ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadRight%2A> metoda dopełnia bieżącego wystąpienia znakami odstępu, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest dopełniana odstępu, tak, aby jego całkowita długość `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadRight%2A> metody.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Znak dopełnienia Unicode.</param>
        <summary>Zwraca nowy ciąg, który lewy wyrównuje znaków w tym ciągu dopełniając po prawej stronie do określonego znaku Unicode, całkowita określonej długości.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównane do lewej i dopełniana po prawej stronie, o tyle <paramref name="paddingChar" /> znaków potrzebne do utworzenia długość <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równy długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Metoda dopełnia koniec zwracanego ciągu. Oznacza to, że w przypadku użycia z językami od prawej do lewej, dopełnia część po lewej stronie ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadRight%2A> metoda dopełnia bieżącego wystąpienia znakami odstępu, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest dopełniana końcowe `paddingChar` znaków tak, aby jego całkowita długość `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadRight%2A> metody.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg usunięto określoną liczbę znaków z bieżącego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera pozycja należy rozpocząć usuwanie znaków.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu, zaczynając od określonej pozycji i kontynuowanie przy użyciu ostatnia pozycja zostały usunięte.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem te parametry, z wyjątkiem usunięte znaki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], ciągi są oparte na zerze. Wartość `startIndex` parametru może należeć do zakresu od 0 do mniejszej o jeden od długości wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w którym wszystkie znaki od pozycji `startIndex` do końca oryginalnego ciągu zostały usunięte.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Remove%2A> metody. W przypadku dalej do ostatniego usuwa cały tekst, zaczynając od określonego indeksu do końca ciągu. Ostatnim przypadku usuwa trzech znaków, zaczynając od określonego indeksu.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> Określa położenie, który nie znajduje się w tym ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera pozycja należy rozpocząć usuwanie znaków.</param>
        <param name="count">Liczba znaków do usunięcia.</param>
        <summary>Zwraca nowy ciąg, w której usunięto określoną liczbę znaków w bieżącym wystąpieniu, zaczynając od określonej pozycji.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, z wyjątkiem usunięte znaki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], ciągi są oparte na zerze. Wartość `startIndex` parametru może należeć do zakresu od 0 do mniejszej o jeden od długości wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w której liczba znaków są określane przez `count` parametru zostały usunięte. Znaki są usuwane w miejscu określonym przez `startIndex`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak usunąć drugie imię z pełną nazwę.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="count" /> określić pozycji poza tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w której wszystkie wystąpienia określony znak Unicode lub <see cref="T:System.String" /> w ciągu bieżącej są zastępowane inny określony znak Unicode lub <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak Unicode, który ma zostać zastąpione.</param>
        <param name="newChar">Znak Unicode, aby zamienić wszystkie wystąpienia <paramref name="oldChar" />.</param>
        <summary>Zwraca nowy ciąg, w której wszystkie wystąpienia Unicode określonego znaku, w tym wystąpieniu są zastępowane inny określony znak Unicode.</summary>
        <returns>Ciąg, który jest równoważny następującemu wyrażeniu wystąpienia, chyba że wszystkie wystąpienia elementu <paramref name="oldChar" /> są zastępowane <paramref name="newChar" />. Jeśli <paramref name="oldChar" /> nie zostanie znaleziony w bieżącym wystąpieniu, metoda zwraca niezmieniony bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe) wyszukiwanie można znaleźć `oldChar`.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w której wszystkie wystąpienia `oldChar` są zastępowane przez `newChar`.  
  
 Ponieważ ta metoda zwraca zmodyfikowaną wersją tego ciągu, można połączyć w łańcuch razem kolejne wywołania <xref:System.String.Replace%2A> metodę, aby wykonać wiele zamiany na oryginalny ciąg. Wywołania metody są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład tworzy listę wartości rozdzielonych przecinkami, wstawiając przecinkami w przypadku pustych wartości między seriami liczb.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg, który ma zostać zastąpione.</param>
        <param name="newValue">Ciąg, aby zamienić wszystkie wystąpienia <paramref name="oldValue" />.</param>
        <summary>Zwraca nowy ciąg, w której wszystkie wystąpienia określonego ciągu w bieżącym wystąpieniu są zastępowane inny określony ciąg.</summary>
        <returns>Ciąg, który odpowiada bieżącej string, chyba że wszystkie wystąpienia elementu <paramref name="oldValue" /> są zastępowane <paramref name="newValue" />. Jeśli <paramref name="oldValue" /> nie zostanie znaleziony w bieżącym wystąpieniu, metoda zwraca niezmieniony bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `newValue` jest `null`, wszystkie wystąpienia `oldValue` są usuwane.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w której wszystkie wystąpienia `oldValue` są zastępowane przez `newValue`.  
  
 Ta metoda przeprowadza porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe) wyszukiwanie można znaleźć `oldValue`.  
  
 Ponieważ ta metoda zwraca zmodyfikowaną wersją tego ciągu, można połączyć w łańcuch razem kolejne wywołania <xref:System.String.Replace%2A> metodę, aby wykonać wiele zamiany na oryginalny ciąg. Wywołania metody są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można użyć <xref:System.String.Replace%2A> metodę, aby naprawić błąd pisowni.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> ciąg pusty ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tablicę ciągów, która zawiera podciągów w tym wystąpieniu, które są rozdzielane przez elementy określonego ciągu lub tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> Służy do dzielenia ciągu podzielonej na podciągi. Tablicy znaków można użyć do określenia zero, jeden lub wiele znaki rozdzielające ( <xref:System.String.Split%28System.Char%5B%5D%29> metoda), lub za pomocą tablicy znaków do określenia zera, jednego lub wielu ciągów ograniczająca. Przeciążenia <xref:System.String.Split%2A> metody pozwalają ograniczyć liczbę podciągów zwracany przez metodę ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> metoda), aby ustalić, czy puste ciągi są umieszczane w zwrócone podciągów ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metody, lub Aby wykonać obie czynności ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> metody).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternatywy dla funkcji String.Split

 <xref:System.String.Split%2A> Metody nie zawsze jest najlepszym sposobem na przerwanie rozdzielany ciąg na podciągi. Jeśli nie chcesz wyodrębnić wszystkie podciągi ciągu rozdzielany lub jeśli chcesz przeanalizować ciąg przy użyciu wzorca zamiast z zestawu znaków ogranicznik, należy wziąć pod uwagę następujących alternatyw.  
  
### <a name="regular-expressions"></a>Wyrażenia regularne  
 Jeśli Twoimi ciągami jest zgodna z wzorcem stały, służy wyrażeń regularnych do wyodrębniania i obsługiwać ich elementy. Na przykład, jeśli ciągi mieć postać "*numer* *operand* *numer*" można użyć [wyrażenia regularnego](~/docs/standard/base-types/regular-expressions.md) wyodrębnić i obsługi elementy ciągu. Oto przykład:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Definicję wzorca wyrażenia regularnego `(\d+)\s+([-+*/])\s+(\d+)` jest zdefiniowany następująco:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`([-+*/])`|Odpowiada to znak operatora arytmetycznego (+, -, *, lub /). Jest to druga grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to trzecia grupa przechwytywania.|  
  
 Umożliwia także wyrażeń regularnych do wyodrębniania podciągów z ciągu oparte na wzorcu zamiast stały zestaw znaków. Jest to typowy scenariusz, gdy wystąpi jedno z tych warunków:  
  
-   Co najmniej jeden znak ogranicznika nie zawsze służy jako ogranicznika w <xref:System.String> wystąpienia.  
  
-   Sekwencja i liczbę znaków ogranicznik jest zmienna lub nieznany.  
  
 Na przykład <xref:System.String.Split%2A> metody nie można użyć do dzielenia następujący ciąg, ponieważ liczba `\n` (w języku C#) lub `vbCrLf` (w języku Visual Basic) znaków jest zmienną i zawsze nie służą jako ograniczniki.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Wyrażenie regularne łatwo, jak w poniższym przykładzie przedstawiono podzielić ten ciąg.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Definicję wzorca wyrażenia regularnego `\[([^\[\]]+)\]` jest zdefiniowany następująco:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\[`|Dopasowuje nawias otwierający.|  
|`([^\[\]]+)`|Dopasowuje dowolny znak, który nie jest otwarcie i nawias zamykający jeden lub więcej razy. Jest to pierwsza grupa przechwytywania.|  
|`\]`|Dopasowuje nawias zamykający.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody jest niemal identyczny <xref:System.String.Split%2A?displayProperty=nameWithType>, chyba że dzieli ciąg w zależności od wzorca wyrażenia regularnego zamiast zestawu stałych znaków. Na przykład w poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodę, aby podzielić ciąg, który zawiera podciągów rozdzielone różnych kombinacji z łącznikami i innych znaków.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Definicję wzorca wyrażenia regularnego `\s-\s?[+*]?\s?-\s` jest zdefiniowany następująco:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\s-`|Dopasowuje znak odstępu, następuje łącznik.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`[+*]?`|Pasuje do zera lub jednego wystąpienia każdej + lub * znaków.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`-\s`|Dopasowuje znak minusa, następuje znak odstępu.|  
  
### <a name="search-methods-and-the-substring-method"></a>Wyszukaj metody i Substring — metoda  
 Jeśli nie jesteś zainteresowany wszystkie podciągów w ciągu, warto pracować z jednej z metod porównania ciągów, które zwraca indeks, od której rozpoczyna się dopasowanie. Następnie możesz wywołać <xref:System.String.Substring%2A> metoda podciągu, który chcesz wyodrębnić. Metody porównania ciągu obejmują:  
  
-   <xref:System.String.IndexOf%2A>, która zwraca liczony od zera indeks pierwszego wystąpienia znaku lub ciąg w wystąpieniu ciągu.  
  
-   <xref:System.String.IndexOfAny%2A>, która zwraca liczony od zera indeks w bieżącym wystąpieniu ciągu pierwszego wystąpienia dowolnego znaku w tablicy znaków.  
  
-   <xref:System.String.LastIndexOf%2A>, która zwraca liczony od zera indeks ostatniego wystąpienia znak lub ciąg w wystąpieniu ciągu.  
  
-   <xref:System.String.LastIndexOfAny%2A>, która zwraca liczony od zera indeks w bieżącym wystąpieniu ciągu ostatniego wystąpienia dowolnego znaku w tablicy znaków.  
  
 W poniższym przykładzie użyto <xref:System.String.IndexOf%2A> metody do znalezienia okresy w ciągu. Następnie używa <xref:System.String.Substring%2A> metody do zwrócenia pełnych zdań.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki tablicy znaków lub <see langword="null" />.</param>
        <summary>Dzieli ciąg na podciągi, które są oparte na znaki w tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągów z tym wystąpieniem, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg sterujący jest ujęty w znanego zestawu znaków, możesz użyć <xref:System.String.Split%28System.Char%5B%5D%29> metodę, aby oddzielić go na podciągi.   
  
### <a name="return-value-details"></a>Szczegóły dotyczące wartości zwracanej  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy. Na przykład, jeśli tablica separator zawiera znak "-" i "aa-bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia.  
  
 Każdy element obiektu `separator` określa znak ogranicznika oddzielne. Jeśli dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający mu element w zwróconej tablicy zawiera <xref:System.String.Empty>. Oto kilka przykładów:  
  
|Wartość ciągu|Separator|Zwracana tablica|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nowe Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banany"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>Tablica separatora  
 Każdy element separatora definiuje ogranicznika oddzielne, który składa się z jednego znaku. Jeśli `separator` argument jest `null` lub nie zawiera żadnych znaków, metoda traktuje znaki odstępu jako ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard. zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Rozpoznanie przeciążenia String.Split(Char[]) i kompilatora  
 Mimo że ten parametr w taki sposób, aby to przeciążenie <xref:System.String.Split%2A?displayProperty=nameWithType> jest tablicy znaków, można wywołać z pojedynczym znakiem, co ilustruje poniższy przykład.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Ponieważ `separator` parametr zostanie nadany <xref:System.ParamArrayAttribute> atrybutu, kompilatory będzie interpretować pojedynczy znak jako tablicę znaków pojedynczego elementu. Nie jest to miejsce w przypadku innych <xref:System.String.Split%2A?displayProperty=nameWithType> przeciążenia, które zawierają `separator` parameter; Musisz jawnie przekazać te przeciążone funkcje tablicy znaków jako `separator` argumentu.  
  
### <a name="comparison-details"></a>Szczegóły dotyczące porównania  
 <xref:System.String.Split%28System.Char%5B%5D%29> Metoda wyodrębnianie podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w `separator` tablicy i zwraca te podciągów jako elementy tablicy.  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> Metoda szuka ograniczników, wykonując porównanie przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody. Istnieje również możliwość korzystania z <xref:System.String.Compare%2A> metodę, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Aby podzielić ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Aby podzielić ciąg za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
## Examples  
 Poniższy przykład przedstawia sposób wyodrębniania poszczególnych wyrazów w bloku tekstu przez traktowanie białych znaków i znaków interpunkcyjnych w dwukropki. Tablicy znaków przekazany do `separator` parametru <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metoda polega na znak spacji i znak tabulacji, wraz z niektóre typowe znaki interpunkcyjne.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki tablicy znaków lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy. Możesz również określić maksymalną liczbę podciągów do zwrócenia.</summary>
        <returns>Tablica, której elementy zawierają podciągów w tym wystąpieniu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia. Jeśli `count` wynosi zero, zwracany jest pusta tablica.  
  
 Jeśli `separator` parametr jest `null` lub nie zawiera żadnych znaków odstępu są uznawane za ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard i zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Każdy element obiektu `separator` określa znak ogranicznika oddzielne. Jeśli dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiedni element tablicy zawiera <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wypadku pierwszy `count` minus 1 podciągi są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich Element wartość zwracaną.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i jest zgłaszany żaden wyjątek.  
  
 Poniższa tabela zawiera przykłady.  
  
|Wartość ciągu|Separator|Liczba|Zwracana tablica|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nowe Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banany"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] o wartości null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] o wartości null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Jeśli ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Jeśli w przypadku dzielenia ciągu za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak `count` wpływa na liczbę ciągów zwracanych przez <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ma wartość ujemną.</exception>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki tablicy znaków lub <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> obejmujący pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na podciągi na podstawie znaków w tablicy. Można określić, czy podciągów obejmują elementy pustą tablicę.</summary>
        <returns>Tablica, której elementy zawierają podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Szczegóły dotyczące wartości zwracanej  
 Znaki ogranicznika (znaki w `separator` tablicy) nie są uwzględnione w elementach zwróconej tablicy. Na przykład jeśli `separator` tablica zawiera znak "-" i "aa-bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia.  
  
 Jeśli `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, metoda zwraca pustą tablicę.  
  
 Każdy element obiektu `separator` definiuje ogranicznika oddzielne, który składa się z jednego znaku. Jeśli `options` argument jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiedni element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład jeśli `separator` zawiera dwa elementy, "-" i "\_", wartość wystąpieniu ciągu "-\_aa -\_" i wartość `options` argument jest <xref:System.StringSplitOptions.None>, Metoda ta zwraca tablicę ciągów, za pomocą pięć następujących elementów:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który poprzedza "-" znaków pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między "-" znaków pod indeksem 0 i pod indeksem 1 znak "_".  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po znaku "_" o indeksie 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po "-" znaków w indeksie 5.  
  
### <a name="the-separator-array"></a>Tablica separatora  
 Jeśli `separator` parametr jest `null` lub nie zawiera żadnych znaków odstępu są uznawane za ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard i zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Jeśli `separator` jest parametr w wywołaniu tego przeciążenia metody `null`, przeciążeń z późnym zakończy się niepowodzeniem. Jednoznacznie identyfikować wywoływanej metody, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Szczegóły dotyczące porównania  
 <xref:System.String.Split%2A> Metoda wyodrębnianie podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w `separator` parametr i zwraca te podciągów w postaci elementów tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników, wykonując porównanie przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Jeśli ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Jeśli w przypadku dzielenia ciągu za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablicę ciągów, ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki lub <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> obejmujący pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na podciągi na podstawie ciągów w tablicy. Można określić, czy podciągów obejmują elementy pustą tablicę.</summary>
        <returns>Tablica, której elementy zawierają podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg sterujący jest ujęty w znanych zestaw ciągów, możesz użyć <xref:System.String.Split%2A> metodę, aby oddzielić go na podciągi.  
  
### <a name="return-value-details"></a>Szczegóły dotyczące wartości zwracanej  
 Ciągi ograniczników nie znajdują się w elementach zwróconej tablicy. Na przykład jeśli `separator` tablica zawiera ciąg "--" i "aa - bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera żadnego z ciągów `separator`, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia.  
  
 Jeśli `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, metoda zwraca pustą tablicę.  
  
 Każdy element obiektu `separator` definiuje ogranicznika oddzielne, który składa się z co najmniej jeden znak. Jeśli `options` argument jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiedni element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład jeśli `separator` zawiera dwa elementy, "-" i "_", wartość wystąpienia ciągu "- _aa -\_" i wartość `options` argument jest <xref:System.StringSplitOptions.None>, metoda zwraca tablicę pieczenie przy użyciu następujących pięć elementów:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który poprzedza "-" podciąg pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między "-" podciąg od indeksu 0 i "_" podciąg pod indeksem 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, znajdujący się pod indeksem 4 podciągu "_".  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po "-" podciągu w indeksie 5.  
  
### <a name="the-separator-array"></a>Tablica separatora  
 Jeśli dowolny z elementów w `separator` składa się wielu znaków cały podciąg jest uznawany za ogranicznikiem. Na przykład, jeśli jest to jeden z elementów w `separator` jest "10", po której próby Rozdziel ciąg "This10is10a10string." zwraca następujące cztery elementowej tablicy: {"This", "is", "", "string". }.  
  
 Jeśli `separator` parametr jest `null` lub nie zawiera żadnych znaków odstępu są uznawane za ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard i zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Jeśli `separator` jest parametr w wywołaniu tego przeciążenia metody `null`, przeciążeń z późnym zakończy się niepowodzeniem. Jednoznacznie identyfikować wywoływanej metody, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Szczegóły dotyczące porównania  
 <xref:System.String.Split%2A> Metoda wyodrębnianie podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w `separator` parametr i zwraca te podciągów w postaci elementów tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników, wykonując porównanie przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
 <xref:System.String.Split%2A> Metoda ignoruje żadnym elementem `separator` o wartości `null` lub pustym ciągiem ("").  
  
 Aby uniknąć Niejednoznaczne wyniki podczas ciągi w `separator` wspólnym znaków, <xref:System.String.Split%2A> operacji rozpoczynające się od początku do końca wartości wystąpienia i pasuje pierwszym elementem w `separator` jest równa ogranicznika w wystąpienie. Kolejność elementów w kolejności wystąpi podciągów w wystąpieniu ma pierwszeństwo przed `separator`.  
  
 Na przykład należy wziąć pod uwagę wystąpienie, którego wartością jest "abcdef". Jeśli do pierwszego elementu w `separator` została "ef", a drugi element "bcde", wynik operacji podziału będzie tablica ciągu, który zawiera dwa elementy, "a" i "f". Jest to spowodowane podciągu w wystąpieniu "bcde" napotkano i pasuje do elementu w `separator` przed napotkaniu podciągu "f".  
  
 Jednakże jeśli pierwszy element `separator` został "bcd", a drugi element "bc", wynik operacji podziału będzie tablica ciągu, który zawiera dwa elementy, "a" i "ef". Jest to spowodowane "bcd" jest pierwszym ogranicznika w `separator` ogranicznika w wystąpieniu, które odpowiadają. Jeśli kolejność separatory została odwrócona, więc pierwszy element był "bc", a drugi element został "bcd", wynikiem będzie tablica ciągu, który zawiera dwa elementy, "a" i "def".  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Jeśli ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Jeśli w przypadku dzielenia ciągu za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnicę w tablice zwracane przez wywołanie metody ciągu <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> metody z jego `options` równa parametr <xref:System.StringSplitOptions.None?displayProperty=nameWithType> i <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 W poniższym przykładzie zdefiniowano tablicę separatory, które zawierają znaki interpunkcyjne oraz znaki odstępu. Przekazanie tej tablicy, wraz z wartością <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> do <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metoda zwraca tablicę, która składa się z poszczególnych wyrazów z ciągu.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Należy zauważyć, że metoda jest wywoływana z `options` argument wartość <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Zapobiega to zwróconej tablicy w tym <xref:System.String.Empty?displayProperty=nameWithType> wartości, które reprezentują dopasowań podciągów pusty między znaków interpunkcyjnych oraz znaków odstępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki tablicy znaków lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> obejmujący pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, lub `count` parametru to 1, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia. Jeśli `separator` parametr jest `null` lub nie zawiera żadnych znaków odstępu są uznawane za ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard i zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody. Jednak jeśli `separator` jest parametr w wywołaniu tego przeciążenia metody `null`, przeciążeń z późnym zakończy się niepowodzeniem. Jednoznacznie identyfikować wywoływanej metody, kod musi wskazywać typ wartości null. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Jeśli `count` parametru wynosi zero, lub `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, pusta tablica jest zwracana.  
  
 Każdy element obiektu `separator` określa znak ogranicznika oddzielne. Jeśli `options` parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiedni element tablicy zawiera <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wypadku pierwszy `count` minus 1 podciągi są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich Element wartość zwracaną.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i jest zgłaszany żaden wyjątek.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Jeśli ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Jeśli w przypadku dzielenia ciągu za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ma wartość ujemną.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablicę ciągów, ograniczającego podciągów w tym ciągu, pusta tablica zawiera nie ograniczniki lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> obejmujący pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów na podstawie ciągów w tablicy. Można określić, czy podciągów obejmują elementy pustą tablicę.</summary>
        <returns>Tablica, której elementy zawierają podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Szczegóły dotyczące wartości zwracanej  
 Ciągi ograniczników nie znajdują się w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera żadnego z ciągów `separator`, lub `count` parametru to 1, zwróconej tablicy składa się z pojedynczy element, który zawiera tego wystąpienia. Jeśli `separator` parametr jest `null` lub nie zawiera żadnych znaków odstępu są uznawane za ograniczniki. Znaki odstępu są zdefiniowane w standardzie Unicode standard i zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody. Jednak jeśli `separator` jest parametr w wywołaniu tego przeciążenia metody `null`, przeciążeń z późnym zakończy się niepowodzeniem. Jednoznacznie identyfikować wywoływanej metody, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Jeśli `count` parametru wynosi zero, lub `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, pusta tablica jest zwracana.  
  
 Każdy element obiektu `separator` definiuje ogranicznika oddzielne, który składa się z co najmniej jeden znak. Jeśli `options` parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są sąsiadujące lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiedni element tablicy zawiera <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wypadku pierwszy `count` minus 1 podciągi są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich Element wartość zwracaną.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i jest zgłaszany żaden wyjątek.  
  
### <a name="the-separator-array"></a>Tablica separatora  
 Jeśli dowolny z elementów w `separator` składa się wielu znaków cały podciąg jest uznawany za ogranicznikiem. Na przykład, jeśli jest to jeden z elementów w `separator` jest "10", po której próby Rozdziel ciąg "This10is10a10string." Zwraca wartość to 4 elementowej tablicy: {"This", "is", "", "string". }.  
  
### <a name="comparison-details"></a>Szczegóły dotyczące porównania  
 <xref:System.String.Split%2A> Metoda wyodrębnianie podciągów w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w `separator` parametr i zwraca te podciągów w postaci elementów tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników, wykonując porównanie przy użyciu reguł sortowania porządkowego. Aby uzyskać więcej informacji dotyczących wyrazów, ciągów i porządków sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
 <xref:System.String.Split%2A> Metoda ignoruje żadnym elementem `separator` o wartości `null` lub pustym ciągiem ("").  
  
 Aby uniknąć Niejednoznaczne wyniki podczas ciągi w `separator` wspólnym znaków, <xref:System.String.Split%2A> metoda rozpoczynające się od początku do końca wartości wystąpienia i pasuje pierwszym elementem w `separator` jest równa ogranicznika w wystąpienie. Kolejność elementów w kolejności wystąpi podciągów w wystąpieniu ma pierwszeństwo przed `separator`.  
  
 Na przykład należy wziąć pod uwagę wystąpienie, którego wartością jest "abcdef". Jeśli do pierwszego elementu w `separator` została "ef", a drugi element "bcde", wynik operacji podziału może być "a" i "f". Jest to spowodowane podciągu w wystąpieniu "bcde" napotkano i pasuje do elementu w `separator` przed napotkaniu podciągu "f".  
  
 Jednakże jeśli pierwszy element `separator` został "bcd", a drugi element "bc", wynik operacji podziału może być "a" i "ef". Jest to spowodowane "bcd" jest pierwszym ogranicznika w `separator` ogranicznika w wystąpieniu, które odpowiadają. Jeśli kolejność separatory została odwrócona, więc pierwszy element był "bc", a drugi element został "bcd", wynikiem będzie "a" i "def".  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Przydzielają pamięć dla obiektu zwróconej tablicy i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma kluczowe znaczenie dla aplikacji, należy wziąć pod uwagę przy użyciu <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg wewnątrz ciągu.  
  
 Jeśli ciąg jest dzielony znakiem separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować znak separatora w ciągu. Jeśli w przypadku dzielenia ciągu za pomocą ciągu separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodę, aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę pozwala ustalić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć tworzenie pojedynczej macierzy i odwoływanie się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ma wartość ujemną.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszymi wersjami, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywana <paramref name="separator" /> to znaczy <see langword="null" /> lub nie zawiera żadnych znaków, metoda wykorzystuje nieco inny zestaw znaków podziału ciągu niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje się przycinania ciągu. Obie metody, począwszy od programu .NET Framework 4, użyj identyczny zestaw znaków spacji Unicode.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy początku tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <summary>Określa, czy początku tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> pasuje do początku ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` do podciągu na początku tego wystąpienia, która jest równa długości `value`i zwraca wskazanie, czy są równe. Równy, `value` musi być ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia, lub musi być zgodna z początku tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `StripStartTags` metody, która używa <xref:System.String.StartsWith%28System.String%29> tagi początkowe metodę, aby usunąć HTML od początku ciągu. Należy pamiętać, że `StripStartTags` metoda jest wywoływana cyklicznie, aby się upewnić, że wiele początkowe znaczniki HTML na początku wiersza. Przykład nie usuwa tagi HTML osadzone w ciągu.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby ustalić, czy ciąg zaczyna się od podciągu określonej za pomocą reguł porównywania ciągów bieżącej kultury, należy wywołać <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> przeciążenie metody z wartością <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa, jak te parametry i <paramref name="value" /> są porównywane.</param>
        <summary>Określa, czy początku tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z przy użyciu opcji porównania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli to wystąpienie rozpoczyna się od <paramref name="value" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> Metoda porównuje `value` parametr podciągu na początku ciągu i zwraca wartość wskazującą, czy są równe. Równy, `value` musi być odwołaniem do tego samego ciągu, musi być ciągiem pustym (""), lub musi być zgodna z początku tego ciągu. Typ porównania wykonywane przez <xref:System.String.StartsWith%2A> metoda zależy od wartości `comparisonType` parametru. Porównanie można używać konwencji bieżącej kultury (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> i <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) lub niezmiennej kultury (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> i <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), lub też może składać się z porównania znak po znaku punkty kodowe (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Porównanie może również być uwzględniana wielkość liter (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, lub <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), lub jego Ignoruj wielkość liter (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Poniższy przykład wyszukuje ciąg "" na początku dłuższy ciąg, który rozpoczyna się od słowa "". Jak wynika z w przykładzie pokazano wywołanie <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metodę, która wykonuje porównanie niewrażliwość na ustawienia kulturowe, ale wielkość liter nie jest zgodny z ciągiem, gdy wywołanie, które wykonuje porównanie insensitive kultury i przypadkami pasuje do ciągu.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Poniższy przykład określa, czy ciąg zaczyna się od danego podciągu. Inicjuje tablicę dwuwymiarową ciągu. Pierwszy element w drugim wymiarze zawiera ciąg, a drugi element zawiera ciąg do wyszukania na początku pierwszego ciągu. Wyniki są zagrożone wyboru kultury, czy wielkość liter jest ignorowana oraz czy wykonywane jest porównanie porządkowe. Należy pamiętać, że po wystąpieniu ciągu zawiera ligatury, wrażliwość na ustawienia kulturowe porównania z wartością jego kolejnych znaków pomyślnie są zgodne.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Informacje dotyczące kultury, która określa, jak te parametry i <paramref name="value" /> są porównywane. Jeśli <paramref name="culture" /> jest <see langword="null" />, bieżąca kultura jest wykorzystywana.</param>
        <summary>Określa, czy początku tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z przy użyciu określonej kultury.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru pasuje do początku ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` podciągu na początku tego ciągu, która jest równa długości parametru `value`i zwraca wartość wskazującą, czy są równe. Równy, `value` musi być ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia, lub musi być zgodna z początku tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie przy użyciu określonego wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na początku innego ciągu. <xref:System.String.StartsWith%2A> Metoda jest wywoływana kilka razy, używając rozróżnianie wielkości liter, ignorowanie wielkości liter i różnych kultur, które mają wpływ na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera podciąg z tego wystąpienia.  
  
Ten element członkowski jest przeciążony. Aby uzyskać pełne informacje dotyczące tego elementu członkowskiego, w tym informacje o jego składni i zastosowaniu oraz odpowiednie przykłady, kliknij nazwę na liście przeciążeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera początkowy znak położenie podciągu w tym wystąpieniu.</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg rozpoczyna się od określonej pozycji znaku i kontynuuje do końca ciągu.</summary>
        <returns>Ciąg, który jest odpowiednikiem podciągu, który rozpoczyna się od <paramref name="startIndex" /> w tym wypadku lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="startIndex" /> jest równy długości tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.String.Substring%28System.Int32%29> metody wyodrębnianie podciągu z parametry, które zaczyna się od określonej pozycji znaku, a następnie kończy się na końcu ciągu. Począwszy od pozycji znaku jest liczony od zera; innymi słowy pierwszy znak w ciągu jest indeksem 0, indeks 1. Aby wyodrębnić podciągu, który rozpoczyna się od określonej pozycji znaku i kończy się przed końcem ciągu, należy wywołać <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który rozpoczyna się od `startIndex` pozycja w ciągu bieżącej.  
  
 Aby wyodrębnić podciągu, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołanie metody takie jak <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> można pobrać wartości `startIndex`. Drugi przykład przedstawia to; wyodrębnienie wartości klucza, który rozpoczyna się jedną pozycję znak po znaku "=".  
  
 Jeśli `startIndex` jest równa zero, metoda zwraca oryginalny ciąg bez zmian.  
   
  
## Examples  
 W poniższym przykładzie pokazano uzyskiwanie podciąg z ciągu.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane przez znak równości znak ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycja znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metoda wyodrębnia nazwę klucza, rozpoczyna się od pierwszego znaku w ciągu, która rozszerza liczbę znaków, zwracany przez wywołanie metody <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metoda następnie wyodrębnia wartość przypisana do klucza. Rozpoczyna się od jednej pozycji znaku poza znak równości i rozszerza się na końcu ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera początkowy znak położenie podciągu w tym wystąpieniu.</param>
        <param name="length">Liczba znaków w podciąg.</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg rozpoczyna się od określonej pozycji znaku i o określonej długości.</summary>
        <returns>Ciąg, który jest odpowiednikiem podciąg długość <paramref name="length" /> który zaczyna się od <paramref name="startIndex" /> w tym wypadku lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="startIndex" /> jest równy długości tego wystąpienia i <paramref name="length" /> wynosi zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnianie podciągu z parametry, które zaczyna się od określonej pozycji znaku, a następnie kończy się przed końcem ciągu. Począwszy od pozycji znaku jest liczony od zera; innymi słowy pierwszy znak w ciągu jest indeksem 0, indeks 1. Aby wyodrębnić podciągu, który rozpoczyna się od określonej pozycji znaku i kontynuuje do końca ciągu, należy wywołać <xref:System.String.Substring%28System.Int32%29> metody.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg z `length` znaków, zaczynając od `startIndex` pozycja w ciągu bieżącej.  
  
 `length` Parametr reprezentuje całkowita liczba znaków do wyodrębnienia z bieżącego wystąpienia ciągu. Obejmuje to początkowy znak w indeksie znaleziono `startIndex`.  Innymi słowy <xref:System.String.Substring%2A> metoda próbuje wyodrębnić znaków z indeksu `startIndex` do indeksu `startIndex`  +  `length` - 1.  
  
 Aby wyodrębnić podciągu, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołanie metody takie jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> można pobrać wartości `startIndex`.  
  
 Jeśli podciąg rozciąga się od `startIndex` na sekwencję znaków określonego, można wywołać metodę takich jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> uzyskać indeks końcowego znaku lub sekwencji znaków.  Możesz następnie przekonwertować tę wartość na indeks pozycji w ciągu w następujący sposób:  
  
-   Jeśli wyszukaniu pojedynczy znak, który jest do oznaczania koniec podciąg, `length` parametr ma wartość `endIndex`  -  `startIndex` + 1, gdzie `endIndex` jest zwracana wartość <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> Metoda. Poniższy przykład wyodrębnia ciągłego bloku znaki "b" z ciągu.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Jeśli po przeszukaniu dla wielu znaków, które chcesz oznaczyć końca podciąg, `length` parametr ma wartość `endIndex`  +  `endMatchLength`  -  `startIndex`, gdzie `endIndex` jest wartością zwracaną <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> metody. i `endMatchLength` długości sekwencji znaków, która oznacza koniec podciąg. Poniższy przykład wyodrębnia blok tekstu, który zawiera kod XML `<definition>` elementu.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Jeśli znak lub sekwencji znaków, nie jest uwzględniony w końcu podciąg, `length` parametr ma wartość `endIndex`  -  `startIndex`, gdzie `endIndex` jest zwracana wartość <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> Metoda.  
  
 Jeśli `startIndex` jest równa zero i jest równa długości ciągu bieżącego, metoda zwraca oryginalny ciąg bez zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano proste wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę, która wyodrębnia dwóch znaków z ciągu, zaczynając od szóstego pozycji znaku (czyli na indeks 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody w następujących przypadkach trzy do izolowania podciągów wewnątrz ciągu. W przypadku dwóch podciągów jest używana przy porównywaniu, a w przypadku trzeciej jest zgłaszany wyjątek, ponieważ określono nieprawidłowe parametry.  
  
-   Ona wyodrębnia pojedynczy znak, a trzeci pozycja w ciągu (pod indeksem 2) i porównuje ją z "c". To porównanie zwraca `true`.  
  
-   Wyodrębnia zero znaków, zaczynając od czwartej pozycji w ciągu (indeksem 3) i przekazuje go do <xref:System.String.IsNullOrEmpty%2A> metody. To zwraca wartość PRAWDA, ponieważ wywołanie <xref:System.String.Substring%2A> metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Próbuje wyodrębnić jeden znak, zaczynając od czwartej pozycji w ciągu. Ponieważ nie istnieje żaden znak w tej pozycji, wywołanie metody zgłasza <xref:System.ArgumentOutOfRangeException> wyjątku.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane przez znak równości znak ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycja znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metoda wyodrębnia nazwę klucza, rozpoczyna się od pierwszego znaku w ciągu, która rozszerza liczbę znaków, zwracany przez wywołanie metody <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metoda następnie wyodrębnia wartość przypisana do klucza. Rozpoczyna się od jednej pozycji znaku poza znak równości i rozszerza się na końcu ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> wskazuje pozycję nie, w ramach tego wystąpienia.  
  
—lub— 
 <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Silnie typizowane moduł wyliczający, który może służyć do iterowania po bieżącej <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.Collections.Generic.IEnumerable%601> obiektu interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Moduł wyliczający, który może służyć do iteracji przez ciąg bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość bieżącego ciągu jest <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> wartość ciągu bieżącego <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość ciągu bieżącego nie jest <see cref="F:System.Boolean.TrueString" /> lub <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest większy niż numer <see cref="F:System.Byte.MaxValue" /> lub mniej niż <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Znak pod indeksem 0 w bieżącym <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniej niż <see cref="F:System.Decimal.MinValue" /> lub niż <see cref="F:System.Decimal.MaxValue" /> większa.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniej niż <see cref="F:System.Double.MinValue" /> lub większa niż <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest większy niż numer <see cref="F:System.Int16.MaxValue" /> lub mniej niż <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest większy niż numer <see cref="F:System.SByte.MaxValue" /> lub mniej niż <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Typ zwracany obiekt.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie można przekonwertować na typ określony przez <paramref name="type" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest większy niż numer <see cref="F:System.UInt16.MaxValue" /> lub mniej niż <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą <see cref="F:System.UInt32.MaxValue" /> lub mniejsza niż <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Przekonwertowane wartości bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowany na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, której elementy są pojedyncze znaki tego wystąpienia. Jeśli to wystąpienie jest pustym ciągiem, zwracana tablica jest pusta i ma zerową długość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje każdy znak (czyli każdy <xref:System.Char> obiekt) w ciągu do tablicy znaków. Pierwszy znak kopiowany przy indeksie jest zero tablicy znaków zwrócony; ostatni znak kopiowany jest indeksem <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Aby utworzyć ciąg znaków w tablicy znaków, należy wywołać <xref:System.String.%23ctor%28System.Char%5B%5D%29> konstruktora.  
  
 Aby utworzyć tablicę bajtów, który zawiera zakodowany znaków w ciągu, Utwórz wystąpienie odpowiedniej <xref:System.Text.Encoding> obiektu, a następnie wywołać jej <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> metody. Standard kodowania, dostępne na platformie .NET między innymi następujące:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.String.ToCharArray%2A> metody będą wyodrębniane znaki ciągu do tablicy znaków. Następnie wyświetla oryginalny ciąg i elementy w tablicy.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano ciąg zawierający znaki, które służą jako ograniczników ciągu rozdzielany. Następnie wywołuje <xref:System.String.ToCharArray%2A> metodę w celu utworzenia tablicy znaków, które mogą być przekazywane do <xref:System.String.Split%28System.Char%5B%5D%29> metodę, aby oddzielić rozdzielany ciąg do jego indywidualnych podciągów.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja początkowa podciągu w tym wystąpieniu.</param>
        <param name="length">Długość podciągu w tym wystąpieniu.</param>
        <summary>Kopiuje znaki z podanym podciągiem, w tym wystąpieniu do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, której elementy są <paramref name="length" /> liczbę znaków, w tym wystąpieniu, zaczynając od pozycji znaku <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje znaki w części ciągu do tablicy znaków. Aby utworzyć ciąg z zakresu znaków w tablicy znaków, należy wywołać <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora.  
  
 `startIndex` Parametr jest liczony od zera. Oznacza to, że indeks pierwszego wystąpienia znaku w wystąpieniu ciągu wynosi zero.  
  
 Jeśli `length` wynosi zero, zwracana tablica jest pusta i ma zerową długość. Jeśli to wystąpienie jest `null` ani być pustym ciągiem (""), zwracana tablica jest pusta i ma zerową długość.  
  
 Aby utworzyć tablicę bajtów, która zawiera zakodowanych znaków fragment ciągu, Utwórz wystąpienie odpowiedniej <xref:System.Text.Encoding> obiektu, a następnie wywołać jej <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> metody. Standard kodowania, dostępne na platformie .NET, należą:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład konwertuje podciągu wewnątrz ciągu na tablicę znaków, a następnie wylicza i wyświetla elementy tablicy.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="length" /> jest większa od długości tego wystąpienia.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię tego ciągu są konwertowane na małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego ciągu są konwertowane na małe litery.</summary>
        <returns>Ciąg małymi literami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przyjmuje uwagę reguł stosowania wielkości liter bieżącej kultury.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Wielkość liter w wyrazie operacji, która wynika z wywołania <xref:System.String.ToLower> metoda uwzględnia konwencje obudowy bieżącej kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To daje ten sam wynik, w każdej kultury (w przeciwieństwie do <xref:System.String.ToLower> metoda) i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje kilka ciągów przypadków mieszanych na małe litery.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość liter w wyrazie ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby dokonać konwersji znaków na małe litery, przy użyciu konwencji obudowy bieżącej kultury, należy wywołać <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> przeciążenie metody z wartością <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię tego ciągu są konwertowane na małe litery, używając reguł stosowania wielkości liter określonej kultury.</summary>
        <returns>Litery odpowiednikiem bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguł stosowania wielkości liter kultury określonej parametrem `culture` parametru ustalić sposób wielkość liter w ciągu zostanie zmieniony.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> metoda <xref:System.Globalization.CultureInfo> obiekt inny niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja wielkość liter w wyrazie uwzględni reguły specyficzne dla kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To daje ten sam wynik w każdej kultury i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje dwa ciągi na wielkie litery na małe litery, znaki przy użyciu kultur Polski i Turecki-Turcja, a następnie porównuje ciągi małe litery. Wielkie litery ciągi są identyczne, z tą różnicą, że dla każdego wystąpienia Unicode LATIN CAPITAL LETTER i w jednym ciągu inny ciąg zawiera LATIN CAPITAL LETTER I z DOT powyżej.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię obiektu to <see cref="T:System.String" /> obiekt przekonwertowany na małe litery, używając reguł stosowania wielkości liter kultury niezmiennej.</summary>
        <returns>Litery odpowiednikiem bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest on skojarzony z języka angielskiego, ale nie przy użyciu określonego kraju lub regionu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli aplikacja zależy od wielkości liter ciągu zmieniają się w przewidywalny sposób, który jest niezależny od bieżącej kultury, użyj <xref:System.String.ToLowerInvariant%2A> metody. <xref:System.String.ToLowerInvariant%2A> Metoda jest równoważna `ToLower(CultureInfo.InvariantCulture)`. Metoda jest zalecane, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolki interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczego wyrazu w wielu językach. <xref:System.String.ToLowerInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległe bez uwzględniania wielkości liter wersję każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy uwzględniana wielkość liter, na podstawie kolejności elementów w tablicy małe, aby upewnić się, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość tego wystąpienia <see cref="T:System.String" />; nie jest wykonywane.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ ta metoda po prostu zwraca bieżący ciąg bez zmian, istnieje nie trzeba bezpośrednio wywoływać. Jest zwykle nazywane niejawnie w operacji, jak pokazano w przykładzie formatowania złożonego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.ToString%2A> metody. Należy zauważyć, że przykład nie jawnie wywołać <xref:System.String.ToString%2A> metody. Zamiast tego, metoda jest wywoływana niejawnie przez [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) funkcji.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Zwraca wartość tego wystąpienia <see cref="T:System.String" />; nie jest wykonywane.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` jest zarezerwowana i aktualnie nie uczestniczy w tej operacji.  
  
 Ponieważ ta metoda po prostu zwraca bieżący ciąg bez zmian, istnieje nie trzeba bezpośrednio wywoływać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery.</summary>
        <returns>Odpowiednik wielkie litery w ciągu bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa reguł stosowania wielkości liter bieżącej kultury, aby przekonwertować każdego znaku w bieżącym wystąpieniu równoważnik wielkie litery. Jeśli znak nie ma odpowiadającej wielkiej litery, jest uwzględnione bez zmian w zwracanym ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
 <xref:System.String.ToUpper%2A> Metoda jest często używana do przekonwertowania ciągu na wielkie litery, tak aby mogły być używane porównania bez uwzględniania wielkości liter. Metoda lepsze porównania bez uwzględniania wielkości liter jest wywołać metodę porównywania ciągów, które ma <xref:System.StringComparison> parametr, którego wartość zostanie ustawiona na <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> porównanie zależne od kultury, bez uwzględniania wielkości liter.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Wielkość liter w wyrazie operacji, która wynika z wywołania <xref:System.String.ToUpper> metoda uwzględnia konwencje obudowy bieżącej kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To daje ten sam wynik, w każdej kultury (w przeciwieństwie do <xref:System.String.ToUpper> metoda) i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.String.ToUpper%2A> metodę, aby przekonwertować szereg ciągów jeden znak, zawierających każdego znaku w zestawach znaków rozszerzonych A Łaciński podstawowy, uzupełnienie Latin-1 i łacińskiego. Następnie wyświetla każdy ciąg, którego wielkiej litery różni się od jego małą literę.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Jak wyjaśniono w [najlepsze rozwiązania dotyczące Using Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość liter w wyrazie ciągów, które podstawiają wartości domyślne i zamiast tego wywoływać metody, które wymagają być jawnie określone parametry. Aby przekonwertować ciąg na wielkie litery, przy użyciu konwencji obudowy bieżącej kultury, należy wywołać <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> przeciążenie metody z wartością <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery, używając reguł stosowania wielkości liter określonej kultury.</summary>
        <returns>Odpowiednik wielkie litery w ciągu bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguł stosowania wielkości liter kultury określonej parametrem `culture` parametru ustalić sposób wielkość liter w ciągu zostanie zmieniony.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> metoda <xref:System.Globalization.CultureInfo> obiekt inny niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja wielkość liter w wyrazie uwzględni reguły specyficzne dla kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To daje ten sam wynik w każdej kultury i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg na małe litery na dwa ciągi na wielkie litery, przy użyciu kultur Polski i Turecki-Turcja, a następnie porównuje ciągi wielkie litery. Wielkie litery ciągi są identyczne, z tą różnicą, że dla każdego wystąpienia Unicode LATIN CAPITAL LETTER i w jednym ciągu inny ciąg zawiera LATIN CAPITAL LETTER I z DOT powyżej.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię obiektu to <see cref="T:System.String" /> obiekt przekonwertowany na wielkie litery, używając reguł stosowania wielkości liter kultury niezmiennej.</summary>
        <returns>Odpowiednik wielkie litery w ciągu bieżącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest on skojarzony z języka angielskiego, ale nie przy użyciu określonego kraju lub regionu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli aplikacja zależy od wielkości liter ciągu zmieniają się w przewidywalny sposób, który jest niezależny od bieżącej kultury, użyj <xref:System.String.ToUpperInvariant%2A> metody. <xref:System.String.ToUpperInvariant%2A> Metoda jest równoważna `ToUpper(CultureInfo.InvariantCulture)`. Metoda jest zalecane, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolki interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczego wyrazu w wielu językach. <xref:System.String.ToUpperInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległe bez uwzględniania wielkości liter wersję każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy uwzględniana wielkość liter, na podstawie kolejności elementów w tablicy wielkie litery, aby upewnić się, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w którym wszystkie wiodące i końcowe wystąpienia zestaw określonych znaków z bieżącego <see cref="T:System.String" /> obiektu są usuwane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wiodące i końcowe białe znaki z bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie znaki odstępu są usuwane z początku i końca ciągu bieżącego. Jeśli żadne znaki nie można przycięcia z bieżącym wystąpieniem, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Metoda usuwa z ciągu bieżącego wszystkie wiodące i końcowe białe znaki. Każda operacja przycinania początkowe i końcowe zatrzymuje, gdy występuje znak inny niż biały. Na przykład, jeśli bieżący ciąg "abc xyz" <xref:System.String.Trim%2A> metoda zwraca "abc xyz". Aby usunąć znaki spacji między wyrazami w ciągu, użyj [wyrażeń regularnych programu .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Jeśli <xref:System.String.Trim%2A> metoda usuwa wszystkie znaki od bieżącego wystąpienia, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w której zostały usunięte wszystkie wiodące i końcowe białe znaki w ramach bieżącego wystąpienia.  
  
 Jeśli bieżący ciąg równa <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składać się ze znaków odstępu, metoda zwraca <xref:System.String.Empty>.  
  
 Znaki odstępu są zdefiniowane w standardzie Unicode. <xref:System.String.Trim> Metoda usuwa wiodące i końcowe znaki, które generują wartość zwracaną `true` gdy są przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Trim?displayProperty=nameWithType> metody do usuwania jakichkolwiek dodatkowych białych wprowadzonej przez użytkownika przed ich łączenie ciągów.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach Obsługa wewnętrzną listę białe znaki, które usuwa tę metodę. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], metoda przycina wszystkie znaki spacji Unicode (to znaczy, znaki tego produktu <see langword="true" /> wartość zwracana, gdy są przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Ze względu na tę zmianę <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF) który <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]i nowszymi wersjami nie usuwać. Ponadto <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersji nie przycinania trzech znaków spacji Unicode: MONGOLSKI SAMOGŁOSEK SEPARATORA (U + 180E), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F) i miejsca MATEMATYCZNA średnia (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia początkowe i końcowe z zestawu znaków, określone w tablicy, od bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z początku i końca ciągu bieżącego. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica białe znaki zostaną usunięte w zamian. Jeśli żadne znaki nie można przycięcia z bieżącym wystąpieniem, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Metoda usuwa z ciągu bieżącego wszystkie wiodące i końcowe znaki, które znajdują się w `trimChars` parametru. Każdego wiodący i końcowy trim kończy działanie, gdy znak, który nie znajduje się w `trimChars` zostanie osiągnięty. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.Trim%2A> metoda zwróci wartość "abc456xyz".  
  
> [!NOTE]
>  Jeśli <xref:System.String.Trim%2A> metoda usuwa wszystkie znaki od bieżącego wystąpienia, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg wszystkie wiodące i końcowe `trimChars` znaków znalezionych w ramach bieżącego wystąpienia są usuwane.  
  
 Jeśli bieżący ciąg równa <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się z znaków `trimChars` tablicy, metoda zwraca <xref:System.String.Empty>.  
  
 Jeśli `trimChars` jest `null` lub pusta tablica, ta metoda usuwa wiodących ani końcowych znaków, które powodują zwracanie — metoda `true` gdy są przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metodę, aby usunąć przestrzeń, gwiazdki (*) i apostrof (') znaków z ciągu.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach utrzymuje wewnętrzną listę białe znaki, które usuwa tę metodę, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda przycina wszystkie znaki spacji Unicode (to znaczy, znaki tego produktu <see langword="true" /> wartość zwracana, gdy są przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Ze względu na tę zmianę <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF) który <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]i nowszymi wersjami nie usuwać. Ponadto <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersji nie przycinania trzech znaków spacji Unicode: MONGOLSKI SAMOGŁOSEK SEPARATORA (U + 180E), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F) i miejsca MATEMATYCZNA średnia (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia końcowe zestaw znaków, określone w tablicy, od bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z końca bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, Unicode znaki odstępu są usuwane zamiast tego. Jeśli żadne znaki nie można przycięcia z bieżącym wystąpieniem, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A> Metoda usuwa z ciągu bieżącego wszystkie końcowe znaki, które znajdują się w `trimChars` parametru. Operacja przycinania zatrzymuje się wraz z pierwszego znaku który nie znajduje się w `trimChars` występuje na końcu ciągu. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimEnd%2A> metoda zwróci wartość "123abc456xyz".  
  
> [!NOTE]
>  Jeśli <xref:System.String.TrimEnd%2A> metoda usuwa wszystkie znaki od bieżącego wystąpienia, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w których wszystkie nieprawidłowymi znakami w `trimChars` są usuwane z bieżącego ciągu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można użyć <xref:System.String.TrimEnd%28System.Char%5B%5D%29> metodę, aby przyciąć spacje lub znaki interpunkcyjne od końca ciągu.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach utrzymuje wewnętrzną listę białe znaki, które usuwa tę metodę, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda przycina wszystkie znaki spacji Unicode (to znaczy, znaki tego produktu <see langword="true" /> wartość zwracana, gdy są przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Ze względu na tę zmianę <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF) który <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] i nowszymi wersjami nie usuwać. Ponadto <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersji nie przycinania trzech znaków spacji Unicode: MONGOLSKI SAMOGŁOSEK SEPARATORA (U + 180E), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F) i miejsca MATEMATYCZNA średnia (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia wiodących zestaw znaków, określone w tablicy, od bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z początku bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica białe znaki zostaną usunięte w zamian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A> Metoda usuwa z ciągu bieżącego wszystkie wiodące znaki, które znajdują się w `trimChars` parametru. Operacja przycinania zatrzymuje się wraz z znak, który nie znajduje się w `trimChars` zostanie osiągnięty. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimStart%2A> metoda zwróci wartość "abc456xyz789".  
  
> [!NOTE]
>  Jeśli <xref:System.String.TrimStart%2A> metoda usuwa wszystkie znaki od bieżącego wystąpienia, Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w której zostały usunięte wszystkie wiodące znaki odstępu w ramach bieżącego wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.TrimStart%2A> metoda można przycięcia biały znak oraz znaki komentarza z wierszy kodu źródłowego. `StripComments` Metoda zawija wywołanie do <xref:System.String.TrimStart%2A> i przekazuje je tablicy znaków, który zawiera spację, a znak komentarz, który jest apostrof (') w języku Visual Basic i ukośnika (/) w języku C#. <xref:System.String.TrimStart%2A> Wywoływana jest metoda również Usuń biały znak wiodących podczas oceny, czy ciąg jest komentarz.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 W poniższym przykładzie pokazano następnie wywołania `StripComments` metody.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach utrzymuje wewnętrzną listę białe znaki, które usuwa tę metodę, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda przycina wszystkie znaki spacji Unicode (to znaczy, znaki tego produktu <see langword="true" /> wartość zwracana, gdy są przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Ze względu na tę zmianę <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF) który <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] i nowszymi wersjami nie usuwać. Ponadto <see cref="M:System.String.Trim" /> method in Class metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i wcześniejszych wersji nie przycinania trzech znaków spacji Unicode: MONGOLSKI SAMOGŁOSEK SEPARATORA (U + 180E), spacja NIEROZDZIELAJĄCA WĄSKIEGO (U + 202F) i miejsca MATEMATYCZNA średnia (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="467811e82b79d9da56a9489d688a30fe2598faf4" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405009" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje tekst jako sekwencję jednostek kodu UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ciąg jest sekwencyjną kolekcją znaków, która jest używana do reprezentowania tekstu. Obiekt jest sekwencyjną <xref:System.Char?displayProperty=nameWithType> kolekcją obiektów, które <xref:System.Char?displayProperty=nameWithType> reprezentują ciąg; obiekt odpowiada jednostce kodu UTF-16. <xref:System.String> Wartość <xref:System.String> obiektu jest zawartością sekwencyjnej <xref:System.Char?displayProperty=nameWithType> kolekcji obiektów i ta wartość jest niezmienna (oznacza to, że jest ona tylko do odczytu). Więcej informacji o niezmienności ciągów znajduje się w sekcji [niezmienności i StringBuilder klasy](#Immutability) w dalszej części tego tematu. Maksymalny rozmiar <xref:System.String> obiektu w pamięci wynosi 2 GB lub około 1 000 000 000 znaków.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 W tej sekcji:  
  
 [Tworzenie wystąpienia obiektu String](#Instantiation)   
 [Obiekty char i znaki Unicode](#Characters)   
 [Ciągi i standard Unicode](#Unicode)   
 [Ciągi i osadzone znaki null](#EmbeddedNulls)   
 [Ciągi i indeksy](#Indexes)   
 [Ciągi o wartości null i puste ciągi](#Nulls)   
 [Niezmienności i StringBuilder — Klasa](#Immutability)   
 [Liczba porządkowa a operacje zależne od kultury](#CultureSensitive)   
 [Normalizacji](#Normalization)   
 [Operacje na ciągach według kategorii](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Utworzenie wystąpienia obiektu String  
 Można utworzyć wystąpienie <xref:System.String> obiektu w następujący sposób:  
  
-   Przypisanie literału ciągu do <xref:System.String> zmiennej. Jest to najczęściej stosowana metoda tworzenia ciągu. Poniższy przykład używa przypisania do tworzenia kilku ciągów. Należy zauważyć, C#że w, ponieważ ukośnik odwrotny (\\) jest znakiem ucieczki, literały ukośników odwrotnych w ciągu muszą być zmienione lub cały ciąg musi być. @-quoted  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Wywoływanie <xref:System.String> konstruktora klasy. Poniższy przykład tworzy wystąpienie ciągów, wywołując kilka konstruktorów klas. Należy zauważyć, że niektóre konstruktory zawierają wskaźniki do tablic znaków lub podpisanych tablic bajtów jako parametry. Visual Basic nie obsługuje wywołań tych konstruktorów. Aby uzyskać szczegółowe informacje <xref:System.String> na temat konstruktorów <xref:System.String.%23ctor%2A> , zobacz podsumowanie konstruktora.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Za pomocą operatora łączenia ciągów (+ w C# i & lub + w Visual Basic) do tworzenia pojedynczego ciągu z dowolnej kombinacji <xref:System.String> wystąpień i literałów ciągów. Poniższy przykład ilustruje użycie operatora łączenia ciągów.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Pobierając właściwość lub wywołując metodę zwracającą ciąg. W poniższym przykładzie zastosowano metody <xref:System.String> klasy, aby wyodrębnić podciąg z większego ciągu.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Wywołując metodę formatowania, aby przekonwertować wartość lub obiekt na jego reprezentację w postaci ciągu. Poniższy przykład używa funkcji [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby osadzić ciąg reprezentujący dwa obiekty w ciągu.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Obiekty char i znaki Unicode  
 Każdy znak w ciągu jest definiowany przez wartość skalarną Unicode, zwaną również literą kodu Unicode lub wartość porządkową (numeryczną) znaku Unicode. Każdy punkt kodu jest kodowany przy użyciu kodowania UTF-16, a wartość liczbowa każdego elementu kodowania jest reprezentowana przez <xref:System.Char> obiekt.  
  
> [!NOTE]
>  Należy zauważyć, że ponieważ <xref:System.String> wystąpienie składa się z sekwencyjnej kolekcji jednostek kodu UTF-16, można <xref:System.String> utworzyć obiekt, który nie jest poprawnie sformułowanym ciągiem Unicode. Na przykład można utworzyć ciąg, który ma dolny Surogat bez odpowiadającego znaku wieloskładnikowego. Chociaż niektóre metody, takie jak metody kodowania i dekodowania obiektów w <xref:System.Text> przestrzeni nazw, mogą wykonywać sprawdzenia, aby upewnić się, że ciągi są dobrze sformułowane, <xref:System.String> członkowie klasy nie zapewnią, że ciąg jest poprawnie sformułowany.  
  
 Pojedynczy <xref:System.Char> obiekt zazwyczaj reprezentuje pojedynczy punkt kodu; oznacza to, że wartość <xref:System.Char> liczbowa jest równa punktowi kodu. Na przykład punkt kodu dla znaku "a" to U + 0061. Jednak punkt kodu może wymagać więcej niż jednego zakodowanego elementu (więcej niż jeden <xref:System.Char> obiekt). Standard Unicode definiuje dwa typy znaków, które odpowiadają wielu <xref:System.Char> obiektom: graphemes i dodatkowe punkty kodowe Unicode, które odnoszą się do znaków w dodatkowych płaszczyznach Unicode.  
  
-   Grapheme jest reprezentowane przez znak podstawowy, po którym następuje co najmniej jeden łączący się znak. Na przykład znak ä jest reprezentowany przez <xref:System.Char> obiekt, którego punkt kodu to u + 0061 <xref:System.Char> , po którym następuje obiekt, którego punkt kodu to u + 0308. Ten znak może być również definiowany przez pojedynczy <xref:System.Char> obiekt, który ma punkt kodu U + 00E4. Jak pokazano na poniższym przykładzie, porównywanie kulturowe dla równości wskazuje, że te dwie reprezentacje są równe, chociaż zwykłe porównanie porządkowe nie jest. Jeśli jednak dwa ciągi są znormalizowane, porównanie porządkowe wskazuje również, że są równe. (Aby uzyskać więcej informacji na temat normalizacji ciągów, [](#Normalization) Zobacz sekcję normalizacji).  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Dodatkowy punkt kodu Unicode (para dwuskładnikowa) jest reprezentowany przez <xref:System.Char> obiekt, którego punkt kodowy jest dużym surogatem, a następnie <xref:System.Char> obiektem, którego punkt kodowy jest dolnym surogatem. Jednostki kodu dla dużych surogatów mieszczą się w zakresie od U + D800 do U + DBFF. Jednostki kodu dla małych surogatów mieszczą się w zakresie od U + DC00 do U + DFFF. Pary dwuskładnikowe służą do reprezentowania znaków w dodatkowych płaszczyznach 16 Unicode. Poniższy przykład tworzy znak zastępczy i przekazuje go do <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metody, aby określić, czy jest to para dwuskładnikowa.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Ciągi i standard Unicode  
 Znaki w ciągu są reprezentowane przez jednostki kodu kodowane w formacie UTF-16, które odpowiadają <xref:System.Char> wartościom.  
  
 Każdy znak w ciągu ma skojarzoną kategorię znaków Unicode, która jest reprezentowana w programie .NET przez <xref:System.Globalization.UnicodeCategory> Wyliczenie. Kategorię znaku lub pary zastępczej można określić, wywołując <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> metodę.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Ponadto platforma .NET obsługuje Porównywanie ciągów i sortowanie na podstawie standardu Unicode. W wersjach .NET Framework przez [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework zachowuje własną tabelę danych ciągu. Jest to również prawdziwe w przypadku wersji .NET Framework rozpoczynających [!INCLUDE[net_v45](~/includes/net-v45-md.md)] się od uruchomienia w systemie Windows 7. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Począwszy od systemu operacyjnego Windows 8 i jego nowszych wersji, środowisko uruchomieniowe deleguje porównanie ciągów i sortowania do systemu operacyjnego. W przypadku platformy .NET Core informacje o porównywaniu ciągów i sortowaniu są udostępniane przez [składniki międzynarodowe dla bibliotek Unicode](http://site.icu-project.org/) . W poniższej tabeli wymieniono wersje programu .NET i wersje standardu Unicode, w których są oparte porównywane i sortowane znaki.  
  
|Wersja platformy .NET|Wersja Unicode Standard|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Standard Unicode wersji 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2,0|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]i nowszych w systemie Windows 7|[Standard Unicode wersji 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]i nowszych wersjach systemu Windows 8 i nowszych systemów operacyjnych Windows|[Standard Unicode wersji wersji 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET core (wszystkie wersje)|Zależy od wersji standardu Unicode obsługiwanego przez podstawowy system operacyjny.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Ciągi i osadzone znaki o wartości zerowej  
 W programie .NET <xref:System.String> obiekt może zawierać osadzone znaki null, które są liczone jako część długości ciągu. Jednak w niektórych językach, takich jak C i C++, znak null wskazuje koniec ciągu; nie jest uważany za część ciągu i nie jest liczony jako część długości ciągu. Oznacza to, że następujące typowe założenia, że C C++ i programiści lub biblioteki w języku c C++ lub mogą wprowadzać ciągi niekoniecznie są ważne w przypadku <xref:System.String> zastosowania do obiektów:  
  
-   Wartość zwracana przez `strlen` funkcję lub `wcslen` nie musi być równa <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Ciąg utworzony przez `strcpy_s` lub `wcscpy_s` funkcji nie musi być identyczny z ciągiem utworzonym przez <xref:System.String.Copy%2A?displayProperty=nameWithType> metodę.  
  
 Należy upewnić się, że natywne C i C++ kod <xref:System.String> , który tworzy wystąpienia obiektów, oraz <xref:System.String> kod, który jest przesyłany przez wywołanie platformy, nie zakłada, że osadzony znak null oznacza koniec ciągu.  
  
 Osadzone znaki null w ciągu są również traktowane inaczej, gdy ciąg jest sortowany (lub porównywany) i kiedy przeszukiwany jest ciąg. Znaki null są ignorowane podczas przeprowadzania porównania z uwzględnieniem kultury między dwoma ciągami, w tym porównania przy użyciu niezmiennej kultury. Są one uznawane tylko za porównania porządkowe lub nieuwzględniające wielkości liter. Z drugiej strony osadzone znaki null są zawsze brane pod uwagę podczas wyszukiwania ciągu przy użyciu metod takich jak <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, i <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Ciągi i indeksy  
 Indeks jest pozycją <xref:System.Char> obiektu (nie znakiem Unicode) <xref:System.String>w. Indeks jest liczony od zera liczbą nieujemną rozpoczynającą się od pierwszej pozycji w ciągu, która jest pozycją indeksu równą zero. Wiele metod wyszukiwania, takich jak <xref:System.String.IndexOf%2A> i <xref:System.String.LastIndexOf%2A>, zwraca indeks znaku lub podciągu w wystąpieniu ciągu.  
  
 Właściwość umożliwia dostęp do pojedynczych <xref:System.Char> obiektów według ich pozycji indeksu w ciągu. <xref:System.String.Chars%2A> Ponieważ właściwość jest właściwością domyślną (w Visual Basic) lub indeksatorem (w programie C#), można uzyskać dostęp do poszczególnych <xref:System.Char> obiektów w ciągu za pomocą kodu, takiego jak poniższy. <xref:System.String.Chars%2A> Ten kod szuka białych znaków w ciągu, aby określić, ile wyrazów zawiera ciąg.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Ponieważ klasa implementuje interfejs, <xref:System.Char> można także wykonać iterację obiektów w ciągu przy użyciu `foreach` konstrukcji, jak pokazano w poniższym przykładzie. <xref:System.Collections.IEnumerable> <xref:System.String>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Kolejne wartości indeksów mogą nie odpowiadać na kolejne znaki Unicode, ponieważ znak Unicode może być zakodowany jako więcej niż jeden <xref:System.Char> obiekt. W szczególności ciąg może zawierać jednoznakowe jednostki tekstu, które są tworzone przez znak podstawowy, po którym następuje co najmniej jeden łączenie znaków lub przez pary zastępcze. Aby współpracować ze znakami Unicode zamiast <xref:System.Char> obiektów, <xref:System.Globalization.StringInfo?displayProperty=nameWithType> Użyj klas i <xref:System.Globalization.TextElementEnumerator> . Poniższy przykład ilustruje różnicę między kodem, który działa z <xref:System.Char> obiektami i kodem, który działa ze znakami Unicode. Porównuje liczbę znaków lub elementów tekstu w każdym słowie zdania. Ciąg zawiera dwie sekwencje znaków podstawowych, po których następuje łączenie znaku.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Ten przykład działa z elementami tekstowymi przy użyciu <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> metody <xref:System.Globalization.TextElementEnumerator> i klasy do wyliczania wszystkich elementów tekstu w ciągu. Możesz również pobrać tablicę zawierającą indeks początkowy każdego elementu tekstowego, wywołując <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> metodę.  
  
 Aby uzyskać więcej informacji na temat pracy z jednostkami tekstu, <xref:System.Char> a nie pojedynczymi <xref:System.Globalization.StringInfo> wartościami, zobacz Klasa.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Ciągi zerowe i puste ciągi  
 Ciąg, który został zadeklarowany, ale nie ma przypisanej wartości `null`. Próba wywołania metod w tym ciągu zwraca wartość <xref:System.NullReferenceException>. Ciąg o wartości null różni się od pustego ciągu, który jest ciągiem, którego wartością jest "" <xref:System.String.Empty?displayProperty=nameWithType>. W niektórych przypadkach przekazywanie ciągu o wartości null lub pustego ciągu jako argumentu w wywołaniu metody zgłasza wyjątek. Na przykład przekazywanie ciągu o wartości null do <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metody <xref:System.ArgumentNullException>zgłasza, i przekazywanie pustego ciągu zgłasza <xref:System.FormatException>. W innych przypadkach argument metody może być ciągiem o wartości null lub ciągiem pustym. Na przykład, jeśli dostarczasz <xref:System.IFormattable> implementację klasy, chcesz zrównać zarówno ciąg o wartości null, jak i pusty ciąg z specyfikatorem formatu ogólnego ("G").  
  
 Klasa obejmuje dwie metody wygodne, które umożliwiają przetestowanie, czy ciąg jest `null` lub pusty: <xref:System.String>  
  
-   <xref:System.String.IsNullOrEmpty%2A>, która wskazuje, czy ciąg ma wartość `null` lub jest <xref:System.String.Empty?displayProperty=nameWithType>równa. Ta metoda eliminuje konieczność użycia kodu, takiego jak:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, która wskazuje, czy ciąg jest `null`równa <xref:System.String.Empty?displayProperty=nameWithType>lub polega wyłącznie na znakach odstępu. Ta metoda eliminuje konieczność użycia kodu, takiego jak:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 W poniższym przykładzie zastosowano <xref:System.String.IsNullOrEmpty%2A> metodę <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> w implementacji klasy niestandardowej `Temperature` . Metoda obsługuje ciągi formatu "G", "C", "F" i "K". Jeśli pusty ciąg formatu lub ciąg formatu, którego wartość jest `null` przenoszona do metody, jego wartość jest zmieniana na ciąg formatu "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Niezmienność i klasa StringBuilder  
 <xref:System.String> Obiekt jest wywoływany jako niezmienny (tylko do odczytu), ponieważ jego wartość nie może być modyfikowana po utworzeniu. Metody, które pojawiają się <xref:System.String> w celu zmodyfikowania obiektu <xref:System.String> , faktycznie zwracają nowy obiekt, który zawiera modyfikację.  
  
 Ponieważ ciągi są niezmienne, procedury manipulowania ciągami, które wykonują powtarzające się operacje dodawania lub usuwania do elementów, które wydaje się być pojedynczym ciągiem, mogą dokładnie mieć znaczny spadek wydajności. Na przykład poniższy kod używa generatora liczb losowych, aby utworzyć ciąg z 1000 znaków w zakresie 0x0001 do 0x052F. Chociaż kod wydaje się używać łączenia ciągów do dołączania nowego znaku do istniejącego ciągu o nazwie `str`, w rzeczywistości tworzy nowy <xref:System.String> obiekt dla każdej operacji łączenia.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Można użyć <xref:System.Text.StringBuilder> klasy zamiast <xref:System.String> klasy dla operacji, które wprowadzają wiele zmian do wartości ciągu. W przeciwieństwie do wystąpień <xref:System.String> klasy, <xref:System.Text.StringBuilder> obiekty są modyfikowalne; podczas łączenia, dołączania lub usuwania podciągów z ciągu, operacje są wykonywane na pojedynczym ciągu. Po zakończeniu modyfikowania wartości <xref:System.Text.StringBuilder> obiektu można wywołać jego <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować ją na ciąg. Poniższy przykład zastępuje <xref:System.String> użycie w poprzednim przykładzie, aby połączyć 1000 losowe znaki z zakresu do 0x0001 do 0x052F <xref:System.Text.StringBuilder> z obiektem.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Operacje porządkowe vs. operacje zależne od kultury  
 Elementy członkowskie <xref:System.String> klasy wykonują operacje na obiektach porządkowych lub wrażliwych na kulturę. <xref:System.String> Operacja porządkowa działa na wartości liczbowej każdego <xref:System.Char> obiektu. Operacje zależne od kultury działają na wartości <xref:System.String> obiektu i pobierają wielkość liter, sortowanie, formatowanie i analizowanie reguł dla konta. Operacje zależne od kultury są wykonywane w kontekście jawnie zadeklarowanej kultury lub niejawnej bieżącej kultury. Dwa rodzaje operacji mogą generować różne wyniki, gdy są wykonywane na tym samym ciągu.  
  
Platforma .NET obsługuje także wielokulturowe operacje na ciągach lingwistycznych przy użyciu niezmiennej<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>kultury (), która jest luźno oparta na ustawieniach kultury w języku angielskim niezależnym od regionu. W przeciwieństwie <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> do innych ustawień, ustawienia niezmiennej kultury są gwarantowane, że są spójne na jednym komputerze, z systemu do systemu i między różnymi wersjami programu .NET. Niezmienna kultura może być traktowana jako rodzaj czarnego pola, które zapewnia stabilność porównywania ciągów i porządkowanie we wszystkich kulturach.  
  
> [!IMPORTANT]
>  Jeśli aplikacja wykonuje decyzję o zabezpieczeniach dotyczącą identyfikatora symbolicznego, takiego jak nazwa pliku lub potok nazwany lub informacje o utrwalonych danych, takich jak dane tekstowe w pliku XML, operacja powinna używać porównania porządkowego zamiast porównania z uwzględnieniem kultury. Wynika to z faktu, że porównanie wrażliwe na kulturę może dać różne wyniki w zależności od kultury, podczas gdy porównanie porządkowe zależy wyłącznie od wartości binarnej porównywanych znaków.  
  
> [!IMPORTANT]
>  Większość metod wykonywania operacji na ciągach zawiera Przeciążenie, które ma parametr typu <xref:System.StringComparison>, który pozwala określić, czy metoda wykonuje operacje porządkową lub zależną od kultury. Ogólnie rzecz biorąc, należy wywołać to Przeciążenie, aby przeznaczenie metody zostało wyczyszczone. Aby zapoznać się z najlepszymi rozwiązaniami i wskazówkami dotyczącymi używania porządkowej i kulturowej operacji na ciągach, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operacje dotyczące [wielkości liter](#casing), [analizowania i formatowania](#parsing), [porównywania i sortowania](#comparison)oraz [testowania pod kątem równości](#equality) mogą być porządkowe lub wrażliwe na kulturę. W poniższych sekcjach omówiono każdą kategorię operacji.  
  
> [!TIP]
>  Należy zawsze wywołać metodę przeciążenia metody, która sprawia, że cel wywołania metody jest wyczyszczony. <xref:System.String.Compare%28System.String%2CSystem.String%29> Na przykład zamiast wywołania metody w celu przeprowadzenia porównania z dwoma ciągami z uwzględnieniem kultury przy użyciu Konwencji bieżącej kultury, należy <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> wywołać <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> metodę z wartością dla `comparisonType` argument. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  

Można pobrać [tabele wagi sortowania](https://www.microsoft.com/download/details.aspx?id=10921), zestaw plików tekstowych, które zawierają informacje o wagach znaków używanych w operacjach sortowania i porównywania dla systemów operacyjnych Windows, a także [domyślną tabelę elementów sortowania Unicode](https://www.unicode.org/Public/UCA/latest/allkeys.txt), sortowanie tabela wag dla systemów Linux i macOS.

<a name="casing"></a>   
### <a name="casing"></a>Wielkość znaków  
 Zasady dotyczące wielkości liter określają, jak zmienić wielkooć liter znaku Unicode; na przykład z małych i wielkich liter. Często operacje dotyczące wielkości liter są wykonywane przed porównaniem ciągu. Na przykład ciąg może zostać przekonwertowany na wielkie litery, aby można go było porównać z innym ciągiem z wielką literą. Możesz przekonwertować znaki w ciągu na <xref:System.String.ToLower%2A> małe, wywołując metodę lub <xref:System.String.ToLowerInvariant%2A> i konwertując je <xref:System.String.ToUpper%2A> na wielkie litery poprzez wywołanie metody lub <xref:System.String.ToUpperInvariant%2A> . Ponadto można użyć <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metody do przekonwertowania ciągu na wielkość liter.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Operacje dotyczące wielkości liter mogą opierać się na regułach bieżącej kultury, określonej kulturze lub kulturze niezmiennej. Ponieważ mapowania wielkości liter mogą się różnić w zależności od używanej kultury, wynik operacji wielkości liter może się różnić w zależności od kultury. Rzeczywiste różnice w wielkości liter są trzy rodzaje:  
  
-   Różnice w mapowaniu przypadku Wielkiej litery I (U + 0049), małych LITERAch I (U + 0069), Wielkiej litery I z KROPKą powyżej (U + 0130) i MAŁĄ LITERą bez ZNAKiem i (U + 0131). W przypadku kultur TR-TR (turecki (Turcja)) i az-Latn-AZ (Azerbejdżan, łaciński), a w obszarze TR, AZ i az-Latn neutralnych, małe litery ALFABETu łacińskiego i są małymi LITERAmi bez znakiem i z wielką literą WIELKA LITERA I Z KROPKĄ POWYŻEJ. We wszystkich innych kulturach, w tym w niezmiennej kulturze, mała litera i Wielka litera, a to małe i wielkie litery.  
  
     W poniższym przykładzie pokazano, jak porównanie ciągów, które uniemożliwia dostęp do systemu plików, może się nie powieść, jeśli jest to zależne od porównania wielkości liter. (Konwencje wielkości liter kultury niezmiennej powinny być używane).  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Różnice w mapowaniu wielkości liter między kulturą niezmienną i wszystkimi innymi kulturami. W takich przypadkach, używając reguł wielkości liter kultury niezmiennej, aby zmienić znak na wielkie lub małe litery zwraca ten sam znak. Dla wszystkich innych kultur zwraca inny znak. Niektóre z tych znaków zostały wymienione w poniższej tabeli.  
  
    |Znak|W przypadku zmiany na|Zwraca|  
    |---------------|-------------------|-------------|  
    |ZNAK MIKRO (U + 00B5)|Wielkie litery|WIELKA LITERA GRECKA (U +-39C)|  
    |WIELKA LITERA I Z KROPKĄ POWYŻEJ (U + 0130)|Małe litery|MAŁA LITERA I (U + 0069)|  
    |MAŁA LITERA Z KROPKĄ I (U + 0131)|Wielkie litery|WIELKA LITERA I (U + 0049)|  
    |MAŁA LITERA S (U + 017F)|Wielkie litery|WIELKA LITERA S (U + 0053)|  
    |WIELKA LITERA D Z MAŁĄ LITERĄ Z ODWRÓCONYM DASZKIEM (U + 01C5)|Małe litery|MAŁA LITERA DZ Z ODWRÓCONYM DASZKIEM (U + 01C6)|  
    |ŁĄCZENIE GRECKIEGO YPOGEGRAMMENI (U + 0345)|Wielkie litery|WIELKA GRECKA LITERA JOTA (U + 0399)|  
  
-   Różnice w mapowaniu przypadku dwuliterowych par przypadków mieszanych w zakresie znaków ASCII. W większości kultur dwuliterowa para przypadków mieszanych jest równa równoważnej dwuliterowej pary wielkie lub małe litery. Nie dotyczy to następujących dwuliterowych par w poniższych kulturach, ponieważ w każdym przypadku są one porównywane z wykresem:  
  
    -   "lJ" i "nJ" w kulturze HR-HR (chorwacki (Chorwacja)).  
  
    -   "cH" w kulturach CS-CZ (czeski (Czechy)) i SK-SK (słowacki (Słowacja)).  
  
    -   "aA" w kulturze da-DK (duński (Dania)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" i "zS" w kulturze hu (węgierski)).  
  
    -   "cH" i "lL" w kulturze es-ES_tradnl (hiszpański (Hiszpania, tradycyjny)).  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "qU", "tH" i "tR" w kulturze VI-VN (wietnamski (Wietnam)).  
  
     Niemniej jednak zdarza się sytuacje, w których porównanie kulturowe tych par tworzy problemy, ponieważ te pary są nietypowe w stałych ciągach lub identyfikatorach.  
  
 Poniższy przykład ilustruje niektóre różnice w regułach wielkości liter między kulturami podczas konwertowania ciągów na wielkie litery.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Formatowanie i analizowanie  
 Formatowanie i analizowanie to operacje odwrotne. Reguły formatowania określają sposób konwersji wartości, takich jak Data i godzina lub liczba, na reprezentację w postaci ciągu, podczas gdy reguły analizy określają, jak konwertować reprezentację ciągu na wartość taką jak Data i godzina. Reguły formatowania i analizowania są zależne od konwencji kulturowych. Poniższy przykład ilustruje niejednoznaczność, która może powstać przy interpretacji ciągu daty specyficznej dla kultury. Bez znajomości Konwencji kultury, która była używana do tworzenia ciągu daty, nie jest możliwe, że 03/01/2011, 3/1/2011 i 01/03/2011 reprezentuje 3 stycznia 2011 lub 1 marca 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Podobnie, jak pokazano w poniższym przykładzie, pojedynczy ciąg może generować różne daty w zależności od kultury, której konwencje są używane w operacji analizowania.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Porównanie ciągów i sortowanie  
 Konwencje do porównywania i sortowania ciągów różnią się od kultury do kultury. Na przykład porządek sortowania może opierać się na fonetycznych lub w wizualnej reprezentacji znaków. W językach wschodnioazjatyckich znaki są sortowane według obrysu i pierwiastka z ideogramy. Sortowanie zależy również od języków zamówienia i kultur używanych dla alfabetu. Na przykład język duński ma znak "Æ", który jest sortowany po "Z" alfabetu. Ponadto porównania mogą uwzględniać wielkość liter lub uwzględniać wielkość liter, a w niektórych przypadkach reguły dotyczące wielkości liter różnią się również kulturą. Porównanie porządkowe, z drugiej strony, używa punktów kodu Unicode poszczególnych znaków w ciągu podczas porównywania i sortowania ciągów.  
  
 Reguły sortowania określają kolejność alfabetyczną znaków Unicode i sposób, w jaki dwa ciągi porównują się ze sobą. Na przykład <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Metoda porównuje dwa ciągi <xref:System.StringComparison> w oparciu o parametr. Jeśli wartość parametru to <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, Metoda wykonuje porównanie lingwistyczne, które używa Konwencji bieżącej kultury; Jeśli wartość parametru to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, Metoda wykonuje porównanie porządkowe. W związku z tym, jak pokazano w poniższym przykładzie, jeśli bieżąca kultura jest w Stanach Zjednoczonych W języku angielskim pierwsze wywołanie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metody (przy użyciu porównania z uwzględnieniem kultury) uważa wartość "a" mniejszą niż "a", ale drugie wywołanie tej samej metody (przy użyciu porównania porządkowej) traktuje "a" większe niż "a".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 Platforma .NET obsługuje reguły sortowania wyrazów, ciągów i porządkowych:  
  
-   Sortowanie wyrazów wykonuje porównanie z uwzględnieniem kultury ciągów, w których niektóre znaki niealfanumeryczne Unicode mogą mieć przypisane specjalne wagi. Na przykład łącznik (-) może mieć przypisaną bardzo małą wagę, tak aby "coop" i "współ-op" pojawiły się obok siebie na sortowanej liście. Aby zapoznać się z listą <xref:System.String> metod, które porównują dwa ciągi przy użyciu reguł sortowania wyrazów, zobacz sekcję operacje na ciągach [według kategorii](#ByCategory) .  
  
-   Sortowanie ciągów wykonuje także porównanie z uwzględnieniem kultury. Jest to podobne do sortowania wyrazów, z tą różnicą, że nie istnieją specjalne przypadki i wszystkie symbole inne niż alfanumeryczne są przed wszystkimi alfanumerycznymi znakami Unicode. Dwa ciągi można porównać przy użyciu reguł sortowania ciągów, wywołując <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> przeciążenia metody, które `options` mają parametr, który <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>ma wartość. Należy zauważyć, że jest to jedyna metoda, którą platforma .NET oferuje do porównywania dwóch ciągów przy użyciu reguł sortowania ciągów.  
  
-   Sortowanie porządkowe porównuje ciągi na podstawie wartości liczbowej każdego <xref:System.Char> obiektu w ciągu. W porównaniu porządkowej jest automatycznie rozróżniana wielkość liter, ponieważ małe litery i wielkie litery znaku mają różne punkty kodów. Jeśli jednak przypadek nie jest istotny, można określić porównanie porządkowe, które ignoruje wielkość liter. Jest to równoznaczne z konwertowaniem ciągu na wielkie litery przy użyciu niezmiennej kultury, a następnie przeprowadzenie porównania porządkowego w wyniku. Aby zapoznać się z listą <xref:System.String> metod, które porównują dwa ciągi przy użyciu reguł sortowania porządkowego, zobacz sekcję operacje na ciągach [według kategorii](#ByCategory) .  
  
 Porównanie wrażliwe na kulturę to dowolne porównanie, które jawnie lub niejawnie używa <xref:System.Globalization.CultureInfo> obiektu, łącznie z niezmienną kulturą określoną <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> przez właściwość. Niejawna kultura to bieżąca kultura, która jest określona przez <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> właściwości i. <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Istnieją znaczne różnice w kolejności sortowania znaków alfabetycznych (czyli znaków, dla których <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> Właściwość zwraca wartość `true`) między kulturami. Można określić porównanie wrażliwe na kulturę, które używa konwencji określonej kultury przez dostarczenie <xref:System.Globalization.CultureInfo> obiektu do metody porównywania ciągów, takiej jak. <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Można określić porównanie wrażliwe na kulturę, które używa Konwencji bieżącej kultury, dostarczając <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions> lub jakikolwiek element członkowski wyliczenia inne niż <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> lub <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> do odpowiednich <xref:System.String.Compare%2A> Przeciążenie metody. Porównanie wrażliwe na kulturę jest zwykle odpowiednie do sortowania, podczas gdy porównanie porządkowe nie jest. Porównanie porządkowe jest ogólnie odpowiednie do określenia, czy dwa ciągi są równe (oznacza to, że w celu określenia tożsamości), podczas gdy porównanie wrażliwe na kulturę nie jest.  
  
 Poniższy przykład ilustruje różnicę między porównaniem uwzględniającym kulturę i porządkową. Przykład szacuje trzy ciągi, "Apple", "Æble" i "AEble", przy użyciu porównania porządkowego oraz Konwencji kultur da-DK i en-us (z których każda jest kulturą domyślną w momencie <xref:System.String.Compare%2A> wywołania metody). Ponieważ język duński traktuje znak "Æ" jako pojedynczą literę i sortuje ją po literze "Z" w alfabecie, ciąg "Æble" jest większy niż "Apple". Jednakże "Æble" nie jest uważany za odpowiednik "AEble", więc wartość "Æble" jest również większa niż "AEble". Kultura en-US nie zawiera litery "Æ", ale traktuje ją jako odpowiednik "AE", co wyjaśnia dlaczego "Æble" jest mniejsze niż "Apple", ale równe "AEble". Porównanie porządkowe, z drugiej strony, uwzględnia wartość "Apple" jako "Æble" i "Æble", aby była większa niż "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Skorzystaj z następujących ogólnych wskazówek, aby wybrać odpowiednią metodę sortowania lub porównywania ciągów:  
  
-   Jeśli chcesz, aby ciągi były uporządkowane w oparciu o kulturę użytkownika, należy uporządkować je na podstawie Konwencji bieżącej kultury. Jeśli kultura użytkownika ulegnie zmianie, porządek posortowanych ciągów również zostanie odpowiednio zmieniony. Na przykład aplikacja tezaurusa powinna zawsze sortować słowa na podstawie kultury użytkownika.  
  
-   Jeśli chcesz, aby ciągi były uporządkowane na podstawie Konwencji określonej kultury, należy je zamówić, dostarczając <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę do metody porównania. Na przykład w aplikacji zaprojektowanej do uczenia studentów w konkretnym języku, chcesz, aby ciągi były uporządkowane na podstawie Konwencji jednej z kultur, które mówią ten język.  
  
-   Jeśli chcesz, aby kolejność ciągów pozostała niezmieniona między kulturami, należy zamówić je na podstawie Konwencji niezmiennej kultury lub użyć porównania porządkowego. Można na przykład użyć sortowania porządkowego do organizowania nazw plików, procesów, muteksów lub nazwanych potoków.  
  
-   Aby zapoznać się z porównaniem obejmującym decyzję dotyczącą zabezpieczeń (np. czy nazwa użytkownika jest prawidłowa), należy zawsze wykonać test porządkowy dla równości, wywołując <xref:System.String.Equals%2A> metodę przeciążenia metody.  
  
> [!NOTE]
>  Zależne od kultury reguły sortowania i wielkości liter używane w porównaniu ciągów zależą od wersji platformy .NET. W .NET Framework 4,5 i nowszych wersjach uruchomionych w [!INCLUDE[win8](~/includes/win8-md.md)] systemie operacyjnym, sortowanie, wielkość liter, normalizacja i informacje o znakach Unicode są zgodne ze standardem Unicode 6,0. W innych systemach operacyjnych Windows jest zgodna ze standardem Unicode 5,0. W przypadku platformy .NET Core jest to zależne od wersji standardu Unicode obsługiwanego przez podstawowy system operacyjny. 
  
 Więcej informacji o regułach sortowania wyraz, String i porządkowych znajduje się w <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> temacie. Aby uzyskać dodatkowe zalecenia dotyczące sytuacji, w których należy użyć każdej reguły, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Zwykle nie są wywoływane metody porównywania ciągów, takie <xref:System.String.Compare%2A> jak bezpośrednie, aby określić kolejność sortowania ciągów. Zamiast tego metody porównania są wywoływane przez metody sortowania, takie <xref:System.Array.Sort%2A?displayProperty=nameWithType> jak <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>lub. W poniższym przykładzie wykonywane są cztery różne operacje sortowania (sortowanie wyrazów przy użyciu bieżącej kultury, sortowanie wyrazów przy użyciu niezmiennej kultury, sortowanie porządkowe i sortowanie ciągów przy użyciu niezmiennej kultury) bez jawnego wywołania metody porównywania ciągów. Mimo że określają typ porównania do użycia. Należy zauważyć, że każdy typ sortowania generuje unikatową kolejność ciągów w tablicy.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Wewnętrznie środowisko .NET używa kluczy sortowania do obsługi porównania ciągów wrażliwych na kulturę. Każdy znak w ciągu zawiera kilka kategorii wag sortowania, takich jak Alphabetic, Case i diakrytycznych. Klucz sortowania reprezentowany przez <xref:System.Globalization.SortKey> klasę zawiera repozytorium tych wag dla określonego ciągu. Jeśli aplikacja wykonuje dużą liczbę operacji wyszukiwania lub sortowania dla tego samego zestawu ciągów, można zwiększyć jej wydajność, generując i przechowując klucze sortowania dla wszystkich używanych przez niego ciągów. Gdy wymagana jest operacja sortowania lub porównywania, zamiast ciągów należy używać kluczy sortowania. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.SortKey> Klasa.  
  
 Jeśli nie określisz Konwencji porównywania ciągów, metody sortowania, takie <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> jak wykonywanie sortowania z uwzględnieniem wielkości liter w ciągach. Poniższy przykład ilustruje, jak zmiana bieżącej kultury wpływa na kolejność posortowanych ciągów w tablicy. Tworzy tablicę trzech ciągów. Po pierwsze ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwość na en-us i <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> wywołuje metodę. Powstały porządek sortowania jest oparty na konwencjach sortowania dla kultury angielskiej (Stany Zjednoczone). Następnie przykład ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwość na da-DK i ponownie <xref:System.Array.Sort%2A?displayProperty=nameWithType> wywołuje metodę. Zwróć uwagę, jak wynikowy porządek sortowania różni się od wyników en-US, ponieważ używa on Konwencji sortowania dla języka duńskiego (Dania).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Jeśli głównym celem w porównaniu ciągów jest określenie, czy są równe, należy wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metodę. Zazwyczaj należy użyć <xref:System.String.Equals%2A> do przeprowadzenia porównania porządkowego. <xref:System.String.Compare%2A?displayProperty=nameWithType> Metoda jest przeznaczona głównie do sortowania ciągów.  
  
 Metody wyszukiwania ciągów, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, również mogą wykonywać porównania ciągów z uwzględnieniem kultury lub porządkową. Poniższy przykład ilustruje różnice między porównaniem porządkowym i kulturowym przy użyciu <xref:System.String.IndexOf%2A> metody. Wyszukiwanie zależne od kultury, w którym bieżąca kultura jest w języku angielskim (Stany Zjednoczone) traktuje podciąg "OE" w celu dopasowania do ligatur "o". Ponieważ łącznik miękki (U + 00AD) jest znakiem o zerowej szerokości, wyszukiwanie traktuje łącznik miękki jako odpowiednik <xref:System.String.Empty> i znajduje dopasowanie na początku ciągu. Wyszukiwanie porządkowe, z drugiej strony, nie znajduje dopasowania w obu przypadkach.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Wyszukiwanie ciągów  
 Metody wyszukiwania ciągów, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, również mogą wykonywać porównania ciągów z uwzględnieniem kulturowym lub porządkowym, aby określić, czy znak lub podciąg zostanie znaleziony w określonym ciągu.  
  
 Metody wyszukiwania w <xref:System.String> klasie, która wyszukuje pojedynczy znak, taki <xref:System.String.IndexOf%2A> jak metoda lub jeden z zestawu <xref:System.String.IndexOfAny%2A> znaków, takich jak metoda, wszystkie wykonują wyszukiwanie porządkowe. Aby przeprowadzić wyszukiwanie znaków z uwzględnieniem kultury, należy wywołać <xref:System.Globalization.CompareInfo> metodę, taką jak <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> lub <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Należy zauważyć, że wyniki wyszukiwania znaku przy użyciu wartości porządkowej i porównywania kulturowego mogą być bardzo inne. Na przykład wyszukiwanie złożonego znaku Unicode, takiego jak ligatury "Æ" (U + 00C6), może pasować do każdego wystąpienia jego składników w poprawnej sekwencji, takiej jak "AE" (U + 041U + 0045), w zależności od kultury. Poniższy przykład ilustruje różnicę między <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> metodami i <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> podczas wyszukiwania pojedynczego znaku. Ligatury "æ" (U + 00E6) znajdują się w ciągu "anten" w przypadku stosowania Konwencji kultury en-US, ale nie w przypadku stosowania Konwencji kultury da-DK lub podczas przeprowadzania porównania porządkowego.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Z drugiej strony metody klasy <xref:System.String> , które wyszukują ciąg, a nie znak wykonują wyszukiwanie wrażliwe na kulturę, jeśli opcje wyszukiwania nie są jawnie określone przez parametr typu. <xref:System.StringComparison> Jedynym wyjątkiem jest <xref:System.String.Contains%2A>, który wykonuje wyszukiwanie porządkowe.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testowanie pod kątem równości  
 <xref:System.String.Compare%2A?displayProperty=nameWithType> Użyj metody, aby określić relację dwóch ciągów w kolejności sortowania. Zwykle jest to operacja zależna od kultury. Z kolei Wywołaj <xref:System.String.Equals%2A?displayProperty=nameWithType> metodę, aby sprawdzić równość. Ponieważ test pod kątem równości zwykle porównuje dane wprowadzane przez użytkownika z nieznanym ciągiem, takim jak prawidłowa nazwa użytkownika, hasło lub ścieżka systemu plików, jest zazwyczaj operacją porządkową.  
  
> [!WARNING]
>  Istnieje możliwość przetestowania pod kątem równości przez wywołanie <xref:System.String.Compare%2A?displayProperty=nameWithType> metody i określenie, czy zwracana wartość jest równa zero. Jednak ta metoda nie jest zalecana. Aby określić, czy dwa ciągi są równe, należy wywołać jedno z przeciążeń <xref:System.String.Equals%2A?displayProperty=nameWithType> metody. Preferowanym przeciążeniem wywołania jest metoda wystąpienia <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> lub metoda statyczna <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> , <xref:System.StringComparison?displayProperty=nameWithType> ponieważ obie metody zawierają parametr jawnie określający typ porównania.  
  
 Poniższy przykład ilustruje niebezpieczeństwo wykonywania porównania z uwzględnieniem kultury dla równości, gdy zamiast tego należy użyć numeru porządkowego. W takim przypadku celem kodu jest zabronienie dostępu systemu plików z adresów URL zaczynających się od "FILE://" lub "file://" przez wykonanie porównania bez uwzględniania wielkości liter początku adresu URL z ciągiem "FILE://". Jednakże jeśli porównanie wrażliwe na kulturę jest wykonywane przy użyciu kultury tureckiej (Turcja) na adres URL zaczynający się od "file://", porównanie dla równości nie powiedzie się, ponieważ turecki wielką literą małych liter "i" jest "i" zamiast "I". W efekcie dostęp do systemu plików jest przypadkowo dozwolony. Z drugiej strony, jeśli zostanie wykonane porównanie porządkowe, porównywanie dla równości powiedzie się i dostęp do systemu plików jest zabroniony.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalizacja  
 Niektóre znaki Unicode mają wiele reprezentacji. Na przykład dowolny z następujących punktów kodu może reprezentować literę "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Wiele reprezentacji pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowywanie i inne operacje na ciągach.  
  
 Standard Unicode definiuje proces o nazwie normalizing, który zwraca jedną reprezentację binarną znaku Unicode dla którejkolwiek z jego równoważnych reprezentacji binarnych. Normalizacja może używać kilku algorytmów nazywanych formularzami normalizacji, które są zgodne z różnymi regułami. Platforma .NET obsługuje normalizacji Unicode w postaci C, D, KC i KD. Gdy ciągi zostały znormalizowane do tego samego formularza normalizacji, można je porównać przy użyciu porównania porządkowego.  
  
 Porównanie porządkowe to binarne porównanie wartości skalarnej Unicode odpowiednich <xref:System.Char> obiektów w każdym ciągu. <xref:System.String> Klasa zawiera szereg metod, które mogą wykonać porównanie porządkowe, w tym następujące:  
  
-   Dowolne Przeciążenie <xref:System.String.Compare%2A>metod, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A> ,,<xref:System.String.EndsWith%2A> i<xref:System.String.LastIndexOf%2A> , które zawierają<xref:System.StringComparison> parametr. <xref:System.String.IndexOf%2A> Metoda wykonuje porównanie porządkowe w przypadku podania wartości <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase> dla tego parametru.  
  
-   Przeciążenia <xref:System.String.CompareOrdinal%2A> metody.  
  
-   Metody, które domyślnie korzystają z porównania porządkowego, <xref:System.String.Contains%2A>takie <xref:System.String.Replace%2A>jak, <xref:System.String.Split%2A>, i.  
  
-   Metody, które przeszukują <xref:System.Char> wartość lub dla elementów <xref:System.Char> w tablicy w wystąpieniu ciągu. Takie metody obejmują <xref:System.String.IndexOf%28System.Char%29> i <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Można określić, czy ciąg jest znormalizowany do normalizacji w postaci C, wywołując <xref:System.String.IsNormalized?displayProperty=nameWithType> metodę, lub można wywołać metodę, aby określić, <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> czy ciąg jest znormalizowany do określonego formularza normalizacji. Możesz również wywołać metodę, <xref:System.String.Normalize?displayProperty=nameWithType> Aby skonwertować ciąg na normalizację w postaci C lub można <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> wywołać metodę, aby przekonwertować ciąg na określony formularz normalizacji. Informacje krok po kroku dotyczące normalizacji i porównywania ciągów można znaleźć w <xref:System.String.Normalize> tematach i. <xref:System.String.Normalize%28System.Text.NormalizationForm%29>  
  
 Poniższy prosty przykład ilustruje normalizację ciągów. Definiuje literę "ố" na trzy różne sposoby w trzech różnych ciągach i używa porównania porządkowego dla równości, aby określić, że każdy ciąg różni się od pozostałych dwóch ciągów. Następnie konwertuje każdy ciąg na obsługiwane formularze normalizacji i ponownie wykonuje porównanie porządkowe każdego ciągu w określonym formularzu normalizacji. W każdym przypadku drugi test pod kątem równości pokazuje, że ciągi są równe.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Aby uzyskać więcej informacji na temat normalizacji i normalizacji, <xref:System.Text.NormalizationForm?displayProperty=nameWithType>Zobacz, a [także #15 w standardzie Unicode: Formy](https://unicode.org/reports/tr15/) normalizacji Unicode i [normalizacja często zadawane pytania](https://www.unicode.org/faq/normalization.html) w witrynie sieci Web Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operacje na ciągach według kategorii  
 <xref:System.String> Klasa zawiera elementy członkowskie do porównywania ciągów, testowania ciągów pod kątem równości, znajdowania znaków lub podciągów w ciągu, modyfikowania ciągu, wyodrębniania podciągów z ciągu, łączenia ciągów, formatowania wartości, kopiowania ciągu i normalizowanie ciągu.  
  
### <a name="comparing-strings"></a>Porównywanie ciągów  
 Można porównać ciągi, aby określić ich względne położenie w porządku sortowania przy użyciu następujących <xref:System.String> metod:  
  
-   <xref:System.String.Compare%2A>Zwraca liczbę całkowitą, która wskazuje związek jednego ciągu z drugim ciągiem w kolejności sortowania.  
  
-   <xref:System.String.CompareOrdinal%2A>Zwraca liczbę całkowitą, która wskazuje związek jednego ciągu z drugim ciągiem na podstawie porównania ich punktów kodowych.  
  
-   <xref:System.String.CompareTo%2A>Zwraca liczbę całkowitą, która wskazuje związek bieżącego wystąpienia ciągu z drugim ciągiem w kolejności sortowania. Metoda udostępnia implementacje <xref:System.IComparable%601> i dla <xref:System.String>klasy. <xref:System.IComparable> <xref:System.String.CompareTo%28System.String%29>  
  
### <a name="testing-strings-for-equality"></a>Testowanie ciągów pod kątem równości  
 Należy wywołać metodę <xref:System.String.Equals%2A> , aby określić, czy dwa ciągi są równe. Wystąpienie <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> i przeciążenia statyczne <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> pozwalają określić, czy porównanie ma być zależne od kultury, czy też w przypadku ignorowania. Większość testów dla równości to liczba porządkowa, a porównania równości, które określają dostęp do zasobów systemowych (takich jak obiekt systemu plików), powinny zawsze być porządkowe.  
  
### <a name="finding-characters-in-a-string"></a>Znajdowanie znaków w ciągu  
 <xref:System.String> Klasa zawiera dwa rodzaje metod wyszukiwania:  
  
-   Metody, które zwracają <xref:System.Boolean> wartość, aby wskazać, czy konkretny podciąg jest obecny w wystąpieniu ciągu. Należą do <xref:System.String.Contains%2A>nich metody <xref:System.String.EndsWith%2A>, i <xref:System.String.StartsWith%2A> .  
  
-   Metody wskazujące początkową pozycję podciągu w wystąpieniu ciągu. Należą do <xref:System.String.IndexOf%2A>nich metody <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>,, <xref:System.String.LastIndexOfAny%2A> i.  
  
> [!WARNING]
>  Jeśli chcesz wyszukać ciąg dla określonego wzorca, a nie określony podciąg, należy użyć wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz [wyrażenia regularne programu .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modyfikowanie ciągu  
 <xref:System.String> Klasa zawiera następujące metody, które pojawiają się w celu zmodyfikowania wartości ciągu:  
  
-   <xref:System.String.Insert%2A>Wstawia ciąg do bieżącego <xref:System.String> wystąpienia.  
  
-   <xref:System.String.PadLeft%2A>Wstawia jedno lub więcej wystąpień określonego znaku na początku ciągu.  
  
-   <xref:System.String.PadRight%2A>Wstawia jedno lub więcej wystąpień określonego znaku na końcu ciągu.  
  
-   <xref:System.String.Remove%2A>usuwa podciąg z bieżącego <xref:System.String> wystąpienia.  
  
-   <xref:System.String.Replace%2A>zamienia podciąg na inny podciąg w bieżącym <xref:System.String> wystąpieniu.  
  
-   <xref:System.String.ToLower%2A>i <xref:System.String.ToLowerInvariant%2A> Konwertuj wszystkie znaki w ciągu na małe litery.  
  
-   <xref:System.String.ToUpper%2A>i <xref:System.String.ToUpperInvariant%2A> Konwertuj wszystkie znaki w ciągu na wielkie litery.  
  
-   <xref:System.String.Trim%2A>usuwa wszystkie wystąpienia znaku od początku i końca ciągu.  
  
-   <xref:System.String.TrimEnd%2A>usuwa wszystkie wystąpienia znaku z końca ciągu.  
  
-   <xref:System.String.TrimStart%2A>usuwa wszystkie wystąpienia znaku od początku ciągu.  
  
> [!IMPORTANT]
>  Wszystkie metody modyfikacji ciągu zwracają nowy <xref:System.String> obiekt. Nie modyfikują wartości bieżącego wystąpienia.  
  
### <a name="extracting-substrings-from-a-string"></a>Wyodrębnianie podciągów z ciągu znaków  
 <xref:System.String.Split%2A?displayProperty=nameWithType> Metoda oddziela pojedynczy ciąg do wielu ciągów. Przeciążenia metody umożliwiają określenie wielu ograniczników, aby określić maksymalną liczbę podciągów wyznaczonych przez metodę i określić, czy puste ciągi (które występują w przypadku sąsiadujących ograniczników) są uwzględniane między zwracanymi ciągami.  
  
### <a name="combining-strings"></a>Łączenie ciągów  
 Do łączenia <xref:System.String> ciągów można używać następujących metod:  
  
-   <xref:System.String.Concat%2A>łączy jeden lub więcej podciągów w jeden ciąg.  
  
-   <xref:System.String.Join%2A>łączy jeden lub więcej podciągów w jeden element i dodaje separator między każdym podciągiem.  
  
### <a name="formatting-values"></a>Formatowanie wartości  
 <xref:System.String.Format%2A?displayProperty=nameWithType> Metoda używa funkcji formatowania złożonego, aby zastąpić jeden lub więcej symboli zastępczych w ciągu ciągiem reprezentującym jakiś obiekt lub wartość. <xref:System.String.Format%2A> Metoda jest często używana do wykonywania następujących czynności:  
  
-   Aby osadzić ciąg reprezentujący wartość liczbową w ciągu.  
  
-   Aby osadzić ciąg reprezentujący wartość daty i godziny w ciągu.  
  
-   Aby osadzić ciąg reprezentujący wartość wyliczenia w ciągu.  
  
-   Aby osadzić ciąg reprezentujący kilka obiektów, które obsługują <xref:System.IFormattable> interfejs w ciągu.  
  
-   Aby wyjustować lub justować do lewej, podciąg w polu w większym ciągu.  
  
 Aby uzyskać szczegółowe informacje na temat formatowania operacji i przykładów, <xref:System.String.Format%2A> Zobacz Podsumowanie przeciążenia.  
  
### <a name="copying-a-string"></a>Kopiowanie ciągu  
 Można wywołać następujące <xref:System.String> metody, aby utworzyć kopię ciągu:  
  
-   <xref:System.String.Clone%2A>Zwraca odwołanie do istniejącego <xref:System.String> obiektu.  
  
-   <xref:System.String.Copy%2A>tworzy kopię istniejącego ciągu.  
  
-   <xref:System.String.CopyTo%2A>kopiuje część ciągu do tablicy znaków.  
  
### <a name="normalizing-a-string"></a>Normalizowanie ciągu  
 W standardzie Unicode pojedynczy znak może mieć wiele punktów kodowych. Normalizacja konwertuje te znaki równoważne na tę samą reprezentację binarną. Metoda wykonuje normalizację, <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> a Metoda określa, czy ciąg jest znormalizowany. <xref:System.String.Normalize%2A?displayProperty=nameWithType>  
  
 Aby uzyskać więcej informacji i zapoznać się z przykładem, zapoznaj się z sekcją [normalizacji](#Normalization) wcześniej w tym temacie.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">Sortowanie tabel wagi dla systemów operacyjnych Windows</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Domyślna tabela elementów sortowania Unicode dla systemów Linux i macOS</related>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Najlepsze praktyki używania ciągów w programie .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
 [Składnia przeciążonego konstruktora](#Syntax)   
 [Wejściowe](#Params)   
 [Wyłączenia](#Exceptions)   
 [Którą metodę nazywam?](#Tasks)   
 [Tworzenie ciągów](#Creating_Strings)   
 [Obsługa powtarzających się ciągów](#Repetitive)   
 Przykłady tworzenia wystąpień ciągów:   
 [Używanie przypisania ciągu](#Ctor1_Example)  
 [Korzystanie z tablicy znaków](#Ctor2_Example)  
 [Użycie części tablicy znaków i powtarzanie pojedynczego znaku](#Ctor3_Example)  
 [Używanie wskaźnika do tablicy znaków](#Ctor4_Example)  
 [Używanie wskaźnika i zakresu tablicy](#Ctor5_Example)  
 [Używanie wskaźnika do podpisanej tablicy bajtów](#Ctor6_Example)  
[Informacje o wersji](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Przeciążona składnia konstruktora  
 Konstruktory ciągów dzielą się na dwie kategorie: te bez parametrów wskaźnika i z parametrami wskaźnika. Konstruktory używające wskaźników nie są zgodne ze specyfikacją CLS. Ponadto Visual Basic nie obsługuje użycia wskaźników i C# wymaga kodu, który używa wskaźników do uruchamiania w niebezpiecznym kontekście. Aby uzyskać więcej informacji, [niebezpieczny](~/docs/csharp/language-reference/keywords/unsafe.md)  
  
 Aby uzyskać dodatkowe wskazówki dotyczące wybierania przeciążenia, zobacz, [która metoda jest wywoływana?](#Tasks)  
  
 `String(Char[] value)`  
 Inicjuje nowe wystąpienie do wartości wskazanej przez tablicę znaków Unicode. Ten Konstruktor kopiuje znaki Unicode ([przykład](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicjuje nowe wystąpienie do wartości wskazanej przez tablicę znaków Unicode, początkową pozycję znaku w tej tablicy i długość ([przykład](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicjuje nowe wystąpienie do wartości wskazanej przez określony znak Unicode powtórzone określoną liczbę razy ([przykład](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy znaków Unicode, która kończy się znakiem null (U + 0000 lub ' \ 0 '). ([przykład](#Ctor4_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy znaków Unicode, początkowy znak w tej tablicy i długość. Konstruktor kopiuje znaki `value` Unicode z lokalizacji w indeksie `startIndex` `startIndex` i kończąc przy indeksie  +  `length` -1 ([przykład](#Ctor5_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value)`  
 **(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem. Przyjęto, że tablica reprezentuje ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowania określonego przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaki z `value` lokalizacji określonej przez wskaźnik do momentu osiągnięcia znaku null (0x00) ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tej tablicy i długości.  Przyjęto, że tablica reprezentuje ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowania określonego przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaki `startIndex` z wartości rozpoczynając od i kończąc na  +  `startIndex` `length` -1 ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, czyli pozycji początkowej w tej tablicy, długości i <xref:System.Text.Encoding> obiektu.  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametry  
 Poniżej znajduje się kompletna lista parametrów używanych przez <xref:System.String> konstruktory, które nie zawierają parametru wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Tablica znaków Unicode.|  
|`c`|<xref:System.Char>|Znak Unicode.|  
|`startIndex`|<xref:System.Int32>|Pozycja `value` początkowa pierwszego znaku w nowym ciągu.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba znaków w `value` do uwzględnienia w nowym ciągu.<br /><br /> Wartość domyślna:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Liczba powtórzeń znaku `c` w nowym ciągu. Jeśli `count` jest równa zero, wartość nowego obiektu to <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Poniżej znajduje się kompletna lista parametrów używanych przez <xref:System.String> konstruktory, które zawierają parametr wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> —lub—<br /><br /> <xref:System.SByte>\*|Wskaźnik do tablicy o wartościach Unicode zakończonych znakiem null lub tablicy 8-bitowych liczb całkowitych ze znakiem. Jeśli `value` jest `null` lub jest pustą tablicą, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Indeks elementu tablicy, który definiuje pierwszy znak w nowym ciągu.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba elementów tablicy, które mają zostać użyte do utworzenia nowego ciągu. Jeśli długość wynosi zero, Konstruktor tworzy ciąg, którego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Wartość domyślna:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Obiekt, który określa sposób `value` kodowania tablicy.<br /><br /> Wartość domyślna: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>lub bieżąca strona kodowa ANSI systemu|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Wyjątki  
 Poniżej znajduje się Lista wyjątków zgłoszonych przez konstruktory, które nie zawierają parametrów wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value`jest `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, lub `count` jest mniejsza od zera.<br /><br /> —lub—<br /><br /> Suma `startIndex` `value`i `length` jest większa niż liczba elementów w.<br /><br /> —lub—<br /><br /> `count`jest mniejsza od zera.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Poniżej znajduje się Lista wyjątków zgłoszonych przez konstruktory, które zawierają parametry wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value`Określa tablicę zawierającą nieprawidłowy znak Unicode.<br /><br /> —lub—<br /><br /> `value`lub `value` określaadres,`startIndex` który jest mniejszy niż 64 KB.  + <br /><br /> —lub—<br /><br /> Nie można <xref:System.String> zainicjować nowego wystąpienia `value` z tablicy bajtowej, ponieważ `value` nie używa domyślnego kodowania strony kodowej.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.ArgumentNullException>|`value`ma wartość null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Bieżący proces nie ma dostępu do odczytu do wszystkich znaków w adresie.<br /><br /> —lub—<br /><br /> `startIndex`lub `length` jest mniejsza od zera, `value`  +  `startIndex` powoduje przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich znaków.<br /><br /> —lub—<br /><br /> Długość nowego ciągu jest zbyt duża, aby można było przydzielić.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.AccessViolationException>|`value``value` lub -1`length` określa nieprawidłowyadres.`startIndex`  +   + |<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Zadanie|Wywołanie lub użycie|  
|--------|-----------------|  
|Utwórz ciąg.|Przypisanie z literału ciągu lub istniejącego ciągu ([przykład](#Ctor1_Example))|  
|Utwórz ciąg z całej tablicy znaków.|<xref:System.String.%23ctor%28System.Char%5B%5D%29>([przykład](#Ctor2_Example))|  
|Utwórz ciąg z części tablicy znaków.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([przykład](#Ctor3_Example))|  
|Utwórz ciąg powtarzający ten sam znak wielokrotnie.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([przykład](#Ctor3_Example))|  
|Utwórz ciąg ze wskaźnika do tablicy znaków Unicode lub szerokiej.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Utwórz ciąg z części tablicy Unicode lub Wide Character przy użyciu jej wskaźnika.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Utwórz ciąg z C++ `char` tablicy.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> —lub—<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Utwórz ciąg z znaków ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Tworzenie ciągów  
 Najczęściej stosowana technika tworzenia ciągów programistycznych jest prostym przypisaniem, jak pokazano w [tym przykładzie](#Ctor1_Example). <xref:System.String> Klasa zawiera również cztery typy przeciążeń konstruktorów, które umożliwiają tworzenie ciągów z następujących wartości:  
  
-   Z tablicy znaków (tablica znaków zakodowanych w formacie UTF-16). Można utworzyć nowy <xref:System.String> obiekt na podstawie znaków w całej tablicy lub jego części. <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiuje wszystkie znaki w tablicy do nowego ciągu. `startIndex` `startIndex`  +  Konstruktor kopiuje znaki z indeksu do indeksu`length` -1 do nowego ciągu. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Jeśli `length` jest równa zero, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Jeśli kod wielokrotnie tworzy wystąpienia ciągów, które mają taką samą wartość, można zwiększyć wydajność aplikacji przy użyciu alternatywnego sposobu tworzenia ciągów. Aby uzyskać więcej informacji, zobacz [Obsługa powtarzających się ciągów](#Repetitive).  
  
-   Z pojedynczego znaku, który jest zduplikowany zero, jeden lub więcej razy, za pomocą <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> konstruktora. Jeśli `count` jest równa zero, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Ze wskaźnika do tablicy znaków zakończonych znakiem null przy użyciu <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora or. <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Konstruktor kopiuje sekwencję znaków Unicode `startIndex` , rozpoczynając od określonego wskaźnika lub od określonego wskaźnika i i kontynuując do końca tablicy lub dla `length` znaków. Jeśli `value` jest wskaźnikiem typu null `length` lub jest zerem, Konstruktor tworzy ciąg, którego wartość to <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli operacja kopiowania przechodzi do końca tablicy, a tablica nie zostanie zakończona null, zachowanie konstruktora jest zależne od systemu. Taki warunek może spowodować naruszenie zasad dostępu.  
  
     Jeśli tablica zawiera wszystkie osadzone znaki null (U + 0000 lub ' \ 0 ') i <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> zostanie wywołana metoda przeciążenia, wystąpienie ciągu zawiera `length` znaki, w tym wszelkie osadzone wartości null. W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null, jest przesyłany do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest początkową tablicę, a wszystkie elementy w tablicy są dodawane do ciągu, Konstruktor tworzy wystąpienie ciągu z dziesięć znaków, w tym dwóch osadzonych wartości null. Z drugiej strony, jeśli ta sama tablica zostanie przekazana do <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora, wynik jest ciągiem zawierającym cztery znaki, który nie zawiera pierwszego znaku null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Tablica musi zawierać znaki Unicode. W C++, oznacza to, że tablica znaków musi być zdefiniowana jako typ zarządzany <xref:System.Char>[] lub niezarządzany`wchar_t`typ [].  
  
     `length`  +  `startIndex` <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Jeśli Przeciążenie jest wywołane i tablica nie została zakończona znakiem null lub jeśli Przeciążenie jest wywołane i-1 zawiera zakres, który poza pamięcią przydzieloną dla sekwencji znaków, <xref:System.String.%23ctor%28System.Char%2A%29> zachowanie konstruktora jest zależne od systemu i może wystąpić naruszenie zasad dostępu. Ponadto w procesorze Intel Itanium wywołania do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> konstruktora mogą <xref:System.DataMisalignedException> zgłosić wyjątek. W <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> takim przypadku Wywołaj zamiast niego.  
  
-   Ze wskaźnika do podpisanej tablicy bajtów. Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Sekwencję bajtów można interpretować przy użyciu domyślnego kodowania strony kodowej lub można określić kodowanie w wywołaniu konstruktora. Jeśli Konstruktor próbuje utworzyć wystąpienie ciągu `value` z całej tablicy, która nie jest zakończona zerem, lub jeśli zakres tablicy od do `value`  +  `startIndex`  +  `startIndex`  +  `length` -1 jest poza pamięcią przydzieloną dla tablicy, zachowanie tego konstruktora jest zależne od systemu i może wystąpić naruszenie zasad dostępu.  
  
     Trzy konstruktory, które zawierają podpisany tablicę bajtową jako parametr, są przeznaczone głównie do C++ `char` konwersji tablicy na ciąg, jak pokazano w tym przykładzie:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Jeśli tablica zawiera znaki null (' \ 0 ') lub bajty, których wartość jest równa 0 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> i zostanie wywołana metoda przeciążenia, wystąpienie ciągu `length` zawiera znaki, w tym wszelkie osadzone wartości null. W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null, jest przesyłany do <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest początkową tablicę, a wszystkie elementy w tablicy są dodawane do ciągu, Konstruktor tworzy wystąpienie ciągu z dziesięć znaków, w tym dwóch osadzonych wartości null. Z drugiej strony, jeśli ta sama tablica zostanie przekazana do <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora, wynik jest ciągiem zawierającym cztery znaki, który nie zawiera pierwszego znaku null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Ponieważ konstruktory <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> `value` i interpretują przy użyciu domyślnej strony kodowej ANSI, wywoływanie tych konstruktorów z identycznymi tablicami bajtowymi może tworzyć ciągi, które mają różne wartości w różnych systemach. <xref:System.String.%23ctor%28System.SByte%2A%29>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Obsługa powtarzających się ciągów  
 Aplikacje, które analizują lub dekodowania strumieni tekstu często <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> używają konstruktora <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> lub metody do konwertowania sekwencji znaków na ciąg. Wielokrotne tworzenie nowych ciągów o tej samej wartości zamiast tworzenia i ponownego używania jednego ciągu pamięci. Jeśli prawdopodobnie chcesz wielokrotnie utworzyć tę samą wartość ciągu przez wywołanie <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora, nawet jeśli nie wiesz, jakie są identyczne wartości ciągu, możesz zamiast tego użyć tabeli odnośników.  
  
 Załóżmy na przykład, że odczytywanie i analizowanie strumienia znaków z pliku zawierającego Tagi i atrybuty XML. Podczas analizowania strumienia często występują pewne tokeny (czyli sekwencje znaków, które mają znaczenie symboliczne). Tokeny równoważne z ciągami "0", "1", "true" i "false" mogą występować często w strumieniu XML.  
  
 Zamiast konwertować każdy token do nowego ciągu, można utworzyć <xref:System.Xml.NameTable?displayProperty=nameWithType> obiekt, który będzie przechowywać często występujące ciągi. <xref:System.Xml.NameTable> Obiekt podnosi wydajność, ponieważ pobiera przechowywane ciągi bez przydzielania pamięci tymczasowej. Gdy napotkasz token, użyj <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby pobrać token z tabeli. Jeśli token istnieje, metoda zwraca odpowiedni ciąg. Jeśli token nie istnieje, użyj <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby wstawić token do tabeli i uzyskać odpowiedni ciąg.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Przykład 1: Używanie przypisania ciągu  
 Poniższy przykład tworzy nowy ciąg, przypisując go literałem ciągu. Tworzy drugi ciąg przez przypisanie wartości pierwszego ciągu do niego. Są to dwa najczęstsze sposoby tworzenia wystąpienia nowego <xref:System.String> obiektu.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Przykład 2: Korzystanie z tablicy znaków  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt z tablicy znaków.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Przykład 3: Użycie części tablicy znaków i powtarzanie pojedynczego znaku  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt z części tablicy znaków i jak utworzyć nowy <xref:System.String> obiekt, który zawiera wiele wystąpień pojedynczego znaku.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Przykład 4: Używanie wskaźnika do tablicy znaków  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt ze wskaźnika do tablicy znaków. C# Przykład musi być skompilowany przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Przykład 5: Tworzenie wystąpienia ciągu ze wskaźnika i zakresu tablicy  
 Poniższy przykład analizuje elementy tablicy znaków dla kropki lub wykrzyknika. Jeśli zostanie znaleziony, tworzy wystąpienie ciągu znaków w tablicy, która poprzedza symbol interpunkcji. W przeciwnym razie tworzy wystąpienie ciągu z całą zawartością tablicy. C# Przykład musi być skompilowany przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Przykład 6: Tworzenie wystąpienia ciągu ze wskaźnika do podpisanej tablicy bajtów  
 Poniższy przykład ilustruje, jak można utworzyć wystąpienie <xref:System.String> klasy <xref:System.String.%23ctor%28System.SByte%2A%29> za pomocą konstruktora.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informacje o wersji  
 .NET Framework  
 Wszystkie przeciążenia są obsługiwane w programie: 4,5, 4, 3,5, 3,0, 2,0, 1,1, 1,0  
  
 .NET Framework Client Profile  
 Wszystkie przeciążenia są obsługiwane w programie: 4, 3,5 Z DODATKIEM SP1  
  
 Biblioteka klas przenośnych  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane  
  
 Środowisko .NET dla aplikacji do Sklepu Windows  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane w programie: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode zakończonych wartością null.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżący proces nie ma dostępu do odczytu do wszystkich znaków w adresie.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />Określa tablicę zawierającą nieprawidłowy znak Unicode lub <paramref name="value" /> określa adres mniejszy niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez tablicę znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy zakończonych znakiem null 8-bitowych liczb całkowitych ze znakiem. Liczby całkowite są interpretowane przy użyciu bieżącego kodowania strony kodowej systemu (czyli kodowania określonego przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest zakodowana w ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość nowego ciągu do zainicjowania, która jest określana przez znak zakończenia null elementu <paramref name="value" />, jest zbyt duża do przydzielenia.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />określa nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode.</param>
        <param name="count">Liczba wystąpień <paramref name="c" /> .</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony znak Unicode powtórzony określoną liczbę razy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode.</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="length">Liczba znaków <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy znaków Unicode, początkowej pozycji znaku w tej tablicy i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera, <paramref name="value" />  +  <paramref name="startIndex" /> powoduje przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich znaków.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />Określa tablicę zawierającą nieprawidłowy znak Unicode lub <paramref name="value" />  +  <paramref name="startIndex" /> określa adres mniejszy niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="length">Liczba znaków <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez tablicę znaków Unicode, początkową pozycję znaku w tej tablicy i długość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.  
  
—lub— 
Suma <paramref name="startIndex" /> <paramref name="value" />i <paramref name="length" /> jest większa niż liczba elementów w.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem. Liczby całkowite są interpretowane przy użyciu bieżącego kodowania strony kodowej systemu (czyli kodowania określonego przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="length">Liczba znaków <paramref name="value" /> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tej tablicy i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.  
  
—lub— 
Adres określony przez <paramref name="value" />  +  jestzadużydlabieżącejplatformy;oznaczato,żeObliczanieadresuzostałoprzepływane.<paramref name="startIndex" />  
  
—lub— 
Długość nowego ciągu do zainicjowania jest zbyt duża, aby można było przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Adres określony przez <paramref name="value" />  +  jestmniejszyniż64KB<paramref name="startIndex" /> .  
  
—lub— 
Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest zakodowana w ANSI.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> i<paramref name="length" /> zbiorczo Określ nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="length">Liczba znaków <paramref name="value" /> do użycia.</param>
        <param name="enc">Obiekt, który określa sposób kodowania tablicy, do <paramref name="value" /> której się odwołuje. Jeśli <paramref name="enc" /> jest<see langword="null" />, założono kodowanie ANSI.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, czyli pozycji początkowej w tej tablicy, długości <see cref="T:System.Text.Encoding" /> i obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.  
  
—lub— 
Adres określony przez <paramref name="value" />  +  jestzadużydlabieżącejplatformy;oznaczato,żeObliczanieadresuzostałoprzepływane.<paramref name="startIndex" />  
  
—lub— 
Długość nowego ciągu do zainicjowania jest zbyt duża, aby można było przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Adres określony przez <paramref name="value" />  +  jestmniejszyniż64KB<paramref name="startIndex" /> .  
  
—lub— 
Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest <paramref name="enc" />zakodowany jako określony przez.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> i<paramref name="length" /> zbiorczo Określ nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w bieżącym ciągu.</param>
        <summary>Pobiera obiekt w określonym położeniu w bieżącym <see cref="T:System.String" /> obiekcie. <see cref="T:System.Char" /></summary>
        <value>Obiekt w położeniu <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest oparty na zero.  
  
 Ta właściwość zwraca <xref:System.Char> obiekt na pozycji określonej `index` przez parametr. Jednak znak Unicode może być reprezentowany przez więcej niż jeden <xref:System.Char>. Użyj klasy do pracy ze znakami Unicode <xref:System.Char> zamiast obiektów. <xref:System.Globalization.StringInfo?displayProperty=nameWithType> Aby uzyskać więcej informacji, zobacz sekcję "znaki obiektów i Unicode" w <xref:System.String> temacie Omówienie klasy.  
  
 W programie C#indeksatorem. <xref:System.String.Chars%2A> W Visual Basic jest to domyślna właściwość <xref:System.String> klasy. Dla <xref:System.Char> każdego obiektu w ciągu można uzyskać dostęp za pomocą kodu, takiego jak poniższy.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak można użyć tego indeksatora w procedurze do walidacji ciągu.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />jest większa niż lub równa długości tego obiektu lub mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>To wystąpienie <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana nie jest niezależną kopią tego wystąpienia; jest to po prostu inny widok tych samych danych. Użyj metody <xref:System.String.CopyTo%2A> <xref:System.String> lub, aby utworzyć oddzielny obiekt o tej samej wartości co to wystąpienie. <xref:System.String.Copy%2A>  
  
 <xref:System.String.Clone%2A> Ponieważ metoda po prostu zwraca istniejące wystąpienie ciągu, istnieje niewielki powód, aby wywołać go bezpośrednio.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie przeciążenia <xref:System.String.Compare%2A> metody zwracają 32-bitową liczbę całkowitą ze znakiem wskazującą, że relacja leksykalna między dwoma comparands.  
  
|Wartość|Warunek|  
|-----------|---------------|  
|Mniej niż zero|Pierwszy podciąg poprzedza drugi podciąg w kolejności sortowania.|  
|Zero|Podciągi występują w tym samym położeniu w kolejności sortowania lub `length` są równe zero.|  
|Większe od zera|Pierwszy podciąg jest zgodny z drugim podciągiem w kolejności sortowania.|  
  
> [!WARNING]
>  Zawsze, gdy jest to możliwe, należy wywołać Przeciążenie <xref:System.String.Compare%2A> metody, która <xref:System.StringComparison> zawiera parametr. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Najlepsze praktyki używania ciągów w programie .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
> [!WARNING]
>  Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Poniższy przykład wywołuje metodę, <xref:System.String.Compare%28System.String%2CSystem.String%29> aby porównać trzy zestawy ciągów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 W poniższym przykładzie `ReverseStringComparer` Klasa pokazuje, jak można obliczyć dwa ciągi <xref:System.String.Compare%2A> za pomocą metody.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie z uwzględnieniem kultury "zwierzę" z "/-źle" (przy użyciu łącznika miękkiego lub U + 00AD) wskazuje, że dwa ciągi są równoważne.  
  
[! code-CSharp[System. String. Compare # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! code — VB[System. String. Compare # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla `comparisonType` parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty, ignorując lub honoruje ich przypadki i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
> [!WARNING]
>  Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, że <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> Metoda jest równoważna z użyciem <xref:System.String.ToUpper%2A> lub <xref:System.String.ToLower%2A> podczas porównywania ciągów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie bez uwzględniania wielkości liter dla "zwierzęcia" z "/-unpoufne" (przy użyciu łącznika nietrwałego lub U + 00AD) wskazuje, że dwa ciągi są równoważne.  
  
[! code-CSharp[System. String. Compare # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! code — VB[System. String. Compare # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty przy użyciu określonych reguł i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />znajduje się w tym samym położeniu, co <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie powinno korzystać z bieżącej lub niezmiennej kultury, przestrzegać lub ignorowania wielkości liter comparands, czy też używać reguł sortowania programu Word (z uwzględnieniem kultury) lub liczby porządkowej (bez uwzględniania kultur).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe końcowi jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Poniższy przykład porównuje trzy wersje litery "I". Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" />nie jest obsługiwana.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <param name="culture">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty, ignorując lub honoruje ich przypadki, i przy użyciu informacji specyficznych dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejność alfabetyczna poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak kultura może wpływać na porównanie. W kulturze Czeskiej, "ch" jest pojedynczym znakiem, który jest większy niż "d". Jednak w języku angielskim Stany Zjednoczone kultura "ch" składa się z dwóch znaków, a "c" jest mniejsze niż "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie bez uwzględniania wielkości liter "zwierzę" z "/-źle" (przy użyciu łącznika miękkiego lub U + 00AD) przy użyciu niezmiennej kultury wskazuje, że dwa ciągi są równoważne.  
  
[! code-CSharp[System. String. Compare # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! code — VB[System. String. Compare # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="culture">Kultura, która dostarcza informacje porównawcze specyficzne dla kultury.</param>
        <param name="options">Opcje do użycia podczas przeprowadzania porównania (na przykład ignorowanie wielkości liter lub symboli).</param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty przy użyciu określonych opcji porównania i informacje specyficzne dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje relację dwóch ciągów do siebie w kolejności sortowania.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem wskazująca leksykalną <paramref name="strA" /> relację między i <paramref name="strB" />, jak pokazano w poniższej tabeli. 
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejności alfabetycznej poszczególnych znaków. Na przykład dana kultura może określać, że niektóre kombinacje znaków mają być traktowane jako pojedynczy znak, że wielkie i małe litery są porównywane w określony sposób lub że kolejność sortowania znaku zależy od znaków, które przed lub po nim.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji. Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne (to znaczy, gdy celem wywołania metody jest przetestowanie wartości zwracanej przez zero). Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.  
  
 Porównanie można dokładniej określić za pomocą `options` parametru, który składa się z co najmniej jednego <xref:System.Globalization.CompareOptions> elementu członkowskiego wyliczenia. Ponieważ jednak celem tej metody jest przeprowadzenie porównania ciągów z uwzględnieniem kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> wartości i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> nie mają żadnego efektu.  
  
 Może to być `null`albo oba comparands. Według definicji, dowolnego ciągu, w <xref:System.String.Empty?displayProperty=nameWithType>tym, porównuje więcej niż odwołanie o wartości null i dwa odwołania o wartości null są porównywane ze sobą.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe końcu jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy.  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa ciągi na trzy różne sposoby: przy użyciu porównania lingwistyczne dla kultury en-US; użycie porównania z uwzględnieniem wielkości liter w kulturze en-US; i przy użyciu porównania porządkowego. Ilustruje to, jak trzy metody porównania dają trzy różne wyniki.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie <see cref="T:System.Globalization.CompareOptions" /> jest wartością.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja podciągu w elemencie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja podciągu w elemencie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem wskazująca, że relacja leksykalna między dwoma comparands.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągi, które mają zostać porównane `indexA` , rozpoczynają `indexB`się w `strA` i w `strB` . Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i ma wartość zero. Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`. Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
> [!WARNING]
>  Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągi.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.  
  
—lub— 
Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe. Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja podciągu w elemencie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja podciągu w elemencie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów, ignorując lub honoruje ich wielkości liter i zwraca liczbę całkowitą, która wskazuje ich względne położenie w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągi, `strA` które mają zostać porównane `indexA`, zaczynają się `indexB`w, i w `strB` . Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i ma wartość zero. Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`. Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
> [!WARNING]
>  Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Nazwa ścieżki musi być porównana w sposób niezmienny. Prawidłowy kod jest następujący:  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Poniższy przykład wykonuje dwa porównania dwóch podciągów, które różnią się tylko wielkością liter. Pierwsze porównanie ignoruje wielkość liter, a drugie porównanie uwzględnia wielkość liter.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.  
  
—lub— 
Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe. Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja podciągu w elemencie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja podciągu w elemencie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przy użyciu określonych reguł i zwraca liczbę całkowitą wskazującą ich położenie względne w kolejności sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> parametr ma wartość zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągi, które mają zostać porównane `indexA` , rozpoczynają `indexB`się w `strA` i w `strB` . Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i znajduje się na pozycji zero, a nie na pozycji 1. Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`. Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 `comparisonType` Parametr wskazuje, czy porównanie powinno korzystać z bieżącej lub niezmiennej kultury, przestrzegać lub ignorowania wielkości liter comparands, czy też używać reguł sortowania programu Word (z uwzględnieniem kultury) lub liczby porządkowej (bez uwzględniania kultur).  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe końcowi jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągi.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.  
  
—lub— 
Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe. Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja podciągu w elemencie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja podciągu w elemencie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <param name="culture">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów, ignorując lub honoruje ich przypadki i wykorzystując informacje specyficzne dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalną relację między dwoma comparands.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągi, `strA` które mają zostać porównane `indexA`, zaczynają się `indexB`w, i w `strB` . Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i znajduje się na pozycji zero, a nie na pozycji 1. Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden. Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`. Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejność alfabetyczna poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
 Może to być `null`jeden lub oba comparands. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągi przy użyciu różnych kultur i ignorując wielkość liter podciągów. Wybór kultury ma wpływ na sposób porównywania litery "I".  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.  
  
—lub— 
Albo <paramref name="strA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="strB" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe. Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja początkowa podciągu w elemencie <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja początkowa podciągu w elemencie <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="culture">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</param>
        <param name="options">Opcje do użycia podczas przeprowadzania porównania (na przykład ignorowanie wielkości liter lub symboli).</param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przy użyciu określonych opcji porównania i informacji specyficznych dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje na relację dwóch podciągów na siebie w kolejność sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalną relację między dwoma podciągami, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podciągi, które mają `strA` zostać porównane, zaczynają się na `indexB`pozycji `indexA` i w `strB` na pozycji. Długość pierwszego podciągu jest długością `strA` znaku minus. `indexA` Długość drugiego podciągu jest długością `strB` minus. `indexB`  
  
 Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`. Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejności alfabetycznej poszczególnych znaków. Na przykład dana kultura może określać, że niektóre kombinacje znaków mają być traktowane jako pojedynczy znak, że wielkie i małe litery są porównywane w określony sposób lub że kolejność sortowania znaku zależy od znaków, które przed lub po nim.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji. Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa podciągi są równoważne (to znaczy, gdy celem wywołania metody jest przetestowanie wartości zwracanej przez zero). Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.  
  
 Jeden lub oba z `strA` i `strB` mogą być `null`. Według definicji, dowolnego ciągu, w <xref:System.String.Empty?displayProperty=nameWithType>tym, porównuje więcej niż odwołanie o wartości null i dwa odwołania o wartości null są porównywane ze sobą.  
  
 Porównanie można dokładniej określić za pomocą `options` parametru, który składa się z co najmniej jednego <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> elementu członkowskiego wyliczenia. Ponieważ jednak celem tej metody jest przeprowadzenie porównania ciągów z uwzględnieniem kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> wartości i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> nie mają żadnego efektu.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe końcu jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodę w celu porównania ostatnich nazw dwóch osób. Następnie wyświetla je w kolejności alfabetycznej.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie <see cref="T:System.Globalization.CompareOptions" /> jest wartością.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" />jest większa niż <paramref name="strA" />. <see langword=".Length" />  
  
—lub— 
 <paramref name="indexB" />jest większa niż <paramref name="strB" />. <see langword=".Length" />  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.  
  
—lub— 
Albo <paramref name="strA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="strB" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe. Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje <see cref="T:System.String" /> dwa obiekty, oceniając wartości liczbowe odpowiednich <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.String" /> określone obiekty przez ocenę wartości liczbowych odpowiednich <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalną relację między dwoma comparands.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="strA" />jest mniejsze niż <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" />i <paramref name="strB" /> są równe.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="strA" />jest większa niż <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter przy użyciu reguł sortowania porządkowego. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie. Aby wykonać porównanie bez uwzględniania wielkości liter przy użyciu reguł sortowania porządkowego, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Wywołaj metodę `comparisonType` z argumentem <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>ustawionym na.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest `strB` `null`metodą statyczną i może być. `strA` Jeśli obie wartości są `null`, metoda zwraca 0 (zero), co oznacza, że `strA` i `strB` są równe. Jeśli jest `null`tylko jedna z wartości, Metoda traktuje wartość inną niż null, aby była większa.  
  
   
  
## Examples  
 Poniższy przykład wykonuje i porównywanie porządkowe dwóch ciągów, które różnią się tylko wielkością liter.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Początkowy indeks podciągu w <paramref name="strA" />.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Początkowy indeks podciągu w <paramref name="strB" />.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przez obliczenie wartości liczbowych odpowiednich <see cref="T:System.Char" /> obiektów w każdym podciągu.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Podciąg w <paramref name="strA" /> jest krótszy niż podciąg w <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> Podciągi są równe lub <paramref name="length" /> wynosi zero.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Podciąg w <paramref name="strA" /> jest większy niż podciąg w <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.  
  
 `strA` Liczba porównywanych znaków to mniejsza długość mniejsza `indexA`, długość `strB` mniejsza `indexB`i `length`.  
  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter przy użyciu reguł sortowania porządkowego. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie. Aby wykonać porównanie bez uwzględniania wielkości liter przy użyciu reguł sortowania porządkowego, <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> Wywołaj metodę `comparisonType` z argumentem <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>ustawionym na.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest `strB` `null`metodą statyczną i może być. `strA` Jeśli obie wartości są `null`, metoda zwraca 0 (zero), co oznacza, że `strA` i `strB` są równe. Jeśli jest `null`tylko jedna z wartości, Metoda traktuje wartość inną niż null, aby była większa.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, że <xref:System.String.CompareOrdinal%2A> i <xref:System.String.Compare%2A> używa różnych kolejności sortowania.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" />nie <see langword="null" /> jest i <paramref name="indexA" /> jest większe niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="strB" />nie <see langword="null" /> jest i <paramref name="indexB" /> jest większe niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
—lub— 
 <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie z określonym obiektem <see cref="T:System.String" /> lub i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania co określony obiekt <see cref="T:System.String" />lub.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba przeciążenia <xref:System.String.CompareTo%2A> metody wykonują dane zależne od kultury i wielkości liter. Nie można użyć tej metody do wykonania porównania bez uwzględniania kultury ani liczby porządkowej. W przypadku przejrzystości kodu zalecamy uniknięcie <xref:System.String.CompareTo%2A> metody i <xref:System.String.Compare%2A> wywołanie metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który jest obliczany przez <see cref="T:System.String" />.</param>
        <summary>Porównuje to wystąpienie z określonym <see cref="T:System.Object" /> i wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania, jak określono <see cref="T:System.Object" />.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności <paramref name="value" /> sortowania jako parametr.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie poprzedza <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie ma tę samą pozycję w kolejności sortowania, co <paramref name="value" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest <paramref name="value" />następujące.  
  
—lub— 
 <paramref name="value" />jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`musi być <xref:System.String> obiektem.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metoda została zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji. Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne. Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
 Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> uwagi w metodzie.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.String.CompareTo%2A> metody <xref:System.Object>z. Ponieważ próbuje porównać <xref:System.String> wystąpienie `TestClass` z obiektem <xref:System.ArgumentException>, metoda zgłasza.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie <see cref="T:System.String" />jest.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.CompareTo(System.Object)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "/-un--(using the Soft łącznik lub U + 00AD) wskazuje, że dwa ciągi są równoważne.  
  
[! code-CSharp[System. String. CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code — VB[System. String. CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodę.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Ciąg, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Porównuje to wystąpienie z określonym <see cref="T:System.String" /> obiektem i wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania co określony ciąg.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności <paramref name="strB" /> sortowania jako parametr.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie poprzedza <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie ma tę samą pozycję w kolejności sortowania, co <paramref name="strB" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest <paramref name="strB" />następujące.  
  
—lub— 
 <paramref name="strB" />jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metoda została zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji. Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne. Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.  
  
 Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję <xref:System.String.Compare%28System.String%2CSystem.String%29> uwagi w metodzie.  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepszą <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> niż metoda, ponieważ nie `strB` musi określać, czy argument jest typem wartości modyfikowalnej, który musi być opakowany i nie musi rzutować parametr z elementu <xref:System.Object> <xref:System.String>do.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.String.CompareTo%2A> metodę, aby porównać bieżące wystąpienie ciągu z innym ciągiem.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 W poniższym przykładzie zademonstrowano ogólne i nieogólne wersje metody CompareTo dla kilku typów wartości i elementów referencyjnych.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zestawy znaków obejmują znaki do pominięcia. <see cref="M:System.String.CompareTo(System.String)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury. Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "/-un--(using the Soft łącznik lub U + 00AD) wskazuje, że dwa ciągi są równoważne.  
  
[! code-CSharp[System. String. CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code — VB[System. String. CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodę.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy jedno lub więcej wystąpień <see cref="T:System.String" /> <see cref="T:System.String" /> lub reprezentacje wartości <see cref="T:System.Object" />jednego lub większej liczby wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  Można również użyć operatora łączenia ciągów języka, takiego `+` jak w C#, lub `&` i `+` w Visual Basic, aby połączyć ciągi. Oba kompilatory tłumaczą operator łączenia na wywołanie jednego z przeciążeń `String.Concat`. 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> i którego argument typu ogólnego jest <see cref="T:System.String" />.</param>
        <summary>Łączy elementy członkowskie skonstruowanej <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcji typu. <see cref="T:System.String" /></summary>
        <returns>Połączone ciągi w <paramref name="values" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="values" /> są puste <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników. Aby określić ogranicznik między poszczególnymi elementami członkowskimi `values`, należy <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> wywołać metodę.  
  
 Ciąg jest używany zamiast dowolnego elementu null w `values`. <xref:System.String.Empty>  
  
 Jeśli `values` jest pusty `IEnumerable(Of String)`, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `values` jest `null` ,<xref:System.ArgumentNullException> Metoda zgłasza wyjątek.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów na tablicę ciągów. Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ). Poniższy przykład przekazuje `List(Of String)` obiekt zawierający wielkie lub małe litery alfabetu do wyrażenia lambda, które wybiera litery, które są równe lub większe niż określona litera (w tym przykładzie jest to "M"). Kolekcja zwracana <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> przez metodę jest przekazana do metodywceluwyświetleniawynikujakopojedynczegociągu.<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> `IEnumerable(Of String)`  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, który następnie przekazuje <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Obiekt reprezentujący lub <see langword="null" />.</param>
        <summary>Tworzy reprezentację ciągu określonego obiektu.</summary>
        <returns>Ciąg reprezentujący wartość <paramref name="arg0" />lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="arg0" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda reprezentuje `arg0` jako ciąg`ToString` przez wywołanie metody bez parametrów. <xref:System.String.Concat%28System.Object%29>  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, która zawiera elementy do łączenia.</param>
        <summary>Łączy reprezentacje ciągów elementów w określonej <see cref="T:System.Object" /> tablicy.</summary>
        <returns>Połączone ciągi reprezentujące wartości elementów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `args` przez wywołanie `ToString` metody bez parametrów tego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego obiektu o wartości null w tablicy.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.String.Concat%2A> metody <xref:System.Object> z tablicą.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage"><para>Ta metoda nie jest wywoływana przez C++ kod. C++ Kompilator rozpoznaje wywołania <see cref="Overload:System.String.Concat" /> , które mają <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />co najmniej cztery parametry obiektu jako wywołanie.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Tablica wystąpień ciągu.</param>
        <summary>Łączy elementy określonej <see cref="T:System.String" /> tablicy.</summary>
        <returns>Połączone elementy <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu o wartości null w tablicy.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.String.Concat%2A> metody <xref:System.String> z tablicą.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do łączenia.</param>
        <param name="arg1">Drugi obiekt do łączenia.</param>
        <summary>Łączy reprezentacje ciągów dwóch określonych obiektów.</summary>
        <returns>Połączone ciąg reprezentujący wartości <paramref name="arg0" /> i. <paramref name="arg1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0` i `arg1` wywołuje `ToString` metodę bezparametrów`arg1`i;nie dodaje żadnych ograniczników. `arg0`  
  
 <xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.  
  
 Jeśli jeden z argumentów jest odwołaniem do tablicy, Metoda łączy ciąg reprezentujący tę tablicę zamiast jej elementów członkowskich (na przykład "System. String []").  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str1">Drugi zakres znaków tylko do odczytu do łączenia.</param>
        <summary>Łączy ciąg reprezentujący dwa określone zakresy znaków tylko do odczytu.</summary>
        <returns>Połączone ciąg reprezentujący wartości <paramref name="str0" /> i. <paramref name="str1" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <summary>Łączy dwa określone wystąpienia elementu <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" /> i <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0` i `str1`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu o wartości null.  
  
## Examples  
 Poniższy przykład łączy imię, drugie imię i nazwisko osoby.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do łączenia.</param>
        <param name="arg1">Drugi obiekt do łączenia.</param>
        <param name="arg2">Trzeci obiekt do łączenia.</param>
        <summary>Łączy ciąg reprezentujący trzy określone obiekty.</summary>
        <returns>Połączone ciąg reprezentujący wartości <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0` `ToString` , `arg1` i`arg2` przez wywołanie metody bez parametrów każdego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str1">Drugi zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str2">Trzeci zakres znaków tylko do odczytu do łączenia.</param>
        <summary>Łączy ciąg reprezentujący trzy określone zakresy znaków tylko do odczytu.</summary>
        <returns>Połączone ciąg reprezentujący wartości <paramref name="str0" />, <paramref name="str1" /> i <paramref name="str2" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <param name="str2">Trzeci ciąg do łączenia.</param>
        <summary>Łączy trzy określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" />, <paramref name="str1" />i. <paramref name="str2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`i `str2`; nie dodaje żadnych ograniczników.  
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.String.Concat%2A> metodę, aby połączyć trzy ciągi i wyświetlić wynik.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do łączenia.</param>
        <param name="arg1">Drugi obiekt do łączenia.</param>
        <param name="arg2">Trzeci obiekt do łączenia.</param>
        <param name="arg3">Czwarty obiekt do łączenia.</param>
        <summary>Łączy reprezentacje ciągów czterech określonych obiektów i wszystkich obiektów określonych w opcjonalnej liście parametrów o zmiennej długości.</summary>
        <returns>Reprezentacja połączonego ciągu dla każdej wartości na liście parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze specyfikacją <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>CLS ma wartość. Kompilatory C# i Visual Basic automatycznie rozwiązują wywołanie tej metody jako wywołanie <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Metoda łączy każdy obiekt na liście parametrów przez wywołanie `ToString` metody bez parametrów; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.  
  
> [!NOTE]
>  Ostatni parametr <xref:System.String.Concat%2A> metody jest opcjonalną rozdzielaną przecinkami listą co najmniej jednego obiektu, który można połączyć.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody do łączenia listy parametrów zmiennych. W tym przypadku metoda jest wywoływana z dziewięcioma parametrami.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest oznaczona za pomocą <see langword="vararg" /> słowa kluczowego, co oznacza, że obsługuje zmienną liczbę parametrów. Metodę można wywołać z wizualizacji C++, ale nie można jej wywołać z C# lub Visual Basic kodzie. Kompilatory C# i Visual Basic rozwiązują wywołania <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> jako wywołania do. <see cref="M:System.String.Concat(System.Object[])" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str1">Drugi zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str2">Trzeci zakres znaków tylko do odczytu do łączenia.</param>
        <param name="str3">Czwarty zakres znaków tylko do odczytu do łączenia.</param>
        <summary>Łączy ciąg reprezentujący cztery określone zakresy znaków tylko do odczytu.</summary>
        <returns><paramref name="str0" />Połączone ciąg reprezentujący wartości, <paramref name="str1" />, <paramref name="str2" /> i <paramref name="str3" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do łączenia.</param>
        <param name="str1">Drugi ciąg do łączenia.</param>
        <param name="str2">Trzeci ciąg do łączenia.</param>
        <param name="str3">Czwarty ciąg do łączenia.</param>
        <summary>Łączy cztery określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie <paramref name="str0" />, <paramref name="str1" />, ,<paramref name="str2" />i .<paramref name="str3" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`, `str2`i ;niedodajeżadnychograniczników.`str3`  
  
## Examples  
 Poniższy przykład definiuje tablicę zawierającą cztery litery słów i zapisuje poszczególne litery w tablicy ciągów, aby je zaszyfrować. Następnie wywołuje <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodę, aby ponownie połączyć zaszyfrowane słowa.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <paramref name="values" />.</typeparam>
        <param name="values">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> interfejs.</param>
        <summary>Łączy elementy członkowskie <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementacji.</summary>
        <returns>Połączone elementy członkowskie w <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu o wartości null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania elementów na ciągi. Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ), jak pokazano w przykładzie. Ciąg reprezentujący każdy obiekt w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano bardzo prostą `Animal` klasę, która zawiera nazwę zwierzęcia i kolejność, do której należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, aby zawierał `Animal` kilka obiektów. Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiektów, `Order` których właściwość jest równa "gryzonie". <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Wynik jest przesyłany do <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody i wyświetlany w konsoli programu.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Znak, który ma zostać przeszukany.</param>
        <summary>Zwraca wartość wskazującą, czy określony znak występuje w tym ciągu.</summary>
        <returns><see langword="true" />Jeśli parametr występuje w tym ciągu; w przeciwnym razie <see langword="false" />,. <paramref name="value" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Zwraca wartość wskazującą, czy w tym ciągu występuje określony podciąg.</summary>
        <returns><see langword="true" />Jeśli parametr występuje w tym ciągu lub jeśli <paramref name="value" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe). Wyszukiwanie rozpoczyna się od pierwszego położenia znaku tego ciągu i jest kontynuowane przez ostatnią pozycję znaku.  
  
 Aby określić, czy ciąg zawiera określony podciąg, przy użyciu innego niż porównanie porządkowe (takie jak porównanie z uwzględnieniem kultury lub porządkową bez uwzględniania wielkości liter), można utworzyć metodę niestandardową. Poniższy przykład ilustruje takie podejście. Definiuje <xref:System.String> metodę rozszerzenia, która <xref:System.StringComparison> zawiera parametr i wskazuje, czy ciąg zawiera podciąg przy użyciu określonej formy porównania ciągów.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Poniższy przykład wywołuje metodę rozszerzenia, `Contains` aby określić, czy podciąg zostanie znaleziony w ciągu podczas korzystania z porównania porządkowego i porównywania porządkowego bez uwzględniania wielkości liter.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Jeśli interesuje Cię pozycja podciągu `value` w bieżącym wystąpieniu, możesz <xref:System.String.IndexOf%2A> wywołać metodę, aby uzyskać początkową pozycję pierwszego wystąpienia <xref:System.String.LastIndexOf%2A> lub wywołać metodę w celu uzyskania pozycji początkowej ostatnie wystąpienie. Przykład zawiera wywołanie metody, <xref:System.String.IndexOf%28System.String%29> Jeśli podciąg zostanie znaleziony w wystąpieniu ciągu.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg "Fox" jest podciągiem znanej oferty. Jeśli w ciągu znaleziono "Fox", wyświetlana jest również jego pozycja początkowa.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Znak, który ma zostać przeszukany.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Zwraca wartość wskazującą, czy określony znak występuje w tym ciągu, przy użyciu określonych reguł porównywania.</summary>
        <returns><see langword="true" />Jeśli parametr występuje w tym ciągu; w przeciwnym razie <see langword="false" />,. <paramref name="value" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Zwraca wartość wskazującą, czy określony ciąg występuje w tym ciągu, przy użyciu określonych reguł porównywania.</summary>
        <returns><see langword="true" />Jeśli parametr występuje w tym ciągu lub jeśli <paramref name="value" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do skopiowania.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.String" /> o takiej samej wartości jak określona <see cref="T:System.String" />.</summary>
        <returns>Nowy ciąg o takiej samej wartości jak <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Copy` Metoda<xref:System.String> zwraca obiekt, który ma taką samą wartość jak oryginalny ciąg, ale reprezentuje inne odwołanie do obiektu. Różni się od operacji przypisania, która przypisuje istniejące odwołanie do ciągu do dodatkowej zmiennej obiektu.

> [!IMPORTANT]
>  Począwszy od platformy .NET Core 3,0, ta metoda jest przestarzała. Nie zaleca się jednak używania ich w żadnej implementacji platformy .NET. W szczególności ze względu na zmiany w ciągu na platformie .NET Core 3,0, w niektórych przypadkach Metoda `Copy` nie utworzy nowego ciągu, ale po prostu zwróci odwołanie do istniejącego ciągu z stażystami.   

W zależności od tego, dlaczego chcesz wywołać `Copy` metodę, istnieje szereg alternatyw:

- Jeśli chcesz, aby w operacji modyfikującej ciąg użyć innego wystąpienia ciągu, użyj oryginalnego wystąpienia ciągu. Ponieważ ciągi są niezmienne, operacja String tworzy nowe wystąpienie ciągu, a oryginalny ciąg pozostaje bez zmian. W tym przypadku nie należy przypisywać nowego ciągu do oryginalnej zmiennej ciągu. Poniższy przykład stanowi ilustrację.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   W takim przypadku wywołanie `Copy` metody w celu utworzenia nowego ciągu przed <xref:System.String.Substring%2A> wywołaniem metody niepotrzebnie tworzy nowe wystąpienie ciągu. 

- Jeśli chcesz utworzyć modyfikowalny bufor o tej samej zawartości co oryginalny ciąg, wywołaj <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> konstruktora or. <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> Przykład:

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- Jeśli chcesz utworzyć modyfikowalną kopię ciągu, aby można było użyć niebezpiecznego kodu do modyfikacji zawartości ciągu, użyj <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> metody. Poniższy przykład używa metody, <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> Aby uzyskać wskaźnik do lokalizacji skopiowanego ciągu w pamięci niezarządzanej, zwiększa punkt kodu Unicode każdego znaku w ciągu przez jeden, a następnie kopiuje otrzymany ciąg z powrotem do zarządzanego ciągu.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Indeks pierwszego znaku w tym wystąpieniu do skopiowania.</param>
        <param name="destination">Tablica znaków Unicode, do których są kopiowane znaki w tym wystąpieniu.</param>
        <param name="destinationIndex">Indeks, w <paramref name="destination" /> którym rozpoczyna się operacja kopiowania.</param>
        <param name="count">Liczba znaków w tym wystąpieniu do skopiowania <paramref name="destination" />.</param>
        <summary>Kopiuje określoną liczbę znaków z określonego położenia w tym wystąpieniu do określonej pozycji w tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje `count` znaki `sourceIndex` z pozycji tego `destination` wystąpienia do `destinationIndex` położenia tablicy znaków. Ta metoda nie zmienia rozmiaru `destination` tablicy znaków; musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane znaki, lub metoda <xref:System.ArgumentOutOfRangeException>zgłasza.  
  
 `sourceIndex`i `destinationIndex` są oparte na zero.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.CopyTo%2A> metodę.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" /> jest ujemna 
—lub— 
 <paramref name="sourceIndex" />nie identyfikuje pozycji w bieżącym wystąpieniu.  
  
—lub— 
 <paramref name="destinationIndex" />nie identyfikuje prawidłowego indeksu w <paramref name="destination" /> tablicy.  
  
—lub— 
 <paramref name="count" />jest większa niż długość podciągu od <paramref name="sourceIndex" /> do końca tego wystąpienia. 
—lub— 
 <paramref name="count" />jest większa niż długość podtablicy od <paramref name="destinationIndex" /> do końca <paramref name="destination" /> tablicy.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pusty ciąg. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest ciągiem o zerowej długości, "".  
  
 W kodzie aplikacji to pole jest najczęściej używane w przypisaniach do inicjowania zmiennej ciągu do pustego ciągu. Aby sprawdzić, czy wartość ciągu jest albo `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, użyj <xref:System.String.IsNullOrEmpty%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
        <returns><see langword="true" />w przypadku <paramref name="value" /> dopasowania do końca tego wystąpienia; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest `value` porównywana z podciągiem na końcu tego wystąpienia, który ma taką samą długość `value`jak i zwraca wskazanie, czy są równe. `value` Musi być odwołaniem do tego samego wystąpienia lub być zgodne z końcem tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy każdy ciąg w tablicy jest zakończony kropką (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `StripEndTags` metodę, która <xref:System.String.EndsWith%28System.String%29> używa metody do usuwania tagów końcowych HTML z końca wiersza. Należy zauważyć, `StripEndTags` że metoda jest wywoływana cyklicznie, aby zapewnić usunięcie wielu tagów końcowych HTML na końcu wiersza.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby określić, czy ciąg jest kończący się określonym podciągiem przy użyciu reguł porównywania ciągów bieżącej kultury, wywołaj <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa, jak ten ciąg <paramref name="value" /> i są porównywane.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną opcją porównania.</summary>
        <returns><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z końcem tego ciągu; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> Metoda porównujeparametrdopodciągunakońcuciąguizwracawartośćwskazującą`value` , czy są równe. Aby była równa `value` , musi być odwołaniem do tego samego ciągu, musi być pustym ciągiem ("") lub musi być zgodna z końcem tego ciągu. Typ porównania wykonywanego przez <xref:System.String.EndsWith%2A> metodę zależy od wartości `comparisonType` parametru.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg jest kończący się określonym podciągiem. Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <param name="culture">Informacje kulturowe, które określają, jak <paramref name="value" /> to wystąpienie i są porównywane. Jeśli <paramref name="culture" /> jest<see langword="null" />, używana jest bieżąca kultura.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną kulturą.</summary>
        <returns><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z końcem tego ciągu; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` parametr do podciągu na końcu ciągu, który ma taką samą długość jak `value`i zwraca wartość wskazującą, czy są równe. Aby była równa `value` , musi być odwołaniem do tego samego wystąpienia lub być zgodne z końcem tego ciągu.  
  
 Ta metoda wykonuje porównanie wyrazu (z uwzględnieniem kultury) przy użyciu określonej wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na końcu innego ciągu. <xref:System.String.EndsWith%2A> Metoda jest wywoływana kilka razy przy użyciu czułości wielkości liter, nierozróżniania wielkości liter i różnych kultur, które wpływają na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z tego ciągu.</summary>
        <returns>Moduł wyliczający ciągów Rune.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

Nieprawidłowe sekwencje są reprezentowane w wyliczeniu przez <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy <see cref="T:System.String" /> dwa obiekty mają tę samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ciąg, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie i określony obiekt, który również musi być <see cref="T:System.String" /> obiektem, mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> <see langword="false" />jest i jej wartość jest taka sama jak to wystąpienie; w przeciwnym razie,. <see cref="T:System.String" />  Jeśli <paramref name="obj" /> <see langword="false" />jest <see langword="null" />, metoda zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie i inny <see cref="T:System.String" /> określony obiekt mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="value" /> parametru jest taka sama jak wartość tego wystąpienia; <see langword="false" />w przeciwnym razie. Jeśli <paramref name="value" /> <see langword="false" />jest <see langword="null" />, metoda zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę. Porównuje słowo Case z tytułem "plik" z odpowiednikiem wyrazu, jego odpowiednikiem małymi literami, jego wielką literą i słowem zawierającym małe litery w postaci niewielkiej i (U + 0131) zamiast wielkiej litery I (U + 0069). Ponieważ metoda wykonuje porównanie porządkowe, tylko porównanie z identycznym słowem zwraca `true`. <xref:System.String.Equals%28System.String%29>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa <see cref="T:System.String" /> określone obiekty mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="a" /> jest taka sama jak <paramref name="b" />wartość; w przeciwnym razie <see langword="false" />. Jeśli obie <paramref name="a" /> i <paramref name="b" /> są <see langword="null" />, metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać porównany z tym wystąpieniem.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa sposób porównywania ciągów.</param>
        <summary>Określa, czy ten ciąg i określony <see cref="T:System.String" /> obiekt mają tę samą wartość. Parametr określa kulturę, wielkość liter i reguły sortowania używane w porównaniu.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="value" /> parametru jest taka sama jak ten ciąg; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie ma korzystać z bieżącej lub niezmiennej kultury, czy ma być uznawany czy ignorowany w przypadku porównywania dwóch ciągów lub użyć reguł sortowania programu Word lub porządkowego.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę ciągów składającą się z wielkich liter "I", litery "i" i z kropką "ı". Następnie wywołuje <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodę w celu porównania ich przy użyciu każdej możliwej <xref:System.StringComparison> wartości wyliczenia.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 Poniższy przykład porównuje cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.  W porównaniach używane są konwencje angielskiej (Stany Zjednoczone) i Lapoński (Wielka Szwecja). Należy zauważyć, że ciągi "Encyclopædia" i "Encyclopaedia" są uważane za równoważne w kulturze en-US, ale nie w kulturze sami (Północna Szwecja).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły dla porównania.</param>
        <summary>Określa, czy dwa <see cref="T:System.String" /> określone obiekty mają tę samą wartość. Parametr określa kulturę, wielkość liter i reguły sortowania używane w porównaniu.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="a" /> parametru jest równa wartości <paramref name="b" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie ma korzystać z bieżącej lub niezmiennej kultury, czy ma być uznawany czy ignorowany w przypadku porównywania dwóch ciągów lub użyć reguł sortowania programu Word lub porządkowego.  
  
   
  
## Examples  
 Poniższy przykład porównuje cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.  W porównaniach używane są konwencje angielskiej (Stany Zjednoczone) i Lapoński (Wielka Szwecja). Należy zauważyć, że ciągi "Encyclopædia" i "Encyclopaedia" są uważane za równoważne w kulturze en-US, ale nie w kulturze sami (Północna Szwecja).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość obiektów na ciągi w oparciu o określone formaty i wstawia je do innego ciągu.  
  
Jeśli dopiero zaczynasz [korzystać z](#Starting) metody,zobaczsekcjęwprowadzeniedometodyString.format,abyzapoznaćsięzkrótkim`String.Format` omówieniem.  
  
Zobacz sekcję [uwagi](#remarks-top) , aby zapoznać się z `String.Format` ogólną dokumentacją dla metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 W tej sekcji:  
  
 [Wprowadzenie do metody String. format](#Starting)   
 [Którą metodę nazywam?](#FTaskList)   
 [Metoda formatowania w skrócie](#Format_Brief)   
 [Element formatu](#FormatItem)   
 [Jak są formatowane argumenty](#HowFormatted)   
 [Sformatuj elementy, które mają ten sam indeks](#SameIndex)   
 [Formatowanie i kultura](#Format_Culture)   
 [Niestandardowe operacje formatowania](#Format_Custom)   
 [Ciąg. format Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Wprowadzenie do metody String. format  
 Użyj <xref:System.String.Format%2A?displayProperty=nameWithType> , jeśli musisz wstawić wartość obiektu, zmiennej lub wyrażenia do innego ciągu. Na przykład można wstawić wartość <xref:System.Decimal> do ciągu, aby wyświetlić go użytkownikowi jako pojedynczy ciąg:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Możesz kontrolować formatowanie tej wartości:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Oprócz formatowania można również kontrolować wyrównanie i odstępy.  
  
 ### <a name="inserting-a-string"></a>Wstawianie ciągu  

 <xref:System.String.Format%2A?displayProperty=nameWithType>rozpoczyna się od ciągu formatu, po którym następuje co najmniej jeden obiekt lub wyrażenie, które zostanie przekonwertowane na ciągi i wstawione w określonym miejscu w ciągu formatu. Przykład:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` Ciąg formatu jest elementem formatu. `0`jest indeksem obiektu, którego wartość ciągu zostanie wstawiona w tym miejscu. (Indeksy zaczynają się od 0). Jeśli obiekt, który ma zostać wstawiony nie jest ciągiem, jego `ToString` Metoda jest wywoływana, aby przekonwertować ją na jeden przed wstawieniem go w ciągu wynikowym.  
  
 Oto inny przykład, w którym są używane dwa elementy formatu i dwa obiekty na liście obiektów:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Możesz mieć dowolną liczbę elementów formatu i dowolną liczbę obiektów na liście obiektów, tak długo, jak indeks każdego elementu formatu ma pasujący obiekt na liście obiektów. Nie trzeba również martwić się o to, które Przeciążenie zostało wywołane; Kompilator wybierze odpowiedni dla siebie.  
  
 ### <a name="controlling-formatting"></a>Kontrolowanie formatowania  
 Możesz użyć indeksu w elemencie formatu z ciągiem formatu, aby kontrolować sposób formatowania obiektu. Na przykład `{0:d}` stosuje ciąg formatu "d" do pierwszego obiektu na liście obiektów. Oto przykład z pojedynczym obiektem i dwoma elementami formatu:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Niektóre typy obsługują ciągi formatujące, w tym wszystkie typy liczbowe (ciągi formatu [standardowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowego](~/docs/standard/base-types/custom-numeric-format-strings.md) ), wszystkie daty i godziny (zarówno w formacie [standardowych](~/docs/standard/base-types/standard-date-and-time-format-strings.md) , jak i niestandardowym) i przedziały czasu (zarówno [standardowe](~/docs/standard/base-types/standard-timespan-format-strings.md) , jak i [](~/docs/standard/base-types/custom-date-and-time-format-strings.md) [niestandardowe](~/docs/standard/base-types/custom-timespan-format-strings.md) ciągi formatujące), wszystkie typy [](~/docs/standard/base-types/enumeration-format-strings.md)wyliczeniowe typów wyliczeniowych i [identyfikatory GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Możesz również dodać obsługę ciągów formatowania do własnych typów.  
  
 ### <a name="controlling-spacing"></a>Kontrolowanie odstępów  
 Można zdefiniować szerokość ciągu, która jest wstawiana do ciągu wynikowego przy użyciu składni takiej jak `{0,12}`, która wstawia 12-znakowy ciąg. W takim przypadku ciąg reprezentujący pierwszy obiekt jest wyrównany do prawej w polu 12 znaków.  (Jeśli ciąg reprezentujący pierwszy obiekt ma więcej niż 12 znaków, chociaż Preferowana szerokość pola jest ignorowana, a cały ciąg zostanie wstawiony do ciągu wynikowego.)  
  
 W poniższym przykładzie zdefiniowano 6-znakowe pole w celu przechowywania ciągu "Year" i niektórych ciągów rok, a także pola 15-znakowego do przechowywania ciągu "populacja" i niektórych danych populacji. Należy zauważyć, że znaki w polu są wyrównane do prawej strony.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Kontrolowanie wyrównania  
 Domyślnie ciągi są wyrównane do prawej w polach w przypadku określenia szerokości pola. Aby wyrównać lewe ciągi w polu, należy poprzedzić szerokość pola znakiem minus, `{0,-12}` na przykład w celu zdefiniowania 12-znakowego pola wyrównanego do lewej.  
  
 Poniższy przykład jest podobny do poprzedniego, z tą różnicą, że wyrównuje zarówno etykiety, jak i dane.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType>używa funkcji formatowania złożonego. Aby uzyskać więcej informacji, zobacz [formatowanie złożone](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Zadanie|Połączeń|  
|--------|----------|  
|Sformatuj jeden lub więcej obiektów przy użyciu Konwencji bieżącej kultury.|Z wyjątkiem przeciążeń zawierających `provider` parametr, pozostałe <xref:System.String.Format%2A> przeciążenia obejmują <xref:System.String> parametr, po którym następuje co najmniej jeden parametr obiektu. W związku z tym nie trzeba określać <xref:System.String.Format%2A> przeciążenia, które mają być wywoływane. Kompilator języka wybiera odpowiednie Przeciążenie z przeciążeń, które nie mają `provider` parametru, na podstawie listy argumentów. Na przykład, jeśli lista argumentów ma pięć argumentów, kompilator wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metodę.|  
|Sformatuj jeden lub więcej obiektów przy użyciu konwencji określonej kultury.|Każde <xref:System.String.Format%2A> Przeciążenie, które zaczyna `provider` się od <xref:System.String> parametru, następuje przez parametr i jeden lub więcej parametrów obiektu. W związku z tym nie trzeba określać konkretnego <xref:System.String.Format%2A> przeciążenia, które ma być wywoływane. Kompilator języka wybiera odpowiednie Przeciążenie z przeciążeń, które mają `provider` parametr oparty na liście argumentów. Na przykład, jeśli lista argumentów ma pięć argumentów, kompilator wywołuje <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodę.|  
|Wykonywanie niestandardowej operacji formatowania z <xref:System.ICustomFormatter> implementacją <xref:System.IFormattable> lub implementacją.|Dowolne z czterech przeciążeń z `provider` parametrem. Kompilator wybiera odpowiednie Przeciążenie spośród przeciążeń, które mają `provider` parametr, na podstawie listy argumentów.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Metoda formatowania w skrócie 

 Każde Przeciążenie <xref:System.String.Format%2A> metody używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby uwzględniać indeksowane symbole zastępcze oparte na zero, nazywane *elementami formatu*, w ciągu formatu złożonego. W czasie wykonywania każdy element formatu jest zamieniany na ciąg reprezentujący odpowiadający argument na liście parametrów. Jeśli wartość argumentu to `null`, element formatu jest <xref:System.String.Empty?displayProperty=nameWithType>zastępowany. <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Na przykład następujące wywołanie metody zawiera ciąg formatu z trzema elementami formatu, {0}, {1}, i {2}i lista argumentów z trzema elementami.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Element formatu  
 Element formatu ma następującą składnię:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Nawiasy klamrowe oznaczają opcjonalne elementy. Otwierające i zamykające nawiasy klamrowe są wymagane. (Aby dołączyć literał otwierającego lub zamykającego nawiasu klamrowego w ciągu formatu, [](~/docs/standard/base-types/composite-formatting.md#escaping-braces) Zobacz sekcję dotyczącą nawiasów klamrowych w artykule dotyczącym [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) ).  
  
 Na przykład element formatu służący do formatowania wartości walutowej może wyglądać następująco:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Element formatu ma następujące elementy:  
  
 *index*  
 Indeks (liczony od zera) argumentu, którego reprezentacja ciągu ma zostać uwzględniona w tym położeniu w ciągu. Jeśli ten argument ma `null`wartość, pusty ciąg zostanie uwzględniony w tej pozycji w ciągu.  
  
 *struktury*  
 Opcjonalna. Liczba całkowita ze znakiem, która wskazuje łączną długość pola, do którego wstawiono argument, i określa, czy jest wyrównany do prawej (dodatnia liczba całkowita) czy wyrównany do lewej (ujemna liczba całkowita). W przypadku pominięcia *wyrównania*, reprezentacja odpowiadającego argumentu jest wstawiana w polu bez spacji wiodących i końcowych.  
  
 Jeśli wartość wyrównania ** jest mniejsza niż długość argumentu, który ma zostać wstawiony, *wyrównanie* jest ignorowane i długość ciągu reprezentującego argument jest używana jako szerokość pola.  
  
 *Formatowanie*  
 Opcjonalny. Ciąg określający format ciągu wynikowego odpowiadającego argumentu. W przypadku pominięcia elementu *FormatString*, odpowiednia `ToString` Metoda bezparametrowa argumentu jest wywoływana w celu utworzenia jego reprezentacji w postaci ciągu. W przypadku określenia elementu *FormatString*argument, do którego odwołuje się element formatu, <xref:System.IFormattable> musi implementować interfejs. Typy obsługujące ciągi formatu obejmują:  
  
-   Wszystkie typy całkowite i zmiennoprzecinkowe. (Zobacz [Standardowe ciągi formatujące liczb](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md)).  
  
-   <xref:System.DateTime>i <xref:System.DateTimeOffset>. (Zobacz [ciągi standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md)).  
  
-   Wszystkie typy wyliczeniowe. (Zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md)).  
  
-   <xref:System.TimeSpan>wartością. (Zobacz [Standardowe ciągi formatujące w formacie TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) oraz [Niestandardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md)).  
  
-   GUIDs. (Zobacz <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> metodę).  
  
 Należy jednak pamiętać, że dowolny typ niestandardowy może <xref:System.IFormattable> zaimplementować lub zwiększyć <xref:System.IFormattable> implementację istniejącego typu.  
  
 W poniższym przykładzie za pomocą `alignment` argumentów `formatString` i są generowane sformatowane dane wyjściowe.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Sposób formatowania argumentów  
 Elementy formatu są przetwarzane sekwencyjnie od początku ciągu. Każdy element formatu ma indeks, który odnosi się do obiektu na liście argumentów metody. <xref:System.String.Format%2A> Metoda pobiera argument i dziedziczy jego reprezentację w postaci ciągu w następujący sposób:  
  
-   Jeśli argument ma `null`wartość, Metoda wstawia <xref:System.String.Empty?displayProperty=nameWithType> do ciągu wynikowego. Nie trzeba mieć <xref:System.NullReferenceException> potrzeby obsługi dla argumentów o wartości null. 
  
-   Jeśli <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> wywołasz Przeciążenie, <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> `provider` a implementacja obiektu zwróci implementację o wartości innej niż <xref:System.ICustomFormatter> null, argument jest przenoszona do jego <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody. Jeśli element formatu zawiera argument *FormatString* , jest przenoszona jako pierwszy argument do metody. <xref:System.ICustomFormatter> Jeśli implementacja jest dostępna i tworzy ciąg o wartości innej niż null, ten ciąg jest zwracany jako ciąg reprezentujący argument; w przeciwnym razie wykonywany jest następny krok.  
  
-   Jeśli argument implementuje <xref:System.IFormattable> interfejs, jego <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementacja jest wywoływana.  
  
-   `ToString` Metoda bez parametrów argumentu, która zastępuje lub dziedziczy z implementacji klasy podstawowej, jest wywoływana.  
  
 Przykład, który przechwytuje wywołania <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> metody i pozwala zobaczyć, <xref:System.String.Format%2A> jakie informacje Metoda przekazuje do metody formatowania dla każdego elementu formatu w ciągu formatu złożonego, zobacz [przykład: Dostawca przechwycenia i program formatujący](#Format7_Example)cyfry rzymskie.  

 Aby uzyskać więcej informacji, zobacz sekcję [kolejność przetwarzania](~/docs/standard/base-types/composite-formatting.md##processing-order) w artykule dotyczącym [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementy formatu o tym samym indeksie  
 <xref:System.String.Format%2A> Metoda<xref:System.FormatException> zgłasza wyjątek, jeśli indeks elementu indeksu jest większy lub równy liczbie argumentów na liście argumentów. `format` Jednak może zawierać więcej elementów formatu niż istnieją argumenty, o ile wiele elementów formatu ma ten sam indeks. W wywołaniu <xref:System.String.Format%28System.String%2CSystem.Object%29> metody w poniższym przykładzie lista argumentów ma jeden argument, ale ciąg formatu zawiera dwa elementy formatu: jeden wyświetla wartość dziesiętną liczby, a druga wyświetla wartość szesnastkową.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatowanie i kultura  
 Ogólnie rzecz biorąc, obiekty na liście argumentów są konwertowane na ich reprezentacje ciągów przy użyciu Konwencji bieżącej kultury, które są zwracane przez <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwość. Możesz kontrolować to zachowanie, wywołując jedno z przeciążeń <xref:System.String.Format%2A> , które `provider` zawierają parametr. `provider` Parametr<xref:System.IFormatProvider> jest implementacją, która dostarcza niestandardowe i specyficzne dla kultury informacje o formatowaniu, które są używane do umiarkowanego procesu formatowania.  
  
 Interfejs ma pojedynczy <xref:System.IFormatProvider.GetFormat%2A>element członkowski, który jest odpowiedzialny za zwracanie obiektu, który zawiera informacje o formatowaniu. <xref:System.IFormatProvider> Platforma .net ma <xref:System.IFormatProvider> trzy implementacje, które zapewniają formatowanie specyficzne dla kultury:  
  
-   <xref:System.Globalization.CultureInfo>. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda zwraca obiekt specyficzny <xref:System.Globalization.NumberFormatInfo> dla kultury służący do formatowania wartości liczbowych i obiekt <xref:System.Globalization.DateTimeFormatInfo> specyficzny dla kultury służący do formatowania wartości daty i godziny.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, który jest używany do formatowania wartości daty i godziny specyficznej dla kultury. Jego <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> Metoda zwraca sam siebie.  
  
-   <xref:System.Globalization.NumberFormatInfo>, który jest używany do formatowania wartości liczbowych specyficznych dla kultury. Jego <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Właściwość zwraca samą siebie. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Niestandardowe formatowanie operacji  
 Można również wywołać dowolne przeciążenia <xref:System.String.Format%2A> metody, która `provider` ma parametr typu <xref:System.IFormatProvider> do wykonywania niestandardowych operacji formatowania. Na przykład można sformatować liczbę całkowitą jako numer identyfikacyjny lub numer telefonu. Aby można było zastosować niestandardowe formatowanie `provider` , argument musi implementować <xref:System.IFormatProvider> zarówno <xref:System.ICustomFormatter> interfejs, jak i. <xref:System.String.Format%2A> `provider` <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Gdy metoda jest przenoszona do <xref:System.ICustomFormatter> implementacji jako argument, metoda wywołuje jego implementację i żąda obiektu typu <xref:System.ICustomFormatter>. <xref:System.String.Format%2A> Następnie wywołuje <xref:System.ICustomFormatter.Format%2A> metodę zwracanego <xref:System.ICustomFormatter> obiektu, aby sformatować każdy element formatu w złożonym ciągu.  
  
 Aby uzyskać więcej informacji na temat udostępniania niestandardowych rozwiązań formatowania [, zobacz How to: Definiowanie i używanie niestandardowych dostawców](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) formatu liczbowego i. <xref:System.ICustomFormatter> Aby zapoznać się z przykładem, który konwertuje liczby całkowite na sformatowane [wartości niestandardowe, zobacz przykład: Niestandardowa operacja](#Format6_Example)formatowania. Przykład, który konwertuje bajty bez znaku na cyfry rzymskie, [Zobacz przykład: Dostawca przechwycenia i program formatujący](#Format7_Example)cyfry rzymskie.  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Przykład: Niestandardowa Operacja formatowania  
 W tym przykładzie zdefiniowano dostawcę formatu, który formatuje wartość całkowitą jako numer konta klienta w postaci x-XXXXX-XX.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Przykład: Dostawca przechwycenia i program formatujący cyfry rzymskie  
 W tym przykładzie zdefiniowano niestandardowego dostawcę formatu, który <xref:System.ICustomFormatter> implementuje <xref:System.IFormatProvider> interfejsy i, aby wykonać dwie czynności:  
  
-   Wyświetla parametry przesłane do <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> wdrożenia. Dzięki temu możemy zobaczyć, jakie parametry <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Metoda jest przekazywana do implementacji formatowania niestandardowego dla każdego obiektu, który próbuje sformatować. Może to być przydatne w przypadku debugowania aplikacji.  
  
-   Jeśli obiekt, który ma być sformatowany jest wartością bajtu bez znaku, która ma zostać sformatowana przy użyciu standardowego ciągu formatu "R", niestandardowy program formatujący formatuje wartość liczbową jako cyfrę rzymską.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>Ciąg. format Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Dlaczego zalecane jest Interpolacja ciągów dla `String.Format` wywołań metody?

Interpolacja ciągów:

- Bardziej elastyczne. Może być używana w dowolnym ciągu bez konieczności wywołania metody, która obsługuje formatowanie złożone. W przeciwnym razie należy wywołać <xref:System.String.Format%2A> metodę lub inną metodę, która obsługuje formatowanie złożone, takie jak <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Bardziej czytelne. Ponieważ wyrażenie, które ma zostać wstawione do ciągu, pojawia się w wyrażeniu interpolowanym, a nie na liście argumentów, interpolowane ciągi są znacznie łatwiejsze do kodu i odczytywania. Ze względu na większą czytelność, interpolowane ciągi mogą zastąpić nie tylko wywołania metod formatu złożonego, ale mogą być również używane w operacjach łączenia ciągów, aby generować bardziej zwięzły, wyraźniejszy kod. 

Porównanie następujących dwóch przykładów kodu ilustruje najwyższą liczbę interpolowanych ciągów na łączenie ciągów i wywołania metod formatowania złożonego. Użycie wielu operacji łączenia ciągów w poniższym przykładzie daje pełny i trudny do odczytu kod.

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Natomiast użycie ciągów interpolowanych w poniższym przykładzie daje dużo wyraźniejszy, bardziej zwięzły kod niż instrukcja łączenia ciągów i wywołanie <xref:System.String.Format%2A> metody w poprzednim przykładzie.

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Gdzie mogę znaleźć listę wstępnie zdefiniowanych ciągów formatu, które mogą być używane z elementami formatowania?  
  
-   Dla wszystkich typów całkowitych i zmiennoprzecinkowych zobacz [Standardowe ciągi formatujące numeryczne](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   W przypadku wartości daty i godziny zobacz [ciągi standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać wartości wyliczenia, zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby <xref:System.TimeSpan> uzyskać wartości, zobacz [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) i [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Aby <xref:System.Guid> uzyskać wartości, zobacz sekcję <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> uwagi na stronie referencyjnej.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Jak mogę kontrolować wyrównanie ciągów wynikowych, które zastępują elementy formatu?  
 Ogólna składnia elementu format jest następująca:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 gdzie *wyrównania* jest ze znakiem liczby całkowitej, która definiuje szerokość pola. Jeśli ta wartość jest ujemna, tekst w polu jest wyrównany do lewej. Jeśli jest dodatnia, tekst jest wyrównany do prawej.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Jak mogę kontrolować liczbę cyfr po separatorze dziesiętnym?  
 Wszystkie [ciągi standardowego formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) z wyjątkiem "D" (które są używane tylko z liczbami całkowitymi), "G", "R" i "X" zezwalają na specyfikator dokładności, który definiuje liczbę cyfr dziesiętnych w ciągu wynikowym. W poniższym przykładzie użyto standardowych ciągów formatu liczbowego do kontrolowania liczby cyfr dziesiętnych w ciągu wynikowym.  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Jeśli używasz [niestandardowego ciągu formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md), użyj specyfikatora formatu "0", aby kontrolować liczbę cyfr dziesiętnych w ciągu wynikowym, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Jak mogę kontrolować liczbę cyfr całkowitych?  
 Domyślnie operacje formatowania wyświetlają tylko niezerowe cyfry całkowite. Jeśli są formatowane liczby całkowite, można użyć specyfikatora dokładności z ciągami formatu standardowego "D" i "X", aby kontrolować liczbę cyfr.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Można uzupełnić liczbę całkowitą lub liczbową zmiennoprzecinkową zerami wiodącymi, aby utworzyć ciąg wynikowy z określoną liczbą cyfr całkowitych przy użyciu [niestandardowego specyfikatora formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md)"0", jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Ile elementów można uwzględnić na liście Format?  
 Nie ma praktycznego limitu. Drugi parametr <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody jest oznakowany <xref:System.ParamArrayAttribute> atrybutem, który umożliwia dołączenie listy rozdzielanej lub tablicy obiektów jako listy formatów.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Jak mogę uwzględnić literały klamrowe ("{" i "}") w ciągu wynikowym?  
 Na przykład jak zapobiec zgłaszaniu <xref:System.FormatException> wyjątku przez następujące wywołanie metody?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Pojedynczy nawias otwierający lub zamykający jest zawsze interpretowany jako początek lub koniec elementu formatu. Aby można było interpretować dosłownie, musi to być znak ucieczki. Nawias klamrowy zostanie dodany przez dodanie kolejnego nawiasu klamrowego ("{{" i "}}" zamiast "{" i "}"), jak w poniższym wywołaniu metody:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Jednak nawet nawiasy klamrowe są łatwo interpretowane nieprawidłowo. Zalecamy dołączenie nawiasów klamrowych na liście Format i użycie elementów formatu do wstawienia ich w ciągu wynikowym, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Dlaczego moje wywołanie metody String. Format powoduje zgłoszenie FormatException?  
 Najczęstszym powodem wyjątku jest to, że indeks elementu formatu nie odpowiada obiektowi na liście Format. Zazwyczaj oznacza to, że liczba indeksów elementów formatowania jest niepograna lub zapomniano dołączyć obiekt z listy format. Próba dołączenia znaku w nawiasie klamrowym w lewo lub w <xref:System.FormatException>prawo powoduje również wyrzucanie. Czasami wyjątek jest wynikiem literówki; na przykład typowym błędem jest błąd "[" (lewy nawias) zamiast "{" (lewy nawias klamrowy).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Jeśli format (System. IFormatProvider, system. String, system. Object []) obsługuje tablice parametrów, dlaczego mój kod zgłasza wyjątek, gdy używam tablicy?  
 Na przykład poniższy kod zgłasza <xref:System.FormatException> wyjątek:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Jest to problem z rozwiązaniem przeciążenia kompilatora. Ponieważ kompilator nie może przekonwertować tablicy liczb całkowitych na tablicę obiektów, traktuje tablicę liczb całkowitych jako pojedynczy argument, więc wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%29> metodę. Wyjątek jest zgłaszany, ponieważ istnieją cztery elementy formatujące, ale tylko jeden element na liście Format.  
  
 Ponieważ ani nie Visual Basic C# ani nie można skonwertować tablicy typu Integer na tablicę obiektów, należy wykonać konwersję samodzielnie przed wywołaniem <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody. Poniższy przykład zawiera jedną implementację.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Liczne przykłady, które wywołują <xref:System.String.Format%2A> metodę, są przeplatane w sekcji [uwagi](#remarks-top) tego artykułu.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

Możesz również pobrać `String.Format` kompletny zestaw przykładów, które są dołączone do [projektu .NET Core 2,0 dla C# ](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) i [projektu .NET Core 2,0 dla Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), z repozytorium w witrynie [GitHub/Samples](https://github.com/dotnet/samples).

Poniżej przedstawiono niektóre przykłady zawarte w artykule:

### <a name="create-a-format-string"></a>Utwórz ciąg formatu

[Wstawianie ciągu](#inserting-a-string)  
[Element formatu](#the-format-item)  
[Sformatuj elementy, które mają ten sam indeks](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Kontrolowanie danych wyjściowych w formacie

[Kontrolowanie formatowania](#controlling-formatting)  
[Kontrolowanie odstępów](#controlling-spacing)  
[Kontrolowanie wyrównania](#controlling-alignment)  
[Kontrolowanie liczby cyfr całkowitych](#how-do-i-control-the-number-of-integral-digits)  
[Kontrolowanie liczby cyfr po separatorze dziesiętnym](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Uwzględnianie nawiasów klamrowych w ciągu wynikowym](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Wprowadź w formacie ciągi kulturowe

[Formatowanie z uwzględnieniem kultur](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Dostosowywanie operacji formatowania

[Niestandardowa Operacja formatowania](#example-a-custom-formatting-operation)  
[Dostawca przechwycenia i program formatujący cyfry rzymskie](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Zamienia jeden lub więcej elementów formatu ciągu na ciąg reprezentujący określony obiekt.</summary>
        <returns>Kopia <paramref name="format" /> , w której każdy element formatu jest zamieniany na ciąg <paramref name="arg0" />reprezentujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość wyrażenia na jego reprezentację ciągu i osadzić tę reprezentację w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Przykład: Formatowanie pojedynczego argumentu  
 
 Poniższy przykład używa <xref:System.String.Format%28System.String%2CSystem.Object%29> metody do osadzenia wieku osoby w środku ciągu.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Element formatu w <paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest równy zero.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia element formatu w określonym ciągu na ciąg reprezentujący odpowiadający obiekt w określonej tablicy.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg reprezentujący odpowiednie obiekty w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość czterech lub więcej wyrażeń na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu. Ponieważ parametr jest oznaczony <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atrybutem, można przekazać obiekty do metody jako <xref:System.Object> pojedyncze argumenty lub jako tablicę. `args` 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Przykład: Formatowanie więcej niż trzech argumentów  
 
 Ten przykład tworzy ciąg, który zawiera dane z wysoką i niską temperaturą w określonym dniu. Ciąg formatu złożonego ma pięć elementów formatu w C# przykładzie i sześć w przykładzie Visual Basic. Dwa elementy formatu definiują szerokość odpowiadającego ciągu wartości, a pierwszy element formatu zawiera również ciąg standardowego formatu daty i godziny.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Można również przekazać obiekty do formatowania jako tablicę, a nie jako listę argumentów.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy od zera lub jest większy lub równy długości <paramref name="args" /> tablicy.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Zamienia element formatu lub elementy w określonym ciągu na ciąg reprezentujący odpowiadający obiekt. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopia <paramref name="format" /> , w której element formatu lub elementy zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość wyrażenia na jego reprezentację ciągu i osadzić tę reprezentację w ciągu. W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego. Metoda jest konwertowana `arg0` na reprezentację ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** Method. Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest równy zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia elementy formatu w ciągu na ciąg reprezentujący odpowiadające obiekty w określonej tablicy. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg reprezentujący odpowiednie obiekty w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby skonwertować cztery lub więcej wyrażeń do ich reprezentacji ciągów i osadzić te reprezentacje w ciągu. W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego. Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** . Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a>Przykład: Formatowanie z uwzględnieniem kultur

 W tym przykładzie użyto <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody, aby wyświetlić reprezentację ciągu niektórych wartości daty i godziny oraz wartości liczbowych przy użyciu kilku różnych kultur.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy od zera lub jest większy lub równy długości <paramref name="args" /> tablicy.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia elementy formatu ciągu na ciąg reprezentujący dwa określone obiekty.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu są zamieniane na ciąg <paramref name="arg0" /> reprezentujący i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) do konwersji wartości dwóch wyrażeń na ich reprezentacje ciągów i osadzania tych reprezentacji w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Przykład: Formatowanie dwóch argumentów  
 
 Ten przykład używa <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metody do wyświetlania danych czasowych i temperatury przechowywanych w obiekcie ogólnym <xref:System.Collections.Generic.Dictionary%602> . Należy zauważyć, że ciąg formatu ma trzy elementy formatu, chociaż istnieją tylko dwa obiekty do sformatowania. Wynika to z faktu, że pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy formatu: Pierwszy element formatu wyświetla godzinę, a druga wyświetla datę.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest równy zero lub jeden.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia elementy formatu ciągu na ciąg reprezentujący dwa określone obiekty. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu są zamieniane na ciąg <paramref name="arg0" /> reprezentujący i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować dwa wyrażenia na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu. W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego. Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** . Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu nie jest równy zero lub jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia elementy formatu ciągu na ciąg reprezentujący trzy określone obiekty.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) do konwersji wartości trzech wyrażeń do ich reprezentacji ciągów i osadzania tych reprezentacji w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Przykład: Formatowanie trzech argumentów  
 
 W <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> tym przykładzie zastosowano metodę, aby utworzyć ciąg, który ilustruje wynik operacji logicznej `And` z dwiema wartościami całkowitymi. Należy zauważyć, że ciąg formatu zawiera sześć elementów formatu, ale metoda ma tylko trzy elementy na liście parametrów, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż zero lub większy niż dwa.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia elementy formatu ciągu na ciąg reprezentujący trzy określone obiekty. Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować trzy wyrażenia na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu. W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego. Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** . Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż zero lub większy niż dwa.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który może wykonywać iterację poszczególnych znaków w tym ciągu.</summary>
        <returns>Obiekt modułu wyliczającego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Zamiast wywoływania <xref:System.String.GetEnumerator%2A> metody w celu <xref:System.CharEnumerator> pobrania obiektu, który będzie używany do wyliczenia ciągu, należy zamiast tego użyć konstrukcji iteracji języka (w C#, w C++/CLR i w Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) w C++/CLR i [for each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) w Visual Basic).
  
 Ta metoda umożliwia Powtarzanie pojedynczych znaków w ciągu. Na przykład Visual Basic C# `foreach` i instrukcje wywołują tę metodę w celu zwrócenia obiektu,którymożezapewnićdostęptylkodoodczytudoznakówwtymwystąpieniuciągu.<xref:System.CharEnumerator> `For Each`  
  
   
  
## Examples  
 Poniższy przykład iteruje znaki w kilku ciągach i wyświetla informacje o ich poszczególnych znakach. Używa konstrukcji iteracji języka, a nie wywołania <xref:System.String.GetEnumerator%2A> metody.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego ciągu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie <xref:System.String.GetHashCode%2A> jest zależne od implementacji, która może ulec zmianie z jednej wersji środowiska uruchomieniowego języka wspólnego na inną. Przyczyną tego problemu może być poprawa wydajności programu <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Jeśli dwa obiekty String są równe, <xref:System.String.GetHashCode%2A> Metoda zwraca identyczne wartości. Nie istnieje jednak unikatowa wartość kodu skrótu dla każdej unikatowej wartości ciągu. Różne ciągi mogą zwracać ten sam kod skrótu.  
>   
>  Sam kod skrótu nie jest gwarantowany jako stabilny. Kody skrótów dla identycznych ciągów mogą różnić się między implementacjami platformy .NET, różnymi wersjami .NET i między platformami .NET (takimi jak 32-bitowe i 64-bitowe) dla jednej wersji platformy .NET. W niektórych przypadkach mogą one nawet różnić się w zależności od domeny aplikacji. Oznacza to, że dwa kolejne uruchomienia tego samego programu mogą zwracać różne kody skrótów.  
>   
>  W związku z tym kody skrótów nigdy nie powinny być używane poza domeną aplikacji, w której zostały utworzone, nigdy nie powinny być używane jako pola kluczy w kolekcji i nigdy nie powinny być utrwalane.  
>   
>  Na koniec nie należy używać kodu skrótu zamiast wartości zwracanej przez kryptograficzną funkcję mieszania, jeśli jest potrzebny kryptograficznie silny skrót. W przypadku skrótów kryptograficznych Użyj klasy pochodnej <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> klasy or. <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>  
>   
>  Aby uzyskać więcej informacji na temat kodów skrótu <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>, zobacz.  
  
 W aplikacjach klasycznych można użyć [ \<elementu UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) , aby generować unikatowe kody skrótów dla poszczególnych domen aplikacji. Może to zmniejszyć liczbę kolizji i zwiększyć ogólną wydajność operacji wstawiania i wyszukiwania, które używają tabel skrótów. Poniższy przykład pokazuje, [ \<jak używać elementu UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definiuje `DisplayString` klasę, która zawiera ciąg prywatny, `s`, którego wartością jest "to jest ciąg". Zawiera `ShowStringHashCode` również metodę, która wyświetla wartość ciągu i jego kod skrótu wraz z nazwą domeny aplikacji, w której jest wykonywana metoda.
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 W przypadku uruchomienia tego przykładu bez podawania pliku konfiguracji wyświetlane są dane wyjściowe podobne do poniższych. Należy zauważyć, że kody skrótów dla ciągu są identyczne w obu domenach aplikacji.  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 Jeśli jednak dodasz następujący plik konfiguracji do katalogu przykładu, a następnie uruchomisz przykład, kody skrótów dla tego samego ciągu różnią się w zależności od domeny aplikacji.  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 Gdy plik konfiguracji jest obecny, w przykładzie są wyświetlane następujące dane wyjściowe:  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  Kody skrótów służą do wydajnego wstawiania i pobierania z tabel skrótów. Jednak kody skrótów nie identyfikują jednoznacznie ciągów. Identyczne ciągi mają równe kody skrótów, ale środowisko uruchomieniowe języka wspólnego może również przypisać ten sam kod skrótu do różnych ciągów. Ponadto kody skrótów mogą różnić się w zależności od wersji platformy .NET, platformy w ramach jednej wersji i domeny aplikacji. W związku z tym nie należy serializować ani utrwalać wartości kodu skrótu ani używać ich jako kluczy w tabeli lub słowniku skrótów.  
  
 Aby uzyskać dodatkowe informacje o używaniu kodów skrótów i `GetHashCode` metody, zobacz. <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.GetHashCode%2A> metodę przy użyciu różnych ciągów wejściowych.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Wartość zwrócona przez <see cref="M:System.String.GetHashCode" /> jest zależna od platformy. Różni się on od 32-bitowych i 64-bitowych wersji .NET Framework. Może również różnić się między wersjami .NET Framework i .NET Core.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; , element</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Zakres znaków tylko do odczytu.</param>
        <summary>Zwraca kod skrótu dla podanego zakresu znaków tylko do odczytu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Zwraca kod skrótu dla tego ciągu przy użyciu określonych reguł.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Zakres znaków tylko do odczytu.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</param>
        <summary>Zwraca kod skrótu dla podanego zakresu znaków tylko do odczytu przy użyciu określonych reguł.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do elementu ciągu pod indeksem zero.</summary>
        <returns>Znak reprezentujący odwołanie do elementu ciągu pod indeksem zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Metoda zwraca znak, który może być używany do <xref:System.String> przypinania w pamięci. `GetPinnableReference` Jest to wymagane do obsługi użycia a <xref:System.String> wewnątrz ustalonej instrukcji.

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Ciąg ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" />Zwraca klasę <see cref="T:System.TypeCode" /> dla klasy.</summary>
        <returns>Stała <see cref="F:System.TypeCode.String" />Wyliczenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia <xref:System.TypeCode> Wyliczenie stałe dla tego <xref:System.String> typu.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raportuje indeks pierwszego wystąpienia określonego znaku Unicode lub ciągu w tym wystąpieniu. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać przeszukany.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu.</summary>
        <returns>Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można wyszukać <xref:System.String> znak <xref:System.String.IndexOf%2A> przy użyciu metody.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera.</summary>
        <returns>Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest. Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana wynosi 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od pierwszego położenia znaku tego wystąpienia i jest kontynuowane aż do ostatniego położenia znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` składa się tylko z co najmniej jednego znaku <xref:System.String.IndexOf%28System.String%29> , który można zignorować, Metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%29> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ łącznik miękki jest znakiem, który można zignorować, wynik jest taki sam jak w przypadku, gdy łącznik miękki nie został uwzględniony w. `value` Podczas wyszukiwania tylko łącznika miękkiego Metoda zwraca wartość 0 (zero), aby wskazać, że znaleziono dopasowanie na początku ciągu.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład wyszukuje "n" w "zwierzęciu". Ponieważ indeksy ciągu zaczynają się od zera, a nie <xref:System.String.IndexOf%28System.String%29> jeden, Metoda wskazuje, że "n" znajduje się na pozycji 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 W poniższym przykładzie zastosowano <xref:System.String.IndexOf%2A> metodę, aby określić pozycję początkową nazwy zwierzęcia w zdaniu. Następnie używa tego położenia, aby wstawić przymiotnik, który opisuje zwierzę w zdaniu.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby znaleźć pierwszy indeks podciągu w wystąpieniu ciągu przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać przeszukany.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu. Wyszukiwanie rozpocznie się z określoną pozycją znaku.</summary>
        <returns>Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku ciągu, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerowanie indeksu rozpoczyna się od 0. `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.  
  
 Wyszukiwanie zakresów od `startIndex` do końca ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.IndexOf%2A> metodę.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Znak, który ma zostać przeszukany.</param>
        <param name="comparisonType">Wartość wyliczenia, która określa reguły dla wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu. Parametr określa typ wyszukiwania do użycia dla określonego znaku.</summary>
        <returns>Indeks (liczony od zera) <paramref name="value" /> , jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Indeks numerowania rozpoczyna się od zera.  
  
Parametr jest składową wyliczenia, która określa, `value` czy wyszukiwanie argumentu używa bieżącej lub niezmiennej kultury, jest rozróżniana wielkość liter, czy też używa reguł porównania programu Word lub porządkowego. <xref:System.StringComparison> `comparisonType`
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera. Wyszukiwanie rozpocznie się z określoną pozycją znaku.</summary>
        <returns>Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest. Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerowanie indeksu rozpoczyna się od 0. `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od `startIndex` pozycji znaku tego wystąpienia i jest kontynuowane do momentu ostatniej pozycji znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Poniższy przykład wyszukuje wszystkie wystąpienia określonego ciągu w ciągu docelowym.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość tego ciągu.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby znaleźć pierwszy indeks podciągu, który występuje po określonej pozycji znaku przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie. Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Pozycja <paramref name="value" /> indeksu parametru, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest. Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana wynosi 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> składa się tylko z co najmniej jednego znaku <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> , który można zignorować, Metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niewygładzony jest znakiem, którego nie można zignorować, wyszukiwanie z uwzględnieniem kultury zwraca tę samą wartość, która byłaby zwracana, jeśli łącznik miękki nie został uwzględniony w ciągu wyszukiwania. Wyszukiwanie porządkowe, jednak pomyślnie znajduje łącznik niewygładzony w jednym ciągu i zgłasza, że nie jest on poza drugim ciągiem.  
  
[! code-CSharp[System. String. IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! code — VB[System. String. IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać przeszukany.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku w tym wystąpieniu. Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</summary>
        <returns>Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku ciągu, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` . Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`  
  
 Numerowanie indeksu zaczyna się od 0 (zero). `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.IndexOf%2A> metodę.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" />jest większa niż długość tego ciągu.  
  
—lub— 
 <paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera. Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</summary>
        <returns>Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest. Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerowanie indeksu zaczyna się od 0 (zero). `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` . Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego do szóstego znaku w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkich wystąpień ciągu "mu" w podciągu innego ciągu. Należy zauważyć, że liczba znaków do przeszukania musi być ponownie obliczana dla każdej iteracji wyszukiwania.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" />jest większa niż długość tego ciągu.  
  
—lub— 
 <paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby użyć reguł porównania bieżącej kultury do wykonania tej operacji, wywołaj <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie. Parametry określają początkową pozycję wyszukiwania w bieżącym ciągu i typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Pozycja indeksu (liczony od zera) <paramref name="value" /> parametru od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie jest. Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerowanie indeksu rozpoczyna się od 0. `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość tego ciągu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego położenia znaku w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-CSharp[System. String. IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! code — VB[System. String. IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie. Parametry określają początkową pozycję wyszukiwania w bieżącym ciągu, liczbę znaków w bieżącym ciągu do wyszukania oraz typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Pozycja indeksu (liczony od zera) <paramref name="value" /> parametru od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie jest. Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerowanie indeksu zaczyna się od 0 (zero). `startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.  
  
 Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` . Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="startIndex" />jest większa niż długość tego wystąpienia.  
  
—lub— 
 <paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego do szóstego znaku w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Gdy wykonuje to porównanie porządkowe, znajduje podciąg tylko w pierwszym ciągu. Należy zauważyć, że w przypadku pierwszego ciągu, który zawiera Łącznik miękki, po którym następuje "m", metoda nie zwróci indeksu łącznika miękkiego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie z uwzględnieniem kultury. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[! code-CSharp[System. String. IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! code — VB[System. String. IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raportuje indeks pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode.</summary>
        <returns>Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter. Jeśli `anyOf` jest tablicą pustą, Metoda znajduje dopasowanie na początku ciągu (czyli przy indeksie zero).  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład odnajduje pierwsze samogłosy w ciągu.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode. Wyszukiwanie rozpocznie się z określoną pozycją znaku.</summary>
        <returns>Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametr może napadać w zakresie od 0 do jednego, który jest mniejszy niż długość wystąpienia ciągu.  
  
 Wyszukiwanie zakresów od `startIndex` do końca ciągu.  
  
 W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wystąpienia dowolnego znaku ciągu "is" w podciągu innego ciągu.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest wartością ujemną.  
  
—lub— 
 <paramref name="startIndex" />jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode. Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</summary>
        <returns>Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` . Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`  
  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametr może napadać w zakresie od 0 do jednego, który jest mniejszy niż długość wystąpienia ciągu.  
  
 W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wystąpienia dowolnego znaku ciągu "pomoc" w podciągu innego ciągu.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.  
  
—lub— 
 <paramref name="count" /> + <paramref name="startIndex" />jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja indeksu (liczony od zera) wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Zwraca nowy ciąg, w którym zostanie wstawiony określony ciąg w określonym położeniu indeksu w tym wystąpieniu.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale z <paramref name="value" /> wstawionym na <paramref name="startIndex" />pozycji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `startIndex` wartość jest równa długości tego wystąpienia, `value` jest dołączana na końcu tego wystąpienia.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym `value` zostanie wstawiony do bieżącego wystąpienia.  
  
 Na przykład zwracaną wartością `"abc".Insert(2, "XYZ")` jest "abXYZc".  
  
   
  
## Examples  
 Poniższy przykład wstawia znak spacji w czwartej pozycji znaku (znak przy indeksie 3) ciągu.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Poniższa Aplikacja konsolowa poprosi użytkowników o wprowadzenie jednego lub więcej przymiotników, aby opisać dwa zwierzęta. Następnie wywołuje metodę, <xref:System.String.Insert%2A> aby wstawić tekst wprowadzony przez użytkownika do ciągu.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest ujemna lub większa niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli InterNIC.</param>
        <summary>Pobiera odwołanie systemu do określonego <see cref="T:System.String" />.</summary>
        <returns>Odwołanie systemu do <paramref name="str" />, jeśli jest InterNIC; w przeciwnym razie, nowe odwołanie do ciągu z <paramref name="str" />wartością.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego chroni magazyn ciągów przez utrzymywanie tabeli zwanej pulą InterNIC, która zawiera pojedyncze odwołanie do każdego unikatowego ciągu literału zadeklarowanego lub utworzonego programowo w programie. W związku z tym wystąpienie ciągu literału z określoną wartością występuje tylko raz w systemie.  
  
 Jeśli na przykład ten sam ciąg literału zostanie przypisany do kilku zmiennych, środowisko uruchomieniowe pobiera te same odwołania do ciągu literału z puli InterNIC i przypisuje je do każdej zmiennej.  
  
 Metoda używa puli stażyst do wyszukiwania ciągu równego `str`wartości. <xref:System.String.Intern%2A> Jeśli taki ciąg istnieje, zwracane jest jego odwołanie w puli stażyst. Jeśli ciąg nie istnieje, odwołanie do `str` jest dodawane do puli InterNIC, to odwołanie zostanie zwrócone.  
  
 W poniższym przykładzie ciąg S1, który ma wartość ". test", został już wybadany, ponieważ jest to literał w programie. <xref:System.Text.StringBuilder?displayProperty=nameWithType> Klasa generuje nowy obiekt ciągu, który ma taką samą wartość jak S1. Odwołanie do tego ciągu jest przypisane do S2. <xref:System.String.Intern%2A> Metoda wyszukuje ciąg, który ma taką samą wartość jak S2. Ponieważ taki ciąg istnieje, metoda zwraca takie samo odwołanie, które jest przypisane do S1. To odwołanie jest następnie przypisywane do S3. Odwołania S1 i S2 są nierówne, ponieważ odwołują się do różnych obiektów; odwołuje się do porównania S1 i S3 równego, ponieważ odwołują się do tego samego ciągu.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Porównaj tę metodę z <xref:System.String.IsInterned%2A> metodą.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] WprogramieMetodaprzywracaswojezachowaniew.NETFramework1,0i1,1wodniesieniudoInterNIC<xref:System.String.Intern%2A> pusty ciąg. W poniższym przykładzie zmienna `str1` jest przypisana odwołanie do <xref:System.String.Empty>, a zmienna `str2` jest przypisana <xref:System.String.Intern%2A> odwołanie do <xref:System.String.Empty> , które jest zwracane przez wywołanie metody po konwersji <xref:System.Text.StringBuilder>obiekt, którego wartością <xref:System.String.Empty> jest ciąg. Następnie odwołania zawarte w `str1` i `str2` są porównywane pod kątem równości.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]W, [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], i [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i`str2`są równe. `str1` [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] W i[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]i nie sąrówne.`str2` `str1`  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli próbujesz zmniejszyć łączną ilość pamięci przydzielonej przez aplikację, pamiętaj, że informowanie ciągu ma dwa niepożądane skutki uboczne. Po pierwsze pamięć przydzielona dla <xref:System.String> obiektów InterNIC nie może zostać wydana do momentu zakończenia środowiska uruchomieniowego języka wspólnego (CLR). Przyczyną jest to, że odwołanie środowiska CLR do <xref:System.String> obiektu InterNIC może być utrwalane po aplikacji, a nawet w domenie aplikacji kończy się. Po drugie, aby InterNIC ciąg, należy najpierw utworzyć ciąg. Pamięć używana przez <xref:System.String> obiekt musi nadal być przydzielone, nawet jeśli pamięć zostanie ostatecznie zebrana.  
  
 W .NET Framework w wersji 2,0 wprowadzono <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> element członkowski wyliczenia. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Element członkowski oznacza zestaw jako niewymagający, aby InterNIC literał ciągu. Można zastosować <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> do zestawu <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> przy użyciu atrybutu. Ponadto w przypadku korzystania z programu [Ngen. exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) do kompilowania zestawu z wyprzedzeniem czasu wykonywania, ciągi nie są InterNIC między modułami.  
  
   
  
## Examples  
 W poniższym przykładzie są używane trzy ciągi, które są równe wartości, aby określić, czy nowo utworzony ciąg i ciąg z ośrodeku InterNIC są równe.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli InterNIC.</param>
        <summary>Pobiera odwołanie do określonego <see cref="T:System.String" />.</summary>
        <returns>Odwołanie do <paramref name="str" /> , <see langword="null" />jeśli znajduje się w puli stażystów środowiska uruchomieniowego języka wspólnego; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego automatycznie utrzymuje tabelę nazywaną pulą InterNIC, która zawiera pojedyncze wystąpienie każdej unikatowej stałej ciągu literału zadeklarowanej w programie, a także wszelkie unikatowe wystąpienia <xref:System.String> dodawane programowo przez wywołanie <xref:System.String.Intern%2A> Metoda.  
  
 Pula stażyst służy do zachowywania magazynu ciągów. W przypadku przypisywania stałej literału ciągu do kilku zmiennych Każda zmienna jest ustawiana jako odwołująca się do tej samej stałej w puli InterNIC <xref:System.String> zamiast odwoływać się do kilku różnych wystąpień, które mają identyczne wartości.  
  
 Ta metoda jest wyszukiwana `str` w puli InterNIC. Jeśli `str` jest już InterNIC, odwołanie do tego wystąpienia jest zwracane; `null` w przeciwnym razie zwraca.  
  
 Porównaj tę metodę z <xref:System.String.Intern%2A> metodą.  
  
 Ta metoda nie zwraca wartości logicznej. Jeśli wywołasz metodę, ponieważ chcesz, aby wartość logiczna wskazywała, czy określony ciąg jest InterNIC, możesz użyć kodu takiego jak poniższe.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Począwszy od .NET Framework w wersji 2,0, można zastąpić użycie puli stażyst w przypadku użycia programu [Ngen. exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) w celu zainstalowania zestawu w pamięci podręcznej obrazów natywnych na komputerze lokalnym. Aby uzyskać więcej informacji, zobacz Zagadnienia dotyczące wydajności w sekcji uwagi <xref:System.String.Intern%2A> dla właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, że literały ciągów są automatycznie Interni przez kompilator.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy ten ciąg znajduje się w konkretnym formularzu normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest w postaci C normalizacji Unicode.</summary>
        <returns><see langword="true" />Jeśli ten ciąg jest w postaci normalizacji C; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Platforma .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg został pomyślnie znormalizowany do różnych formularzy normalizacji.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formularz normalizacji Unicode.</param>
        <summary>Wskazuje, czy ten ciąg znajduje się w określonym formularzu normalizacji Unicode.</summary>
        <returns><see langword="true" />Jeśli ten ciąg znajduje się w formularzu normalizacji określonym przez <paramref name="normalizationForm" /> parametr; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Platforma .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.String.IsNormalized%2A> metody i <xref:System.String.Normalize%2A> .  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do przetestowania.</param>
        <summary>Wskazuje, czy określony ciąg jest <see langword="null" /> lub pustym ciągiem ("").</summary>
        <returns><see langword="true" />Jeśli parametr jest lub <see langword="null" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A>jest wygodną metodą, która umożliwia jednoczesne testowanie, czy <xref:System.String> jest `null` lub jej wartość <xref:System.String.Empty?displayProperty=nameWithType>. Odpowiada to następującemu kodowi:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Możesz użyć <xref:System.String.IsNullOrWhiteSpace%2A> metody <xref:System.String.Empty?displayProperty=nameWithType>, aby sprawdzić, czy ciąg jest `null`, jego wartość lub zawiera tylko znaki odstępu.  
  
## <a name="what-is-a-null-string"></a>Co to jest ciąg o wartości null?

Ciąg jest `null` , jeśli nie ma przypisanej wartości (w C++ i Visual Basic) lub jeśli został jawnie `null`przypisany do wartości. Mimo że funkcja [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) może bezpiecznie obsłużyć ciąg o wartości null, jak pokazano w poniższym przykładzie, próba wywołania jednego z nich powoduje, <xref:System.NullReferenceException>że jego członkowie zgłaszają.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Co to jest pusty ciąg?  

Ciąg jest pusty, jeśli jest jawnie przypisany do pustego ciągu ("") lub <xref:System.String.Empty?displayProperty=nameWithType>. Pusty ciąg ma <xref:System.String.Length%2A> wartość 0.  Poniższy przykład tworzy pusty ciąg i wyświetla jego wartość oraz jego długość.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 Poniższy przykład analizuje trzy ciągi i określa, czy każdy ciąg ma wartość, jest pustym ciągiem lub jest `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do przetestowania.</param>
        <summary>Wskazuje, czy określony ciąg jest <see langword="null" />pusty lub zawiera tylko znaki odstępu.</summary>
        <returns><see langword="true" />Jeśli parametr jest <see langword="null" /> <paramref name="value" /> lub <see cref="F:System.String.Empty" />lub, lub, jeśli zawiera wyłącznie znaki białych znaków. <paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A>jest wygodną metodą podobną do poniższego kodu, z tą różnicą, że oferuje najwyższą wydajność:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Znaki odstępu są definiowane przez standard Unicode. Metoda interpretuje dowolny znak, który zwraca `true` wartość, gdy jest przenoszona do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody jako znak odstępu. <xref:System.String.IsNullOrWhiteSpace%2A>  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę ciągów, a następnie przekazuje każdy element tablicy do <xref:System.String.IsNullOrWhiteSpace%2A> metody.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy elementy określonej tablicy lub elementów członkowskich kolekcji przy użyciu określonego separatora między każdym elementem lub członkiem.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg, który ma być używany jako separator.<paramref name="separator" /> jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</param>
        <param name="values">Kolekcja zawierająca ciągi do łączenia.</param>
        <summary>Łączy elementy członkowskie skonstruowanej <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcji typu <see cref="T:System.String" />przy użyciu określonego separatora między poszczególnymi elementami członkowskimi.</summary>
        <returns>Ciąg, który składa się z składowych <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg. Jeśli <paramref name="values" /> nie ma żadnych elementów członkowskich, Metoda <see cref="F:System.String.Empty" />zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu (). Jeśli którykolwiek element członkowski `values` jest `null`, zamiast niego zostanie użyty pusty ciąg.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów na tablicę ciągów. Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ). Poniższy przykład przekazuje `List(Of String)` obiekt zawierający wielkie lub małe litery alfabetu do wyrażenia lambda, które wybiera litery, które są równe lub większe niż określona litera (w tym przykładzie jest to "M"). Kolekcja zwrócona <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> przez<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę jest przekazana do metody w celu wyświetlenia wyniku jako pojedynczego ciągu. `IEnumerable(Of String)`  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, który następnie przekazuje <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</param>
        <param name="values">Tablica zawierająca elementy, które mają być połączone.</param>
        <summary>Łączy elementy tablicy obiektów przy użyciu określonego separatora między poszczególnymi elementami.</summary>
        <returns>Ciąg, który składa się z elementów <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg. Jeśli <paramref name="values" /> jest tablicą pustą, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null` <xref:System.String.Empty?displayProperty=nameWithType>lub jeśli którykolwiek element `null`innego niż pierwszy element ma wartość, zamiast niego zostanie użyty pusty ciąg (). `values` Zapoznaj się z sekcją uwagi dla wywołań, jeśli pierwszy `values` element `null`jest.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w tablicy obiektów bez jawnej konwersji elementów na ciągi. Ciąg reprezentujący każdy obiekt w tablicy jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do tablicy liczb całkowitych, która następnie przechodzi do <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> metody.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Jeśli <paramref name="values" /> pierwszy element <see cref="F:System.String.Empty" />jest <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> Metoda nie łączy elementów w <paramref name="values" /> , ale zamiast tego zwraca. Dostępne są różne obejścia tego problemu. Najprostszym sposobem jest przypisanie wartości <see cref="F:System.String.Empty" /> do pierwszego elementu tablicy, jak pokazano w poniższym przykładzie.  
  
[! code-CSharp[System. String. Join # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code — VB[System. String. Join # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="value" /> wtedy, gdy ma więcej niż jeden element.</param>
        <param name="value">Tablica zawierająca elementy, które mają być połączone.</param>
        <summary>Łączy wszystkie elementy tablicy ciągów przy użyciu określonego separatora między każdym elementem.</summary>
        <returns>Ciąg, który składa się z elementów <paramref name="value" /> , które są rozdzielane <paramref name="separator" /> przez ciąg. Jeśli <paramref name="value" /> jest tablicą pustą, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i `value` elementami są "Apple", "pomarańcze", "grono" i "gruszki", `Join(separator, value)` zwraca "Apple, pomarańcz, winogron, grusze".  
  
 Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu (). Jeśli dowolny element w `value` to `null`, zamiast niego zostanie użyty pusty ciąg.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Join%2A> metodę.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="value" /> wtedy, gdy ma więcej niż jeden element.</param>
        <param name="value">Tablica zawierająca elementy, które mają być połączone.</param>
        <param name="startIndex">Pierwszy element w <paramref name="value" /> do użycia.</param>
        <param name="count">Liczba elementów <paramref name="value" /> do użycia.</param>
        <summary>Łączy określone elementy tablicy ciągów przy użyciu określonego separatora między każdym elementem.</summary>
        <returns>Ciąg, który składa się z ciągów <paramref name="value" /> rozdzielanych <paramref name="separator" /> przez ciąg.  
  
—lub— 
 <see cref="F:System.String.Empty" />Jeśli <paramref name="count" /> jest równa <paramref name="value" /> zero, nie ma elementów <paramref name="separator" /> ani i wszystkie elementy <paramref name="value" /> <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i `value` elementy są "Apple", "pomarańcze", "grono" i "gruszki", `Join(separator, value, 1, 2)` zwraca "pomarańczowe i winogronowe".  
  
 Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu (). Jeśli dowolny element w `value` to `null`, zamiast niego zostanie użyty pusty ciąg.  
  
   
  
## Examples  
 Poniższy przykład łączy dwa elementy z tablicy nazw owoców.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="count" /> jest mniejsza od 0.  
  
—lub— 
 <paramref name="startIndex" />Plus <paramref name="count" /> jest większa niż liczba elementów w <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <paramref name="values" />.</typeparam>
        <param name="separator">Ciąg, który ma być używany jako separator.<paramref name="separator" /> jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</param>
        <param name="values">Kolekcja zawierająca obiekty do łączenia.</param>
        <summary>Łączy elementy członkowskie kolekcji przy użyciu określonego separatora między poszczególnymi elementami członkowskimi.</summary>
        <returns>Ciąg, który składa się z składowych <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg. Jeśli <paramref name="values" /> nie ma żadnych elementów członkowskich, Metoda <see cref="F:System.String.Empty" />zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu (). Jeśli którykolwiek element członkowski `values` jest `null`, zamiast niego zostanie użyty pusty ciąg.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów członkowskich <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania ich na ciągi. Ciąg reprezentujący każdy obiekt w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.  
  
 Ta metoda jest szczególnie przydatna w przypadku wyrażeń zapytań dotyczących języka (LINQ). Na przykład poniższy kod definiuje bardzo prostą `Animal` klasę, która zawiera nazwę zwierzęcia i kolejność, do której należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, który zawiera `Animal` kilka obiektów. Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiektów, `Order` których właściwość jest równa "gryzonie". <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Wynik jest przesyłany do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu Integer, który następnie przekazuje <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodę.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode lub ciągu w tym wystąpieniu. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać wyszukany.</param>
        <summary>Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w tym wystąpieniu.</summary>
        <returns>Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Ta metoda rozpoczyna wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku rozpoczęcia do momentu `value` znalezienia lub przeanalizowania pierwszej pozycji znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ExtractFilename` metodę, która <xref:System.String.LastIndexOf%28System.Char%29> używa metody do znalezienia ostatniego znaku separatora katalogu w ciągu i wyodrębnienia nazwy pliku ciągu. Jeśli plik istnieje, metoda zwraca nazwę pliku bez jego ścieżki.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</summary>
        <returns>Pozycja początkowego indeksu rozpoczynającego się od zera <paramref name="value" /> , jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest. Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana jest ostatnim położeniem indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu `value` jego znalezienia lub przeanalizowania pierwszej pozycji znaku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%28System.String%29> , które można zignorować, Metoda zawsze zwraca <xref:System.String.Length%2A?displayProperty=nameWithType> wartość-1, która reprezentuje ostatnią pozycję indeksu w bieżącym wystąpieniu. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%29> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ łącznik miękki jest znakiem, który można zignorować, wynik jest taki sam jak w przypadku, gdy łącznik miękki nie został uwzględniony w. `value` Podczas wyszukiwania tylko łącznika miękkiego Metoda zwraca wartość 6 i 5. Te wartości odpowiadają indeksowi ostatniego znaku w dwóch ciągach.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład usuwa otwierając i zamyka Tagi HTML z ciągu, jeśli Tagi zaczynają się i kończą ciąg. Jeśli ciąg kończy się znakiem zamykającego nawiasu klamrowego (">"), w <xref:System.String.LastIndexOf%2A> przykładzie zostanie użyta metoda lokalizowania początku tagu końcowego.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby znaleźć ostatni indeks podciągu w wystąpieniu ciągu przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodę przeciążenia metody z <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać wyszukany.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <summary>Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Pozycja <paramref name="value" /> indeksu liczony od zera, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1. Ta metoda rozpoczyna wyszukiwanie `startIndex` na pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku bieżącego wystąpienia do momentu `value` został znaleziony lub pierwsze położenie znaku zostało zbadane. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie znajduje się indeks wszystkich wystąpień znaku w ciągu, który działa od końca ciągu do początku ciągu.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż lub równe długości tego wystąpienia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest <see cref="F:System.String.Empty" />równe. Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku `value` do momentu jego znalezienia lub przeanalizowania pierwszego stanowiska znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> Metoda jest używana do znajdowania podciągu, który zawiera Łącznik miękki (U + 00AD), który poprzedza lub zawiera końcową literę "m" w ciągu. Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niezbędny w ciągu wyszukiwania jest ignorowany, wywołanie metody w celu znalezienia podciągu, który składa się z łącznika miękkiego i "m" zwraca pozycję "m" w ciągu, podczas gdy wywołanie go w celu znalezienia elementu substrin g, która składa się z łącznika miękkiego i "n" zwraca pozycję "n". Gdy ciąg wyszukiwania zawiera tylko łącznik miękki, metoda zwraca indeks "m", który reprezentuje wartość `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 W poniższym przykładzie znajduje się indeks wszystkich wystąpień ciągu w ciągu docelowym, który działa od końca ciągu docelowego do początku ciągu docelowego.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż długość bieżącego wystąpienia.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze niż-1 lub większe od zera.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby znaleźć indeks podciągu, który poprzedza konkretną pozycję znaku przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raportuje indeks od zera ostatniego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie. Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</summary>
        <returns>Pozycja początkowego indeksu rozpoczynającego się od zera w <paramref name="value" /> przypadku znalezienia tego ciągu lub-1, jeśli nie jest. Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana jest ostatnim położeniem indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu `value` jego znalezienia lub przeanalizowania pierwszej pozycji znaku.  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="options" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <see cref="P:System.String.Length" /> wartość-1, która reprezentuje ostatnią pozycję indeksu w bieżącym wystąpieniu.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niewygładzony jest znakiem, którego nie można zignorować, wyszukiwanie z uwzględnieniem kultury zwraca tę samą wartość, która byłaby zwracana, jeśli łącznik miękki nie został uwzględniony w ciągu wyszukiwania. Wyszukiwanie porządkowe, jednak pomyślnie znajduje łącznik niewygładzony w jednym ciągu i zgłasza, że nie jest on poza drugim ciągiem.  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode, który ma zostać wyszukany.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w podciągu w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</summary>
        <returns>Pozycja <paramref name="value" /> indeksu liczony od zera, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku i przechodzi do tyłu w kierunku początku tego wystąpienia `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkich wystąpień znaku w podciągu, który działa od końca podciągu do początku podciągu.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż lub równe długości tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie <see cref="F:System.String.Empty" />nie jest równe, a <paramref name="startIndex" />  -  <paramref name="count" /> + 1 jest mniejsze od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</summary>
        <returns>Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest <see cref="F:System.String.Empty" />równe. Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku rozpoczęcia `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku. Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%2A> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%2A> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD) w dwóch znakach poprzedzających końcowy "m" dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkich wystąpień ciągu w podciągu, który działa od końca podciągu do początku podciągu.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest wartością ujemną.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest ujemne.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest większe niż długość tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie <see cref="F:System.String.Empty" />nie jest równe, a <paramref name="startIndex" />  -  <paramref name="count" />+ 1 określa pozycję, która nie znajduje się w tym wystąpieniu.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsze niż-1 lub większe od zera.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większe niż 1.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby wykonać tę operację przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę przeciążenia metody z <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raportuje indeks od zera ostatniego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków. Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</summary>
        <returns>Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie odnaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku i przechodzi do tyłu `value` do momentu znalezienia lub przeanalizowania pierwszej pozycji znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku.  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż długość bieżącego wystąpienia.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze niż-1 lub większe od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m", począwszy od końcowego "m" w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku. Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</summary>
        <returns>Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie odnaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.  
  
 Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku i przechodzi do tyłu `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu.  
  
 Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest wartością ujemną.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest ujemne.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest większe niż długość tego wystąpienia.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />, a <paramref name="startIndex" /> + 1 — <paramref name="count" /> określa pozycję, która nie znajduje się w tym wystąpieniu.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsze niż-1 lub większe od zera.  
  
—lub— 
Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większe niż 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</exception>
        <block subset="none" type="usage"><para>Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.  
  
W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje "m" we wszystkich oprócz pierwszej pozycji znaku przed ostatnim "m" w dwóch ciągach. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury. Gdy wykonuje to porównanie porządkowe, znajduje podciąg tylko w pierwszym ciągu. Należy zauważyć, że w przypadku pierwszego ciągu, który zawiera Łącznik miękki, po którym następuje "m", metoda nie zwróci indeksu łącznika miękkiego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie z uwzględnieniem kultury. Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</summary>
        <returns>Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> , lub-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu znalezienia znaku w `anyOf` lub po sprawdzeniu pierwszego położenia znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w innym ciągu.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak z <paramref name="anyOf" /> ;-1, jeśli nie odnaleziono żadnego <paramref name="anyOf" /> znaku lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu znalezienia znaku w `anyOf` lub po sprawdzeniu pierwszego położenia znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w podciągu innego ciągu.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> określa pozycję, która nie znajduje się w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</summary>
        <returns>Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak z <paramref name="anyOf" /> ;-1, jeśli nie odnaleziono żadnego <paramref name="anyOf" /> znaku lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu, gdy zostanie znaleziony znak w `anyOf` lub `count` pozycje znakowe zostały zbadane. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "pomoc" w podciągu innego ciągu.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemne.  
  
—lub— 
Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />, a <paramref name="startIndex" /> minus <paramref name="count" /> + 1 jest mniejsze od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaków w bieżącym <see cref="T:System.String" /> obiekcie.</summary>
        <value>Liczba znaków w bieżącym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> Właściwość zwraca<xref:System.Char> liczbę obiektów w tym wystąpieniu, a nie liczbę znaków Unicode. Przyczyną jest to, że znak Unicode może być reprezentowany przez więcej niż jeden <xref:System.Char>. Użyj klasy do pracy z każdym znakiem Unicode zamiast każdego <xref:System.Char>. <xref:System.Globalization.StringInfo?displayProperty=nameWithType>  
  
 W niektórych językach, takich jak C i C++, znak null wskazuje koniec ciągu. W programie .NET znak null może być osadzony w ciągu. Gdy ciąg zawiera jeden lub więcej znaków null, są one uwzględnione w długości łącznego ciągu. Na przykład, w poniższym ciągu, podciągi "ABC" i "def" są oddzielane znakiem null. <xref:System.String.Length%2A> Właściwość zwraca wartość 7, co oznacza, że zawiera sześć znaków alfabetu, a także znak null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Length%2A> właściwość.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, którego reprezentacja binarna znajduje się w określonym formularzu normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna jest zgodna z formą normalizacji Unicode C.</summary>
        <returns>Nowy, znormalizowany ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale którego reprezentacja binarna jest w postaci C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Na przykład dowolny z następujących punktów kodu może reprezentować literę "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Platforma .NET obsługuje cztery formy normalizacji (C, D, KC i KD), które są zdefiniowane przez standard Unicode. Gdy dwa ciągi są reprezentowane w tym samym formularzu normalizacji, można je porównać przy użyciu porównania porządkowego.  
  
 Aby znormalizować i porównać dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągi do porównania ze źródła danych wejściowych, takie jak plik lub urządzenie wejściowe użytkownika.  
  
2.  Wywołaj <xref:System.String.Normalize> metodę, aby znormalizować ciągi do normalizacji w postaci C.  
  
3.  Aby porównać dwa ciągi, należy wywołać metodę, która obsługuje Porównywanie ciągów porządkowych, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> takie jak metoda, i podać <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> wartość lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argument. Aby posortować tablicę znormalizowanych ciągów, należy przekazać `comparer` <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> wartość lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągi w posortowanych danych wyjściowych na podstawie kolejności wskazanej przez poprzedni krok.  
  
 Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularzy normalizacji, potwierdza, że ciąg został znormalizowany do określonego formularza normalizacji, a następnie wyświetla listę punktów kodu w znormalizowanym ciągu.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formularz normalizacji Unicode.</param>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna znajduje się w określonym formularzu normalizacji Unicode.</summary>
        <returns>Nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna znajduje się w postaci normalizacji <paramref name="normalizationForm" /> określonej przez parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Platforma .NET obsługuje cztery formy normalizacji (C, D, KC i KD), które są zdefiniowane przez standard Unicode. Gdy dwa ciągi są reprezentowane w tym samym formularzu normalizacji, można je porównać przy użyciu porównania porządkowego.  
  
 Aby znormalizować i porównać dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągi do porównania ze źródła danych wejściowych, takie jak plik lub urządzenie wejściowe użytkownika.  
  
2.  Wywołaj <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodę, aby znormalizować ciągi do określonego formularza normalizacji.  
  
3.  Aby porównać dwa ciągi, należy wywołać metodę, która obsługuje Porównywanie ciągów porządkowych, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> takie jak metoda, i podać <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> wartość lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argument. Aby posortować tablicę znormalizowanych ciągów, należy przekazać `comparer` <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> wartość lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągi w posortowanych danych wyjściowych na podstawie kolejności wskazanej przez poprzedni krok.  
  
 Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularzy normalizacji, potwierdza, że ciąg został znormalizowany do określonego formularza normalizacji, a następnie wyświetla listę punktów kodu w znormalizowanym ciągu.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda może zgłosić <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />chociaż zwraca wartość.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone ciągi mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="a" /> jest taka sama jak <paramref name="b" />wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora równości <xref:System.String> dla klasy. <xref:System.String.op_Equality%2A> Umożliwia to kod, taki jak pokazano w sekcji przykład. Operator z kolei wywołuje metodę statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> , która wykonuje numer porządkowy (z uwzględnieniem wielkości liter i bez uwzględniania kultury).  
  
> [!NOTE]
>  Kompilator Visual Basic nie rozpoznaje operatora równości jako wywołania <xref:System.String.op_Equality%2A> metody. Zamiast tego operator równości zawija wywołanie <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje operator równości.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone ciągi mają różne wartości.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="a" /> jest różna od <paramref name="b" />wartości; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora nierówności <xref:System.String> dla klasy. <xref:System.String.op_Inequality%2A>   Umożliwia ona wykonywanie kodu, takiego jak pokazano w sekcji przykładów.  
  
 Operator z kolei wywołuje metodę statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> , która wykonuje porównanie porządkowe (z uwzględnieniem wielkości liter i bez uwzględniania kultury). <xref:System.String.op_Inequality%2A>  
  
> [!NOTE]
>  Kompilator Visual Basic nie rozpoznaje operatora nierówności jako wywołania <xref:System.String.op_Inequality%2A> metody. Zamiast tego operator nierówności otacza wywołanie <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład demonstruje operator nierówności.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym początek bieżącego ciągu jest uzupełniony spacjami lub z określonym znakiem Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który wyrównuje znaki w tym wystąpieniu przez uzupełnienie ich spacjami po lewej stronie, dla określonej całkowitej długości.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i uzupełniony po lewej stronie z dowolną liczbą spacji, aby utworzyć długość <paramref name="totalWidth" />. Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzeń Unicode jest definiowana jako szesnastkowy 0x0020.  
  
 <xref:System.String.PadLeft%28System.Int32%29> Metoda określa początek zwracanego ciągu. Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, w odpowiedniej części ciągu.  
  
> [!NOTE]
>  <xref:System.String.PadLeft%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest uzupełniony wiodącym białym znakiem, tak aby łączna długość była `totalWidth` znakiem.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.PadLeft%2A> metodę.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" />jest mniejsza od zera.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Znak uzupełniania Unicode.</param>
        <summary>Zwraca nowy ciąg, który wyrównuje znaki w tym wystąpieniu przez uzupełnienie ich po lewej stronie z określonym znakiem Unicode, dla określonej całkowitej długości.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i uzupełniony po lewej stronie o <paramref name="paddingChar" /> tyle znaków, ile jest potrzebnych do utworzenia <paramref name="totalWidth" />długości. Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Metoda określa początek zwracanego ciągu. Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, w odpowiedniej części ciągu.  
  
> [!NOTE]
>  <xref:System.String.PadLeft%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest uzupełniony znakami wiodącymi `paddingChar` , tak aby łączna długość była `totalWidth` znakami.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.PadLeft%2A> metodę.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" />jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym koniec bieżącego ciągu jest uzupełniony spacjami lub z określonym znakiem Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który wyrównuje znaki w tym ciągu przez uzupełnienie ich spacjami po prawej stronie, dla określonej całkowitej długości.</summary>
        <returns>Nowy ciąg, który jest równoznaczny z tym wystąpieniem, ale wyrównany do lewej i uzupełniony po prawej stronie z dowolną liczbą spacji, aby utworzyć długość <paramref name="totalWidth" />. Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzeń Unicode jest definiowana jako szesnastkowy 0x0020.  
  
 <xref:System.String.PadRight%28System.Int32%29> Metoda określa koniec zwracanego ciągu. Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, po lewej stronie ciągu.  
  
> [!NOTE]
>  <xref:System.String.PadRight%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który zostanie uzupełniony końcowym białym znakiem, tak aby jego łączna długość była `totalWidth` znakami.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.PadRight%2A> metodę.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" />jest mniejsza od zera.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Znak uzupełniania Unicode.</param>
        <summary>Zwraca nowy ciąg, który wyrównuje znaki w tym ciągu przez uzupełnienie ich po prawej stronie z określonym znakiem Unicode, dla określonej całkowitej długości.</summary>
        <returns>Nowy ciąg, który jest równoważny z tym wystąpieniem, ale wyrównany do lewej i uzupełniony po prawej stronie o <paramref name="paddingChar" /> tyle znaków, ile jest potrzebnych do utworzenia <paramref name="totalWidth" />długości. Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Metoda określa koniec zwracanego ciągu. Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, po lewej stronie ciągu.  
  
> [!NOTE]
>  <xref:System.String.PadRight%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest uzupełniony `paddingChar` znakami końcowymi, tak aby łączna długość była `totalWidth` znaków.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.PadRight%2A> metodę.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" />jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w którym usunięto określoną liczbę znaków z bieżącego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja od zera, aby rozpocząć usuwanie znaków.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu, zaczynając od określonej pozycji i kontynuując ostatnią pozycję, zostały usunięte.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego ciągu, z wyjątkiem usuniętych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]W, ciągi są zależne od zera. Wartość `startIndex` parametru może być z zakresu od zera do jednego mniejszego niż długość wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki od pozycji `startIndex` do końca oryginalnego ciągu zostały usunięte.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.Remove%2A> metodę. W następnym przypadku tekst jest usuwany od określonego indeksu do końca ciągu. Ostatni przypadek usuwa trzy znaki Zaczynając od określonego indeksu.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />Określa pozycję, która nie znajduje się w tym ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja od zera, aby rozpocząć usuwanie znaków.</param>
        <param name="count">Liczba znaków do usunięcia.</param>
        <summary>Zwraca nowy ciąg, w którym usunięto określoną liczbę znaków w bieżącym wystąpieniu rozpoczynającym się w określonej pozycji.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, z wyjątkiem usuniętych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]W, ciągi są zależne od zera. Wartość `startIndex` parametru może być z zakresu od zera do jednego mniejszego niż długość wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym liczba znaków określona przez `count` parametr został usunięty. Znaki są usuwane na pozycji określonej przez `startIndex`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak usunąć nazwę środkową z pełnej nazwy.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> Albo<paramref name="count" /> jest mniejsze od zera.  
  
—lub— 
 <paramref name="startIndex" />Plus <paramref name="count" /> określ pozycję poza tym wystąpieniem.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego znaku Unicode lub <see cref="T:System.String" /> w bieżącym ciągu są zamieniane na inny określony znak Unicode lub. <see cref="T:System.String" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak Unicode, który ma zostać zastąpiony.</param>
        <param name="newChar">Znak Unicode, aby zastąpić wszystkie wystąpienia <paramref name="oldChar" />.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego znaku Unicode w tym wystąpieniu są zamieniane na inny określony znak Unicode.</summary>
        <returns>Ciąg, który jest odpowiednikiem tego wystąpienia, z tą różnicą <paramref name="oldChar" /> , że wszystkie <paramref name="newChar" />wystąpienia programu są zastępowane przez. Jeśli <paramref name="oldChar" /> nie można odnaleźć w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje wyszukiwanie w liczbie porządkowej (uwzględniając `oldChar`wielkość liter i bez uwzględniania wielkości liter).  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie wystąpienia `oldChar` są zastępowane przez. `newChar`  
  
 Ponieważ ta metoda zwraca zmodyfikowany ciąg, można połączyć kolejne wywołania <xref:System.String.Replace%2A> metody, aby wykonać wiele zamian w oryginalnym ciągu. Wywołania metod są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład tworzy listę wartości rozdzielanych przecinkami przez podstawianie przecinków dla pustych danych między serią cyfr.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg, który ma zostać zastąpiony.</param>
        <param name="newValue">Ciąg, w którym mają zostać zamienione <paramref name="oldValue" />wszystkie wystąpienia.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego ciągu w bieżącym wystąpieniu są zastępowane innym określonym ciągiem.</summary>
        <returns>Ciąg, który jest odpowiednikiem bieżącego ciągu, z wyjątkiem tego, że <paramref name="oldValue" /> wszystkie wystąpienia są <paramref name="newValue" />zastępowane przez. Jeśli <paramref name="oldValue" /> nie można odnaleźć w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `newValue` jest `null` ,wszystkie`oldValue` wystąpienia są usuwane.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie wystąpienia `oldValue` są zastępowane przez. `newValue`  
  
 Ta metoda wykonuje wyszukiwanie w liczbie porządkowej (uwzględniając `oldValue`wielkość liter i bez uwzględniania wielkości liter).  
  
 Ponieważ ta metoda zwraca zmodyfikowany ciąg, można połączyć kolejne wywołania <xref:System.String.Replace%2A> metody, aby wykonać wiele zamian w oryginalnym ciągu. Wywołania metod są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, <xref:System.String.Replace%2A> jak można użyć metody w celu naprawienia błędu pisowni.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" />jest ciągiem pustym ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tablicę ciągów zawierającą podciągi w tym wystąpieniu, które są ograniczone przez elementy określonego ciągu lub tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A>służy do dzielenia ciągu rozdzielonego na podciągi. Można użyć tablicy znaków, aby określić zero, jeden lub wiele znaków ograniczających ( <xref:System.String.Split%28System.Char%5B%5D%29> Metoda) lub użyć tablicy znakowej, aby określić zero, jeden lub wiele ciągów, które mają być ograniczone. Przeciążenia metody pozwalają ograniczyć liczbę podciągów zwracanych przez metodę <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> (Metoda), aby określić, czy puste ciągi są zawarte w zwracanych podciągach ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodach lub <xref:System.String.Split%2A> Aby wykonać obie metody ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> ).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternatywy dla ciągu. Split

 <xref:System.String.Split%2A> Metoda nie zawsze jest najlepszym sposobem na rozbicie rozdzielanego ciągu na podciągi. Jeśli nie chcesz wyodrębnić wszystkich podciągów z rozdzielonym ciągiem lub jeśli chcesz przeanalizować ciąg na podstawie wzorca zamiast zestawu znaków ogranicznika, weź pod uwagę następujące alternatywy.  
  
### <a name="regular-expressions"></a>Wyrażenia regularne  
 Jeśli ciągi są zgodne ze stałym wzorcem, można użyć wyrażenia regularnego, aby wyodrębnić i obsłużyć ich elementy. Na przykład, jeśli ciągi przyjmują postać "** ** *numer*operandu numeru" można użyć [wyrażenia regularnego](~/docs/standard/base-types/regular-expressions.md) , aby wyodrębnić i obsłużyć elementy ciągu. Oto przykład:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Wzorzec `(\d+)\s+([-+*/])\s+(\d+)` wyrażenia regularnego jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`([-+*/])`|Dopasowuje znak operatora arytmetycznego (+,-, * lub/). Jest to druga grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to trzecia grupa przechwytywania.|  
  
 Możesz również użyć wyrażenia regularnego, aby wyodrębnić podciągi z ciągu na podstawie wzorca, a nie stałego zestawu znaków. Jest to typowy scenariusz, gdy występuje jeden z następujących warunków:  
  
-   Co najmniej jeden znak ogranicznika nie zawsze pełni rolę ogranicznika w <xref:System.String> wystąpieniu.  
  
-   Sekwencja i liczba znaków ogranicznika są zmienne lub nieznane.  
  
 Na przykład <xref:System.String.Split%2A> Metoda nie może być używana do dzielenia poniższego ciągu, ponieważ `\n` liczba znaków (in C#) lub `vbCrLf` (w Visual Basic) jest zmienna i nie zawsze są one ogranicznikami.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Wyrażenie regularne może łatwo podzielić ten ciąg, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Wzorzec `\[([^\[\]]+)\]` wyrażenia regularnego jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\[`|Dopasowuje nawias otwierający.|  
|`([^\[\]]+)`|Dopasowuje dowolny znak, który nie jest otwierającym lub zamykającym nawiasem jeden lub więcej razy. Jest to pierwsza grupa przechwytywania.|  
|`\]`|Dopasowuje nawias zamykający.|  
  
 Metoda jest niemal identyczna z <xref:System.String.Split%2A?displayProperty=nameWithType>, z tą różnicą, że dzieli ciąg na podstawie wzorca wyrażenia regularnego zamiast stałego zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Na przykład poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metody, aby podzielić ciąg, który zawiera podciągi rozdzielone różnymi kombinacjami łączników i innych znaków.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Wzorzec `\s-\s?[+*]?\s?-\s` wyrażenia regularnego jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\s-`|Dopasowuje znak odstępu, po którym następuje łącznik.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`[+*]?`|Dopasowanie do zera lub jednego wystąpienia znaku + lub *.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`-\s`|Dopasowuje łącznik po którym następuje znak odstępu.|  
  
### <a name="search-methods-and-the-substring-method"></a>Metody wyszukiwania i Metoda substring  
 Jeśli nie interesują Cię wszystkie podciągi w ciągu, być może wolisz pracować z jedną z metod porównywania ciągów, która zwraca indeks, w którym rozpoczyna się dopasowanie. Następnie można wywołać <xref:System.String.Substring%2A> metodę, aby wyodrębnić żądany podciąg. Metody porównywania ciągów obejmują:  
  
-   <xref:System.String.IndexOf%2A>, która zwraca indeks (liczony od zera) pierwszego wystąpienia znaku lub ciągu w wystąpieniu ciągu.  
  
-   <xref:System.String.IndexOfAny%2A>, która zwraca indeks (liczony od zera) w bieżącym wystąpieniu ciągu pierwszego wystąpienia dowolnego znaku w tablicy znaków.  
  
-   <xref:System.String.LastIndexOf%2A>, która zwraca indeks (liczony od zera) ostatniego wystąpienia znaku lub ciągu w wystąpieniu ciągu.  
  
-   <xref:System.String.LastIndexOfAny%2A>, która zwraca indeks (liczony od zera) w bieżącym wystąpieniu ciągu ostatniego wystąpienia dowolnego znaku w tablicy znaków.  
  
 W poniższym przykładzie zastosowano <xref:System.String.IndexOf%2A> metodę, aby znaleźć okresy w ciągu. Następnie używa <xref:System.String.Substring%2A> metody do zwracania pełnych zdań.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <summary>Dzieli ciąg na podciągi, które są oparte na znakach w tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągi z tego wystąpienia, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg jest rozdzielany przez znany zestaw znaków, można użyć <xref:System.String.Split%28System.Char%5B%5D%29> metody, aby oddzielić ją na podciągi.   
  
### <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy. Na przykład, jeśli tablica separatora zawiera znak "-", a wartość bieżącego wystąpienia ciągu to "AA-BB-CC", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".  
  
 Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.  
  
 Każdy element `separator` definiuje oddzielny znak ogranicznika. Jeśli dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element w zwracanej tablicy zawiera <xref:System.String.Empty>. Oto kilka przykładów:  
  
|Wartość ciągu|Separator|Tablica zwrócona|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|New Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42.. 12.. 19"|nowy znak [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|Banan|nowy znak [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>Tablica separatorów  
 Każdy element separatora definiuje oddzielny ogranicznik, który składa się z pojedynczego znaku. Jeśli argument ma `null` lub nie zawiera znaków, Metoda traktuje znaki odstępu jako ograniczniki. `separator` Znaki odstępu są definiowane przez standard Unicode; zwracają `true` one<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> , jeśli są przesyłane do metody.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Ciąg. Split (Char []) i rozwiązanie przeciążenia kompilatora  
 Chociaż pojedynczy parametr dla tego przeciążenia <xref:System.String.Split%2A?displayProperty=nameWithType> jest tablicą znaków, można wywołać ją z pojedynczym znakiem, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Ponieważ parametr ma <xref:System.ParamArrayAttribute> atrybut, kompilatory interpretują pojedynczy znak jako jednoelementowy tablicę znaków. `separator` W przypadku innych <xref:System.String.Split%2A?displayProperty=nameWithType> przeciążeń, które `separator` zawierają parametr; należy jawnie przekazać te przeciążenia tablicę znakową jako `separator` argument.  
  
### <a name="comparison-details"></a>Szczegóły porównania  
 Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków `separator` w tablicy, i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%28System.Char%5B%5D%29>  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter. Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, należy rozważyć <xref:System.String.IndexOf%2A> użycie <xref:System.String.IndexOfAny%2A> metody lub. Istnieje również możliwość użycia <xref:System.String.Compare%2A> metody do lokalizowania podciągu w ciągu.  
  
 Aby podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. Aby podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
## Examples  
 Poniższy przykład ilustruje sposób wyodrębniania pojedynczych wyrazów z bloku tekstu przez traktowanie białych znaków i interpunkcji jako ograniczników. Tablica znaków przeniesiona do `separator` parametru <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody składa się z znaku spacji i znaku tabulacji wraz z niektórymi typowymi symbolami interpunkcji.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy. Należy również określić maksymalną liczbę podciągów do zwrócenia.</summary>
        <returns>Tablica, której elementy zawierają podciągi w tym wystąpieniu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie. Jeśli `count` jest równa zero, zwracana jest pusta tablica.  
  
 Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator` Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.  
  
 Każdy element `separator` definiuje oddzielny znak ogranicznika. Jeśli dwa ograniczniki są przyległe lub ogranicznik jest znaleziony na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>.  
  
 Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.  
  
 W poniższej tabeli przedstawiono przykłady.  
  
|Wartość ciągu|Separator|Count|Tablica zwrócona|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|New Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c, "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42.. 12.. 19"|nowy znak [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|Banan|nowy znak [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] null (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] null (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.  
  
 W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje `count` wpływ liczby ciągów zwracanych przez <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest wartością ujemną.</exception>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</param>
        <summary>Dzieli ciąg na podciągi w oparciu o znaki w tablicy. Można określić, czy podciągi mają zawierać puste elementy tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Znaki ogranicznika (znaki w `separator` tablicy) nie są uwzględniane w elementach zwracanej tablicy. Na przykład, jeśli `separator` tablica zawiera znak "-", a wartość bieżącego wystąpienia ciągu to "AA-BB-CC", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".  
  
 Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.  
  
 Jeśli parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, metoda zwraca pustą tablicę. `options`  
  
 Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z pojedynczego znaku. Jeśli argument jest <xref:System.StringSplitOptions.None>, a dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. `options` Na przykład, jeśli `separator` zawiera dwa elementy, "-" i "\_", wartość wystąpienia ciągu to "-\_AA `options` -\_", a wartość argumentu to <xref:System.StringSplitOptions.None>, metoda zwraca tablicę ciągów z pięć następujących elementów:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg poprzedzający znak "-" pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między znakiem "-" w indeksie 0 i znak "_" pod indeksem 1.  
  
3.  "AA",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po znaku "_" przy indeksie 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po znaku "-" pod indeksem 5.  
  
### <a name="the-separator-array"></a>Tablica separatorów  
 Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator` Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.  
  
 Jeśli parametr w wywołaniu tego przeciążenia metody jest `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. `separator` Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Szczegóły porównania  
 Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden znak `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A>  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter. Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.  
  
 W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica ciągów, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</param>
        <summary>Dzieli ciąg na podciągi na podstawie ciągów w tablicy. Można określić, czy podciągi mają zawierać puste elementy tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg jest rozdzielany przez znany zestaw ciągów, można użyć <xref:System.String.Split%2A> metody, aby oddzielić ją na podciągi.  
  
### <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Ciągi ograniczników nie są uwzględniane w elementach zwracanej tablicy. Na przykład, jeśli `separator` tablica zawiera ciąg "--", a wartość bieżącego wystąpienia ciągu to "AA--BB-DW", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".  
  
 Jeśli to wystąpienie nie zawiera żadnych ciągów w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.  
  
 Jeśli parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, metoda zwraca pustą tablicę. `options`  
  
 Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z co najmniej jednego znaku. Jeśli argument jest <xref:System.StringSplitOptions.None>, a dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. `options` Na przykład, jeśli `separator` zawiera dwa elementy, "-" i "\_", wartość wystąpienia ciągu to "-\_AA `options` -\_", a wartość argumentu to <xref:System.StringSplitOptions.None>, metoda zwraca tablicę Sting z pięć następujących elementów:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg poprzedzający podciąg "-" pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między podciągiem "-" w indeksie 0 i podciąg "_" pod indeksem 1.  
  
3.  "AA",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po podciągu "_" przy indeksie 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po podciągu "-" pod indeksem 5.  
  
### <a name="the-separator-array"></a>Tablica separatorów  
 Jeśli którykolwiek z elementów w `separator` składa się z wielu znaków, cały podciąg jest traktowany jako ogranicznik. Na przykład, jeśli jeden z elementów w `separator` ma wartość "10", próbuje podzielić ciąg "This10is10a10string". zwraca następującą tablicę z czterema elementami: {"This", "is", "a", "String". }.  
  
 Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator` Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.  
  
 Jeśli parametr w wywołaniu tego przeciążenia metody jest `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. `separator` Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Szczegóły porównania  
 Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden ciąg `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A>  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter. Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.  
  
 Metoda ignoruje wszystkie elementy, `separator` których wartość jest `null` lub pusty ciąg (""). <xref:System.String.Split%2A>  
  
 Aby uniknąć niejednoznacznych wyników `separator` <xref:System.String.Split%2A> , gdy ciągi w znaki są wspólne, operacja przechodzi od początku do końca wartości wystąpienia i dopasowuje pierwszy element w `separator` , który jest równy ogranicznikowi w np. Kolejność, w której są napotkane podciągi, ma pierwszeństwo przed kolejnością elementów w `separator`.  
  
 Rozważmy na przykład wystąpienie o wartości "abcdef". Jeśli pierwszy element w `separator` było "EF", a drugi element miał wartość "bcde", wynikiem operacji Split będzie tablica ciągów zawierająca dwa elementy: "a" i "f". Wynika to z faktu, że podciąg w wystąpieniu ("bcde") został napotkany i pasuje `separator` do elementu w elemencie przed wystąpieniem podciągu "f".  
  
 Jeśli jednak pierwszy element elementu `separator` to "bcd", a drugi element miał wartość "BC", wynikiem operacji Split jest tablica ciągów zawierająca dwa elementy: "a" i "EF". Dzieje się tak, ponieważ "bcd" to pierwszy ogranicznik w programie `separator` , który pasuje do ogranicznika w wystąpieniu. Jeśli kolejność separatorów została odwrócona, więc pierwszy element miał wartość "BC", a drugi element to "bcd", wynikiem będzie tablica ciągów zawierająca dwa elementy: "a" i "def".  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.  
  
 W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> ilustruje różnicę w tablicach zwracanych przez wywołanie metody ciągu z jej `options` parametrem równym <xref:System.StringSplitOptions.None?displayProperty=nameWithType> i <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 W poniższym przykładzie zdefiniowano tablicę separatorów, które zawierają znaki interpunkcyjne i odstępy. Przekazanie tej tablicy wraz z wartością <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> do metody zwraca tablicę, która składa się z pojedynczych wyrazów z ciągu.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Należy zauważyć, że metoda jest wywoływana z `options` argumentem ustawionym na <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Zapobiega to dołączeniu <xref:System.String.Empty?displayProperty=nameWithType> wartości, które reprezentują puste podciągi między znakami interpunkcyjnymi i znakami odstępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, `count` lub parametr ma wartość 1, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie. Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator` Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody. Jeśli `separator` jednak parametr w wywołaniu tego przeciążenia metody ma wartość `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ wartości null. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Jeśli parametr ma wartość zero `options` lub parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, zwracana jest pusta tablica. `count`  
  
 Każdy element `separator` definiuje oddzielny znak ogranicznika. Jeśli parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>. `options`  
  
 Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.  
  
 W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest wartością ujemną.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica ciągów, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów na podstawie ciągów w tablicy. Można określić, czy podciągi mają zawierać puste elementy tablicy.</summary>
        <returns>Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Ciągi ograniczników nie są uwzględniane w elementach zwracanej tablicy.  
  
 Jeśli to wystąpienie nie zawiera żadnych ciągów w `separator` `count` lub parametr ma wartość 1, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie. Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator` Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody. Jeśli `separator` jednak parametr w wywołaniu tego przeciążenia metody ma wartość `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Jeśli parametr ma wartość zero `options` lub parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, zwracana jest pusta tablica. `count`  
  
 Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z co najmniej jednego znaku. Jeśli parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>. `options`  
  
 Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.  
  
### <a name="the-separator-array"></a>Tablica separatorów  
 Jeśli którykolwiek z elementów w `separator` składa się z wielu znaków, cały podciąg jest traktowany jako ogranicznik. Na przykład, jeśli jeden z elementów w `separator` ma wartość "10", próbuje podzielić ciąg "This10is10a10string". zwraca tablicę czterech elementów: {"This", "is", "a", "String". }.  
  
### <a name="comparison-details"></a>Szczegóły porównania  
 Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden ciąg `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A>  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter. Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.  
  
 Metoda ignoruje wszystkie elementy, `separator` których wartość jest `null` lub pusty ciąg (""). <xref:System.String.Split%2A>  
  
 Aby uniknąć niejednoznacznych wyników `separator` <xref:System.String.Split%2A> , gdy ciągi w znaki są wspólne, Metoda przechodzi od początku do końca wartości wystąpienia i dopasowuje pierwszy element w `separator` , który jest równy ogranicznikowi w np. Kolejność, w której są napotkane podciągi, ma pierwszeństwo przed kolejnością elementów w `separator`.  
  
 Rozważmy na przykład wystąpienie o wartości "abcdef". Jeśli pierwszy element w `separator` było "EF", a drugi element miał wartość "bcde", wynikiem operacji podziału byłaby "a" i "f". Wynika to z faktu, że podciąg w wystąpieniu ("bcde") został napotkany i pasuje `separator` do elementu w elemencie przed wystąpieniem podciągu "f".  
  
 Jeśli jednak pierwszy element `separator` to "bcd", a drugi element miał wartość "BC", wynikiem operacji podziału byłaby "a" i "EF". Dzieje się tak, ponieważ "bcd" to pierwszy ogranicznik w programie `separator` , który pasuje do ogranicznika w wystąpieniu. Jeśli kolejność separatorów została odwrócona, więc pierwszy element miał wartość "BC", a drugi element to "bcd", wynikiem byłaby "a" i "def".  
  
### <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A> Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.  
  
 W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu. W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora. Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest wartością ujemną.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg. Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <summary>Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> pasuje do początku tego ciągu; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` do podciągu na początku tego wystąpienia, które ma taką samą długość jak `value`i zwraca wskazanie, czy są równe. Musi być pustym ciągiem (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi być zgodna z początkiem tego wystąpienia. `value`  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `StripStartTags` metodę, która <xref:System.String.StartsWith%28System.String%29> używa metody do usuwania tagów początkowych HTML od początku ciągu znaków. Należy zauważyć, `StripStartTags` że metoda jest wywoływana cyklicznie, aby upewnić się, że wiele tagów początkowych HTML na początku wiersza zostanie usuniętych. Przykład nie usuwa tagów HTML osadzonych w ciągu.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby określić, czy ciąg rozpoczyna się od określonego podciągu przy użyciu reguł porównywania ciągów bieżącej kultury, wywołaj <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, która określa, jak ten ciąg <paramref name="value" /> i są porównywane.</param>
        <summary>Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną opcją porównania.</summary>
        <returns><see langword="true" />Jeśli to wystąpienie zaczyna się <paramref name="value" />od; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> Metoda porównujeparametrdopodciągunapoczątkutegociąguizwracawartośćwskazującą`value` , czy są równe. Aby była równa `value` , musi być odwołaniem do tego samego ciągu, musi być pustym ciągiem ("") lub musi być zgodna z początkiem tego ciągu. Typ porównania wykonywanego przez <xref:System.String.StartsWith%2A> metodę zależy od wartości `comparisonType` parametru. Porównanie może korzystać z Konwencji bieżącej kultury (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> i <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) lub niezmiennej kultury (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> i <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) lub może składać się z porównania znak po znaku dla punktów kodu (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Wynikiem porównania może być również uwzględnianie wielkości liter<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>( <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>,, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>lub) lub ignorowanie wielkości liter (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Poniższy przykład wyszukuje ciąg "The" na początku dłuższego ciągu, który rozpoczyna się od słowa "The". Dane wyjściowe z przykładu pokazują, że wywołanie <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metody, która wykonuje niezależność od wielkości liter, ale nie dopasowuje się do ciągu, podczas gdy wywołanie, które wykonuje porównanie bez uwzględniania wielkości liter, pasuje do ciągu.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Poniższy przykład określa, czy ciąg rozpoczyna się od określonego podciągu. Inicjuje dwuwymiarową tablicę ciągów. Pierwszy element w drugim wymiarze zawiera ciąg, a drugi element zawiera ciąg do wyszukania na początku pierwszego ciągu. Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe. Należy zauważyć, że gdy wystąpienie ciągu zawiera ligatury, porównywanie z uwzględnieniem kultury z następującymi po sobie znakami powiodło się.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></param>
        <param name="culture">Informacje kulturowe, które określają, jak <paramref name="value" /> ten ciąg i są porównywane. Jeśli <paramref name="culture" /> jest<see langword="null" />, używana jest bieżąca kultura.</param>
        <summary>Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną kulturą.</summary>
        <returns><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z początkiem tego ciągu; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` parametr do podciągu na początku tego ciągu, który ma taką samą długość jak `value`i zwraca wartość wskazującą, czy są równe. Musi być pustym ciągiem (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi być zgodna z początkiem tego wystąpienia. `value`  
  
 Ta metoda wykonuje porównanie przy użyciu określonej wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na początku innego ciągu. <xref:System.String.StartsWith%2A> Metoda jest wywoływana kilka razy przy użyciu czułości wielkości liter, nierozróżniania wielkości liter i różnych kultur, które wpływają na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera podciąg z tego wystąpienia.  
  
 Ten element członkowski jest przeciążony. Aby uzyskać pełne informacje dotyczące tego elementu członkowskiego, w tym informacje o jego składni i zastosowaniu oraz odpowiednie przykłady, kliknij nazwę na liście przeciążeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Początkowa pozycja znaku w podciągu w tym wystąpieniu (liczony od zera).</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg zaczyna się od określonej pozycji znaku i przechodzi do końca ciągu.</summary>
        <returns>Ciąg, który jest odpowiednikiem podciągu, który rozpoczyna <paramref name="startIndex" /> się w tym wystąpieniu <paramref name="startIndex" /> lub <see cref="F:System.String.Empty" /> jest równy długości tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana <xref:System.String.Substring%28System.Int32%29> jest metoda wyodrębniania podciągu z ciągu, który rozpoczyna się od określonej pozycji znaku i kończy się na końcu ciągu. Początkowe położenie znaku jest zależne od zera. Innymi słowy, pierwszy znak w ciągu ma indeks 0, a nie indeks 1. Aby wyodrębnić podciąg, który rozpoczyna się od określonej pozycji znaku i kończy przed końcem ciągu, wywołaj <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który rozpoczyna się w `startIndex` pozycji w bieżącym ciągu.  
  
 Aby wyodrębnić podciąg, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołaj metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> , `startIndex`Aby uzyskać wartość. Drugi przykład ilustruje to; Wyodrębnia wartość klucza rozpoczynającą się jedną pozycją znaku po znaku "=".  
  
 Jeśli `startIndex` jest równa zero, metoda zwraca oryginalny ciąg niezmieniony.  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać podciąg z ciągu.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 W poniższym przykładzie zastosowano <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane znakiem równości ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycji znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, która zaczyna się od pierwszego znaku w ciągu i rozszerza liczbę znaków zwracanych przez wywołanie <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metody następnie wyodrębnia wartość przypisaną do klucza. Zaczyna się od jednej pozycji znaku poza znakiem równości i rozciąga się na koniec ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Początkowa pozycja znaku w podciągu w tym wystąpieniu (liczony od zera).</param>
        <param name="length">Liczba znaków w podciągu.</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg zaczyna się od określonej pozycji znaku i ma określoną długość.</summary>
        <returns>Ciąg, który jest równoznaczny z podciągiem długości <paramref name="length" /> , który <paramref name="startIndex" /> rozpoczyna się w tym wystąpieniu, <see cref="F:System.String.Empty" /> lub <paramref name="startIndex" /> jeśli jest równy długości tego wystąpienia i <paramref name="length" /> wynosi zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> jest metoda wyodrębniania podciągu z ciągu, który rozpoczyna się od określonej pozycji znaku i kończy przed końcem ciągu. Początkowe położenie znaku jest zależne od zera. Innymi słowy, pierwszy znak w ciągu ma indeks 0, a nie indeks 1. Aby wyodrębnić podciąg, który rozpoczyna się od określonej pozycji znaku i przechodzi do końca ciągu, wywołaj <xref:System.String.Substring%28System.Int32%29> metodę.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg `length` znaków, zaczynając `startIndex` od pozycji w bieżącym ciągu.  
  
 `length` Parametr reprezentuje łączną liczbę znaków do wyodrębnienia z bieżącego wystąpienia ciągu. Obejmuje to znak początkowy znaleziony w indeksie `startIndex`.  <xref:System.String.Substring%2A> Innymi słowy, metoda próbuje wyodrębnić znaki z indeksu `length` `startIndex` do indeksu `startIndex`  +  -1.  
  
 Aby wyodrębnić podciąg, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołaj metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> , `startIndex`Aby uzyskać wartość.  
  
 Jeśli podciąg rozciąga się od `startIndex` do określonej sekwencji znaków, można wywołać metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> , aby uzyskać indeks znaku końcowego lub sekwencji znaków.  Następnie można przekonwertować tę wartość na pozycję indeksu w ciągu w następujący sposób:  
  
-   Jeśli `length` szukasz pojedynczego znaku, który ma oznaczać koniec podciągu, parametr jest równy `endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex` + 1, gdzie `endIndex` jest wartością zwracaną lub <xref:System.String.IndexOf%2A> Method. Poniższy przykład wyodrębnia ciągły blok znaków "b" z ciągu.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Jeśli szukasz wielu znaków, które mają oznaczać koniec podciągu, `length` parametr Equals `endIndex`  +  `startIndex` `endMatchLength`  - ma wartość, gdzie `endIndex` jest wartością zwracaną<xref:System.String.IndexOf%2A> lub Metoda<xref:System.String.IndexOf%2A> oraz`endMatchLength` jest długością sekwencji znaków, która oznacza koniec podciągu. Poniższy przykład wyodrębnia blok tekstu, który zawiera element XML `<definition>` .  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Jeśli znak lub sekwencja znaków nie `length` jest uwzględniona na końcu podciągu, `endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex`parametr ma wartość, gdzie `endIndex` jest wartością zwracaną lub <xref:System.String.IndexOf%2A> Method.  
  
 Jeśli `startIndex` jest równa zero i równa długości bieżącego ciągu, metoda zwraca oryginalny ciąg niezmieniony.  
  
   
  
## Examples  
 Poniższy przykład ilustruje proste wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody, która wyodrębnia dwa znaki z ciągu, zaczynając od szóstej pozycji znaku (czyli przy indeksie pięciu).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 W poniższym przykładzie zastosowano <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę w następujących trzech przypadkach w celu wyodrębnienia podciągów w ciągu. W dwóch przypadkach podciągi są używane w porównaniach, a w trzecim przypadku wyjątek jest zgłaszany, ponieważ określono nieprawidłowe parametry.  
  
-   Wyodrębnia pojedynczy znak i trzecią pozycję w ciągu (przy indeksie 2) i porównuje go z literą "c". To porównanie zwraca `true`wartość.  
  
-   Wyodrębnia zero znaków, zaczynając od czwartego pozycji w ciągu (przy indeksie 3) i przekazuje go do <xref:System.String.IsNullOrEmpty%2A> metody. Zwraca wartość true, ponieważ wywołanie <xref:System.String.Substring%2A> metody zwraca <xref:System.String.Empty?displayProperty=nameWithType>wartość.  
  
-   Podejmuje próbę wyodrębnienia jednego znaku, rozpoczynając od czwartej pozycji w ciągu. Ponieważ w tym miejscu nie ma żadnego znaku, wywołanie metody zgłasza <xref:System.ArgumentOutOfRangeException> wyjątek.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 W poniższym przykładzie zastosowano <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane znakiem równości ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycji znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, która zaczyna się od pierwszego znaku w ciągu i rozszerza liczbę znaków zwracanych przez wywołanie <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metody następnie wyodrębnia wartość przypisaną do klucza. Zaczyna się od jednej pozycji znaku poza znakiem równości i rozciąga się na koniec ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znak <paramref name="length" /> Plus wskazuje pozycję, która nie znajduje się w tym wystąpieniu.  
  
—lub— 
 <paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację <see cref="T:System.String" /> bieżącego obiektu.</summary>
        <returns>Moduł wyliczający z jednoznacznie określonym typem, który może być używany do iteracji <see cref="T:System.String" /> w bieżącym obiekcie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.Collections.Generic.IEnumerable%601> na obiekt interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację <see cref="T:System.String" /> bieżącego obiektu.</summary>
        <returns>Moduł wyliczający, który może służyć do iteracji w bieżącym ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli wartość bieżącego ciągu to <see cref="F:System.Boolean.TrueString" />; wartość bieżącego ciągu to <see cref="F:System.Boolean.FalseString" />. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego ciągu nie <see cref="F:System.Boolean.TrueString" /> jest lub. <see cref="F:System.Boolean.FalseString" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Byte.MaxValue" /> większą lub mniejszą niż <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Znak pod indeksem 0 w bieżącym <see cref="T:System.String" /> obiekcie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniejszą niż <see cref="F:System.Decimal.MinValue" /> lub <see cref="F:System.Decimal.MaxValue" /> większą.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Double.MinValue" /> mniejszą lub większą od <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Int16.MaxValue" /> większą lub mniejszą niż <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.SByte.MaxValue" /> większą lub mniejszą niż <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ zwracanego obiektu.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przekonwertowana na typ określony <paramref name="type" /> przez parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.UInt16.MaxValue" /> większą lub mniejszą niż <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą większą <see cref="F:System.UInt32.MaxValue" /> lub mniejszą niż<see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, której elementy są pojedynczymi znakami tego wystąpienia. Jeśli to wystąpienie jest pustym ciągiem, zwracana tablica jest pusta i ma zerową długość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje każdy znak (czyli każdy <xref:System.Char> obiekt) w ciągu do tablicy znaków. Pierwszy skopiowany znak jest przy indeksie równym zero zwróconej tablicy znaków; Ostatni skopiowany znak ma wartość index <xref:System.Array.Length%2A?displayProperty=nameWithType> -1.  
  
 Aby utworzyć ciąg znaków w tablicy znaków, wywołaj <xref:System.String.%23ctor%28System.Char%5B%5D%29> konstruktora.  
  
 Aby utworzyć tablicę bajtową, która zawiera zakodowane znaki w ciągu, Utwórz wystąpienie <xref:System.Text.Encoding> odpowiedniego obiektu i Wywołaj jego <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> metodę. Niektóre standardowe kodowanie dostępne w programie .NET obejmują następujące elementy:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje metodę, <xref:System.String.ToCharArray%2A> aby wyodrębnić znaki w ciągu do tablicy znaków. Następnie wyświetla oryginalny ciąg i elementy w tablicy.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano ciąg zawierający znaki, które pełnią rolę ograniczników w ciągu rozdzielanym. Następnie wywołuje <xref:System.String.ToCharArray%2A> metodę, aby utworzyć tablicę znaków, która może zostać przeniesiona <xref:System.String.Split%28System.Char%5B%5D%29> do metody w celu oddzielenia rozdzielanego ciągu na jego poszczególne podciągi.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja początkowa podciągu w tym wystąpieniu.</param>
        <param name="length">Długość podciągu w tym wystąpieniu.</param>
        <summary>Kopiuje znaki w określonym podciągu w tym wystąpieniu do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, <paramref name="length" /> której elementy to liczba znaków w tym wystąpieniu rozpoczynająca się od pozycji <paramref name="startIndex" />znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje znaki w części ciągu do tablicy znaków. Aby utworzyć ciąg z zakresu znaków w tablicy znaków, wywołaj <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora.  
  
 `startIndex` Parametr jest oparty na zero. Oznacza to, że indeks pierwszego znaku w wystąpieniu ciągu wynosi zero.  
  
 Jeśli `length` jest równa zero, zwracana tablica jest pusta i ma zerową długość. Jeśli to wystąpienie jest `null` lub pustym ciągiem (""), zwracana tablica jest pusta i ma zerową długość.  
  
 Aby utworzyć tablicę bajtową, która zawiera zakodowane znaki w części ciągu, Utwórz wystąpienie odpowiedniego <xref:System.Text.Encoding> obiektu i Wywołaj jego <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> metodę. Niektóre standardowe kodowanie dostępne w programie .NET obejmują:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład konwertuje podciąg w ciągu na tablicę znaków, a następnie wylicza i wyświetla elementy tablicy.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />znak <paramref name="length" /> Plus jest większy niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na małe litery.</summary>
        <returns>Ciąg pisany małymi literami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda uwzględnia reguły wielkości liter bieżącej kultury.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Operacja uwzględniania wielkości liter, która wynika <xref:System.String.ToLower> z wywołania metody, przyjmuje konwencje wielkości liter w obecnej kulturze. Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A> Daje to ten sam wynik w każdej kulturze (w przeciwieństwie do <xref:System.String.ToLower> metody) i wykonuje bardziej wydajne działanie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje kilka mieszanych ciągów wielkości liter na małe litery.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod wielkości liter w ciągu, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby skonwertować znak na małe litery przy użyciu konwencji wielkości liter w bieżącej kulturze, wywołaj <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> Przeciążenie metody <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> wartością dla <paramref name="culture" /> parametru.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na małe litery przy użyciu reguł wielkości liter w określonej kulturze.</summary>
        <returns>Odpowiednik małymi literami bieżącego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguły wielkości liter kultury określonej przez `culture` parametr określają sposób zmiany wielkości liter ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> metody obiektu innego niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja przekroczenia spowoduje uwzględnienie reguł dotyczących kultury. Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A> Daje to ten sam wynik w każdej kulturze i wykonuje bardziej wydajne działanie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje dwa ciągi wielkich liter na małe litery przy użyciu kultur Stany Zjednoczone i tureckich, a następnie porównuje ciągi z małymi literami. Wielkie litery są identyczne, z wyjątkiem tego, że dla każdego wystąpienia wielkiej litery Unicode I w jednym ciągu, drugi ciąg zawiera wielką LITERę I z KROPKą powyżej.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowaną na małe litery przy użyciu reguł wielkości liter dla niezmiennej kultury.</summary>
        <returns>Odpowiednik małymi literami bieżącego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest ona skojarzona z językiem angielskim, ale nie z określonym krajem lub regionem. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwość.  
  
 Jeśli aplikacja jest zależna od wielkości liter zmiany ciągu w przewidywalny sposób, który nie ma wpływu na bieżącą kulturę, użyj <xref:System.String.ToLowerInvariant%2A> metody. Metoda jest równoważna z `ToLower(CultureInfo.InvariantCulture)`. <xref:System.String.ToLowerInvariant%2A> Metoda jest zalecana, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolce interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A>  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczy wyraz w wielu językach. <xref:System.String.ToLowerInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległej bez uwzględniania wielkości liter każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy małych liter, aby zapewnić, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana żadna rzeczywista konwersja.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ ta metoda po prostu zwraca bieżący ciąg niezmieniony, nie ma potrzeby wywoływania go bezpośrednio. Jest zazwyczaj wywoływana niejawnie w operacji formatowania złożonego, jak pokazano w przykładzie.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.String.ToString%2A> metodę. Należy zauważyć, że przykład nie wywołuje <xref:System.String.ToString%2A> jawnie metody. Zamiast tego Metoda jest wywoływana niejawnie przez funkcję [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana żadna rzeczywista konwersja.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider`jest zarezerwowany i nie uczestniczy obecnie w tej operacji.  
  
 Ponieważ ta metoda po prostu zwraca bieżący ciąg niezmieniony, nie ma potrzeby wywoływania go bezpośrednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na wielkie litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na wielkie litery.</summary>
        <returns>Wielka litera odpowiadająca bieżącemu ciągowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa reguł wielkości liter bieżącej kultury do konwersji każdego znaku w bieżącym wystąpieniu na jego wielką literę. Jeśli znak nie ma wielkiej litery, jest uwzględniany niezmieniony w zwracanym ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
 <xref:System.String.ToUpper%2A> Metoda jest często używana do przekonwertowania ciągu na wielkie litery, aby można było go użyć w porównaniu bez uwzględniania wielkości liter. Lepszym sposobem wykonania porównania bez uwzględniania wielkości liter jest wywołanie metody porównywania ciągów, która ma <xref:System.StringComparison> parametr, którego wartość jest <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> ustawiona na potrzeby porównania z uwzględnieniem wielkości kulturowej.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Operacja uwzględniania wielkości liter, która wynika <xref:System.String.ToUpper> z wywołania metody, przyjmuje konwencje wielkości liter w obecnej kulturze. Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A> Daje to ten sam wynik w każdej kulturze (w przeciwieństwie do <xref:System.String.ToUpper> metody) i wykonuje bardziej wydajne działanie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje metodę, <xref:System.String.ToUpper%2A> Aby skonwertować serię ciągów jednoznakowych, które zawierają każdy znak w bazowym języku łaciński, łaciński-1 i łaciński rozszerzony-zestaw znaków. Następnie wyświetla każdy ciąg, którego wielkie litery różni się od znaku małymi literami.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod wielkości liter w ciągu, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia. Aby przekonwertować ciąg na wielkie litery przy użyciu konwencji wielkości liter w bieżącej kulturze, wywołaj <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> Przeciążenie metody <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> wartością dla <paramref name="culture" /> parametru.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię tego ciągu przekonwertowaną na wielkie litery przy użyciu reguł wielkości liter w określonej kulturze.</summary>
        <returns>Wielka litera odpowiadająca bieżącemu ciągowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguły wielkości liter kultury określonej przez `culture` parametr określają sposób zmiany wielkości liter ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> metody obiektu innego niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja przekroczenia spowoduje uwzględnienie reguł dotyczących kultury. Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A> Daje to ten sam wynik w każdej kulturze i wykonuje bardziej wydajne działanie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg małych liter na dwa ciągi wielkich liter przy użyciu kultur Stany Zjednoczone i turecki-Turcja, a następnie porównuje ciągi z wielką literą. Wielkie litery są identyczne, z wyjątkiem tego, że dla każdego wystąpienia wielkiej litery Unicode I w jednym ciągu, drugi ciąg zawiera wielką LITERę I z KROPKą powyżej.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowaną na wielkie litery przy użyciu reguł wielkości liter dla niezmiennej kultury.</summary>
        <returns>Wielka litera odpowiadająca bieżącemu ciągowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest ona skojarzona z językiem angielskim, ale nie z określonym krajem lub regionem. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwość.  
  
 Jeśli aplikacja jest zależna od wielkości liter zmiany ciągu w przewidywalny sposób, który nie ma wpływu na bieżącą kulturę, użyj <xref:System.String.ToUpperInvariant%2A> metody. Metoda jest równoważna z `ToUpper(CultureInfo.InvariantCulture)`. <xref:System.String.ToUpperInvariant%2A> Metoda jest zalecana, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolce interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A>  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczy wyraz w wielu językach. <xref:System.String.ToUpperInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległej bez uwzględniania wielkości liter każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy z wielką literą, aby upewnić się, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w którym usuwane są wszystkie początkowe i końcowe wystąpienia zestawu określonych znaków z bieżącego <see cref="T:System.String" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wiodące i końcowe znaki białych z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostanie po wszystkich znakach odstępu zostanie usunięty z początku i końca bieżącego ciągu. Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Metoda usuwa z bieżącego ciągu wszystkie wiodące i końcowe znaki białych znaków. Każda operacja przycinania wiodących i końcowych zostaje zatrzymana, gdy zostanie napotkany znak niebędący odstępem. Na przykład, jeśli bieżącym ciągiem jest "ABC XYZ", <xref:System.String.Trim%2A> Metoda zwraca "ABC XYZ". Aby usunąć znaki odstępu między wyrazami w ciągu, użyj [wyrażeń regularnych programu .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  <xref:System.String.Trim%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie początkowe i końcowe białe znaki Znalezione w bieżącym wystąpieniu są usuwane.  
  
 Jeśli bieżący ciąg jest równy <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się ze znaków odstępu, metoda zwraca. <xref:System.String.Empty>  
  
 Znaki odstępu są definiowane przez standard Unicode. Metoda usuwa wszystkie znaki wiodące i końcowe, które generują `true` wartość zwracaną, gdy są <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> one przesyłane do metody. <xref:System.String.Trim>  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody <xref:System.String.Trim?displayProperty=nameWithType> , aby usunąć wszystkie dodatkowe odstępy od ciągów wprowadzonych przez użytkownika przed ich połączeniem.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>I [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] starsze wersje zachowują wewnętrzną listę znaków białych, które są przycinane przez tę metodę. Począwszy od <see langword="true" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> , metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]która metoda w i nowszych wersjach. nie usuwaj. Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie początkowe i końcowe wystąpienia zestawu znaków określonego w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z początku i końca bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu. Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa z bieżącego ciągu wszystkie znaki wiodące i końcowe, które znajdują się `trimChars` w parametrze. <xref:System.String.Trim%2A> Każda operacja przycinania wiodących i końcowych zostaje zatrzymana, gdy wystąpił znak, który nie znajduje się w `trimChars` . Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.Trim%2A> , metoda zwraca wartość "abc456xyz".  
  
> [!NOTE]
>  <xref:System.String.Trim%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie `trimChars` znaki wiodące i końcowe Znalezione w bieżącym wystąpieniu są usuwane.  
  
 Jeśli bieżący ciąg jest równy <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się z znaków `trimChars` w tablicy, metoda zwraca <xref:System.String.Empty>.  
  
 Jeśli `trimChars` jest `null` lub jest pustą tablicą, ta metoda usuwa wszystkie znaki wiodące lub końcowe, które powodują zwrócenie `true` metody po przekazaniu ich <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody,  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metody do usuwania spacji, gwiazdki (*) i znaków apostrofu (') z ciągu.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] <see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]która metoda w i nowszych wersjach. nie usuwaj. Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie końcowe wystąpienia zestawu znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z końca bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu Unicode. Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa z bieżącego ciągu wszystkie znaki końcowe, które znajdują się `trimChars` w parametrze. <xref:System.String.TrimEnd%2A> Operacja Trim zostaje zatrzymana, gdy pierwszy znak, który nie `trimChars` znajduje się na końcu ciągu znaków. Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimEnd%2A> , metoda zwraca wartość "123abc456xyz".  
  
> [!NOTE]
>  <xref:System.String.TrimEnd%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki końcowe Znalezione w programie `trimChars` są usuwane z bieżącego ciągu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje, <xref:System.String.TrimEnd%28System.Char%5B%5D%29> jak można użyć metody do przycinania białych znaków lub interpunkcji z końca ciągu.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] <see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] która metoda w i nowszych wersjach. nie usuwaj. Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wiodące wystąpienia zestawu znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z początku bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa z bieżącego ciągu wszystkie znaki wiodące, które znajdują się `trimChars` w parametrze. <xref:System.String.TrimStart%2A> Operacja Trim zostaje zatrzymana, gdy wystąpił znak, `trimChars` który nie znajduje się w. Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimStart%2A> , metoda zwraca wartość "abc456xyz789".  
  
> [!NOTE]
>  <xref:System.String.TrimStart%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w którym zostaną usunięte wszystkie wiodące białe znaki znajdujące się w bieżącym wystąpieniu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono podstawowe funkcje <xref:System.String.TrimStart%2A> metody:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 W poniższym przykładzie zastosowano <xref:System.String.TrimStart%2A> metodę, aby przyciąć biały znak i znaki komentarza z wierszy kodu źródłowego. Metoda zawija wywołanie do <xref:System.String.TrimStart%2A> i przekazuje go tablicę znaków, która zawiera spację i znak komentarza, który jest apostrofem (') w Visual Basic i ukośnik (/) w. C# `StripComments` Metoda <xref:System.String.TrimStart%2A> jest również wywoływana, aby usunąć wiodący biały znak podczas oceniania, czy ciąg jest komentarzem.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 Poniższy przykład ilustruje wywołanie `StripComments` metody.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] <see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] która metoda w i nowszych wersjach. nie usuwaj. Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>

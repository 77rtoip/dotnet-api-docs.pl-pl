<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="467811e82b79d9da56a9489d688a30fe2598faf4" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405009" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ba178-101">Reprezentuje tekst jako sekwencję jednostek kodu UTF-16.</span><span class="sxs-lookup"><span data-stu-id="ba178-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="ba178-102">Ciąg jest sekwencyjną kolekcją znaków, która jest używana do reprezentowania tekstu.</span><span class="sxs-lookup"><span data-stu-id="ba178-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="ba178-103">Obiekt jest sekwencyjną <xref:System.Char?displayProperty=nameWithType> kolekcją obiektów, które <xref:System.Char?displayProperty=nameWithType> reprezentują ciąg; obiekt odpowiada jednostce kodu UTF-16. <xref:System.String></span><span class="sxs-lookup"><span data-stu-id="ba178-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="ba178-104">Wartość <xref:System.String> obiektu jest zawartością sekwencyjnej <xref:System.Char?displayProperty=nameWithType> kolekcji obiektów i ta wartość jest niezmienna (oznacza to, że jest ona tylko do odczytu).</span><span class="sxs-lookup"><span data-stu-id="ba178-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="ba178-105">Więcej informacji o niezmienności ciągów znajduje się w sekcji [niezmienności i StringBuilder klasy](#Immutability) w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="ba178-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="ba178-106">Maksymalny rozmiar <xref:System.String> obiektu w pamięci wynosi 2 GB lub około 1 000 000 000 znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 <span data-ttu-id="ba178-107">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="ba178-107">In this section:</span></span>  
  
 <span data-ttu-id="ba178-108">[Tworzenie wystąpienia obiektu String](#Instantiation) </span><span class="sxs-lookup"><span data-stu-id="ba178-108">[Instantiating a String object](#Instantiation) </span></span>  
 <span data-ttu-id="ba178-109">[Obiekty char i znaki Unicode](#Characters) </span><span class="sxs-lookup"><span data-stu-id="ba178-109">[Char objects and Unicode characters](#Characters) </span></span>  
 <span data-ttu-id="ba178-110">[Ciągi i standard Unicode](#Unicode) </span><span class="sxs-lookup"><span data-stu-id="ba178-110">[Strings and The Unicode Standard](#Unicode) </span></span>  
 <span data-ttu-id="ba178-111">[Ciągi i osadzone znaki null](#EmbeddedNulls) </span><span class="sxs-lookup"><span data-stu-id="ba178-111">[Strings and embedded null characters](#EmbeddedNulls) </span></span>  
 <span data-ttu-id="ba178-112">[Ciągi i indeksy](#Indexes) </span><span class="sxs-lookup"><span data-stu-id="ba178-112">[Strings and indexes](#Indexes) </span></span>  
 <span data-ttu-id="ba178-113">[Ciągi o wartości null i puste ciągi](#Nulls) </span><span class="sxs-lookup"><span data-stu-id="ba178-113">[Null strings and empty strings](#Nulls) </span></span>  
 <span data-ttu-id="ba178-114">[Niezmienności i StringBuilder — Klasa](#Immutability) </span><span class="sxs-lookup"><span data-stu-id="ba178-114">[Immutability and the StringBuilder class](#Immutability) </span></span>  
 <span data-ttu-id="ba178-115">[Liczba porządkowa a operacje zależne od kultury](#CultureSensitive) </span><span class="sxs-lookup"><span data-stu-id="ba178-115">[Ordinal vs. culture-sensitive operations](#CultureSensitive) </span></span>  
 <span data-ttu-id="ba178-116">[Normalizacji](#Normalization) </span><span class="sxs-lookup"><span data-stu-id="ba178-116">[Normalization](#Normalization) </span></span>  
 [<span data-ttu-id="ba178-117">Operacje na ciągach według kategorii</span><span class="sxs-lookup"><span data-stu-id="ba178-117">String operations by category</span></span>](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a><span data-ttu-id="ba178-118">Utworzenie wystąpienia obiektu String</span><span class="sxs-lookup"><span data-stu-id="ba178-118">Instantiating a String object</span></span>  
 <span data-ttu-id="ba178-119">Można utworzyć wystąpienie <xref:System.String> obiektu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-119">You can instantiate a <xref:System.String> object in the following ways:</span></span>  
  
-   <span data-ttu-id="ba178-120">Przypisanie literału ciągu do <xref:System.String> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="ba178-120">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="ba178-121">Jest to najczęściej stosowana metoda tworzenia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-121">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="ba178-122">Poniższy przykład używa przypisania do tworzenia kilku ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-122">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="ba178-123">Należy zauważyć, C#że w, ponieważ ukośnik odwrotny (\\) jest znakiem ucieczki, literały ukośników odwrotnych w ciągu muszą być zmienione lub cały ciąg musi być. @-quoted</span><span class="sxs-lookup"><span data-stu-id="ba178-123">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <span data-ttu-id="ba178-124">Wywoływanie <xref:System.String> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="ba178-124">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="ba178-125">Poniższy przykład tworzy wystąpienie ciągów, wywołując kilka konstruktorów klas.</span><span class="sxs-lookup"><span data-stu-id="ba178-125">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="ba178-126">Należy zauważyć, że niektóre konstruktory zawierają wskaźniki do tablic znaków lub podpisanych tablic bajtów jako parametry.</span><span class="sxs-lookup"><span data-stu-id="ba178-126">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="ba178-127">Visual Basic nie obsługuje wywołań tych konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="ba178-127">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="ba178-128">Aby uzyskać szczegółowe informacje <xref:System.String> na temat konstruktorów <xref:System.String.%23ctor%2A> , zobacz podsumowanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-128">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   <span data-ttu-id="ba178-129">Za pomocą operatora łączenia ciągów (+ w C# i & lub + w Visual Basic) do tworzenia pojedynczego ciągu z dowolnej kombinacji <xref:System.String> wystąpień i literałów ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-129">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="ba178-130">Poniższy przykład ilustruje użycie operatora łączenia ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-130">The following example illustrates the use of the string concatenation operator.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   <span data-ttu-id="ba178-131">Pobierając właściwość lub wywołując metodę zwracającą ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-131">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="ba178-132">W poniższym przykładzie zastosowano metody <xref:System.String> klasy, aby wyodrębnić podciąg z większego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-132">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   <span data-ttu-id="ba178-133">Wywołując metodę formatowania, aby przekonwertować wartość lub obiekt na jego reprezentację w postaci ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-133">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="ba178-134">Poniższy przykład używa funkcji [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby osadzić ciąg reprezentujący dwa obiekty w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-134">The following example uses the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="ba178-135">Obiekty char i znaki Unicode</span><span class="sxs-lookup"><span data-stu-id="ba178-135">Char objects and Unicode characters</span></span>  
 <span data-ttu-id="ba178-136">Każdy znak w ciągu jest definiowany przez wartość skalarną Unicode, zwaną również literą kodu Unicode lub wartość porządkową (numeryczną) znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-136">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="ba178-137">Każdy punkt kodu jest kodowany przy użyciu kodowania UTF-16, a wartość liczbowa każdego elementu kodowania jest reprezentowana przez <xref:System.Char> obiekt.</span><span class="sxs-lookup"><span data-stu-id="ba178-137">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-138">Należy zauważyć, że ponieważ <xref:System.String> wystąpienie składa się z sekwencyjnej kolekcji jednostek kodu UTF-16, można <xref:System.String> utworzyć obiekt, który nie jest poprawnie sformułowanym ciągiem Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-138">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="ba178-139">Na przykład można utworzyć ciąg, który ma dolny Surogat bez odpowiadającego znaku wieloskładnikowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-139">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="ba178-140">Chociaż niektóre metody, takie jak metody kodowania i dekodowania obiektów w <xref:System.Text> przestrzeni nazw, mogą wykonywać sprawdzenia, aby upewnić się, że ciągi są dobrze sformułowane, <xref:System.String> członkowie klasy nie zapewnią, że ciąg jest poprawnie sformułowany.</span><span class="sxs-lookup"><span data-stu-id="ba178-140">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>  
  
 <span data-ttu-id="ba178-141">Pojedynczy <xref:System.Char> obiekt zazwyczaj reprezentuje pojedynczy punkt kodu; oznacza to, że wartość <xref:System.Char> liczbowa jest równa punktowi kodu.</span><span class="sxs-lookup"><span data-stu-id="ba178-141">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="ba178-142">Na przykład punkt kodu dla znaku "a" to U + 0061.</span><span class="sxs-lookup"><span data-stu-id="ba178-142">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="ba178-143">Jednak punkt kodu może wymagać więcej niż jednego zakodowanego elementu (więcej niż jeden <xref:System.Char> obiekt).</span><span class="sxs-lookup"><span data-stu-id="ba178-143">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="ba178-144">Standard Unicode definiuje dwa typy znaków, które odpowiadają wielu <xref:System.Char> obiektom: graphemes i dodatkowe punkty kodowe Unicode, które odnoszą się do znaków w dodatkowych płaszczyznach Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-144">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>  
  
-   <span data-ttu-id="ba178-145">Grapheme jest reprezentowane przez znak podstawowy, po którym następuje co najmniej jeden łączący się znak.</span><span class="sxs-lookup"><span data-stu-id="ba178-145">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="ba178-146">Na przykład znak ä jest reprezentowany przez <xref:System.Char> obiekt, którego punkt kodu to u + 0061 <xref:System.Char> , po którym następuje obiekt, którego punkt kodu to u + 0308.</span><span class="sxs-lookup"><span data-stu-id="ba178-146">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="ba178-147">Ten znak może być również definiowany przez pojedynczy <xref:System.Char> obiekt, który ma punkt kodu U + 00E4.</span><span class="sxs-lookup"><span data-stu-id="ba178-147">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="ba178-148">Jak pokazano na poniższym przykładzie, porównywanie kulturowe dla równości wskazuje, że te dwie reprezentacje są równe, chociaż zwykłe porównanie porządkowe nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-148">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="ba178-149">Jeśli jednak dwa ciągi są znormalizowane, porównanie porządkowe wskazuje również, że są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-149">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="ba178-150">(Aby uzyskać więcej informacji na temat normalizacji ciągów, [](#Normalization) Zobacz sekcję normalizacji).</span><span class="sxs-lookup"><span data-stu-id="ba178-150">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   <span data-ttu-id="ba178-151">Dodatkowy punkt kodu Unicode (para dwuskładnikowa) jest reprezentowany przez <xref:System.Char> obiekt, którego punkt kodowy jest dużym surogatem, a następnie <xref:System.Char> obiektem, którego punkt kodowy jest dolnym surogatem.</span><span class="sxs-lookup"><span data-stu-id="ba178-151">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="ba178-152">Jednostki kodu dla dużych surogatów mieszczą się w zakresie od U + D800 do U + DBFF.</span><span class="sxs-lookup"><span data-stu-id="ba178-152">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="ba178-153">Jednostki kodu dla małych surogatów mieszczą się w zakresie od U + DC00 do U + DFFF.</span><span class="sxs-lookup"><span data-stu-id="ba178-153">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="ba178-154">Pary dwuskładnikowe służą do reprezentowania znaków w dodatkowych płaszczyznach 16 Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-154">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="ba178-155">Poniższy przykład tworzy znak zastępczy i przekazuje go do <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metody, aby określić, czy jest to para dwuskładnikowa.</span><span class="sxs-lookup"><span data-stu-id="ba178-155">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="ba178-156">Ciągi i standard Unicode</span><span class="sxs-lookup"><span data-stu-id="ba178-156">Strings and the Unicode Standard</span></span>  
 <span data-ttu-id="ba178-157">Znaki w ciągu są reprezentowane przez jednostki kodu kodowane w formacie UTF-16, które odpowiadają <xref:System.Char> wartościom.</span><span class="sxs-lookup"><span data-stu-id="ba178-157">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>  
  
 <span data-ttu-id="ba178-158">Każdy znak w ciągu ma skojarzoną kategorię znaków Unicode, która jest reprezentowana w programie .NET przez <xref:System.Globalization.UnicodeCategory> Wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="ba178-158">Each character in a string has an associated Unicode character category, which is represented in .NET by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="ba178-159">Kategorię znaku lub pary zastępczej można określić, wywołując <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-159">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 <span data-ttu-id="ba178-160">Ponadto platforma .NET obsługuje Porównywanie ciągów i sortowanie na podstawie standardu Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-160">In addition, .NET supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="ba178-161">W wersjach .NET Framework przez [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework zachowuje własną tabelę danych ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-161">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="ba178-162">Jest to również prawdziwe w przypadku wersji .NET Framework rozpoczynających [!INCLUDE[net_v45](~/includes/net-v45-md.md)] się od uruchomienia w systemie Windows 7.</span><span class="sxs-lookup"><span data-stu-id="ba178-162">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="ba178-163">[!INCLUDE[net_v45](~/includes/net-v45-md.md)] Począwszy od systemu operacyjnego Windows 8 i jego nowszych wersji, środowisko uruchomieniowe deleguje porównanie ciągów i sortowania do systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="ba178-163">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="ba178-164">W przypadku platformy .NET Core informacje o porównywaniu ciągów i sortowaniu są udostępniane przez [składniki międzynarodowe dla bibliotek Unicode](http://site.icu-project.org/) . W poniższej tabeli wymieniono wersje programu .NET i wersje standardu Unicode, w których są oparte porównywane i sortowane znaki.</span><span class="sxs-lookup"><span data-stu-id="ba178-164">On .NET Core, string comparison and sorting information is provided by  [International Components for Unicode](http://site.icu-project.org/) libraries.The following table lists the versions of .NET and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>  
  
|<span data-ttu-id="ba178-165">Wersja platformy .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-165">.NET version</span></span>|<span data-ttu-id="ba178-166">Wersja Unicode Standard</span><span class="sxs-lookup"><span data-stu-id="ba178-166">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="ba178-167">Standard Unicode wersji 4.0.0</span><span class="sxs-lookup"><span data-stu-id="ba178-167">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="ba178-168">.NET Framework 2,0</span><span class="sxs-lookup"><span data-stu-id="ba178-168">The .NET Framework 2.0</span></span>|[<span data-ttu-id="ba178-169">Standard Unicode wersji 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ba178-169">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="ba178-170">Standard Unicode wersji 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ba178-170">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="ba178-171">Standard Unicode wersji 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ba178-171">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="ba178-172">i nowszych w systemie Windows 7</span><span class="sxs-lookup"><span data-stu-id="ba178-172">and later on Windows 7</span></span>|[<span data-ttu-id="ba178-173">Standard Unicode wersji 5.0.0</span><span class="sxs-lookup"><span data-stu-id="ba178-173">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="ba178-174">i nowszych wersjach systemu Windows 8 i nowszych systemów operacyjnych Windows</span><span class="sxs-lookup"><span data-stu-id="ba178-174">and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="ba178-175">Standard Unicode wersji wersji 6.3.0</span><span class="sxs-lookup"><span data-stu-id="ba178-175">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|<span data-ttu-id="ba178-176">.NET core (wszystkie wersje)</span><span class="sxs-lookup"><span data-stu-id="ba178-176">.NET Core (all versions)</span></span>|<span data-ttu-id="ba178-177">Zależy od wersji standardu Unicode obsługiwanego przez podstawowy system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="ba178-177">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="ba178-178">Ciągi i osadzone znaki o wartości zerowej</span><span class="sxs-lookup"><span data-stu-id="ba178-178">Strings and embedded null characters</span></span>  
 <span data-ttu-id="ba178-179">W programie .NET <xref:System.String> obiekt może zawierać osadzone znaki null, które są liczone jako część długości ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-179">In .NET, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="ba178-180">Jednak w niektórych językach, takich jak C i C++, znak null wskazuje koniec ciągu; nie jest uważany za część ciągu i nie jest liczony jako część długości ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-180">However, in some languages such as C and C++, a null character indicates the end of a string; it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="ba178-181">Oznacza to, że następujące typowe założenia, że C C++ i programiści lub biblioteki w języku c C++ lub mogą wprowadzać ciągi niekoniecznie są ważne w przypadku <xref:System.String> zastosowania do obiektów:</span><span class="sxs-lookup"><span data-stu-id="ba178-181">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>  
  
-   <span data-ttu-id="ba178-182">Wartość zwracana przez `strlen` funkcję lub `wcslen` nie musi być równa <xref:System.String.Length%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-182">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ba178-183">Ciąg utworzony przez `strcpy_s` lub `wcscpy_s` funkcji nie musi być identyczny z ciągiem utworzonym przez <xref:System.String.Copy%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-183">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba178-184">Należy upewnić się, że natywne C i C++ kod <xref:System.String> , który tworzy wystąpienia obiektów, oraz <xref:System.String> kod, który jest przesyłany przez wywołanie platformy, nie zakłada, że osadzony znak null oznacza koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-184">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>  
  
 <span data-ttu-id="ba178-185">Osadzone znaki null w ciągu są również traktowane inaczej, gdy ciąg jest sortowany (lub porównywany) i kiedy przeszukiwany jest ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-185">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="ba178-186">Znaki null są ignorowane podczas przeprowadzania porównania z uwzględnieniem kultury między dwoma ciągami, w tym porównania przy użyciu niezmiennej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-186">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="ba178-187">Są one uznawane tylko za porównania porządkowe lub nieuwzględniające wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-187">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="ba178-188">Z drugiej strony osadzone znaki null są zawsze brane pod uwagę podczas wyszukiwania ciągu przy użyciu metod takich jak <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, i <xref:System.String.IndexOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba178-188">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a><span data-ttu-id="ba178-189">Ciągi i indeksy</span><span class="sxs-lookup"><span data-stu-id="ba178-189">Strings and indexes</span></span>  
 <span data-ttu-id="ba178-190">Indeks jest pozycją <xref:System.Char> obiektu (nie znakiem Unicode) <xref:System.String>w.</span><span class="sxs-lookup"><span data-stu-id="ba178-190">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="ba178-191">Indeks jest liczony od zera liczbą nieujemną rozpoczynającą się od pierwszej pozycji w ciągu, która jest pozycją indeksu równą zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-191">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="ba178-192">Wiele metod wyszukiwania, takich jak <xref:System.String.IndexOf%2A> i <xref:System.String.LastIndexOf%2A>, zwraca indeks znaku lub podciągu w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-192">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>  
  
 <span data-ttu-id="ba178-193">Właściwość umożliwia dostęp do pojedynczych <xref:System.Char> obiektów według ich pozycji indeksu w ciągu. <xref:System.String.Chars%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-193">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="ba178-194">Ponieważ właściwość jest właściwością domyślną (w Visual Basic) lub indeksatorem (w programie C#), można uzyskać dostęp do poszczególnych <xref:System.Char> obiektów w ciągu za pomocą kodu, takiego jak poniższy. <xref:System.String.Chars%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-194">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="ba178-195">Ten kod szuka białych znaków w ciągu, aby określić, ile wyrazów zawiera ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-195">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <span data-ttu-id="ba178-196">Ponieważ klasa implementuje interfejs, <xref:System.Char> można także wykonać iterację obiektów w ciągu przy użyciu `foreach` konstrukcji, jak pokazano w poniższym przykładzie. <xref:System.Collections.IEnumerable> <xref:System.String></span><span class="sxs-lookup"><span data-stu-id="ba178-196">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 <span data-ttu-id="ba178-197">Kolejne wartości indeksów mogą nie odpowiadać na kolejne znaki Unicode, ponieważ znak Unicode może być zakodowany jako więcej niż jeden <xref:System.Char> obiekt.</span><span class="sxs-lookup"><span data-stu-id="ba178-197">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="ba178-198">W szczególności ciąg może zawierać jednoznakowe jednostki tekstu, które są tworzone przez znak podstawowy, po którym następuje co najmniej jeden łączenie znaków lub przez pary zastępcze.</span><span class="sxs-lookup"><span data-stu-id="ba178-198">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="ba178-199">Aby współpracować ze znakami Unicode zamiast <xref:System.Char> obiektów, <xref:System.Globalization.StringInfo?displayProperty=nameWithType> Użyj klas i <xref:System.Globalization.TextElementEnumerator> .</span><span class="sxs-lookup"><span data-stu-id="ba178-199">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes.</span></span> <span data-ttu-id="ba178-200">Poniższy przykład ilustruje różnicę między kodem, który działa z <xref:System.Char> obiektami i kodem, który działa ze znakami Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-200">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="ba178-201">Porównuje liczbę znaków lub elementów tekstu w każdym słowie zdania.</span><span class="sxs-lookup"><span data-stu-id="ba178-201">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="ba178-202">Ciąg zawiera dwie sekwencje znaków podstawowych, po których następuje łączenie znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-202">The string includes two sequences of a base character followed by a combining character.</span></span>  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 <span data-ttu-id="ba178-203">Ten przykład działa z elementami tekstowymi przy użyciu <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> metody <xref:System.Globalization.TextElementEnumerator> i klasy do wyliczania wszystkich elementów tekstu w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-203">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="ba178-204">Możesz również pobrać tablicę zawierającą indeks początkowy każdego elementu tekstowego, wywołując <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-204">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba178-205">Aby uzyskać więcej informacji na temat pracy z jednostkami tekstu, <xref:System.Char> a nie pojedynczymi <xref:System.Globalization.StringInfo> wartościami, zobacz Klasa.</span><span class="sxs-lookup"><span data-stu-id="ba178-205">For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.</span></span>  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="ba178-206">Ciągi zerowe i puste ciągi</span><span class="sxs-lookup"><span data-stu-id="ba178-206">Null strings and empty strings</span></span>  
 <span data-ttu-id="ba178-207">Ciąg, który został zadeklarowany, ale nie ma przypisanej wartości `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-207">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="ba178-208">Próba wywołania metod w tym ciągu zwraca wartość <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="ba178-208">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="ba178-209">Ciąg o wartości null różni się od pustego ciągu, który jest ciągiem, którego wartością jest "" <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-209">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-210">W niektórych przypadkach przekazywanie ciągu o wartości null lub pustego ciągu jako argumentu w wywołaniu metody zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-210">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="ba178-211">Na przykład przekazywanie ciągu o wartości null do <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metody <xref:System.ArgumentNullException>zgłasza, i przekazywanie pustego ciągu zgłasza <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba178-211">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ba178-212">W innych przypadkach argument metody może być ciągiem o wartości null lub ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="ba178-212">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="ba178-213">Na przykład, jeśli dostarczasz <xref:System.IFormattable> implementację klasy, chcesz zrównać zarówno ciąg o wartości null, jak i pusty ciąg z specyfikatorem formatu ogólnego ("G").</span><span class="sxs-lookup"><span data-stu-id="ba178-213">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>  
  
 <span data-ttu-id="ba178-214">Klasa obejmuje dwie metody wygodne, które umożliwiają przetestowanie, czy ciąg jest `null` lub pusty: <xref:System.String></span><span class="sxs-lookup"><span data-stu-id="ba178-214">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>  
  
-   <span data-ttu-id="ba178-215"><xref:System.String.IsNullOrEmpty%2A>, która wskazuje, czy ciąg ma wartość `null` lub jest <xref:System.String.Empty?displayProperty=nameWithType>równa.</span><span class="sxs-lookup"><span data-stu-id="ba178-215"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-216">Ta metoda eliminuje konieczność użycia kodu, takiego jak:</span><span class="sxs-lookup"><span data-stu-id="ba178-216">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <span data-ttu-id="ba178-217"><xref:System.String.IsNullOrWhiteSpace%2A>, która wskazuje, czy ciąg jest `null`równa <xref:System.String.Empty?displayProperty=nameWithType>lub polega wyłącznie na znakach odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-217"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="ba178-218">Ta metoda eliminuje konieczność użycia kodu, takiego jak:</span><span class="sxs-lookup"><span data-stu-id="ba178-218">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 <span data-ttu-id="ba178-219">W poniższym przykładzie zastosowano <xref:System.String.IsNullOrEmpty%2A> metodę <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> w implementacji klasy niestandardowej `Temperature` .</span><span class="sxs-lookup"><span data-stu-id="ba178-219">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="ba178-220">Metoda obsługuje ciągi formatu "G", "C", "F" i "K".</span><span class="sxs-lookup"><span data-stu-id="ba178-220">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="ba178-221">Jeśli pusty ciąg formatu lub ciąg formatu, którego wartość jest `null` przenoszona do metody, jego wartość jest zmieniana na ciąg formatu "G".</span><span class="sxs-lookup"><span data-stu-id="ba178-221">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="ba178-222">Niezmienność i klasa StringBuilder</span><span class="sxs-lookup"><span data-stu-id="ba178-222">Immutability and the StringBuilder class</span></span>  
 <span data-ttu-id="ba178-223"><xref:System.String> Obiekt jest wywoływany jako niezmienny (tylko do odczytu), ponieważ jego wartość nie może być modyfikowana po utworzeniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-223">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="ba178-224">Metody, które pojawiają się <xref:System.String> w celu zmodyfikowania obiektu <xref:System.String> , faktycznie zwracają nowy obiekt, który zawiera modyfikację.</span><span class="sxs-lookup"><span data-stu-id="ba178-224">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>  
  
 <span data-ttu-id="ba178-225">Ponieważ ciągi są niezmienne, procedury manipulowania ciągami, które wykonują powtarzające się operacje dodawania lub usuwania do elementów, które wydaje się być pojedynczym ciągiem, mogą dokładnie mieć znaczny spadek wydajności.</span><span class="sxs-lookup"><span data-stu-id="ba178-225">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="ba178-226">Na przykład poniższy kod używa generatora liczb losowych, aby utworzyć ciąg z 1000 znaków w zakresie 0x0001 do 0x052F.</span><span class="sxs-lookup"><span data-stu-id="ba178-226">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="ba178-227">Chociaż kod wydaje się używać łączenia ciągów do dołączania nowego znaku do istniejącego ciągu o nazwie `str`, w rzeczywistości tworzy nowy <xref:System.String> obiekt dla każdej operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-227">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 <span data-ttu-id="ba178-228">Można użyć <xref:System.Text.StringBuilder> klasy zamiast <xref:System.String> klasy dla operacji, które wprowadzają wiele zmian do wartości ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-228">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="ba178-229">W przeciwieństwie do wystąpień <xref:System.String> klasy, <xref:System.Text.StringBuilder> obiekty są modyfikowalne; podczas łączenia, dołączania lub usuwania podciągów z ciągu, operacje są wykonywane na pojedynczym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-229">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="ba178-230">Po zakończeniu modyfikowania wartości <xref:System.Text.StringBuilder> obiektu można wywołać jego <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować ją na ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-230">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="ba178-231">Poniższy przykład zastępuje <xref:System.String> użycie w poprzednim przykładzie, aby połączyć 1000 losowe znaki z zakresu do 0x0001 do 0x052F <xref:System.Text.StringBuilder> z obiektem.</span><span class="sxs-lookup"><span data-stu-id="ba178-231">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="ba178-232">Operacje porządkowe vs. operacje zależne od kultury</span><span class="sxs-lookup"><span data-stu-id="ba178-232">Ordinal vs. culture-sensitive operations</span></span>  
 <span data-ttu-id="ba178-233">Elementy członkowskie <xref:System.String> klasy wykonują operacje na obiektach porządkowych lub wrażliwych na kulturę. <xref:System.String></span><span class="sxs-lookup"><span data-stu-id="ba178-233">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="ba178-234">Operacja porządkowa działa na wartości liczbowej każdego <xref:System.Char> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-234">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="ba178-235">Operacje zależne od kultury działają na wartości <xref:System.String> obiektu i pobierają wielkość liter, sortowanie, formatowanie i analizowanie reguł dla konta.</span><span class="sxs-lookup"><span data-stu-id="ba178-235">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="ba178-236">Operacje zależne od kultury są wykonywane w kontekście jawnie zadeklarowanej kultury lub niejawnej bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-236">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="ba178-237">Dwa rodzaje operacji mogą generować różne wyniki, gdy są wykonywane na tym samym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-237">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>  
  
<span data-ttu-id="ba178-238">Platforma .NET obsługuje także wielokulturowe operacje na ciągach lingwistycznych przy użyciu niezmiennej<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>kultury (), która jest luźno oparta na ustawieniach kultury w języku angielskim niezależnym od regionu.</span><span class="sxs-lookup"><span data-stu-id="ba178-238">.NET also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="ba178-239">W przeciwieństwie <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> do innych ustawień, ustawienia niezmiennej kultury są gwarantowane, że są spójne na jednym komputerze, z systemu do systemu i między różnymi wersjami programu .NET.</span><span class="sxs-lookup"><span data-stu-id="ba178-239">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of .NET.</span></span> <span data-ttu-id="ba178-240">Niezmienna kultura może być traktowana jako rodzaj czarnego pola, które zapewnia stabilność porównywania ciągów i porządkowanie we wszystkich kulturach.</span><span class="sxs-lookup"><span data-stu-id="ba178-240">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba178-241">Jeśli aplikacja wykonuje decyzję o zabezpieczeniach dotyczącą identyfikatora symbolicznego, takiego jak nazwa pliku lub potok nazwany lub informacje o utrwalonych danych, takich jak dane tekstowe w pliku XML, operacja powinna używać porównania porządkowego zamiast porównania z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-241">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-242">Wynika to z faktu, że porównanie wrażliwe na kulturę może dać różne wyniki w zależności od kultury, podczas gdy porównanie porządkowe zależy wyłącznie od wartości binarnej porównywanych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-242">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba178-243">Większość metod wykonywania operacji na ciągach zawiera Przeciążenie, które ma parametr typu <xref:System.StringComparison>, który pozwala określić, czy metoda wykonuje operacje porządkową lub zależną od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-243">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="ba178-244">Ogólnie rzecz biorąc, należy wywołać to Przeciążenie, aby przeznaczenie metody zostało wyczyszczone.</span><span class="sxs-lookup"><span data-stu-id="ba178-244">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="ba178-245">Aby zapoznać się z najlepszymi rozwiązaniami i wskazówkami dotyczącymi używania porządkowej i kulturowej operacji na ciągach, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-245">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-246">Operacje dotyczące [wielkości liter](#casing), [analizowania i formatowania](#parsing), [porównywania i sortowania](#comparison)oraz [testowania pod kątem równości](#equality) mogą być porządkowe lub wrażliwe na kulturę.</span><span class="sxs-lookup"><span data-stu-id="ba178-246">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="ba178-247">W poniższych sekcjach omówiono każdą kategorię operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-247">The following sections discuss each category of operation.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="ba178-248">Należy zawsze wywołać metodę przeciążenia metody, która sprawia, że cel wywołania metody jest wyczyszczony.</span><span class="sxs-lookup"><span data-stu-id="ba178-248">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="ba178-249"><xref:System.String.Compare%28System.String%2CSystem.String%29> Na przykład zamiast wywołania metody w celu przeprowadzenia porównania z dwoma ciągami z uwzględnieniem kultury przy użyciu Konwencji bieżącej kultury, należy <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> wywołać <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> metodę z wartością dla `comparisonType` argument.</span><span class="sxs-lookup"><span data-stu-id="ba178-249">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="ba178-250">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-250">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  

<span data-ttu-id="ba178-251">Można pobrać [tabele wagi sortowania](https://www.microsoft.com/download/details.aspx?id=10921), zestaw plików tekstowych, które zawierają informacje o wagach znaków używanych w operacjach sortowania i porównywania dla systemów operacyjnych Windows, a także [domyślną tabelę elementów sortowania Unicode](https://www.unicode.org/Public/UCA/latest/allkeys.txt), sortowanie tabela wag dla systemów Linux i macOS.</span><span class="sxs-lookup"><span data-stu-id="ba178-251">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the sort weight table for Linux and macOS.</span></span>

<a name="casing"></a>   
### <a name="casing"></a><span data-ttu-id="ba178-252">Wielkość znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-252">Casing</span></span>  
 <span data-ttu-id="ba178-253">Zasady dotyczące wielkości liter określają, jak zmienić wielkooć liter znaku Unicode; na przykład z małych i wielkich liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-253">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="ba178-254">Często operacje dotyczące wielkości liter są wykonywane przed porównaniem ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-254">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="ba178-255">Na przykład ciąg może zostać przekonwertowany na wielkie litery, aby można go było porównać z innym ciągiem z wielką literą.</span><span class="sxs-lookup"><span data-stu-id="ba178-255">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="ba178-256">Możesz przekonwertować znaki w ciągu na <xref:System.String.ToLower%2A> małe, wywołując metodę lub <xref:System.String.ToLowerInvariant%2A> i konwertując je <xref:System.String.ToUpper%2A> na wielkie litery poprzez wywołanie metody lub <xref:System.String.ToUpperInvariant%2A> .</span><span class="sxs-lookup"><span data-stu-id="ba178-256">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ba178-257">Ponadto można użyć <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metody do przekonwertowania ciągu na wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-257">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 <span data-ttu-id="ba178-258">Operacje dotyczące wielkości liter mogą opierać się na regułach bieżącej kultury, określonej kulturze lub kulturze niezmiennej.</span><span class="sxs-lookup"><span data-stu-id="ba178-258">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="ba178-259">Ponieważ mapowania wielkości liter mogą się różnić w zależności od używanej kultury, wynik operacji wielkości liter może się różnić w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-259">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="ba178-260">Rzeczywiste różnice w wielkości liter są trzy rodzaje:</span><span class="sxs-lookup"><span data-stu-id="ba178-260">The actual differences in casing are of three kinds:</span></span>  
  
-   <span data-ttu-id="ba178-261">Różnice w mapowaniu przypadku Wielkiej litery I (U + 0049), małych LITERAch I (U + 0069), Wielkiej litery I z KROPKą powyżej (U + 0130) i MAŁĄ LITERą bez ZNAKiem i (U + 0131).</span><span class="sxs-lookup"><span data-stu-id="ba178-261">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="ba178-262">W przypadku kultur TR-TR (turecki (Turcja)) i az-Latn-AZ (Azerbejdżan, łaciński), a w obszarze TR, AZ i az-Latn neutralnych, małe litery ALFABETu łacińskiego i są małymi LITERAmi bez znakiem i z wielką literą WIELKA LITERA I Z KROPKĄ POWYŻEJ.</span><span class="sxs-lookup"><span data-stu-id="ba178-262">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="ba178-263">We wszystkich innych kulturach, w tym w niezmiennej kulturze, mała litera i Wielka litera, a to małe i wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-263">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>  
  
     <span data-ttu-id="ba178-264">W poniższym przykładzie pokazano, jak porównanie ciągów, które uniemożliwia dostęp do systemu plików, może się nie powieść, jeśli jest to zależne od porównania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-264">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="ba178-265">(Konwencje wielkości liter kultury niezmiennej powinny być używane).</span><span class="sxs-lookup"><span data-stu-id="ba178-265">(The casing conventions of the invariant culture should have been used.)</span></span>  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   <span data-ttu-id="ba178-266">Różnice w mapowaniu wielkości liter między kulturą niezmienną i wszystkimi innymi kulturami.</span><span class="sxs-lookup"><span data-stu-id="ba178-266">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="ba178-267">W takich przypadkach, używając reguł wielkości liter kultury niezmiennej, aby zmienić znak na wielkie lub małe litery zwraca ten sam znak.</span><span class="sxs-lookup"><span data-stu-id="ba178-267">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="ba178-268">Dla wszystkich innych kultur zwraca inny znak.</span><span class="sxs-lookup"><span data-stu-id="ba178-268">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="ba178-269">Niektóre z tych znaków zostały wymienione w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="ba178-269">Some of the affected characters are listed in the following table.</span></span>  
  
    |<span data-ttu-id="ba178-270">Znak</span><span class="sxs-lookup"><span data-stu-id="ba178-270">Character</span></span>|<span data-ttu-id="ba178-271">W przypadku zmiany na</span><span class="sxs-lookup"><span data-stu-id="ba178-271">If changed to</span></span>|<span data-ttu-id="ba178-272">Zwraca</span><span class="sxs-lookup"><span data-stu-id="ba178-272">Returns</span></span>|  
    |---------------|-------------------|-------------|  
    |<span data-ttu-id="ba178-273">ZNAK MIKRO (U + 00B5)</span><span class="sxs-lookup"><span data-stu-id="ba178-273">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="ba178-274">Wielkie litery</span><span class="sxs-lookup"><span data-stu-id="ba178-274">Uppercase</span></span>|<span data-ttu-id="ba178-275">WIELKA LITERA GRECKA (U +-39C)</span><span class="sxs-lookup"><span data-stu-id="ba178-275">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|  
    |<span data-ttu-id="ba178-276">WIELKA LITERA I Z KROPKĄ POWYŻEJ (U + 0130)</span><span class="sxs-lookup"><span data-stu-id="ba178-276">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="ba178-277">Małe litery</span><span class="sxs-lookup"><span data-stu-id="ba178-277">Lowercase</span></span>|<span data-ttu-id="ba178-278">MAŁA LITERA I (U + 0069)</span><span class="sxs-lookup"><span data-stu-id="ba178-278">LATIN SMALL LETTER I (U+0069)</span></span>|  
    |<span data-ttu-id="ba178-279">MAŁA LITERA Z KROPKĄ I (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="ba178-279">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="ba178-280">Wielkie litery</span><span class="sxs-lookup"><span data-stu-id="ba178-280">Uppercase</span></span>|<span data-ttu-id="ba178-281">WIELKA LITERA I (U + 0049)</span><span class="sxs-lookup"><span data-stu-id="ba178-281">LATIN CAPITAL LETTER I (U+0049)</span></span>|  
    |<span data-ttu-id="ba178-282">MAŁA LITERA S (U + 017F)</span><span class="sxs-lookup"><span data-stu-id="ba178-282">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="ba178-283">Wielkie litery</span><span class="sxs-lookup"><span data-stu-id="ba178-283">Uppercase</span></span>|<span data-ttu-id="ba178-284">WIELKA LITERA S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="ba178-284">LATIN CAPITAL LETTER S (U+0053)</span></span>|  
    |<span data-ttu-id="ba178-285">WIELKA LITERA D Z MAŁĄ LITERĄ Z ODWRÓCONYM DASZKIEM (U + 01C5)</span><span class="sxs-lookup"><span data-stu-id="ba178-285">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="ba178-286">Małe litery</span><span class="sxs-lookup"><span data-stu-id="ba178-286">Lowercase</span></span>|<span data-ttu-id="ba178-287">MAŁA LITERA DZ Z ODWRÓCONYM DASZKIEM (U + 01C6)</span><span class="sxs-lookup"><span data-stu-id="ba178-287">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|  
    |<span data-ttu-id="ba178-288">ŁĄCZENIE GRECKIEGO YPOGEGRAMMENI (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="ba178-288">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="ba178-289">Wielkie litery</span><span class="sxs-lookup"><span data-stu-id="ba178-289">Uppercase</span></span>|<span data-ttu-id="ba178-290">WIELKA GRECKA LITERA JOTA (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="ba178-290">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|  
  
-   <span data-ttu-id="ba178-291">Różnice w mapowaniu przypadku dwuliterowych par przypadków mieszanych w zakresie znaków ASCII.</span><span class="sxs-lookup"><span data-stu-id="ba178-291">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="ba178-292">W większości kultur dwuliterowa para przypadków mieszanych jest równa równoważnej dwuliterowej pary wielkie lub małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-292">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="ba178-293">Nie dotyczy to następujących dwuliterowych par w poniższych kulturach, ponieważ w każdym przypadku są one porównywane z wykresem:</span><span class="sxs-lookup"><span data-stu-id="ba178-293">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>  
  
    -   <span data-ttu-id="ba178-294">"lJ" i "nJ" w kulturze HR-HR (chorwacki (Chorwacja)).</span><span class="sxs-lookup"><span data-stu-id="ba178-294">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>  
  
    -   <span data-ttu-id="ba178-295">"cH" w kulturach CS-CZ (czeski (Czechy)) i SK-SK (słowacki (Słowacja)).</span><span class="sxs-lookup"><span data-stu-id="ba178-295">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>  
  
    -   <span data-ttu-id="ba178-296">"aA" w kulturze da-DK (duński (Dania)).</span><span class="sxs-lookup"><span data-stu-id="ba178-296">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>  
  
    -   <span data-ttu-id="ba178-297">"cS", "dZ", "dZS", "nY", "sZ", "tY" i "zS" w kulturze hu (węgierski)).</span><span class="sxs-lookup"><span data-stu-id="ba178-297">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>  
  
    -   <span data-ttu-id="ba178-298">"cH" i "lL" w kulturze es-ES_tradnl (hiszpański (Hiszpania, tradycyjny)).</span><span class="sxs-lookup"><span data-stu-id="ba178-298">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>  
  
    -   <span data-ttu-id="ba178-299">"cH", "gI", "kH", "nG" "nH", "pH", "qU", "tH" i "tR" w kulturze VI-VN (wietnamski (Wietnam)).</span><span class="sxs-lookup"><span data-stu-id="ba178-299">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>  
  
     <span data-ttu-id="ba178-300">Niemniej jednak zdarza się sytuacje, w których porównanie kulturowe tych par tworzy problemy, ponieważ te pary są nietypowe w stałych ciągach lub identyfikatorach.</span><span class="sxs-lookup"><span data-stu-id="ba178-300">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>  
  
 <span data-ttu-id="ba178-301">Poniższy przykład ilustruje niektóre różnice w regułach wielkości liter między kulturami podczas konwertowania ciągów na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-301">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a><span data-ttu-id="ba178-302">Formatowanie i analizowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-302">Parsing and formatting</span></span>  
 <span data-ttu-id="ba178-303">Formatowanie i analizowanie to operacje odwrotne.</span><span class="sxs-lookup"><span data-stu-id="ba178-303">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="ba178-304">Reguły formatowania określają sposób konwersji wartości, takich jak Data i godzina lub liczba, na reprezentację w postaci ciągu, podczas gdy reguły analizy określają, jak konwertować reprezentację ciągu na wartość taką jak Data i godzina.</span><span class="sxs-lookup"><span data-stu-id="ba178-304">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="ba178-305">Reguły formatowania i analizowania są zależne od konwencji kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-305">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="ba178-306">Poniższy przykład ilustruje niejednoznaczność, która może powstać przy interpretacji ciągu daty specyficznej dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-306">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="ba178-307">Bez znajomości Konwencji kultury, która była używana do tworzenia ciągu daty, nie jest możliwe, że 03/01/2011, 3/1/2011 i 01/03/2011 reprezentuje 3 stycznia 2011 lub 1 marca 2011.</span><span class="sxs-lookup"><span data-stu-id="ba178-307">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 <span data-ttu-id="ba178-308">Podobnie, jak pokazano w poniższym przykładzie, pojedynczy ciąg może generować różne daty w zależności od kultury, której konwencje są używane w operacji analizowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-308">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="ba178-309">Porównanie ciągów i sortowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-309">String comparison and sorting</span></span>  
 <span data-ttu-id="ba178-310">Konwencje do porównywania i sortowania ciągów różnią się od kultury do kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-310">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="ba178-311">Na przykład porządek sortowania może opierać się na fonetycznych lub w wizualnej reprezentacji znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-311">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="ba178-312">W językach wschodnioazjatyckich znaki są sortowane według obrysu i pierwiastka z ideogramy.</span><span class="sxs-lookup"><span data-stu-id="ba178-312">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="ba178-313">Sortowanie zależy również od języków zamówienia i kultur używanych dla alfabetu.</span><span class="sxs-lookup"><span data-stu-id="ba178-313">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="ba178-314">Na przykład język duński ma znak "Æ", który jest sortowany po "Z" alfabetu.</span><span class="sxs-lookup"><span data-stu-id="ba178-314">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="ba178-315">Ponadto porównania mogą uwzględniać wielkość liter lub uwzględniać wielkość liter, a w niektórych przypadkach reguły dotyczące wielkości liter różnią się również kulturą.</span><span class="sxs-lookup"><span data-stu-id="ba178-315">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="ba178-316">Porównanie porządkowe, z drugiej strony, używa punktów kodu Unicode poszczególnych znaków w ciągu podczas porównywania i sortowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-316">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>  
  
 <span data-ttu-id="ba178-317">Reguły sortowania określają kolejność alfabetyczną znaków Unicode i sposób, w jaki dwa ciągi porównują się ze sobą.</span><span class="sxs-lookup"><span data-stu-id="ba178-317">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="ba178-318">Na przykład <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Metoda porównuje dwa ciągi <xref:System.StringComparison> w oparciu o parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-318">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ba178-319">Jeśli wartość parametru to <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, Metoda wykonuje porównanie lingwistyczne, które używa Konwencji bieżącej kultury; Jeśli wartość parametru to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, Metoda wykonuje porównanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-319">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="ba178-320">W związku z tym, jak pokazano w poniższym przykładzie, jeśli bieżąca kultura jest w Stanach Zjednoczonych W języku angielskim pierwsze wywołanie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metody (przy użyciu porównania z uwzględnieniem kultury) uważa wartość "a" mniejszą niż "a", ale drugie wywołanie tej samej metody (przy użyciu porównania porządkowej) traktuje "a" większe niż "a".</span><span class="sxs-lookup"><span data-stu-id="ba178-320">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 <span data-ttu-id="ba178-321">Platforma .NET obsługuje reguły sortowania wyrazów, ciągów i porządkowych:</span><span class="sxs-lookup"><span data-stu-id="ba178-321">.NET supports word, string, and ordinal sort rules:</span></span>  
  
-   <span data-ttu-id="ba178-322">Sortowanie wyrazów wykonuje porównanie z uwzględnieniem kultury ciągów, w których niektóre znaki niealfanumeryczne Unicode mogą mieć przypisane specjalne wagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-322">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="ba178-323">Na przykład łącznik (-) może mieć przypisaną bardzo małą wagę, tak aby "coop" i "współ-op" pojawiły się obok siebie na sortowanej liście.</span><span class="sxs-lookup"><span data-stu-id="ba178-323">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="ba178-324">Aby zapoznać się z listą <xref:System.String> metod, które porównują dwa ciągi przy użyciu reguł sortowania wyrazów, zobacz sekcję operacje na ciągach [według kategorii](#ByCategory) .</span><span class="sxs-lookup"><span data-stu-id="ba178-324">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
-   <span data-ttu-id="ba178-325">Sortowanie ciągów wykonuje także porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-325">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-326">Jest to podobne do sortowania wyrazów, z tą różnicą, że nie istnieją specjalne przypadki i wszystkie symbole inne niż alfanumeryczne są przed wszystkimi alfanumerycznymi znakami Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-326">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="ba178-327">Dwa ciągi można porównać przy użyciu reguł sortowania ciągów, wywołując <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> przeciążenia metody, które `options` mają parametr, który <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>ma wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-327">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-328">Należy zauważyć, że jest to jedyna metoda, którą platforma .NET oferuje do porównywania dwóch ciągów przy użyciu reguł sortowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-328">Note that this is the only method that .NET provides to compare two strings using string sort rules.</span></span>  
  
-   <span data-ttu-id="ba178-329">Sortowanie porządkowe porównuje ciągi na podstawie wartości liczbowej każdego <xref:System.Char> obiektu w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-329">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="ba178-330">W porównaniu porządkowej jest automatycznie rozróżniana wielkość liter, ponieważ małe litery i wielkie litery znaku mają różne punkty kodów.</span><span class="sxs-lookup"><span data-stu-id="ba178-330">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="ba178-331">Jeśli jednak przypadek nie jest istotny, można określić porównanie porządkowe, które ignoruje wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-331">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="ba178-332">Jest to równoznaczne z konwertowaniem ciągu na wielkie litery przy użyciu niezmiennej kultury, a następnie przeprowadzenie porównania porządkowego w wyniku.</span><span class="sxs-lookup"><span data-stu-id="ba178-332">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="ba178-333">Aby zapoznać się z listą <xref:System.String> metod, które porównują dwa ciągi przy użyciu reguł sortowania porządkowego, zobacz sekcję operacje na ciągach [według kategorii](#ByCategory) .</span><span class="sxs-lookup"><span data-stu-id="ba178-333">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
 <span data-ttu-id="ba178-334">Porównanie wrażliwe na kulturę to dowolne porównanie, które jawnie lub niejawnie używa <xref:System.Globalization.CultureInfo> obiektu, łącznie z niezmienną kulturą określoną <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> przez właściwość.</span><span class="sxs-lookup"><span data-stu-id="ba178-334">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ba178-335">Niejawna kultura to bieżąca kultura, która jest określona przez <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> właściwości i. <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-335">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="ba178-336">Istnieją znaczne różnice w kolejności sortowania znaków alfabetycznych (czyli znaków, dla których <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> Właściwość zwraca wartość `true`) między kulturami.</span><span class="sxs-lookup"><span data-stu-id="ba178-336">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="ba178-337">Można określić porównanie wrażliwe na kulturę, które używa konwencji określonej kultury przez dostarczenie <xref:System.Globalization.CultureInfo> obiektu do metody porównywania ciągów, takiej jak. <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29></span><span class="sxs-lookup"><span data-stu-id="ba178-337">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="ba178-338">Można określić porównanie wrażliwe na kulturę, które używa Konwencji bieżącej kultury, dostarczając <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions> lub jakikolwiek element członkowski wyliczenia inne niż <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> lub <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> do odpowiednich <xref:System.String.Compare%2A> Przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-338">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="ba178-339">Porównanie wrażliwe na kulturę jest zwykle odpowiednie do sortowania, podczas gdy porównanie porządkowe nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-339">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="ba178-340">Porównanie porządkowe jest ogólnie odpowiednie do określenia, czy dwa ciągi są równe (oznacza to, że w celu określenia tożsamości), podczas gdy porównanie wrażliwe na kulturę nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-340">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>  
  
 <span data-ttu-id="ba178-341">Poniższy przykład ilustruje różnicę między porównaniem uwzględniającym kulturę i porządkową.</span><span class="sxs-lookup"><span data-stu-id="ba178-341">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="ba178-342">Przykład szacuje trzy ciągi, "Apple", "Æble" i "AEble", przy użyciu porównania porządkowego oraz Konwencji kultur da-DK i en-us (z których każda jest kulturą domyślną w momencie <xref:System.String.Compare%2A> wywołania metody).</span><span class="sxs-lookup"><span data-stu-id="ba178-342">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="ba178-343">Ponieważ język duński traktuje znak "Æ" jako pojedynczą literę i sortuje ją po literze "Z" w alfabecie, ciąg "Æble" jest większy niż "Apple".</span><span class="sxs-lookup"><span data-stu-id="ba178-343">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="ba178-344">Jednakże "Æble" nie jest uważany za odpowiednik "AEble", więc wartość "Æble" jest również większa niż "AEble".</span><span class="sxs-lookup"><span data-stu-id="ba178-344">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="ba178-345">Kultura en-US nie zawiera litery "Æ", ale traktuje ją jako odpowiednik "AE", co wyjaśnia dlaczego "Æble" jest mniejsze niż "Apple", ale równe "AEble".</span><span class="sxs-lookup"><span data-stu-id="ba178-345">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="ba178-346">Porównanie porządkowe, z drugiej strony, uwzględnia wartość "Apple" jako "Æble" i "Æble", aby była większa niż "AEble".</span><span class="sxs-lookup"><span data-stu-id="ba178-346">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 <span data-ttu-id="ba178-347">Skorzystaj z następujących ogólnych wskazówek, aby wybrać odpowiednią metodę sortowania lub porównywania ciągów:</span><span class="sxs-lookup"><span data-stu-id="ba178-347">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>  
  
-   <span data-ttu-id="ba178-348">Jeśli chcesz, aby ciągi były uporządkowane w oparciu o kulturę użytkownika, należy uporządkować je na podstawie Konwencji bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-348">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="ba178-349">Jeśli kultura użytkownika ulegnie zmianie, porządek posortowanych ciągów również zostanie odpowiednio zmieniony.</span><span class="sxs-lookup"><span data-stu-id="ba178-349">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="ba178-350">Na przykład aplikacja tezaurusa powinna zawsze sortować słowa na podstawie kultury użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ba178-350">For example, a thesaurus application should always sort words based on the user's culture.</span></span>  
  
-   <span data-ttu-id="ba178-351">Jeśli chcesz, aby ciągi były uporządkowane na podstawie Konwencji określonej kultury, należy je zamówić, dostarczając <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę do metody porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-351">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="ba178-352">Na przykład w aplikacji zaprojektowanej do uczenia studentów w konkretnym języku, chcesz, aby ciągi były uporządkowane na podstawie Konwencji jednej z kultur, które mówią ten język.</span><span class="sxs-lookup"><span data-stu-id="ba178-352">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>  
  
-   <span data-ttu-id="ba178-353">Jeśli chcesz, aby kolejność ciągów pozostała niezmieniona między kulturami, należy zamówić je na podstawie Konwencji niezmiennej kultury lub użyć porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-353">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="ba178-354">Można na przykład użyć sortowania porządkowego do organizowania nazw plików, procesów, muteksów lub nazwanych potoków.</span><span class="sxs-lookup"><span data-stu-id="ba178-354">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>  
  
-   <span data-ttu-id="ba178-355">Aby zapoznać się z porównaniem obejmującym decyzję dotyczącą zabezpieczeń (np. czy nazwa użytkownika jest prawidłowa), należy zawsze wykonać test porządkowy dla równości, wywołując <xref:System.String.Equals%2A> metodę przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-355">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-356">Zależne od kultury reguły sortowania i wielkości liter używane w porównaniu ciągów zależą od wersji platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="ba178-356">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET.</span></span> <span data-ttu-id="ba178-357">W .NET Framework 4,5 i nowszych wersjach uruchomionych w [!INCLUDE[win8](~/includes/win8-md.md)] systemie operacyjnym, sortowanie, wielkość liter, normalizacja i informacje o znakach Unicode są zgodne ze standardem Unicode 6,0.</span><span class="sxs-lookup"><span data-stu-id="ba178-357">In the .NET Framework 4.5 and later versions running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="ba178-358">W innych systemach operacyjnych Windows jest zgodna ze standardem Unicode 5,0.</span><span class="sxs-lookup"><span data-stu-id="ba178-358">On other Windows operating systems, it conforms to the Unicode 5.0 standard.</span></span> <span data-ttu-id="ba178-359">W przypadku platformy .NET Core jest to zależne od wersji standardu Unicode obsługiwanego przez podstawowy system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="ba178-359">On .NET Core, it depends on the version of the Unicode Standard supported by the underlying operating system.</span></span> 
  
 <span data-ttu-id="ba178-360">Więcej informacji o regułach sortowania wyraz, String i porządkowych znajduje się w <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-360">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="ba178-361">Aby uzyskać dodatkowe zalecenia dotyczące sytuacji, w których należy użyć każdej reguły, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-361">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-362">Zwykle nie są wywoływane metody porównywania ciągów, takie <xref:System.String.Compare%2A> jak bezpośrednie, aby określić kolejność sortowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-362">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="ba178-363">Zamiast tego metody porównania są wywoływane przez metody sortowania, takie <xref:System.Array.Sort%2A?displayProperty=nameWithType> jak <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>lub.</span><span class="sxs-lookup"><span data-stu-id="ba178-363">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-364">W poniższym przykładzie wykonywane są cztery różne operacje sortowania (sortowanie wyrazów przy użyciu bieżącej kultury, sortowanie wyrazów przy użyciu niezmiennej kultury, sortowanie porządkowe i sortowanie ciągów przy użyciu niezmiennej kultury) bez jawnego wywołania metody porównywania ciągów. Mimo że określają typ porównania do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-364">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="ba178-365">Należy zauważyć, że każdy typ sortowania generuje unikatową kolejność ciągów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-365">Note that each type of sort produces a unique ordering of strings in its array.</span></span>  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  <span data-ttu-id="ba178-366">Wewnętrznie środowisko .NET używa kluczy sortowania do obsługi porównania ciągów wrażliwych na kulturę.</span><span class="sxs-lookup"><span data-stu-id="ba178-366">Internally, .NET uses sort keys to support culturally sensitive string comparison.</span></span> <span data-ttu-id="ba178-367">Każdy znak w ciągu zawiera kilka kategorii wag sortowania, takich jak Alphabetic, Case i diakrytycznych.</span><span class="sxs-lookup"><span data-stu-id="ba178-367">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="ba178-368">Klucz sortowania reprezentowany przez <xref:System.Globalization.SortKey> klasę zawiera repozytorium tych wag dla określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-368">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="ba178-369">Jeśli aplikacja wykonuje dużą liczbę operacji wyszukiwania lub sortowania dla tego samego zestawu ciągów, można zwiększyć jej wydajność, generując i przechowując klucze sortowania dla wszystkich używanych przez niego ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-369">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="ba178-370">Gdy wymagana jest operacja sortowania lub porównywania, zamiast ciągów należy używać kluczy sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-370">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="ba178-371">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.SortKey> Klasa.</span><span class="sxs-lookup"><span data-stu-id="ba178-371">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>  
  
 <span data-ttu-id="ba178-372">Jeśli nie określisz Konwencji porównywania ciągów, metody sortowania, takie <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> jak wykonywanie sortowania z uwzględnieniem wielkości liter w ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-372">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="ba178-373">Poniższy przykład ilustruje, jak zmiana bieżącej kultury wpływa na kolejność posortowanych ciągów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-373">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="ba178-374">Tworzy tablicę trzech ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-374">It creates an array of three strings.</span></span> <span data-ttu-id="ba178-375">Po pierwsze ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwość na en-us i <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> wywołuje metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-375">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-376">Powstały porządek sortowania jest oparty na konwencjach sortowania dla kultury angielskiej (Stany Zjednoczone).</span><span class="sxs-lookup"><span data-stu-id="ba178-376">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="ba178-377">Następnie przykład ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwość na da-DK i ponownie <xref:System.Array.Sort%2A?displayProperty=nameWithType> wywołuje metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-377">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="ba178-378">Zwróć uwagę, jak wynikowy porządek sortowania różni się od wyników en-US, ponieważ używa on Konwencji sortowania dla języka duńskiego (Dania).</span><span class="sxs-lookup"><span data-stu-id="ba178-378">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  <span data-ttu-id="ba178-379">Jeśli głównym celem w porównaniu ciągów jest określenie, czy są równe, należy wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-379">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-380">Zazwyczaj należy użyć <xref:System.String.Equals%2A> do przeprowadzenia porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-380">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="ba178-381"><xref:System.String.Compare%2A?displayProperty=nameWithType> Metoda jest przeznaczona głównie do sortowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-381">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>  
  
 <span data-ttu-id="ba178-382">Metody wyszukiwania ciągów, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, również mogą wykonywać porównania ciągów z uwzględnieniem kultury lub porządkową.</span><span class="sxs-lookup"><span data-stu-id="ba178-382">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="ba178-383">Poniższy przykład ilustruje różnice między porównaniem porządkowym i kulturowym przy użyciu <xref:System.String.IndexOf%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-383">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ba178-384">Wyszukiwanie zależne od kultury, w którym bieżąca kultura jest w języku angielskim (Stany Zjednoczone) traktuje podciąg "OE" w celu dopasowania do ligatur "o".</span><span class="sxs-lookup"><span data-stu-id="ba178-384">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="ba178-385">Ponieważ łącznik miękki (U + 00AD) jest znakiem o zerowej szerokości, wyszukiwanie traktuje łącznik miękki jako odpowiednik <xref:System.String.Empty> i znajduje dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-385">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="ba178-386">Wyszukiwanie porządkowe, z drugiej strony, nie znajduje dopasowania w obu przypadkach.</span><span class="sxs-lookup"><span data-stu-id="ba178-386">An ordinal search, on the other hand, does not find a match in either case.</span></span>  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a><span data-ttu-id="ba178-387">Wyszukiwanie ciągów</span><span class="sxs-lookup"><span data-stu-id="ba178-387">Searching Strings</span></span>  
 <span data-ttu-id="ba178-388">Metody wyszukiwania ciągów, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, również mogą wykonywać porównania ciągów z uwzględnieniem kulturowym lub porządkowym, aby określić, czy znak lub podciąg zostanie znaleziony w określonym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-388">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>  
  
 <span data-ttu-id="ba178-389">Metody wyszukiwania w <xref:System.String> klasie, która wyszukuje pojedynczy znak, taki <xref:System.String.IndexOf%2A> jak metoda lub jeden z zestawu <xref:System.String.IndexOfAny%2A> znaków, takich jak metoda, wszystkie wykonują wyszukiwanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-389">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="ba178-390">Aby przeprowadzić wyszukiwanie znaków z uwzględnieniem kultury, należy wywołać <xref:System.Globalization.CompareInfo> metodę, taką jak <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> lub <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-390">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-391">Należy zauważyć, że wyniki wyszukiwania znaku przy użyciu wartości porządkowej i porównywania kulturowego mogą być bardzo inne.</span><span class="sxs-lookup"><span data-stu-id="ba178-391">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="ba178-392">Na przykład wyszukiwanie złożonego znaku Unicode, takiego jak ligatury "Æ" (U + 00C6), może pasować do każdego wystąpienia jego składników w poprawnej sekwencji, takiej jak "AE" (U + 041U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-392">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="ba178-393">Poniższy przykład ilustruje różnicę między <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> metodami i <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> podczas wyszukiwania pojedynczego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-393">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="ba178-394">Ligatury "æ" (U + 00E6) znajdują się w ciągu "anten" w przypadku stosowania Konwencji kultury en-US, ale nie w przypadku stosowania Konwencji kultury da-DK lub podczas przeprowadzania porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-394">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 <span data-ttu-id="ba178-395">Z drugiej strony metody klasy <xref:System.String> , które wyszukują ciąg, a nie znak wykonują wyszukiwanie wrażliwe na kulturę, jeśli opcje wyszukiwania nie są jawnie określone przez parametr typu. <xref:System.StringComparison></span><span class="sxs-lookup"><span data-stu-id="ba178-395">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="ba178-396">Jedynym wyjątkiem jest <xref:System.String.Contains%2A>, który wykonuje wyszukiwanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-396">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a><span data-ttu-id="ba178-397">Testowanie pod kątem równości</span><span class="sxs-lookup"><span data-stu-id="ba178-397">Testing for equality</span></span>  
 <span data-ttu-id="ba178-398"><xref:System.String.Compare%2A?displayProperty=nameWithType> Użyj metody, aby określić relację dwóch ciągów w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-398">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="ba178-399">Zwykle jest to operacja zależna od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-399">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="ba178-400">Z kolei Wywołaj <xref:System.String.Equals%2A?displayProperty=nameWithType> metodę, aby sprawdzić równość.</span><span class="sxs-lookup"><span data-stu-id="ba178-400">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="ba178-401">Ponieważ test pod kątem równości zwykle porównuje dane wprowadzane przez użytkownika z nieznanym ciągiem, takim jak prawidłowa nazwa użytkownika, hasło lub ścieżka systemu plików, jest zazwyczaj operacją porządkową.</span><span class="sxs-lookup"><span data-stu-id="ba178-401">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-402">Istnieje możliwość przetestowania pod kątem równości przez wywołanie <xref:System.String.Compare%2A?displayProperty=nameWithType> metody i określenie, czy zwracana wartość jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-402">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="ba178-403">Jednak ta metoda nie jest zalecana.</span><span class="sxs-lookup"><span data-stu-id="ba178-403">However, this practice is not recommended.</span></span> <span data-ttu-id="ba178-404">Aby określić, czy dwa ciągi są równe, należy wywołać jedno z przeciążeń <xref:System.String.Equals%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-404">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-405">Preferowanym przeciążeniem wywołania jest metoda wystąpienia <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> lub metoda statyczna <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> , <xref:System.StringComparison?displayProperty=nameWithType> ponieważ obie metody zawierają parametr jawnie określający typ porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-405">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>  
  
 <span data-ttu-id="ba178-406">Poniższy przykład ilustruje niebezpieczeństwo wykonywania porównania z uwzględnieniem kultury dla równości, gdy zamiast tego należy użyć numeru porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-406">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="ba178-407">W takim przypadku celem kodu jest zabronienie dostępu systemu plików z adresów URL zaczynających się od "FILE://" lub "file://" przez wykonanie porównania bez uwzględniania wielkości liter początku adresu URL z ciągiem "FILE://".</span><span class="sxs-lookup"><span data-stu-id="ba178-407">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="ba178-408">Jednakże jeśli porównanie wrażliwe na kulturę jest wykonywane przy użyciu kultury tureckiej (Turcja) na adres URL zaczynający się od "file://", porównanie dla równości nie powiedzie się, ponieważ turecki wielką literą małych liter "i" jest "i" zamiast "I".</span><span class="sxs-lookup"><span data-stu-id="ba178-408">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="ba178-409">W efekcie dostęp do systemu plików jest przypadkowo dozwolony.</span><span class="sxs-lookup"><span data-stu-id="ba178-409">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="ba178-410">Z drugiej strony, jeśli zostanie wykonane porównanie porządkowe, porównywanie dla równości powiedzie się i dostęp do systemu plików jest zabroniony.</span><span class="sxs-lookup"><span data-stu-id="ba178-410">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a><span data-ttu-id="ba178-411">Normalizacja</span><span class="sxs-lookup"><span data-stu-id="ba178-411">Normalization</span></span>  
 <span data-ttu-id="ba178-412">Niektóre znaki Unicode mają wiele reprezentacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-412">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="ba178-413">Na przykład dowolny z następujących punktów kodu może reprezentować literę "ắ":</span><span class="sxs-lookup"><span data-stu-id="ba178-413">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ba178-414">U+1EAF</span><span class="sxs-lookup"><span data-stu-id="ba178-414">U+1EAF</span></span>  
  
-   <span data-ttu-id="ba178-415">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ba178-415">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ba178-416">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ba178-416">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ba178-417">Wiele reprezentacji pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowywanie i inne operacje na ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-417">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>  
  
 <span data-ttu-id="ba178-418">Standard Unicode definiuje proces o nazwie normalizing, który zwraca jedną reprezentację binarną znaku Unicode dla którejkolwiek z jego równoważnych reprezentacji binarnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-418">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="ba178-419">Normalizacja może używać kilku algorytmów nazywanych formularzami normalizacji, które są zgodne z różnymi regułami.</span><span class="sxs-lookup"><span data-stu-id="ba178-419">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="ba178-420">Platforma .NET obsługuje normalizacji Unicode w postaci C, D, KC i KD.</span><span class="sxs-lookup"><span data-stu-id="ba178-420">.NET supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="ba178-421">Gdy ciągi zostały znormalizowane do tego samego formularza normalizacji, można je porównać przy użyciu porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-421">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ba178-422">Porównanie porządkowe to binarne porównanie wartości skalarnej Unicode odpowiednich <xref:System.Char> obiektów w każdym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-422">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="ba178-423"><xref:System.String> Klasa zawiera szereg metod, które mogą wykonać porównanie porządkowe, w tym następujące:</span><span class="sxs-lookup"><span data-stu-id="ba178-423">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>  
  
-   <span data-ttu-id="ba178-424">Dowolne Przeciążenie <xref:System.String.Compare%2A>metod, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A> ,,<xref:System.String.EndsWith%2A> i<xref:System.String.LastIndexOf%2A> , które zawierają<xref:System.StringComparison> parametr. <xref:System.String.IndexOf%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-424">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ba178-425">Metoda wykonuje porównanie porządkowe w przypadku podania wartości <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase> dla tego parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-425">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>  
  
-   <span data-ttu-id="ba178-426">Przeciążenia <xref:System.String.CompareOrdinal%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-426">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>  
  
-   <span data-ttu-id="ba178-427">Metody, które domyślnie korzystają z porównania porządkowego, <xref:System.String.Contains%2A>takie <xref:System.String.Replace%2A>jak, <xref:System.String.Split%2A>, i.</span><span class="sxs-lookup"><span data-stu-id="ba178-427">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>  
  
-   <span data-ttu-id="ba178-428">Metody, które przeszukują <xref:System.Char> wartość lub dla elementów <xref:System.Char> w tablicy w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-428">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="ba178-429">Takie metody obejmują <xref:System.String.IndexOf%28System.Char%29> i <xref:System.String.Split%28System.Char%5B%5D%29>.</span><span class="sxs-lookup"><span data-stu-id="ba178-429">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>  
  
 <span data-ttu-id="ba178-430">Można określić, czy ciąg jest znormalizowany do normalizacji w postaci C, wywołując <xref:System.String.IsNormalized?displayProperty=nameWithType> metodę, lub można wywołać metodę, aby określić, <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> czy ciąg jest znormalizowany do określonego formularza normalizacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-430">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="ba178-431">Możesz również wywołać metodę, <xref:System.String.Normalize?displayProperty=nameWithType> Aby skonwertować ciąg na normalizację w postaci C lub można <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> wywołać metodę, aby przekonwertować ciąg na określony formularz normalizacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-431">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="ba178-432">Informacje krok po kroku dotyczące normalizacji i porównywania ciągów można znaleźć w <xref:System.String.Normalize> tematach i. <xref:System.String.Normalize%28System.Text.NormalizationForm%29></span><span class="sxs-lookup"><span data-stu-id="ba178-432">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>  
  
 <span data-ttu-id="ba178-433">Poniższy prosty przykład ilustruje normalizację ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-433">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="ba178-434">Definiuje literę "ố" na trzy różne sposoby w trzech różnych ciągach i używa porównania porządkowego dla równości, aby określić, że każdy ciąg różni się od pozostałych dwóch ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-434">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="ba178-435">Następnie konwertuje każdy ciąg na obsługiwane formularze normalizacji i ponownie wykonuje porównanie porządkowe każdego ciągu w określonym formularzu normalizacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-435">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="ba178-436">W każdym przypadku drugi test pod kątem równości pokazuje, że ciągi są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-436">In each case, the second test for equality shows that the strings are equal.</span></span>  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 <span data-ttu-id="ba178-437">Aby uzyskać więcej informacji na temat normalizacji i normalizacji, <xref:System.Text.NormalizationForm?displayProperty=nameWithType>Zobacz, a [także #15 w standardzie Unicode: Formy](https://unicode.org/reports/tr15/) normalizacji Unicode i [normalizacja często zadawane pytania](https://www.unicode.org/faq/normalization.html) w witrynie sieci Web Unicode.org.</span><span class="sxs-lookup"><span data-stu-id="ba178-437">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a><span data-ttu-id="ba178-438">Operacje na ciągach według kategorii</span><span class="sxs-lookup"><span data-stu-id="ba178-438">String operations by category</span></span>  
 <span data-ttu-id="ba178-439"><xref:System.String> Klasa zawiera elementy członkowskie do porównywania ciągów, testowania ciągów pod kątem równości, znajdowania znaków lub podciągów w ciągu, modyfikowania ciągu, wyodrębniania podciągów z ciągu, łączenia ciągów, formatowania wartości, kopiowania ciągu i normalizowanie ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-439">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>  
  
### <a name="comparing-strings"></a><span data-ttu-id="ba178-440">Porównywanie ciągów</span><span class="sxs-lookup"><span data-stu-id="ba178-440">Comparing strings</span></span>  
 <span data-ttu-id="ba178-441">Można porównać ciągi, aby określić ich względne położenie w porządku sortowania przy użyciu następujących <xref:System.String> metod:</span><span class="sxs-lookup"><span data-stu-id="ba178-441">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>  
  
-   <span data-ttu-id="ba178-442"><xref:System.String.Compare%2A>Zwraca liczbę całkowitą, która wskazuje związek jednego ciągu z drugim ciągiem w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-442"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>  
  
-   <span data-ttu-id="ba178-443"><xref:System.String.CompareOrdinal%2A>Zwraca liczbę całkowitą, która wskazuje związek jednego ciągu z drugim ciągiem na podstawie porównania ich punktów kodowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-443"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>  
  
-   <span data-ttu-id="ba178-444"><xref:System.String.CompareTo%2A>Zwraca liczbę całkowitą, która wskazuje związek bieżącego wystąpienia ciągu z drugim ciągiem w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-444"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="ba178-445">Metoda udostępnia implementacje <xref:System.IComparable%601> i dla <xref:System.String>klasy. <xref:System.IComparable> <xref:System.String.CompareTo%28System.String%29></span><span class="sxs-lookup"><span data-stu-id="ba178-445">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>  
  
### <a name="testing-strings-for-equality"></a><span data-ttu-id="ba178-446">Testowanie ciągów pod kątem równości</span><span class="sxs-lookup"><span data-stu-id="ba178-446">Testing strings for equality</span></span>  
 <span data-ttu-id="ba178-447">Należy wywołać metodę <xref:System.String.Equals%2A> , aby określić, czy dwa ciągi są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-447">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="ba178-448">Wystąpienie <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> i przeciążenia statyczne <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> pozwalają określić, czy porównanie ma być zależne od kultury, czy też w przypadku ignorowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-448">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="ba178-449">Większość testów dla równości to liczba porządkowa, a porównania równości, które określają dostęp do zasobów systemowych (takich jak obiekt systemu plików), powinny zawsze być porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-449">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>  
  
### <a name="finding-characters-in-a-string"></a><span data-ttu-id="ba178-450">Znajdowanie znaków w ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-450">Finding characters in a string</span></span>  
 <span data-ttu-id="ba178-451"><xref:System.String> Klasa zawiera dwa rodzaje metod wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="ba178-451">The <xref:System.String> class includes two kinds of search methods:</span></span>  
  
-   <span data-ttu-id="ba178-452">Metody, które zwracają <xref:System.Boolean> wartość, aby wskazać, czy konkretny podciąg jest obecny w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-452">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="ba178-453">Należą do <xref:System.String.Contains%2A>nich metody <xref:System.String.EndsWith%2A>, i <xref:System.String.StartsWith%2A> .</span><span class="sxs-lookup"><span data-stu-id="ba178-453">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>  
  
-   <span data-ttu-id="ba178-454">Metody wskazujące początkową pozycję podciągu w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-454">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="ba178-455">Należą do <xref:System.String.IndexOf%2A>nich metody <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>,, <xref:System.String.LastIndexOfAny%2A> i.</span><span class="sxs-lookup"><span data-stu-id="ba178-455">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-456">Jeśli chcesz wyszukać ciąg dla określonego wzorca, a nie określony podciąg, należy użyć wyrażeń regularnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-456">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="ba178-457">Aby uzyskać więcej informacji, zobacz [wyrażenia regularne programu .NET](~/docs/standard/base-types/regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-457">For more information, see [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
### <a name="modifying-a-string"></a><span data-ttu-id="ba178-458">Modyfikowanie ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-458">Modifying a string</span></span>  
 <span data-ttu-id="ba178-459"><xref:System.String> Klasa zawiera następujące metody, które pojawiają się w celu zmodyfikowania wartości ciągu:</span><span class="sxs-lookup"><span data-stu-id="ba178-459">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>  
  
-   <span data-ttu-id="ba178-460"><xref:System.String.Insert%2A>Wstawia ciąg do bieżącego <xref:System.String> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-460"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ba178-461"><xref:System.String.PadLeft%2A>Wstawia jedno lub więcej wystąpień określonego znaku na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-461"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>  
  
-   <span data-ttu-id="ba178-462"><xref:System.String.PadRight%2A>Wstawia jedno lub więcej wystąpień określonego znaku na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-462"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>  
  
-   <span data-ttu-id="ba178-463"><xref:System.String.Remove%2A>usuwa podciąg z bieżącego <xref:System.String> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-463"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ba178-464"><xref:System.String.Replace%2A>zamienia podciąg na inny podciąg w bieżącym <xref:System.String> wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-464"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ba178-465"><xref:System.String.ToLower%2A>i <xref:System.String.ToLowerInvariant%2A> Konwertuj wszystkie znaki w ciągu na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-465"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>  
  
-   <span data-ttu-id="ba178-466"><xref:System.String.ToUpper%2A>i <xref:System.String.ToUpperInvariant%2A> Konwertuj wszystkie znaki w ciągu na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-466"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>  
  
-   <span data-ttu-id="ba178-467"><xref:System.String.Trim%2A>usuwa wszystkie wystąpienia znaku od początku i końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-467"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>  
  
-   <span data-ttu-id="ba178-468"><xref:System.String.TrimEnd%2A>usuwa wszystkie wystąpienia znaku z końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-468"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>  
  
-   <span data-ttu-id="ba178-469"><xref:System.String.TrimStart%2A>usuwa wszystkie wystąpienia znaku od początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-469"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba178-470">Wszystkie metody modyfikacji ciągu zwracają nowy <xref:System.String> obiekt.</span><span class="sxs-lookup"><span data-stu-id="ba178-470">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="ba178-471">Nie modyfikują wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-471">They don't modify the value of the current instance.</span></span>  
  
### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="ba178-472">Wyodrębnianie podciągów z ciągu znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-472">Extracting substrings from a string</span></span>  
 <span data-ttu-id="ba178-473"><xref:System.String.Split%2A?displayProperty=nameWithType> Metoda oddziela pojedynczy ciąg do wielu ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-473">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="ba178-474">Przeciążenia metody umożliwiają określenie wielu ograniczników, aby określić maksymalną liczbę podciągów wyznaczonych przez metodę i określić, czy puste ciągi (które występują w przypadku sąsiadujących ograniczników) są uwzględniane między zwracanymi ciągami.</span><span class="sxs-lookup"><span data-stu-id="ba178-474">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>  
  
### <a name="combining-strings"></a><span data-ttu-id="ba178-475">Łączenie ciągów</span><span class="sxs-lookup"><span data-stu-id="ba178-475">Combining strings</span></span>  
 <span data-ttu-id="ba178-476">Do łączenia <xref:System.String> ciągów można używać następujących metod:</span><span class="sxs-lookup"><span data-stu-id="ba178-476">The following <xref:System.String> methods can be used for string concatenation:</span></span>  
  
-   <span data-ttu-id="ba178-477"><xref:System.String.Concat%2A>łączy jeden lub więcej podciągów w jeden ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-477"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>  
  
-   <span data-ttu-id="ba178-478"><xref:System.String.Join%2A>łączy jeden lub więcej podciągów w jeden element i dodaje separator między każdym podciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-478"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>  
  
### <a name="formatting-values"></a><span data-ttu-id="ba178-479">Formatowanie wartości</span><span class="sxs-lookup"><span data-stu-id="ba178-479">Formatting values</span></span>  
 <span data-ttu-id="ba178-480"><xref:System.String.Format%2A?displayProperty=nameWithType> Metoda używa funkcji formatowania złożonego, aby zastąpić jeden lub więcej symboli zastępczych w ciągu ciągiem reprezentującym jakiś obiekt lub wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-480">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="ba178-481"><xref:System.String.Format%2A> Metoda jest często używana do wykonywania następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="ba178-481">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>  
  
-   <span data-ttu-id="ba178-482">Aby osadzić ciąg reprezentujący wartość liczbową w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-482">To embed the string representation of a numeric value in a string.</span></span>  
  
-   <span data-ttu-id="ba178-483">Aby osadzić ciąg reprezentujący wartość daty i godziny w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-483">To embed the string representation of a date and time value in a string.</span></span>  
  
-   <span data-ttu-id="ba178-484">Aby osadzić ciąg reprezentujący wartość wyliczenia w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-484">To embed the string representation of an enumeration value in a string.</span></span>  
  
-   <span data-ttu-id="ba178-485">Aby osadzić ciąg reprezentujący kilka obiektów, które obsługują <xref:System.IFormattable> interfejs w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-485">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>  
  
-   <span data-ttu-id="ba178-486">Aby wyjustować lub justować do lewej, podciąg w polu w większym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-486">To right-justify or left-justify a substring in a field within a larger string.</span></span>  
  
 <span data-ttu-id="ba178-487">Aby uzyskać szczegółowe informacje na temat formatowania operacji i przykładów, <xref:System.String.Format%2A> Zobacz Podsumowanie przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-487">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>  
  
### <a name="copying-a-string"></a><span data-ttu-id="ba178-488">Kopiowanie ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-488">Copying a string</span></span>  
 <span data-ttu-id="ba178-489">Można wywołać następujące <xref:System.String> metody, aby utworzyć kopię ciągu:</span><span class="sxs-lookup"><span data-stu-id="ba178-489">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>  
  
-   <span data-ttu-id="ba178-490"><xref:System.String.Clone%2A>Zwraca odwołanie do istniejącego <xref:System.String> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-490"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="ba178-491"><xref:System.String.Copy%2A>tworzy kopię istniejącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-491"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>  
  
-   <span data-ttu-id="ba178-492"><xref:System.String.CopyTo%2A>kopiuje część ciągu do tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-492"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>  
  
### <a name="normalizing-a-string"></a><span data-ttu-id="ba178-493">Normalizowanie ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-493">Normalizing a string</span></span>  
 <span data-ttu-id="ba178-494">W standardzie Unicode pojedynczy znak może mieć wiele punktów kodowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-494">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="ba178-495">Normalizacja konwertuje te znaki równoważne na tę samą reprezentację binarną.</span><span class="sxs-lookup"><span data-stu-id="ba178-495">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="ba178-496">Metoda wykonuje normalizację, <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> a Metoda określa, czy ciąg jest znormalizowany. <xref:System.String.Normalize%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-496">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>  
  
 <span data-ttu-id="ba178-497">Aby uzyskać więcej informacji i zapoznać się z przykładem, zapoznaj się z sekcją [normalizacji](#Normalization) wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-497">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921"><span data-ttu-id="ba178-498">Sortowanie tabel wagi dla systemów operacyjnych Windows</span><span class="sxs-lookup"><span data-stu-id="ba178-498">Sorting Weight Tables for Windows operating systems</span></span></related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt"><span data-ttu-id="ba178-499">Domyślna tabela elementów sortowania Unicode dla systemów Linux i macOS</span><span class="sxs-lookup"><span data-stu-id="ba178-499">Default Unicode Collation Element Table, for Linux and macOS</span></span></related>
    <threadsafe><span data-ttu-id="ba178-500">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="ba178-500">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-501">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-501">Formatting Types in .NET</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7"><span data-ttu-id="ba178-502">Najlepsze praktyki używania ciągów w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="ba178-502">Best Practices for Using Strings in the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-503">Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="ba178-503">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-504">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="ba178-504">In this section:</span></span>  
  
 <span data-ttu-id="ba178-505">[Składnia przeciążonego konstruktora](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="ba178-505">[Overloaded constructor syntax](#Syntax) </span></span>  
 <span data-ttu-id="ba178-506">[Wejściowe](#Params) </span><span class="sxs-lookup"><span data-stu-id="ba178-506">[Parameters](#Params) </span></span>  
 <span data-ttu-id="ba178-507">[Wyłączenia](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="ba178-507">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="ba178-508">[Którą metodę nazywam?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="ba178-508">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="ba178-509">[Tworzenie ciągów](#Creating_Strings) </span><span class="sxs-lookup"><span data-stu-id="ba178-509">[Creating strings](#Creating_Strings) </span></span>  
 <span data-ttu-id="ba178-510">[Obsługa powtarzających się ciągów](#Repetitive) </span><span class="sxs-lookup"><span data-stu-id="ba178-510">[Handling repetitive strings](#Repetitive) </span></span>  
 <span data-ttu-id="ba178-511">Przykłady tworzenia wystąpień ciągów:</span><span class="sxs-lookup"><span data-stu-id="ba178-511">Examples of instantiating strings:</span></span>   
 [<span data-ttu-id="ba178-512">Używanie przypisania ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-512">Using string assignment</span></span>](#Ctor1_Example)  
 [<span data-ttu-id="ba178-513">Korzystanie z tablicy znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-513">Using a character array</span></span>](#Ctor2_Example)  
 [<span data-ttu-id="ba178-514">Użycie części tablicy znaków i powtarzanie pojedynczego znaku</span><span class="sxs-lookup"><span data-stu-id="ba178-514">Using a portion of a character array and repeating a single character</span></span>](#Ctor3_Example)  
 [<span data-ttu-id="ba178-515">Używanie wskaźnika do tablicy znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-515">Using a pointer to a character array</span></span>](#Ctor4_Example)  
 [<span data-ttu-id="ba178-516">Używanie wskaźnika i zakresu tablicy</span><span class="sxs-lookup"><span data-stu-id="ba178-516">Using  a pointer and a range of an array</span></span>](#Ctor5_Example)  
 [<span data-ttu-id="ba178-517">Używanie wskaźnika do podpisanej tablicy bajtów</span><span class="sxs-lookup"><span data-stu-id="ba178-517">Using a pointer to a signed byte array</span></span>](#Ctor6_Example)  
[<span data-ttu-id="ba178-518">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="ba178-518">Version information</span></span>](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="ba178-519">Przeciążona składnia konstruktora</span><span class="sxs-lookup"><span data-stu-id="ba178-519">Overloaded constructor syntax</span></span>  
 <span data-ttu-id="ba178-520">Konstruktory ciągów dzielą się na dwie kategorie: te bez parametrów wskaźnika i z parametrami wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-520">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="ba178-521">Konstruktory używające wskaźników nie są zgodne ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="ba178-521">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="ba178-522">Ponadto Visual Basic nie obsługuje użycia wskaźników i C# wymaga kodu, który używa wskaźników do uruchamiania w niebezpiecznym kontekście.</span><span class="sxs-lookup"><span data-stu-id="ba178-522">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="ba178-523">Aby uzyskać więcej informacji, [niebezpieczny](~/docs/csharp/language-reference/keywords/unsafe.md)</span><span class="sxs-lookup"><span data-stu-id="ba178-523">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>  
  
 <span data-ttu-id="ba178-524">Aby uzyskać dodatkowe wskazówki dotyczące wybierania przeciążenia, zobacz, [która metoda jest wywoływana?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="ba178-524">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 `String(Char[] value)`  
 <span data-ttu-id="ba178-525">Inicjuje nowe wystąpienie do wartości wskazanej przez tablicę znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-525">Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="ba178-526">Ten Konstruktor kopiuje znaki Unicode ([przykład](#Ctor2_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-526">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ba178-527">Inicjuje nowe wystąpienie do wartości wskazanej przez tablicę znaków Unicode, początkową pozycję znaku w tej tablicy i długość ([przykład](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-527">Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>  
  
 `String(Char c, Int32 count)`  
 <span data-ttu-id="ba178-528">Inicjuje nowe wystąpienie do wartości wskazanej przez określony znak Unicode powtórzone określoną liczbę razy ([przykład](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-528">Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>  
  
 `String(char* value)`  
 <span data-ttu-id="ba178-529">**(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy znaków Unicode, która kończy się znakiem null (U + 0000 lub ' \ 0 ').</span><span class="sxs-lookup"><span data-stu-id="ba178-529">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="ba178-530">([przykład](#Ctor4_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-530">([example](#Ctor4_Example)).</span></span>  
  
 <span data-ttu-id="ba178-531">Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-531">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-532">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-532">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ba178-533">**(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy znaków Unicode, początkowy znak w tej tablicy i długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-533">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="ba178-534">Konstruktor kopiuje znaki `value` Unicode z lokalizacji w indeksie `startIndex` `startIndex` i kończąc przy indeksie  +  `length` -1 ([przykład](#Ctor5_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-534">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` - 1 ([example](#Ctor5_Example)).</span></span>  
  
 <span data-ttu-id="ba178-535">Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-535">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-536">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-536">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value)`  
 <span data-ttu-id="ba178-537">**(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-537">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ba178-538">Przyjęto, że tablica reprezentuje ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowania określonego przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ba178-538">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ba178-539">Konstruktor przetwarza znaki z `value` lokalizacji określonej przez wskaźnik do momentu osiągnięcia znaku null (0x00) ([przykład](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-539">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ba178-540">Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-540">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-541">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-541">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ba178-542">**(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tej tablicy i długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-542">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="ba178-543">Przyjęto, że tablica reprezentuje ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowania określonego przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ba178-543">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ba178-544">Konstruktor przetwarza znaki `startIndex` z wartości rozpoczynając od i kończąc na  +  `startIndex` `length` -1 ([przykład](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="ba178-544">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` - 1 ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ba178-545">Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-545">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-546">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-546">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 <span data-ttu-id="ba178-547">**(Niezgodne ze specyfikacją CLS)** Inicjuje nowe wystąpienie do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, czyli pozycji początkowej w tej tablicy, długości i <xref:System.Text.Encoding> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-547">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>  
  
 <span data-ttu-id="ba178-548">Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-548">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-549">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-549">This member cannot be used by partially trusted or transparent code.</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="ba178-550">Parametry</span><span class="sxs-lookup"><span data-stu-id="ba178-550">Parameters</span></span>  
 <span data-ttu-id="ba178-551">Poniżej znajduje się kompletna lista parametrów używanych przez <xref:System.String> konstruktory, które nie zawierają parametru wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-551">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="ba178-552">Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-552">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ba178-553">Parametr</span><span class="sxs-lookup"><span data-stu-id="ba178-553">Parameter</span></span>|<span data-ttu-id="ba178-554">Typ</span><span class="sxs-lookup"><span data-stu-id="ba178-554">Type</span></span>|<span data-ttu-id="ba178-555">Opis</span><span class="sxs-lookup"><span data-stu-id="ba178-555">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<span data-ttu-id="ba178-556"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="ba178-556"><xref:System.Char>[]</span></span>|<span data-ttu-id="ba178-557">Tablica znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-557">An array of Unicode characters.</span></span>|  
|`c`|<xref:System.Char>|<span data-ttu-id="ba178-558">Znak Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-558">A Unicode character.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ba178-559">Pozycja `value` początkowa pierwszego znaku w nowym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-559">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ba178-560">Wartość domyślna: 0</span><span class="sxs-lookup"><span data-stu-id="ba178-560">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ba178-561">Liczba znaków w `value` do uwzględnienia w nowym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-561">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="ba178-562">Wartość domyślna:<xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-562">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`count`|<xref:System.Int32>|<span data-ttu-id="ba178-563">Liczba powtórzeń znaku `c` w nowym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-563">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="ba178-564">Jeśli `count` jest równa zero, wartość nowego obiektu to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-564">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="ba178-565">Poniżej znajduje się kompletna lista parametrów używanych przez <xref:System.String> konstruktory, które zawierają parametr wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-565">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="ba178-566">Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-566">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ba178-567">Parametr</span><span class="sxs-lookup"><span data-stu-id="ba178-567">Parameter</span></span>|<span data-ttu-id="ba178-568">Typ</span><span class="sxs-lookup"><span data-stu-id="ba178-568">Type</span></span>|<span data-ttu-id="ba178-569">Opis</span><span class="sxs-lookup"><span data-stu-id="ba178-569">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="ba178-570">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-570">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="ba178-571">Wskaźnik do tablicy o wartościach Unicode zakończonych znakiem null lub tablicy 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-571">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="ba178-572">Jeśli `value` jest `null` lub jest pustą tablicą, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-572">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ba178-573">Indeks elementu tablicy, który definiuje pierwszy znak w nowym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-573">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ba178-574">Wartość domyślna: 0</span><span class="sxs-lookup"><span data-stu-id="ba178-574">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ba178-575">Liczba elementów tablicy, które mają zostać użyte do utworzenia nowego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-575">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="ba178-576">Jeśli długość wynosi zero, Konstruktor tworzy ciąg, którego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-576">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="ba178-577">Wartość domyślna:<xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-577">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="ba178-578">Obiekt, który określa sposób `value` kodowania tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-578">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="ba178-579">Wartość domyślna: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>lub bieżąca strona kodowa ANSI systemu</span><span class="sxs-lookup"><span data-stu-id="ba178-579">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="ba178-580">Wyjątki</span><span class="sxs-lookup"><span data-stu-id="ba178-580">Exceptions</span></span>  
 <span data-ttu-id="ba178-581">Poniżej znajduje się Lista wyjątków zgłoszonych przez konstruktory, które nie zawierają parametrów wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-581">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>  
  
|<span data-ttu-id="ba178-582">Wyjątek</span><span class="sxs-lookup"><span data-stu-id="ba178-582">Exception</span></span>|<span data-ttu-id="ba178-583">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-583">Condition</span></span>|<span data-ttu-id="ba178-584">Generowane przez</span><span class="sxs-lookup"><span data-stu-id="ba178-584">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ba178-585">`value`jest `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-585">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ba178-586">`startIndex`,`length`, lub `count` jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-586">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="ba178-587">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-587">-or-</span></span><br /><br /> <span data-ttu-id="ba178-588">Suma `startIndex` `value`i `length` jest większa niż liczba elementów w.</span><span class="sxs-lookup"><span data-stu-id="ba178-588">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="ba178-589">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-589">-or-</span></span><br /><br /> <span data-ttu-id="ba178-590">`count`jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-590">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 <span data-ttu-id="ba178-591">Poniżej znajduje się Lista wyjątków zgłoszonych przez konstruktory, które zawierają parametry wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-591">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>  
  
|<span data-ttu-id="ba178-592">Wyjątek</span><span class="sxs-lookup"><span data-stu-id="ba178-592">Exception</span></span>|<span data-ttu-id="ba178-593">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-593">Condition</span></span>|<span data-ttu-id="ba178-594">Generowane przez</span><span class="sxs-lookup"><span data-stu-id="ba178-594">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="ba178-595">`value`Określa tablicę zawierającą nieprawidłowy znak Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-595">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="ba178-596">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-596">-or-</span></span><br /><br /> <span data-ttu-id="ba178-597">`value`lub `value` określaadres,`startIndex` który jest mniejszy niż 64 KB.  + </span><span class="sxs-lookup"><span data-stu-id="ba178-597">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="ba178-598">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-598">-or-</span></span><br /><br /> <span data-ttu-id="ba178-599">Nie można <xref:System.String> zainicjować nowego wystąpienia `value` z tablicy bajtowej, ponieważ `value` nie używa domyślnego kodowania strony kodowej.</span><span class="sxs-lookup"><span data-stu-id="ba178-599">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="ba178-600">Wszystkie konstruktory ze wskazówkami.</span><span class="sxs-lookup"><span data-stu-id="ba178-600">All constructors with pointers.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ba178-601">`value`ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="ba178-601">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ba178-602">Bieżący proces nie ma dostępu do odczytu do wszystkich znaków w adresie.</span><span class="sxs-lookup"><span data-stu-id="ba178-602">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ba178-603">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-603">-or-</span></span><br /><br /> <span data-ttu-id="ba178-604">`startIndex`lub `length` jest mniejsza od zera, `value`  +  `startIndex` powoduje przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-604">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ba178-605">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-605">-or-</span></span><br /><br /> <span data-ttu-id="ba178-606">Długość nowego ciągu jest zbyt duża, aby można było przydzielić.</span><span class="sxs-lookup"><span data-stu-id="ba178-606">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="ba178-607">Wszystkie konstruktory ze wskazówkami.</span><span class="sxs-lookup"><span data-stu-id="ba178-607">All constructors with pointers.</span></span>|  
|<xref:System.AccessViolationException>|<span data-ttu-id="ba178-608">`value``value` lub -1`length` określa nieprawidłowyadres.`startIndex`  +   + </span><span class="sxs-lookup"><span data-stu-id="ba178-608">`value`, or `value` + `startIndex` + `length` - 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ba178-609">Jaką metodę wywołać?</span><span class="sxs-lookup"><span data-stu-id="ba178-609">Which method do I call?</span></span>  
  
|<span data-ttu-id="ba178-610">Zadanie</span><span class="sxs-lookup"><span data-stu-id="ba178-610">To</span></span>|<span data-ttu-id="ba178-611">Wywołanie lub użycie</span><span class="sxs-lookup"><span data-stu-id="ba178-611">Call or use</span></span>|  
|--------|-----------------|  
|<span data-ttu-id="ba178-612">Utwórz ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-612">Create a string.</span></span>|<span data-ttu-id="ba178-613">Przypisanie z literału ciągu lub istniejącego ciągu ([przykład](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="ba178-613">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|  
|<span data-ttu-id="ba178-614">Utwórz ciąg z całej tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-614">Create a string from an entire character array.</span></span>|<span data-ttu-id="ba178-615"><xref:System.String.%23ctor%28System.Char%5B%5D%29>([przykład](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="ba178-615"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|  
|<span data-ttu-id="ba178-616">Utwórz ciąg z części tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-616">Create a string from a portion of a character array.</span></span>|<span data-ttu-id="ba178-617"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([przykład](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ba178-617"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ba178-618">Utwórz ciąg powtarzający ten sam znak wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="ba178-618">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="ba178-619"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([przykład](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ba178-619"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ba178-620">Utwórz ciąg ze wskaźnika do tablicy znaków Unicode lub szerokiej.</span><span class="sxs-lookup"><span data-stu-id="ba178-620">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|<span data-ttu-id="ba178-621">Utwórz ciąg z części tablicy Unicode lub Wide Character przy użyciu jej wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="ba178-621">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|<span data-ttu-id="ba178-622">Utwórz ciąg z C++ `char` tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-622">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="ba178-623"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="ba178-623"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="ba178-624">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-624">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<span data-ttu-id="ba178-625">Utwórz ciąg z znaków ASCII.</span><span class="sxs-lookup"><span data-stu-id="ba178-625">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a><span data-ttu-id="ba178-626">Tworzenie ciągów</span><span class="sxs-lookup"><span data-stu-id="ba178-626">Creating strings</span></span>  
 <span data-ttu-id="ba178-627">Najczęściej stosowana technika tworzenia ciągów programistycznych jest prostym przypisaniem, jak pokazano w [tym przykładzie](#Ctor1_Example).</span><span class="sxs-lookup"><span data-stu-id="ba178-627">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="ba178-628"><xref:System.String> Klasa zawiera również cztery typy przeciążeń konstruktorów, które umożliwiają tworzenie ciągów z następujących wartości:</span><span class="sxs-lookup"><span data-stu-id="ba178-628">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>  
  
-   <span data-ttu-id="ba178-629">Z tablicy znaków (tablica znaków zakodowanych w formacie UTF-16).</span><span class="sxs-lookup"><span data-stu-id="ba178-629">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="ba178-630">Można utworzyć nowy <xref:System.String> obiekt na podstawie znaków w całej tablicy lub jego części.</span><span class="sxs-lookup"><span data-stu-id="ba178-630">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="ba178-631"><xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiuje wszystkie znaki w tablicy do nowego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-631">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="ba178-632">`startIndex` `startIndex`  +  Konstruktor kopiuje znaki z indeksu do indeksu`length` -1 do nowego ciągu. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="ba178-632">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` - 1 to the new string.</span></span> <span data-ttu-id="ba178-633">Jeśli `length` jest równa zero, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-633">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
     <span data-ttu-id="ba178-634">Jeśli kod wielokrotnie tworzy wystąpienia ciągów, które mają taką samą wartość, można zwiększyć wydajność aplikacji przy użyciu alternatywnego sposobu tworzenia ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-634">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="ba178-635">Aby uzyskać więcej informacji, zobacz [Obsługa powtarzających się ciągów](#Repetitive).</span><span class="sxs-lookup"><span data-stu-id="ba178-635">For more information, see [Handling repetitive strings](#Repetitive).</span></span>  
  
-   <span data-ttu-id="ba178-636">Z pojedynczego znaku, który jest zduplikowany zero, jeden lub więcej razy, za pomocą <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-636">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ba178-637">Jeśli `count` jest równa zero, wartość nowego ciągu to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-637">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ba178-638">Ze wskaźnika do tablicy znaków zakończonych znakiem null przy użyciu <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora or. <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="ba178-638">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ba178-639">Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie.</span><span class="sxs-lookup"><span data-stu-id="ba178-639">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ba178-640">Konstruktor kopiuje sekwencję znaków Unicode `startIndex` , rozpoczynając od określonego wskaźnika lub od określonego wskaźnika i i kontynuując do końca tablicy lub dla `length` znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-640">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="ba178-641">Jeśli `value` jest wskaźnikiem typu null `length` lub jest zerem, Konstruktor tworzy ciąg, którego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-641">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-642">Jeśli operacja kopiowania przechodzi do końca tablicy, a tablica nie zostanie zakończona null, zachowanie konstruktora jest zależne od systemu.</span><span class="sxs-lookup"><span data-stu-id="ba178-642">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="ba178-643">Taki warunek może spowodować naruszenie zasad dostępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-643">Such a condition might cause an access violation.</span></span>  
  
     <span data-ttu-id="ba178-644">Jeśli tablica zawiera wszystkie osadzone znaki null (U + 0000 lub ' \ 0 ') i <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> zostanie wywołana metoda przeciążenia, wystąpienie ciągu zawiera `length` znaki, w tym wszelkie osadzone wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-644">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ba178-645">W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null, jest przesyłany do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-645">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ba178-646">Ponieważ adres jest początkową tablicę, a wszystkie elementy w tablicy są dodawane do ciągu, Konstruktor tworzy wystąpienie ciągu z dziesięć znaków, w tym dwóch osadzonych wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-646">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ba178-647">Z drugiej strony, jeśli ta sama tablica zostanie przekazana do <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora, wynik jest ciągiem zawierającym cztery znaki, który nie zawiera pierwszego znaku null.</span><span class="sxs-lookup"><span data-stu-id="ba178-647">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     <span data-ttu-id="ba178-648">Tablica musi zawierać znaki Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-648">The array must contain Unicode characters.</span></span> <span data-ttu-id="ba178-649">W C++, oznacza to, że tablica znaków musi być zdefiniowana jako typ zarządzany <xref:System.Char>[] lub niezarządzany`wchar_t`typ [].</span><span class="sxs-lookup"><span data-stu-id="ba178-649">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>  
  
     <span data-ttu-id="ba178-650">`length`  +  `startIndex` <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Jeśli Przeciążenie jest wywołane i tablica nie została zakończona znakiem null lub jeśli Przeciążenie jest wywołane i-1 zawiera zakres, który poza pamięcią przydzieloną dla sekwencji znaków, <xref:System.String.%23ctor%28System.Char%2A%29> zachowanie konstruktora jest zależne od systemu i może wystąpić naruszenie zasad dostępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-650">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="ba178-651">Ponadto w procesorze Intel Itanium wywołania do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> konstruktora mogą <xref:System.DataMisalignedException> zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-651">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="ba178-652">W <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> takim przypadku Wywołaj zamiast niego.</span><span class="sxs-lookup"><span data-stu-id="ba178-652">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>  
  
-   <span data-ttu-id="ba178-653">Ze wskaźnika do podpisanej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="ba178-653">From a pointer to a signed byte array.</span></span> <span data-ttu-id="ba178-654">Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie.</span><span class="sxs-lookup"><span data-stu-id="ba178-654">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ba178-655">Sekwencję bajtów można interpretować przy użyciu domyślnego kodowania strony kodowej lub można określić kodowanie w wywołaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-655">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="ba178-656">Jeśli Konstruktor próbuje utworzyć wystąpienie ciągu `value` z całej tablicy, która nie jest zakończona zerem, lub jeśli zakres tablicy od do `value`  +  `startIndex`  +  `startIndex`  +  `length` -1 jest poza pamięcią przydzieloną dla tablicy, zachowanie tego konstruktora jest zależne od systemu i może wystąpić naruszenie zasad dostępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-656">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>  
  
     <span data-ttu-id="ba178-657">Trzy konstruktory, które zawierają podpisany tablicę bajtową jako parametr, są przeznaczone głównie do C++ `char` konwersji tablicy na ciąg, jak pokazano w tym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="ba178-657">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     <span data-ttu-id="ba178-658">Jeśli tablica zawiera znaki null (' \ 0 ') lub bajty, których wartość jest równa 0 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> i zostanie wywołana metoda przeciążenia, wystąpienie ciągu `length` zawiera znaki, w tym wszelkie osadzone wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-658">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ba178-659">W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów, który zawiera dwa znaki null, jest przesyłany do <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-659">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ba178-660">Ponieważ adres jest początkową tablicę, a wszystkie elementy w tablicy są dodawane do ciągu, Konstruktor tworzy wystąpienie ciągu z dziesięć znaków, w tym dwóch osadzonych wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-660">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ba178-661">Z drugiej strony, jeśli ta sama tablica zostanie przekazana do <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora, wynik jest ciągiem zawierającym cztery znaki, który nie zawiera pierwszego znaku null.</span><span class="sxs-lookup"><span data-stu-id="ba178-661">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <span data-ttu-id="ba178-662">Ponieważ konstruktory <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> `value` i interpretują przy użyciu domyślnej strony kodowej ANSI, wywoływanie tych konstruktorów z identycznymi tablicami bajtowymi może tworzyć ciągi, które mają różne wartości w różnych systemach. <xref:System.String.%23ctor%28System.SByte%2A%29></span><span class="sxs-lookup"><span data-stu-id="ba178-662">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a><span data-ttu-id="ba178-663">Obsługa powtarzających się ciągów</span><span class="sxs-lookup"><span data-stu-id="ba178-663">Handling repetitive strings</span></span>  
 <span data-ttu-id="ba178-664">Aplikacje, które analizują lub dekodowania strumieni tekstu często <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> używają konstruktora <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> lub metody do konwertowania sekwencji znaków na ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-664">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="ba178-665">Wielokrotne tworzenie nowych ciągów o tej samej wartości zamiast tworzenia i ponownego używania jednego ciągu pamięci.</span><span class="sxs-lookup"><span data-stu-id="ba178-665">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="ba178-666">Jeśli prawdopodobnie chcesz wielokrotnie utworzyć tę samą wartość ciągu przez wywołanie <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora, nawet jeśli nie wiesz, jakie są identyczne wartości ciągu, możesz zamiast tego użyć tabeli odnośników.</span><span class="sxs-lookup"><span data-stu-id="ba178-666">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>  
  
 <span data-ttu-id="ba178-667">Załóżmy na przykład, że odczytywanie i analizowanie strumienia znaków z pliku zawierającego Tagi i atrybuty XML.</span><span class="sxs-lookup"><span data-stu-id="ba178-667">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="ba178-668">Podczas analizowania strumienia często występują pewne tokeny (czyli sekwencje znaków, które mają znaczenie symboliczne).</span><span class="sxs-lookup"><span data-stu-id="ba178-668">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="ba178-669">Tokeny równoważne z ciągami "0", "1", "true" i "false" mogą występować często w strumieniu XML.</span><span class="sxs-lookup"><span data-stu-id="ba178-669">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>  
  
 <span data-ttu-id="ba178-670">Zamiast konwertować każdy token do nowego ciągu, można utworzyć <xref:System.Xml.NameTable?displayProperty=nameWithType> obiekt, który będzie przechowywać często występujące ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-670">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="ba178-671"><xref:System.Xml.NameTable> Obiekt podnosi wydajność, ponieważ pobiera przechowywane ciągi bez przydzielania pamięci tymczasowej.</span><span class="sxs-lookup"><span data-stu-id="ba178-671">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="ba178-672">Gdy napotkasz token, użyj <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby pobrać token z tabeli.</span><span class="sxs-lookup"><span data-stu-id="ba178-672">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="ba178-673">Jeśli token istnieje, metoda zwraca odpowiedni ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-673">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="ba178-674">Jeśli token nie istnieje, użyj <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby wstawić token do tabeli i uzyskać odpowiedni ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-674">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a><span data-ttu-id="ba178-675">Przykład 1: Używanie przypisania ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-675">Example 1: Using string assignment</span></span>  
 <span data-ttu-id="ba178-676">Poniższy przykład tworzy nowy ciąg, przypisując go literałem ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-676">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="ba178-677">Tworzy drugi ciąg przez przypisanie wartości pierwszego ciągu do niego.</span><span class="sxs-lookup"><span data-stu-id="ba178-677">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="ba178-678">Są to dwa najczęstsze sposoby tworzenia wystąpienia nowego <xref:System.String> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-678">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a><span data-ttu-id="ba178-679">Przykład 2: Korzystanie z tablicy znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-679">Example 2: Using a character array</span></span>  
 <span data-ttu-id="ba178-680">W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt z tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-680">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="ba178-681">Przykład 3: Użycie części tablicy znaków i powtarzanie pojedynczego znaku</span><span class="sxs-lookup"><span data-stu-id="ba178-681">Example 3: Using a portion of a character array and repeating a single character</span></span>  
 <span data-ttu-id="ba178-682">W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt z części tablicy znaków i jak utworzyć nowy <xref:System.String> obiekt, który zawiera wiele wystąpień pojedynczego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-682">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a><span data-ttu-id="ba178-683">Przykład 4: Używanie wskaźnika do tablicy znaków</span><span class="sxs-lookup"><span data-stu-id="ba178-683">Example 4: Using a pointer to a character array</span></span>  
 <span data-ttu-id="ba178-684">W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.String> obiekt ze wskaźnika do tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-684">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="ba178-685">C# Przykład musi być skompilowany przy użyciu `/unsafe` przełącznika kompilatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-685">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="ba178-686">Przykład 5: Tworzenie wystąpienia ciągu ze wskaźnika i zakresu tablicy</span><span class="sxs-lookup"><span data-stu-id="ba178-686">Example 5: Instantiating a string from a pointer and a range of an array</span></span>  
 <span data-ttu-id="ba178-687">Poniższy przykład analizuje elementy tablicy znaków dla kropki lub wykrzyknika.</span><span class="sxs-lookup"><span data-stu-id="ba178-687">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="ba178-688">Jeśli zostanie znaleziony, tworzy wystąpienie ciągu znaków w tablicy, która poprzedza symbol interpunkcji.</span><span class="sxs-lookup"><span data-stu-id="ba178-688">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="ba178-689">W przeciwnym razie tworzy wystąpienie ciągu z całą zawartością tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-689">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="ba178-690">C# Przykład musi być skompilowany przy użyciu `/unsafe` przełącznika kompilatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-690">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="ba178-691">Przykład 6: Tworzenie wystąpienia ciągu ze wskaźnika do podpisanej tablicy bajtów</span><span class="sxs-lookup"><span data-stu-id="ba178-691">Example 6: Instantiating a string from a pointer to a signed byte array</span></span>  
 <span data-ttu-id="ba178-692">Poniższy przykład ilustruje, jak można utworzyć wystąpienie <xref:System.String> klasy <xref:System.String.%23ctor%28System.SByte%2A%29> za pomocą konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-692">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="ba178-693">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="ba178-693">Version information</span></span>  
 <span data-ttu-id="ba178-694">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="ba178-694">.NET Framework</span></span>  
 <span data-ttu-id="ba178-695">Wszystkie przeciążenia są obsługiwane w programie: 4,5, 4, 3,5, 3,0, 2,0, 1,1, 1,0</span><span class="sxs-lookup"><span data-stu-id="ba178-695">All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
  
 <span data-ttu-id="ba178-696">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="ba178-696">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="ba178-697">Wszystkie przeciążenia są obsługiwane w programie: 4, 3,5 Z DODATKIEM SP1</span><span class="sxs-lookup"><span data-stu-id="ba178-697">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="ba178-698">Biblioteka klas przenośnych</span><span class="sxs-lookup"><span data-stu-id="ba178-698">Portable Class Library</span></span>  
 <span data-ttu-id="ba178-699">Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane</span><span class="sxs-lookup"><span data-stu-id="ba178-699">All overloads without an <xref:System.SByte>`*` parameter are supported</span></span>  
  
 <span data-ttu-id="ba178-700">Środowisko .NET dla aplikacji do Sklepu Windows</span><span class="sxs-lookup"><span data-stu-id="ba178-700">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="ba178-701">Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane w programie: Windows 8</span><span class="sxs-lookup"><span data-stu-id="ba178-701">All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-702">Wskaźnik do tablicy znaków Unicode zakończonych wartością null.</span><span class="sxs-lookup"><span data-stu-id="ba178-702">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ba178-703">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-703">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-704">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-704">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-705">Bieżący proces nie ma dostępu do odczytu do wszystkich znaków w adresie.</span><span class="sxs-lookup"><span data-stu-id="ba178-705">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-706"><paramref name="value" />Określa tablicę zawierającą nieprawidłowy znak Unicode lub <paramref name="value" /> określa adres mniejszy niż 64000.</span><span class="sxs-lookup"><span data-stu-id="ba178-706"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba178-707">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-707">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-708">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-708">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-709">Tablica znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-709">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ba178-710">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez tablicę znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-710">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-711">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-711">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-712">Wskaźnik do tablicy zakończonych znakiem null 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-712">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="ba178-713">Liczby całkowite są interpretowane przy użyciu bieżącego kodowania strony kodowej systemu (czyli kodowania określonego przez <see cref="P:System.Text.Encoding.Default" />).</span><span class="sxs-lookup"><span data-stu-id="ba178-713">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="ba178-714">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazywanej przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-714">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-715">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-715">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-716"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-716"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-717">Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest zakodowana w ANSI.</span><span class="sxs-lookup"><span data-stu-id="ba178-717">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-718">Długość nowego ciągu do zainicjowania, która jest określana przez znak zakończenia null elementu <paramref name="value" />, jest zbyt duża do przydzielenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-718">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ba178-719"><paramref name="value" />określa nieprawidłowy adres.</span><span class="sxs-lookup"><span data-stu-id="ba178-719"><paramref name="value" /> specifies an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba178-720">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-720">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-721">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-721">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="ba178-722">Znak Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-722">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-723">Liczba wystąpień <paramref name="c" /> .</span><span class="sxs-lookup"><span data-stu-id="ba178-723">The number of times <paramref name="c" /> occurs.</span></span></param>
        <summary><span data-ttu-id="ba178-724">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony znak Unicode powtórzony określoną liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="ba178-724">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-725">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-725">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-726"><paramref name="count" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-726"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-727">Wskaźnik do tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-727">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-728">Pozycja początkowa w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-728">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-729">Liczba znaków <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-729">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ba178-730">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy znaków Unicode, początkowej pozycji znaku w tej tablicy i długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-730">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-731">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-731">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-732"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera, <paramref name="value" />  +  <paramref name="startIndex" /> powoduje przepełnienie wskaźnika lub bieżący proces nie ma dostępu do odczytu do wszystkich znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-732"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-733"><paramref name="value" />Określa tablicę zawierającą nieprawidłowy znak Unicode lub <paramref name="value" />  +  <paramref name="startIndex" /> określa adres mniejszy niż 64000.</span><span class="sxs-lookup"><span data-stu-id="ba178-733"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba178-734">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-734">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-735">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-735">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-736">Tablica znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-736">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-737">Pozycja początkowa w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-737">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-738">Liczba znaków <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-738">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ba178-739">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez tablicę znaków Unicode, początkową pozycję znaku w tej tablicy i długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-739">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-740">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-740">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-741"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-741"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-742"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-742"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-743">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-743">-or-</span></span> 
<span data-ttu-id="ba178-744">Suma <paramref name="startIndex" /> <paramref name="value" />i <paramref name="length" /> jest większa niż liczba elementów w.</span><span class="sxs-lookup"><span data-stu-id="ba178-744">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-745">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-745">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ba178-746">Liczby całkowite są interpretowane przy użyciu bieżącego kodowania strony kodowej systemu (czyli kodowania określonego przez <see cref="P:System.Text.Encoding.Default" />).</span><span class="sxs-lookup"><span data-stu-id="ba178-746">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-747">Pozycja początkowa w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-747">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-748">Liczba znaków <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-748">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ba178-749">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tej tablicy i długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-749">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-750">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-750">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-751"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-751"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-752"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-752"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-753">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-753">-or-</span></span> 
<span data-ttu-id="ba178-754">Adres określony przez <paramref name="value" />  +  jestzadużydlabieżącejplatformy;oznaczato,żeObliczanieadresuzostałoprzepływane.<paramref name="startIndex" /></span><span class="sxs-lookup"><span data-stu-id="ba178-754">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
<span data-ttu-id="ba178-755">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-755">-or-</span></span> 
<span data-ttu-id="ba178-756">Długość nowego ciągu do zainicjowania jest zbyt duża, aby można było przydzielić.</span><span class="sxs-lookup"><span data-stu-id="ba178-756">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-757">Adres określony przez <paramref name="value" />  +  jestmniejszyniż64KB<paramref name="startIndex" /> .</span><span class="sxs-lookup"><span data-stu-id="ba178-757">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
<span data-ttu-id="ba178-758">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-758">-or-</span></span> 
<span data-ttu-id="ba178-759">Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest zakodowana w ANSI.</span><span class="sxs-lookup"><span data-stu-id="ba178-759">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ba178-760"><paramref name="value" />, <paramref name="startIndex" /> i<paramref name="length" /> zbiorczo Określ nieprawidłowy adres.</span><span class="sxs-lookup"><span data-stu-id="ba178-760"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba178-761">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-761">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-762">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-762">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-763">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-763">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-764">Pozycja początkowa w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-764">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-765">Liczba znaków <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-765">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="ba178-766">Obiekt, który określa sposób kodowania tablicy, do <paramref name="value" /> której się odwołuje.</span><span class="sxs-lookup"><span data-stu-id="ba178-766">An object that specifies how the array referenced by <paramref name="value" /> is encoded.</span></span> <span data-ttu-id="ba178-767">Jeśli <paramref name="enc" /> jest<see langword="null" />, założono kodowanie ANSI.</span><span class="sxs-lookup"><span data-stu-id="ba178-767">If <paramref name="enc" /> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="ba178-768">Inicjuje nowe wystąpienie <see cref="T:System.String" /> klasy do wartości wskazanej przez określony wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, czyli pozycji początkowej w tej tablicy, długości <see cref="T:System.Text.Encoding" /> i obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-768">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-769">Przykłady i kompleksowe informacje o użyciu tego i innych `String` przeciążeń konstruktora można znaleźć w <xref:System.String.%23ctor%2A> podsumowaniu konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-769">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-770"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-770"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-771"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-771"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-772">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-772">-or-</span></span> 
<span data-ttu-id="ba178-773">Adres określony przez <paramref name="value" />  +  jestzadużydlabieżącejplatformy;oznaczato,żeObliczanieadresuzostałoprzepływane.<paramref name="startIndex" /></span><span class="sxs-lookup"><span data-stu-id="ba178-773">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
<span data-ttu-id="ba178-774">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-774">-or-</span></span> 
<span data-ttu-id="ba178-775">Długość nowego ciągu do zainicjowania jest zbyt duża, aby można było przydzielić.</span><span class="sxs-lookup"><span data-stu-id="ba178-775">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-776">Adres określony przez <paramref name="value" />  +  jestmniejszyniż64KB<paramref name="startIndex" /> .</span><span class="sxs-lookup"><span data-stu-id="ba178-776">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
<span data-ttu-id="ba178-777">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-777">-or-</span></span> 
<span data-ttu-id="ba178-778">Nie można zainicjować nowego <see cref="T:System.String" /> wystąpienia programu przy użyciu polecenia <paramref name="value" />, przy <paramref name="value" /> założeniu, że jest <paramref name="enc" />zakodowany jako określony przez.</span><span class="sxs-lookup"><span data-stu-id="ba178-778">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ba178-779"><paramref name="value" />, <paramref name="startIndex" /> i<paramref name="length" /> zbiorczo Określ nieprawidłowy adres.</span><span class="sxs-lookup"><span data-stu-id="ba178-779"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba178-780">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-780">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba178-781">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-781">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="ba178-782">Pozycja w bieżącym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-782">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="ba178-783">Pobiera obiekt w określonym położeniu w bieżącym <see cref="T:System.String" /> obiekcie. <see cref="T:System.Char" /></span><span class="sxs-lookup"><span data-stu-id="ba178-783">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ba178-784">Obiekt w położeniu <paramref name="index" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-784">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-785">`index` Parametr jest oparty na zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-785">The `index` parameter is zero-based.</span></span>  
  
 <span data-ttu-id="ba178-786">Ta właściwość zwraca <xref:System.Char> obiekt na pozycji określonej `index` przez parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-786">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="ba178-787">Jednak znak Unicode może być reprezentowany przez więcej niż jeden <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="ba178-787">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ba178-788">Użyj klasy do pracy ze znakami Unicode <xref:System.Char> zamiast obiektów. <xref:System.Globalization.StringInfo?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-788">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="ba178-789">Aby uzyskać więcej informacji, zobacz sekcję "znaki obiektów i Unicode" w <xref:System.String> temacie Omówienie klasy.</span><span class="sxs-lookup"><span data-stu-id="ba178-789">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>  
  
 <span data-ttu-id="ba178-790">W programie C#indeksatorem. <xref:System.String.Chars%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-790">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="ba178-791">W Visual Basic jest to domyślna właściwość <xref:System.String> klasy.</span><span class="sxs-lookup"><span data-stu-id="ba178-791">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="ba178-792">Dla <xref:System.Char> każdego obiektu w ciągu można uzyskać dostęp za pomocą kodu, takiego jak poniższy.</span><span class="sxs-lookup"><span data-stu-id="ba178-792">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-793">Poniższy przykład ilustruje, jak można użyć tego indeksatora w procedurze do walidacji ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-793">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="ba178-794"><paramref name="index" />jest większa niż lub równa długości tego obiektu lub mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-794"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-795">Zwraca odwołanie do tego wystąpienia <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-795">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-796">To wystąpienie <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-796">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-797">Wartość zwracana nie jest niezależną kopią tego wystąpienia; jest to po prostu inny widok tych samych danych.</span><span class="sxs-lookup"><span data-stu-id="ba178-797">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="ba178-798">Użyj metody <xref:System.String.CopyTo%2A> <xref:System.String> lub, aby utworzyć oddzielny obiekt o tej samej wartości co to wystąpienie. <xref:System.String.Copy%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-798">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>  
  
 <span data-ttu-id="ba178-799"><xref:System.String.Clone%2A> Ponieważ metoda po prostu zwraca istniejące wystąpienie ciągu, istnieje niewielki powód, aby wywołać go bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="ba178-799">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-800">Porównuje dwa <see cref="T:System.String" /> określone obiekty i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-800">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-801">Wszystkie przeciążenia <xref:System.String.Compare%2A> metody zwracają 32-bitową liczbę całkowitą ze znakiem wskazującą, że relacja leksykalna między dwoma comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-801">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
|<span data-ttu-id="ba178-802">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-802">Value</span></span>|<span data-ttu-id="ba178-803">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-803">Condition</span></span>|  
|-----------|---------------|  
|<span data-ttu-id="ba178-804">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-804">Less than zero</span></span>|<span data-ttu-id="ba178-805">Pierwszy podciąg poprzedza drugi podciąg w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-805">The first substring precedes the second substring in the sort order.</span></span>|  
|<span data-ttu-id="ba178-806">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-806">Zero</span></span>|<span data-ttu-id="ba178-807">Podciągi występują w tym samym położeniu w kolejności sortowania lub `length` są równe zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-807">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|  
|<span data-ttu-id="ba178-808">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-808">Greater than zero</span></span>|<span data-ttu-id="ba178-809">Pierwszy podciąg jest zgodny z drugim podciągiem w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-809">The first substring follows the second substring in the sort order.</span></span>|  
  
> [!WARNING]
>  <span data-ttu-id="ba178-810">Zawsze, gdy jest to możliwe, należy wywołać Przeciążenie <xref:System.String.Compare%2A> metody, która <xref:System.StringComparison> zawiera parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-810">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ba178-811">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-811">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7"><span data-ttu-id="ba178-812">Najlepsze praktyki używania ciągów w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="ba178-812">Best Practices for Using Strings in the .NET Framework</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-813">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-813">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-814">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-814">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ba178-815">Porównuje dwa <see cref="T:System.String" /> określone obiekty i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-815">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-816">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-816">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-817">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-817">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-818">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-818">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-819">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-819">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-820"><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-820"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-821">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-821">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-822"><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-822"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-823">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-823">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-824"><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-824"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-825">Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-825">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-826">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-826">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-827">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-827">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-828">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-828">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-829">Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-829">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ba178-830">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-830">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-831">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-831">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-832">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-832">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-833">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-833">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ba178-834">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-834">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-835">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-835">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-836">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-836">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-837">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-837">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 <span data-ttu-id="ba178-838">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-838">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-839">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-839">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-840">Poniższy przykład wywołuje metodę, <xref:System.String.Compare%28System.String%2CSystem.String%29> aby porównać trzy zestawy ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-840">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 <span data-ttu-id="ba178-841">W poniższym przykładzie `ReverseStringComparer` Klasa pokazuje, jak można obliczyć dwa ciągi <xref:System.String.Compare%2A> za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-841">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-842">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-842">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-843"><see cref="M:System.String.Compare(System.String,System.String)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-843">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-844">Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie z uwzględnieniem kultury "zwierzę" z "/-źle" (przy użyciu łącznika miękkiego lub U + 00AD) wskazuje, że dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-844">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ba178-845">[! code-CSharp[System. String. Compare # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! code — VB[System. String. Compare # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="ba178-845">[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span></span> 
<span data-ttu-id="ba178-846">Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-846">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-847">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-847">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-848">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-848">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-849"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-849"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba178-850">Porównuje dwa <see cref="T:System.String" /> określone obiekty, ignorując lub honoruje ich przypadki i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-850">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-851">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-851">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-852">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-852">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-853">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-853">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-854">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-854">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-855"><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-855"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-856">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-856">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-857"><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-857"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-858">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-858">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-859"><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-859"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-860">Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-860">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-861">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-861">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-862">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-862">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-863">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-863">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-864">Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-864">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ba178-865">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-865">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-866">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-866">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-867">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-867">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-868">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-868">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ba178-869">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-869">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-870">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-870">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-871">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-871">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-872">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-872">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 <span data-ttu-id="ba178-873">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-873">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-874">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-874">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-875">Poniższy przykład pokazuje, że <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> Metoda jest równoważna z użyciem <xref:System.String.ToUpper%2A> lub <xref:System.String.ToLower%2A> podczas porównywania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-875">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-876">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-876">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-877"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-877">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-878">Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie bez uwzględniania wielkości liter dla "zwierzęcia" z "/-unpoufne" (przy użyciu łącznika nietrwałego lub U + 00AD) wskazuje, że dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-878">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ba178-879">[! code-CSharp[System. String. Compare # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! code — VB[System. String. Compare # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="ba178-879">[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span></span> 
<span data-ttu-id="ba178-880">Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-880">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-881">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-881">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-882">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-882">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-883">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-883">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-884">Porównuje dwa <see cref="T:System.String" /> określone obiekty przy użyciu określonych reguł i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-884">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-885">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-885">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-886">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-886">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-887">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-887">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-888">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-888">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-889"><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-889"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-890">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-890">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-891"><paramref name="strA" />znajduje się w tym samym położeniu, co <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-891"><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-892">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-892">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-893"><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-893"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-894">`comparisonType` Parametr wskazuje, czy porównanie powinno korzystać z bieżącej lub niezmiennej kultury, przestrzegać lub ignorowania wielkości liter comparands, czy też używać reguł sortowania programu Word (z uwzględnieniem kultury) lub liczby porządkowej (bez uwzględniania kultur).</span><span class="sxs-lookup"><span data-stu-id="ba178-894">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ba178-895">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-895">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-896">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-896">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-897">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-897">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ba178-898">Jeśli jednak dwa porównywane ciągi są równe końcowi jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-898">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-899">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-899">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-900">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-900">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-901">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-901">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 <span data-ttu-id="ba178-902">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-902">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-903">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-903">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-904">Poniższy przykład porównuje trzy wersje litery "I".</span><span class="sxs-lookup"><span data-stu-id="ba178-904">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="ba178-905">Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-905">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-906"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-906"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba178-907"><see cref="T:System.StringComparison" />nie jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="ba178-907"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-908">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-908">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-909"><see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-909">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-910">Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-910">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-911">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-911">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-912">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-912">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-913"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-913"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-914">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-914">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ba178-915">Porównuje dwa <see cref="T:System.String" /> określone obiekty, ignorując lub honoruje ich przypadki, i przy użyciu informacji specyficznych dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje ich względne położenie w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-915">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-916">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-916">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-917">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-917">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-918">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-918">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-919">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-919">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-920"><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-920"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-921">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-921">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-922"><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-922"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-923">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-923">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-924"><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-924"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-925">Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejność alfabetyczna poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-925">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-926">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-926">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-927">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-927">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-928">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-928">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-929">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-929">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-930">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-930">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-931">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-931">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ba178-932">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-932">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-933">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-933">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-934">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-934">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-935">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-935">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 <span data-ttu-id="ba178-936">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-936">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-937">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-937">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-938">Poniższy przykład ilustruje, jak kultura może wpływać na porównanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-938">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="ba178-939">W kulturze Czeskiej, "ch" jest pojedynczym znakiem, który jest większy niż "d".</span><span class="sxs-lookup"><span data-stu-id="ba178-939">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="ba178-940">Jednak w języku angielskim Stany Zjednoczone kultura "ch" składa się z dwóch znaków, a "c" jest mniejsze niż "d".</span><span class="sxs-lookup"><span data-stu-id="ba178-940">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-941"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-941"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-942">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-942">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-943"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-943">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-944">Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie bez uwzględniania wielkości liter "zwierzę" z "/-źle" (przy użyciu łącznika miękkiego lub U + 00AD) przy użyciu niezmiennej kultury wskazuje, że dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-944">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ba178-945">[! code-CSharp[System. String. Compare # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! code — VB[System. String. Compare # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="ba178-945">[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span></span> 
<span data-ttu-id="ba178-946">Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodę i podaj wartość albo <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-946">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-947">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-947">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-948">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-948">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-949">Kultura, która dostarcza informacje porównawcze specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-949">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-950">Opcje do użycia podczas przeprowadzania porównania (na przykład ignorowanie wielkości liter lub symboli).</span><span class="sxs-lookup"><span data-stu-id="ba178-950">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ba178-951">Porównuje dwa <see cref="T:System.String" /> określone obiekty przy użyciu określonych opcji porównania i informacje specyficzne dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje relację dwóch ciągów do siebie w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-951">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-952">32-bitowa liczba całkowita ze znakiem wskazująca leksykalną <paramref name="strA" /> relację między i <paramref name="strB" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="ba178-952">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span> 
 <list type="table"><listheader><term> <span data-ttu-id="ba178-953">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-953">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-954">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-954">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-955">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-955">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-956"><paramref name="strA" /><paramref name="strB" /> poprzedza w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-956"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-957">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-957">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-958"><paramref name="strA" />występuje w tym samym położeniu <paramref name="strB" /> co w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-958"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-959">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-959">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-960"><paramref name="strA" />poniżej <paramref name="strB" /> w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-960"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-961">Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejności alfabetycznej poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-961">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ba178-962">Na przykład dana kultura może określać, że niektóre kombinacje znaków mają być traktowane jako pojedynczy znak, że wielkie i małe litery są porównywane w określony sposób lub że kolejność sortowania znaku zależy od znaków, które przed lub po nim.</span><span class="sxs-lookup"><span data-stu-id="ba178-962">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ba178-963"><xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-963">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ba178-964">Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne (to znaczy, gdy celem wywołania metody jest przetestowanie wartości zwracanej przez zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-964">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ba178-965">Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-965">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-966">Porównanie można dokładniej określić za pomocą `options` parametru, który składa się z co najmniej jednego <xref:System.Globalization.CompareOptions> elementu członkowskiego wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-966">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="ba178-967">Ponieważ jednak celem tej metody jest przeprowadzenie porównania ciągów z uwzględnieniem kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> wartości i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> nie mają żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-967">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ba178-968">Może to być `null`albo oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-968">Either or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-969">Według definicji, dowolnego ciągu, w <xref:System.String.Empty?displayProperty=nameWithType>tym, porównuje więcej niż odwołanie o wartości null i dwa odwołania o wartości null są porównywane ze sobą.</span><span class="sxs-lookup"><span data-stu-id="ba178-969">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-970">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-970">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ba178-971">Jeśli jednak dwa porównywane ciągi są równe końcu jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-971">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-972">Poniższy przykład porównuje dwa ciągi na trzy różne sposoby: przy użyciu porównania lingwistyczne dla kultury en-US; użycie porównania z uwzględnieniem wielkości liter w kulturze en-US; i przy użyciu porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-972">The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="ba178-973">Ilustruje to, jak trzy metody porównania dają trzy różne wyniki.</span><span class="sxs-lookup"><span data-stu-id="ba178-973">It illustrates how the three methods of comparison produce three different results.</span></span>  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-974"><paramref name="options" />nie <see cref="T:System.Globalization.CompareOptions" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-974"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-975"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-975"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-976">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-976">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-977"><see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-977">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-978">Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-978">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-979">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-979">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-980">Pozycja podciągu w elemencie <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-980">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-981">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-981">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-982">Pozycja podciągu w elemencie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-982">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-983">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-983">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ba178-984">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-984">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-985">32-bitowa liczba całkowita ze znakiem wskazująca, że relacja leksykalna między dwoma comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-985">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-986">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-986">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-987">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-987">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-988">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-988">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-989">Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-989">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-990">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-990">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-991">Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-991">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-992">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-992">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-993">Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-993">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-994">Podciągi, które mają zostać porównane `indexA` , rozpoczynają `indexB`się w `strA` i w `strB` .</span><span class="sxs-lookup"><span data-stu-id="ba178-994">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ba178-995">Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-995">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ba178-996">Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-996">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ba178-997">Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-997">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ba178-998">Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-998">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ba178-999">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-999">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1000">Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1000">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-1001">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1001">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-1002">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1002">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-1003">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1003">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-1004">Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1004">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ba178-1005">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1005">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-1006">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1006">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-1007">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1007">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-1008">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1008">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ba178-1009">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1009">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-1010">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1010">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-1011">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1011">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-1012">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-1012">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 <span data-ttu-id="ba178-1013">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1013">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-1014">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-1014">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1015">Poniższy przykład porównuje dwa podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1015">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1016"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1016"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1017">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1017">-or-</span></span> 
 <span data-ttu-id="ba178-1018"><paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1018"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1019">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1019">-or-</span></span> 
 <span data-ttu-id="ba178-1020"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1020"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-1021">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1021">-or-</span></span> 
<span data-ttu-id="ba178-1022">Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1022">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1023">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1023">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1024"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1024">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1025">Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1025">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1026">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1026">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-1027">Pozycja podciągu w elemencie <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1027">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1028">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1028">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-1029">Pozycja podciągu w elemencie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1029">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-1030">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1030">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-1031"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1031"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1032">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów, ignorując lub honoruje ich wielkości liter i zwraca liczbę całkowitą, która wskazuje ich względne położenie w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1032">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-1033">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1033">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1034">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1034">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1035">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1035">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1036">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1036">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1037">Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1037">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1038">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1038">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1039">Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1039">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1040">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1040">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1041">Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1041">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1042">Podciągi, `strA` które mają zostać porównane `indexA`, zaczynają się `indexB`w, i w `strB` .</span><span class="sxs-lookup"><span data-stu-id="ba178-1042">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ba178-1043">Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1043">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ba178-1044">Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1044">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ba178-1045">Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1045">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ba178-1046">Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1046">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ba178-1047">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1047">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1048">Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1048">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-1049">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1049">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-1050">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1050">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-1051">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1051">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ba178-1052">Podczas porównywania ciągów należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określenia typu porównania ciągów używanego przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1052">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ba178-1053">Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące używania ciągów](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1053">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ba178-1054">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1054">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-1055">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1055">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-1056">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1056">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ba178-1057">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1057">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-1058">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1058">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-1059">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1059">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-1060">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-1060">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 <span data-ttu-id="ba178-1061">Nazwa ścieżki musi być porównana w sposób niezmienny.</span><span class="sxs-lookup"><span data-stu-id="ba178-1061">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="ba178-1062">Prawidłowy kod jest następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-1062">The correct code to do this is as follows.</span></span>  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1063">Poniższy przykład wykonuje dwa porównania dwóch podciągów, które różnią się tylko wielkością liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-1063">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="ba178-1064">Pierwsze porównanie ignoruje wielkość liter, a drugie porównanie uwzględnia wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-1064">The first comparison ignores case and the second comparison considers case.</span></span>  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1065"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1065"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1066">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1066">-or-</span></span> 
 <span data-ttu-id="ba178-1067"><paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1067"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1068">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1068">-or-</span></span> 
 <span data-ttu-id="ba178-1069"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1069"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-1070">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1070">-or-</span></span> 
<span data-ttu-id="ba178-1071">Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1071">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1072">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1072">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1073"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1073">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1074">Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1074">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1075">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1075">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-1076">Pozycja podciągu w elemencie <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1076">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1077">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1077">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-1078">Pozycja podciągu w elemencie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1078">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-1079">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1079">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1080">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1080">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-1081">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przy użyciu określonych reguł i zwraca liczbę całkowitą wskazującą ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1081">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-1082">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1082">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1083">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1083">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1084">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1084">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1085">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1085">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1086">Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1086">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1087">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1087">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1088">Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> parametr ma wartość zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1088">The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1089">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1089">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1090">Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1090">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1091">Podciągi, które mają zostać porównane `indexA` , rozpoczynają `indexB`się w `strA` i w `strB` .</span><span class="sxs-lookup"><span data-stu-id="ba178-1091">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ba178-1092">Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i znajduje się na pozycji zero, a nie na pozycji 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-1092">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ba178-1093">Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1093">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ba178-1094">Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1094">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ba178-1095">Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1095">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ba178-1096">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1096">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1097">`comparisonType` Parametr wskazuje, czy porównanie powinno korzystać z bieżącej lub niezmiennej kultury, przestrzegać lub ignorowania wielkości liter comparands, czy też używać reguł sortowania programu Word (z uwzględnieniem kultury) lub liczby porządkowej (bez uwzględniania kultur).</span><span class="sxs-lookup"><span data-stu-id="ba178-1097">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ba178-1098">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1098">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-1099">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1099">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-1100">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1100">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ba178-1101">Jeśli jednak dwa porównywane ciągi są równe końcowi jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1101">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-1102">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1102">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-1103">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1103">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-1104">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-1104">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 <span data-ttu-id="ba178-1105">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1105">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-1106">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-1106">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1107">Poniższy przykład porównuje dwa podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1107">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1108"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1108"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1109">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1109">-or-</span></span> 
 <span data-ttu-id="ba178-1110"><paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1110"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1111">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1111">-or-</span></span> 
 <span data-ttu-id="ba178-1112"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1112"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-1113">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1113">-or-</span></span> 
<span data-ttu-id="ba178-1114">Albo <paramref name="indexA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="indexB" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1114">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1115"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1115"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1116">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1116">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1117"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1117">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1118">Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1118">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1119">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1119">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-1120">Pozycja podciągu w elemencie <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1120">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1121">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1121">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-1122">Pozycja podciągu w elemencie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1122">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-1123">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1123">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-1124"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1124"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-1125">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1125">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ba178-1126">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów, ignorując lub honoruje ich przypadki i wykorzystując informacje specyficzne dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje ich położenie względne w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1126">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-1127">Liczba całkowita, która wskazuje leksykalną relację między dwoma comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1127">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1128">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1128">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1129">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1129">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1130">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1130">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1131">Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1131">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1132">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1132">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1133">Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1133">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1134">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1134">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1135">Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1135">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1136">Podciągi, `strA` które mają zostać porównane `indexA`, zaczynają się `indexB`w, i w `strB` .</span><span class="sxs-lookup"><span data-stu-id="ba178-1136">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ba178-1137">Zarówno `indexA` , `indexB` jak i są liczone od zera; oznacza to, że pierwszy `strA` znak `strB` w i znajduje się na pozycji zero, a nie na pozycji 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-1137">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ba178-1138">Długość pierwszego podciągu jest równa długości `strA` minusa `indexA` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1138">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ba178-1139">Długość drugiego podciągu jest równa długości `strB` znaku minus `indexB` plus jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1139">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ba178-1140">Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1140">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ba178-1141">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1141">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1142">Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejność alfabetyczna poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1142">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ba178-1143">Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1143">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ba178-1144">Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1144">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ba178-1145">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1145">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-1146">Może to być `null`jeden lub oba comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1146">One or both comparands can be `null`.</span></span> <span data-ttu-id="ba178-1147">Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1147">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-1148">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1148">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ba178-1149">Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1149">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-1150">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1150">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ba178-1151">Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1151">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ba178-1152">Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.</span><span class="sxs-lookup"><span data-stu-id="ba178-1152">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 <span data-ttu-id="ba178-1153">Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1153">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ba178-1154">Poprawny kod będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="ba178-1154">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1155">Poniższy przykład porównuje dwa podciągi przy użyciu różnych kultur i ignorując wielkość liter podciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1155">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="ba178-1156">Wybór kultury ma wpływ na sposób porównywania litery "I".</span><span class="sxs-lookup"><span data-stu-id="ba178-1156">The choice of culture affects how the letter "I" is compared.</span></span>  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1157"><paramref name="indexA" />jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1157"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1158">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1158">-or-</span></span> 
 <span data-ttu-id="ba178-1159"><paramref name="indexB" />jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1159"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1160">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1160">-or-</span></span> 
 <span data-ttu-id="ba178-1161"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1161"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-1162">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1162">-or-</span></span> 
<span data-ttu-id="ba178-1163">Albo <paramref name="strA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="strB" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1163">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1164"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1164"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1165">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1165">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1166"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1166">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1167">Aby rozpoznać ignorowane znaki w porównaniu, wywołaj <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodę i podaj <see cref="F:System.Globalization.CompareOptions.Ordinal" /> wartość lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1167">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1168">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1168">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-1169">Pozycja początkowa podciągu w elemencie <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1169">The starting position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1170">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1170">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-1171">Pozycja początkowa podciągu w elemencie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1171">The starting position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-1172">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1172">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-1173">Obiekt, który dostarcza informacje porównawcze specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1173">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-1174">Opcje do użycia podczas przeprowadzania porównania (na przykład ignorowanie wielkości liter lub symboli).</span><span class="sxs-lookup"><span data-stu-id="ba178-1174">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ba178-1175">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przy użyciu określonych opcji porównania i informacji specyficznych dla kultury, które mają wpływ na porównanie, i zwraca liczbę całkowitą, która wskazuje na relację dwóch podciągów na siebie w kolejność sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1175">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ba178-1176">Liczba całkowita, która wskazuje leksykalną relację między dwoma podciągami, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="ba178-1176">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1177">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1177">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1178">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1178">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1179">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1179">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1180">Podciąg w <paramref name="strA" /> elemencie poprzedza podciąg w <paramref name="strB" /> kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1180">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1181">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1181">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1182">Podciągi występują w tym samym położeniu w kolejności sortowania lub <paramref name="length" /> są równe zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1182">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1183">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1183">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1184">Podciąg w <paramref name="strA" /> poniższym <paramref name="strB" /> podciągu w kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1184">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1185">Podciągi, które mają `strA` zostać porównane, zaczynają się na `indexB`pozycji `indexA` i w `strB` na pozycji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1185">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="ba178-1186">Długość pierwszego podciągu jest długością `strA` znaku minus. `indexA`</span><span class="sxs-lookup"><span data-stu-id="ba178-1186">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="ba178-1187">Długość drugiego podciągu jest długością `strB` minus. `indexB`</span><span class="sxs-lookup"><span data-stu-id="ba178-1187">The length of the second substring is the length of `strB` minus `indexB`.</span></span>  
  
 <span data-ttu-id="ba178-1188">Liczba znaków do porównania jest mniejsza z długości dwóch podciągów i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1188">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ba178-1189">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1189">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1190">Porównanie używa `culture` parametru, aby uzyskać informacje specyficzne dla kultury, takie jak reguły dotyczące wielkości liter i kolejności alfabetycznej poszczególnych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1190">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ba178-1191">Na przykład dana kultura może określać, że niektóre kombinacje znaków mają być traktowane jako pojedynczy znak, że wielkie i małe litery są porównywane w określony sposób lub że kolejność sortowania znaku zależy od znaków, które przed lub po nim.</span><span class="sxs-lookup"><span data-stu-id="ba178-1191">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ba178-1192"><xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Metoda jest zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1192">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ba178-1193">Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa podciągi są równoważne (to znaczy, gdy celem wywołania metody jest przetestowanie wartości zwracanej przez zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-1193">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ba178-1194">Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1194">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-1195">Jeden lub oba z `strA` i `strB` mogą być `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1195">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ba178-1196">Według definicji, dowolnego ciągu, w <xref:System.String.Empty?displayProperty=nameWithType>tym, porównuje więcej niż odwołanie o wartości null i dwa odwołania o wartości null są porównywane ze sobą.</span><span class="sxs-lookup"><span data-stu-id="ba178-1196">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ba178-1197">Porównanie można dokładniej określić za pomocą `options` parametru, który składa się z co najmniej jednego <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> elementu członkowskiego wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1197">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="ba178-1198">Ponieważ jednak celem tej metody jest przeprowadzenie porównania ciągów z uwzględnieniem kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> wartości i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> nie mają żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1198">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ba178-1199">Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1199">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ba178-1200">Jeśli jednak dwa porównywane ciągi są równe końcu jednego ciągu, a drugi ciąg zawiera znaki pozostałe, ciąg z pozostałymi znakami jest traktowany jako większy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1200">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="ba178-1201">Zwracana wartość jest wynikiem ostatniego wykonanego porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1201">The return value is the result of the last comparison performed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1202">W poniższym przykładzie zastosowano <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodę w celu porównania ostatnich nazw dwóch osób.</span><span class="sxs-lookup"><span data-stu-id="ba178-1202">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="ba178-1203">Następnie wyświetla je w kolejności alfabetycznej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1203">It then lists them in alphabetical order.</span></span>  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1204"><paramref name="options" />nie <see cref="T:System.Globalization.CompareOptions" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1204"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1205"><paramref name="indexA" />jest większa niż <paramref name="strA" />. <see langword=".Length" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1205"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>  
  
<span data-ttu-id="ba178-1206">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1206">-or-</span></span> 
 <span data-ttu-id="ba178-1207"><paramref name="indexB" />jest większa niż <paramref name="strB" />. <see langword=".Length" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1207"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>  
  
<span data-ttu-id="ba178-1208">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1208">-or-</span></span> 
 <span data-ttu-id="ba178-1209"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1209"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-1210">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1210">-or-</span></span> 
<span data-ttu-id="ba178-1211">Albo <paramref name="strA" /> jest ,i<paramref name="length" /> jest większa od zera. <see langword="null" /> <paramref name="strB" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1211">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1212"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1212"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1213">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1213">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1214"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Metoda nie uwzględnia tych znaków, gdy wykonuje to porównanie lingwistyczne lub kulturowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1214">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1215">Aby rozpoznać ignorowanych znaków w porównaniu, podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1215">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1216">Porównuje <see cref="T:System.String" /> dwa obiekty, oceniając wartości liczbowe odpowiednich <see cref="T:System.Char" /> obiektów w każdym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1216">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1217">Pierwszy ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1217">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1218">Drugi ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1218">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ba178-1219">Porównuje dwa <see cref="T:System.String" /> określone obiekty przez ocenę wartości liczbowych odpowiednich <see cref="T:System.Char" /> obiektów w każdym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1219">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1220">Liczba całkowita, która wskazuje leksykalną relację między dwoma comparands.</span><span class="sxs-lookup"><span data-stu-id="ba178-1220">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1221">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1221">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1222">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1222">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1223">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1223">Less than zero</span></span> 
 </term><description><span data-ttu-id="ba178-1224"><paramref name="strA" />jest mniejsze niż <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1224"><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1225">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1225">Zero</span></span> 
 </term><description><span data-ttu-id="ba178-1226"><paramref name="strA" />i <paramref name="strB" /> są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1226"><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1227">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1227">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ba178-1228"><paramref name="strA" />jest większa niż <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1228"><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1229">Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter przy użyciu reguł sortowania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1229">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ba178-1230">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1230">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-1231">Aby wykonać porównanie bez uwzględniania wielkości liter przy użyciu reguł sortowania porządkowego, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Wywołaj metodę `comparisonType` z argumentem <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="ba178-1231">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-1232">Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest `strB` `null`metodą statyczną i może być. `strA`</span><span class="sxs-lookup"><span data-stu-id="ba178-1232">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ba178-1233">Jeśli obie wartości są `null`, metoda zwraca 0 (zero), co oznacza, że `strA` i `strB` są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1233">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ba178-1234">Jeśli jest `null`tylko jedna z wartości, Metoda traktuje wartość inną niż null, aby była większa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1234">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1235">Poniższy przykład wykonuje i porównywanie porządkowe dwóch ciągów, które różnią się tylko wielkością liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-1235">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ba178-1236">Pierwszy ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1236">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ba178-1237">Początkowy indeks podciągu w <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1237">The starting index of the substring in <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ba178-1238">Drugi ciąg do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1238">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ba178-1239">Początkowy indeks podciągu w <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1239">The starting index of the substring in <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-1240">Maksymalna liczba znaków w podciągach do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1240">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ba178-1241">Porównuje podciągi dwóch określonych <see cref="T:System.String" /> obiektów przez obliczenie wartości liczbowych odpowiednich <see cref="T:System.Char" /> obiektów w każdym podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1241">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="ba178-1242">32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1242">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1243">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1243">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1244">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1244">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1245">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1245">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1246">Podciąg w <paramref name="strA" /> jest krótszy niż podciąg w <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1246">The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1247">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1247">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1248">Podciągi są równe lub <paramref name="length" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1248">The substrings are equal, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1249">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1249">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1250">Podciąg w <paramref name="strA" /> jest większy niż podciąg w <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1250">The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1251">Parametry `indexA`, `indexB` i`length` nie mogą być ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1251">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ba178-1252">`strA` Liczba porównywanych znaków to mniejsza długość mniejsza `indexA`, długość `strB` mniejsza `indexB`i `length`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1252">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>  
  
 <span data-ttu-id="ba178-1253">Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter przy użyciu reguł sortowania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1253">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ba178-1254">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1254">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-1255">Aby wykonać porównanie bez uwzględniania wielkości liter przy użyciu reguł sortowania porządkowego, <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> Wywołaj metodę `comparisonType` z argumentem <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="ba178-1255">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-1256">Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest `strB` `null`metodą statyczną i może być. `strA`</span><span class="sxs-lookup"><span data-stu-id="ba178-1256">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ba178-1257">Jeśli obie wartości są `null`, metoda zwraca 0 (zero), co oznacza, że `strA` i `strB` są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1257">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ba178-1258">Jeśli jest `null`tylko jedna z wartości, Metoda traktuje wartość inną niż null, aby była większa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1258">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1259">Poniższy przykład pokazuje, że <xref:System.String.CompareOrdinal%2A> i <xref:System.String.Compare%2A> używa różnych kolejności sortowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1259">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1260"><paramref name="strA" />nie <see langword="null" /> jest i <paramref name="indexA" /> jest większe niż <paramref name="strA" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1260"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1261">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1261">-or-</span></span> 
 <span data-ttu-id="ba178-1262"><paramref name="strB" />nie <see langword="null" /> jest i <paramref name="indexB" /> jest większe niż <paramref name="strB" />.<see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1262"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ba178-1263">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1263">-or-</span></span> 
 <span data-ttu-id="ba178-1264"><paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1264"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1265">Porównuje to wystąpienie z określonym obiektem <see cref="T:System.String" /> lub i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania co określony obiekt <see cref="T:System.String" />lub.</span><span class="sxs-lookup"><span data-stu-id="ba178-1265">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1266">Oba przeciążenia <xref:System.String.CompareTo%2A> metody wykonują dane zależne od kultury i wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-1266">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="ba178-1267">Nie można użyć tej metody do wykonania porównania bez uwzględniania kultury ani liczby porządkowej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1267">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="ba178-1268">W przypadku przejrzystości kodu zalecamy uniknięcie <xref:System.String.CompareTo%2A> metody i <xref:System.String.Compare%2A> wywołanie metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1268">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1269">Obiekt, który jest obliczany przez <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1269">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1270">Porównuje to wystąpienie z określonym <see cref="T:System.Object" /> i wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania, jak określono <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1270">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1271">32-bitowa liczba całkowita ze znakiem, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności <paramref name="value" /> sortowania jako parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-1271">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1272">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1272">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1273">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1273">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1274">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1274">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1275">To wystąpienie poprzedza <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1275">This instance precedes <paramref name="value" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1276">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1276">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1277">To wystąpienie ma tę samą pozycję w kolejności sortowania, co <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1277">This instance has the same position in the sort order as <paramref name="value" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1278">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1278">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1279">To wystąpienie jest <paramref name="value" />następujące.</span><span class="sxs-lookup"><span data-stu-id="ba178-1279">This instance follows <paramref name="value" />.</span></span>  
  
<span data-ttu-id="ba178-1280">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1280">-or-</span></span> 
 <span data-ttu-id="ba178-1281"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1281"><paramref name="value" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1282">`value`musi być <xref:System.String> obiektem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1282">`value` must be a <xref:System.String> object.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ba178-1283"><xref:System.String.CompareTo%2A> Metoda została zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1283">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ba178-1284">Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1284">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ba178-1285">Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1285">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-1286">Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1286">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ba178-1287">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1287">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-1288">Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> uwagi w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1288">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1289">Poniższy przykład używa <xref:System.String.CompareTo%2A> metody <xref:System.Object>z.</span><span class="sxs-lookup"><span data-stu-id="ba178-1289">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="ba178-1290">Ponieważ próbuje porównać <xref:System.String> wystąpienie `TestClass` z obiektem <xref:System.ArgumentException>, metoda zgłasza.</span><span class="sxs-lookup"><span data-stu-id="ba178-1290">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1291"><paramref name="value" />nie <see cref="T:System.String" />jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-1291"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1292">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1292">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1293"><see cref="M:System.String.CompareTo(System.Object)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1293">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1294">Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "/-un--(using the Soft łącznik lub U + 00AD) wskazuje, że dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1294">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ba178-1295">[! code-CSharp[System. String. CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code — VB[System. String. CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="ba178-1295">[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span></span> 
<span data-ttu-id="ba178-1296">Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1296">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="ba178-1297">Ciąg, który ma zostać porównany z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1297">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-1298">Porównuje to wystąpienie z określonym <see cref="T:System.String" /> obiektem i wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności sortowania co określony ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-1298">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1299">32-bitowa liczba całkowita ze znakiem, która wskazuje, czy to wystąpienie poprzedza, następuje po lub występuje w tym samym położeniu w kolejności <paramref name="strB" /> sortowania jako parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-1299">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ba178-1300">Wartość</span><span class="sxs-lookup"><span data-stu-id="ba178-1300">Value</span></span> 
 </term><description> <span data-ttu-id="ba178-1301">Warunek</span><span class="sxs-lookup"><span data-stu-id="ba178-1301">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ba178-1302">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1302">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1303">To wystąpienie poprzedza <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1303">This instance precedes <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1304">Zero</span><span class="sxs-lookup"><span data-stu-id="ba178-1304">Zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1305">To wystąpienie ma tę samą pozycję w kolejności sortowania, co <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1305">This instance has the same position in the sort order as <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ba178-1306">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="ba178-1306">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ba178-1307">To wystąpienie jest <paramref name="strB" />następujące.</span><span class="sxs-lookup"><span data-stu-id="ba178-1307">This instance follows <paramref name="strB" />.</span></span>  
  
<span data-ttu-id="ba178-1308">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1308">-or-</span></span> 
 <span data-ttu-id="ba178-1309"><paramref name="strB" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1309"><paramref name="strB" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1310">Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1310">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ba178-1311">Więcej informacji na temat wyrazów, ciągów i liczb porządkowych można znaleźć <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>w temacie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1311">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ba178-1312"><xref:System.String.CompareTo%2A> Metoda została zaprojektowana głównie do użycia podczas sortowania lub alphabetizing operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1312">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ba178-1313">Nie należy jej używać, gdy głównym celem wywołania metody jest określenie, czy dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1313">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ba178-1314">Aby określić, czy dwa ciągi są równoważne, wywołaj <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1314">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-1315">Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję <xref:System.String.Compare%28System.String%2CSystem.String%29> uwagi w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1315">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>  
  
 <span data-ttu-id="ba178-1316">Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepszą <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> niż metoda, ponieważ nie `strB` musi określać, czy argument jest typem wartości modyfikowalnej, który musi być opakowany i nie musi rzutować parametr z elementu <xref:System.Object> <xref:System.String>do.</span><span class="sxs-lookup"><span data-stu-id="ba178-1316">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1317">W poniższym przykładzie zastosowano <xref:System.String.CompareTo%2A> metodę, aby porównać bieżące wystąpienie ciągu z innym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1317">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 <span data-ttu-id="ba178-1318">W poniższym przykładzie zademonstrowano ogólne i nieogólne wersje metody CompareTo dla kilku typów wartości i elementów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1318">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1319">Zestawy znaków obejmują znaki do pominięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1319">Character sets include ignorable characters.</span></span> <span data-ttu-id="ba178-1320"><see cref="M:System.String.CompareTo(System.String)" /> Metoda nie uwzględnia takich znaków, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1320">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-1321">Na przykład, jeśli Poniższy kod jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, porównanie "zwierzę" z "/-un--(using the Soft łącznik lub U + 00AD) wskazuje, że dwa ciągi są równoważne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1321">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ba178-1322">[! code-CSharp[System. String. CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code — VB[System. String. CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="ba178-1322">[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span></span> 
<span data-ttu-id="ba178-1323">Aby rozpoznać ignorowanie znaków w porównaniu ciągów, wywołaj <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1323">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1324">Łączy jedno lub więcej wystąpień <see cref="T:System.String" /> <see cref="T:System.String" /> lub reprezentacje wartości <see cref="T:System.Object" />jednego lub większej liczby wystąpień.</span><span class="sxs-lookup"><span data-stu-id="ba178-1324">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  <span data-ttu-id="ba178-1325">Można również użyć operatora łączenia ciągów języka, takiego `+` jak w C#, lub `&` i `+` w Visual Basic, aby połączyć ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1325">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic, to concatenate strings.</span></span> <span data-ttu-id="ba178-1326">Oba kompilatory tłumaczą operator łączenia na wywołanie jednego z przeciążeń `String.Concat`.</span><span class="sxs-lookup"><span data-stu-id="ba178-1326">Both compilers translate the concatenation operator into a call to one of the overloads of `String.Concat`.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ba178-1327">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> i którego argument typu ogólnego jest <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1327">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1328">Łączy elementy członkowskie skonstruowanej <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcji typu. <see cref="T:System.String" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1328">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1329">Połączone ciągi w <paramref name="values" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="values" /> są puste <see langword="IEnumerable(Of String)" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1329">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1330">Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1330">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="ba178-1331">Aby określić ogranicznik między poszczególnymi elementami członkowskimi `values`, należy <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1331">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="ba178-1332">Ciąg jest używany zamiast dowolnego elementu null w `values`. <xref:System.String.Empty></span><span class="sxs-lookup"><span data-stu-id="ba178-1332">An <xref:System.String.Empty> string is used in place of any null element in `values`.</span></span>  
  
 <span data-ttu-id="ba178-1333">Jeśli `values` jest pusty `IEnumerable(Of String)`, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1333">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-1334">Jeśli `values` jest `null` ,<xref:System.ArgumentNullException> Metoda zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-1334">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>  
  
 <span data-ttu-id="ba178-1335"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów na tablicę ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1335"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ba178-1336">Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ).</span><span class="sxs-lookup"><span data-stu-id="ba178-1336">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ba178-1337">Poniższy przykład przekazuje `List(Of String)` obiekt zawierający wielkie lub małe litery alfabetu do wyrażenia lambda, które wybiera litery, które są równe lub większe niż określona litera (w tym przykładzie jest to "M").</span><span class="sxs-lookup"><span data-stu-id="ba178-1337">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ba178-1338">Kolekcja zwracana <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> przez metodę jest przekazana do metodywceluwyświetleniawynikujakopojedynczegociągu.<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> `IEnumerable(Of String)`</span><span class="sxs-lookup"><span data-stu-id="ba178-1338">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1339">W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza.</span><span class="sxs-lookup"><span data-stu-id="ba178-1339">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ba178-1340">Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, który następnie przekazuje <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1340">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1341"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1341"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ba178-1342">Obiekt reprezentujący lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1342">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1343">Tworzy reprezentację ciągu określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1343">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ba178-1344">Ciąg reprezentujący wartość <paramref name="arg0" />lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="arg0" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1344">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1345">Metoda reprezentuje `arg0` jako ciąg`ToString` przez wywołanie metody bez parametrów. <xref:System.String.Concat%28System.Object%29></span><span class="sxs-lookup"><span data-stu-id="ba178-1345">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1346">Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1346">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="ba178-1347">Tablica obiektów, która zawiera elementy do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1347">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1348">Łączy reprezentacje ciągów elementów w określonej <see cref="T:System.Object" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1348">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="ba178-1349">Połączone ciągi reprezentujące wartości elementów w <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1349">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1350">Metoda łączy każdy obiekt w `args` przez wywołanie `ToString` metody bez parametrów tego obiektu; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1350">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1351"><xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego obiektu o wartości null w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1351"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1352">Poniższy przykład demonstruje użycie <xref:System.String.Concat%2A> metody <xref:System.Object> z tablicą.</span><span class="sxs-lookup"><span data-stu-id="ba178-1352">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1353"><paramref name="args" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1353"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ba178-1354">Za mało pamięci.</span><span class="sxs-lookup"><span data-stu-id="ba178-1354">Out of memory.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1355">Ta metoda nie jest wywoływana przez C++ kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-1355">This method is not called by C++ code.</span></span> <span data-ttu-id="ba178-1356">C++ Kompilator rozpoznaje wywołania <see cref="Overload:System.String.Concat" /> , które mają <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />co najmniej cztery parametry obiektu jako wywołanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1356">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ba178-1357">Tablica wystąpień ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1357">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="ba178-1358">Łączy elementy określonej <see cref="T:System.String" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1358">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="ba178-1359">Połączone elementy <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1359">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1360">Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1360">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1361"><xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu o wartości null w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1361">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1362">Poniższy przykład demonstruje użycie <xref:System.String.Concat%2A> metody <xref:System.String> z tablicą.</span><span class="sxs-lookup"><span data-stu-id="ba178-1362">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1363"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1363"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ba178-1364">Za mało pamięci.</span><span class="sxs-lookup"><span data-stu-id="ba178-1364">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ba178-1365">Pierwszy obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1365">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1366">Drugi obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1366">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1367">Łączy reprezentacje ciągów dwóch określonych obiektów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1367">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ba178-1368">Połączone ciąg reprezentujący wartości <paramref name="arg0" /> i. <paramref name="arg1" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1368">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1369">Metoda łączy `arg0` i `arg1` wywołuje `ToString` metodę bezparametrów`arg1`i;nie dodaje żadnych ograniczników. `arg0`</span><span class="sxs-lookup"><span data-stu-id="ba178-1369">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1370"><xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1370"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ba178-1371">Jeśli jeden z argumentów jest odwołaniem do tablicy, Metoda łączy ciąg reprezentujący tę tablicę zamiast jej elementów członkowskich (na przykład "System. String []").</span><span class="sxs-lookup"><span data-stu-id="ba178-1371">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1372">Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1372">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1373">Pierwszy zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1373">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1374">Drugi zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1374">The second read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1375">Łączy ciąg reprezentujący dwa określone zakresy znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1375">Concatenates the string representations of two specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="ba178-1376">Połączone ciąg reprezentujący wartości <paramref name="str0" /> i. <paramref name="str1" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1376">The concatenated string representations of the values of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1377">Pierwszy ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1377">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1378">Drugi ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1378">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1379">Łączy dwa określone wystąpienia elementu <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1379">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1380">Łączenie <paramref name="str0" /> i <paramref name="str1" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1380">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1381">Metoda łączy `str0` i `str1`; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1381">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1382"><xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1382">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
## Examples  
 <span data-ttu-id="ba178-1383">Poniższy przykład łączy imię, drugie imię i nazwisko osoby.</span><span class="sxs-lookup"><span data-stu-id="ba178-1383">The following example concatenates a person's first, middle, and last name.</span></span>  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ba178-1384">Pierwszy obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1384">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1385">Drugi obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1385">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ba178-1386">Trzeci obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1386">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1387">Łączy ciąg reprezentujący trzy określone obiekty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1387">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ba178-1388">Połączone ciąg reprezentujący wartości <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1388">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1389">Metoda łączy `arg0` `ToString` , `arg1` i`arg2` przez wywołanie metody bez parametrów każdego obiektu; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1389">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1390"><xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1390"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1391">Poniższy przykład demonstruje <xref:System.String.Concat%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1391">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1392">Pierwszy zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1392">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1393">Drugi zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1393">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ba178-1394">Trzeci zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1394">The third read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1395">Łączy ciąg reprezentujący trzy określone zakresy znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1395">Concatenates the string representations of three specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="ba178-1396">Połączone ciąg reprezentujący wartości <paramref name="str0" />, <paramref name="str1" /> i <paramref name="str2" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1396">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" /> and <paramref name="str2" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1397">Pierwszy ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1397">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1398">Drugi ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1398">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ba178-1399">Trzeci ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1399">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1400">Łączy trzy określone wystąpienia <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1400">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1401">Łączenie <paramref name="str0" />, <paramref name="str1" />i. <paramref name="str2" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1401">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1402">Metoda łączy `str0`, `str1`i `str2`; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1402">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>  
  
## Examples  
 <span data-ttu-id="ba178-1403">W poniższym przykładzie zastosowano <xref:System.String.Concat%2A> metodę, aby połączyć trzy ciągi i wyświetlić wynik.</span><span class="sxs-lookup"><span data-stu-id="ba178-1403">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ba178-1404">Pierwszy obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1404">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1405">Drugi obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1405">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ba178-1406">Trzeci obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1406">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="ba178-1407">Czwarty obiekt do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1407">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1408">Łączy reprezentacje ciągów czterech określonych obiektów i wszystkich obiektów określonych w opcjonalnej liście parametrów o zmiennej długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-1408">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="ba178-1409">Reprezentacja połączonego ciągu dla każdej wartości na liście parametrów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1409">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ba178-1410">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="ba178-1410">This API is not CLS-compliant.</span></span> <span data-ttu-id="ba178-1411">Alternatywa zgodna ze specyfikacją <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>CLS ma wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1411">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-1412">Kompilatory C# i Visual Basic automatycznie rozwiązują wywołanie tej metody jako wywołanie <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1412">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-1413">Metoda łączy każdy obiekt na liście parametrów przez wywołanie `ToString` metody bez parametrów; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1413">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1414"><xref:System.String.Empty?displayProperty=nameWithType>jest używany zamiast dowolnego argumentu o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1414"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-1415">Ostatni parametr <xref:System.String.Concat%2A> metody jest opcjonalną rozdzielaną przecinkami listą co najmniej jednego obiektu, który można połączyć.</span><span class="sxs-lookup"><span data-stu-id="ba178-1415">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1416">Poniższy przykład ilustruje użycie <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody do łączenia listy parametrów zmiennych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1416">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="ba178-1417">W tym przypadku metoda jest wywoływana z dziewięcioma parametrami.</span><span class="sxs-lookup"><span data-stu-id="ba178-1417">In this case, the method is called with nine parameters.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1418">Ta metoda jest oznaczona za pomocą <see langword="vararg" /> słowa kluczowego, co oznacza, że obsługuje zmienną liczbę parametrów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1418">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="ba178-1419">Metodę można wywołać z wizualizacji C++, ale nie można jej wywołać z C# lub Visual Basic kodzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1419">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="ba178-1420">Kompilatory C# i Visual Basic rozwiązują wywołania <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> jako wywołania do. <see cref="M:System.String.Concat(System.Object[])" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1420">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1421">Pierwszy zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1421">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1422">Drugi zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1422">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ba178-1423">Trzeci zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1423">The third read-only character span to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="ba178-1424">Czwarty zakres znaków tylko do odczytu do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1424">The fourth read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1425">Łączy ciąg reprezentujący cztery określone zakresy znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1425">Concatenates the string representations of four specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="ba178-1426"><paramref name="str0" />Połączone ciąg reprezentujący wartości, <paramref name="str1" />, <paramref name="str2" /> i <paramref name="str3" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1426">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> and <paramref name="str3" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ba178-1427">Pierwszy ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1427">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ba178-1428">Drugi ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1428">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ba178-1429">Trzeci ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1429">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="ba178-1430">Czwarty ciąg do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1430">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-1431">Łączy cztery określone wystąpienia <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1431">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1432">Łączenie <paramref name="str0" />, <paramref name="str1" />, ,<paramref name="str2" />i .<paramref name="str3" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1432">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1433">Metoda łączy `str0`, `str1`, `str2`i ;niedodajeżadnychograniczników.`str3`</span><span class="sxs-lookup"><span data-stu-id="ba178-1433">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>  
  
## Examples  
 <span data-ttu-id="ba178-1434">Poniższy przykład definiuje tablicę zawierającą cztery litery słów i zapisuje poszczególne litery w tablicy ciągów, aby je zaszyfrować.</span><span class="sxs-lookup"><span data-stu-id="ba178-1434">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="ba178-1435">Następnie wywołuje <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodę, aby ponownie połączyć zaszyfrowane słowa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1435">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ba178-1436">Typ elementów członkowskich <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1436">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="values"><span data-ttu-id="ba178-1437">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> interfejs.</span><span class="sxs-lookup"><span data-stu-id="ba178-1437">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="ba178-1438">Łączy elementy członkowskie <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1438">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="ba178-1439">Połączone elementy członkowskie w <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1439">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1440">Metoda łączy każdy obiekt w `values`; nie dodaje żadnych ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-1440">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ba178-1441"><xref:System.String.Empty> Ciąg jest używany zamiast dowolnego argumentu o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1441">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ba178-1442"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania elementów na ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1442"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="ba178-1443">Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ), jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1443">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="ba178-1444">Ciąg reprezentujący każdy obiekt w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1444">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1445">W poniższym przykładzie zdefiniowano bardzo prostą `Animal` klasę, która zawiera nazwę zwierzęcia i kolejność, do której należy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1445">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ba178-1446">Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, aby zawierał `Animal` kilka obiektów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1446">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="ba178-1447">Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiektów, `Order` których właściwość jest równa "gryzonie". <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-1447">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ba178-1448">Wynik jest przesyłany do <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody i wyświetlany w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1448">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1449"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1449"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1450">Znak, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-1450">The character to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-1451">Zwraca wartość wskazującą, czy określony znak występuje w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1451">Returns a value indicating whether a specified character occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1452"><see langword="true" />Jeśli parametr występuje w tym ciągu; w przeciwnym razie <see langword="false" />,. <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1452"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1453">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1453">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-1454">Zwraca wartość wskazującą, czy w tym ciągu występuje określony podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-1454">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1455"><see langword="true" />Jeśli parametr występuje w tym ciągu lub jeśli <paramref name="value" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1455"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1456">Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).</span><span class="sxs-lookup"><span data-stu-id="ba178-1456">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="ba178-1457">Wyszukiwanie rozpoczyna się od pierwszego położenia znaku tego ciągu i jest kontynuowane przez ostatnią pozycję znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-1457">The search begins at the first character position of this string and continues through the last character position.</span></span>  
  
 <span data-ttu-id="ba178-1458">Aby określić, czy ciąg zawiera określony podciąg, przy użyciu innego niż porównanie porządkowe (takie jak porównanie z uwzględnieniem kultury lub porządkową bez uwzględniania wielkości liter), można utworzyć metodę niestandardową.</span><span class="sxs-lookup"><span data-stu-id="ba178-1458">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="ba178-1459">Poniższy przykład ilustruje takie podejście.</span><span class="sxs-lookup"><span data-stu-id="ba178-1459">The following example illustrates one such approach.</span></span> <span data-ttu-id="ba178-1460">Definiuje <xref:System.String> metodę rozszerzenia, która <xref:System.StringComparison> zawiera parametr i wskazuje, czy ciąg zawiera podciąg przy użyciu określonej formy porównania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1460">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 <span data-ttu-id="ba178-1461">Poniższy przykład wywołuje metodę rozszerzenia, `Contains` aby określić, czy podciąg zostanie znaleziony w ciągu podczas korzystania z porównania porządkowego i porównywania porządkowego bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-1461">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 <span data-ttu-id="ba178-1462">Jeśli interesuje Cię pozycja podciągu `value` w bieżącym wystąpieniu, możesz <xref:System.String.IndexOf%2A> wywołać metodę, aby uzyskać początkową pozycję pierwszego wystąpienia <xref:System.String.LastIndexOf%2A> lub wywołać metodę w celu uzyskania pozycji początkowej ostatnie wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1462">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="ba178-1463">Przykład zawiera wywołanie metody, <xref:System.String.IndexOf%28System.String%29> Jeśli podciąg zostanie znaleziony w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1463">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1464">Poniższy przykład określa, czy ciąg "Fox" jest podciągiem znanej oferty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1464">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="ba178-1465">Jeśli w ciągu znaleziono "Fox", wyświetlana jest również jego pozycja początkowa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1465">If "fox" is found in the string, it also displays its starting position.</span></span>  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1466"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1466"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1467">Znak, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-1467">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1468">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1468">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-1469">Zwraca wartość wskazującą, czy określony znak występuje w tym ciągu, przy użyciu określonych reguł porównywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1469">Returns a value indicating whether a specified character occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="ba178-1470"><see langword="true" />Jeśli parametr występuje w tym ciągu; w przeciwnym razie <see langword="false" />,. <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1470"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1471">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1471">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1472">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1472">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-1473">Zwraca wartość wskazującą, czy określony ciąg występuje w tym ciągu, przy użyciu określonych reguł porównywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1473">Returns a value indicating whether a specified string occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="ba178-1474"><see langword="true" />Jeśli parametr występuje w tym ciągu lub jeśli <paramref name="value" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1474"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ba178-1475">Ciąg do skopiowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1475">The string to copy.</span></span></param>
        <summary><span data-ttu-id="ba178-1476">Tworzy nowe wystąpienie <see cref="T:System.String" /> o takiej samej wartości jak określona <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1476">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-1477">Nowy ciąg o takiej samej wartości jak <paramref name="str" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1477">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="ba178-1478">`Copy` Metoda<xref:System.String> zwraca obiekt, który ma taką samą wartość jak oryginalny ciąg, ale reprezentuje inne odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1478">The `Copy` method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="ba178-1479">Różni się od operacji przypisania, która przypisuje istniejące odwołanie do ciągu do dodatkowej zmiennej obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1479">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="ba178-1480">Począwszy od platformy .NET Core 3,0, ta metoda jest przestarzała.</span><span class="sxs-lookup"><span data-stu-id="ba178-1480">Starting with .NET Core 3.0, this method is obsolete.</span></span> <span data-ttu-id="ba178-1481">Nie zaleca się jednak używania ich w żadnej implementacji platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="ba178-1481">However, we do not recommend its use in any .NET implementation.</span></span> <span data-ttu-id="ba178-1482">W szczególności ze względu na zmiany w ciągu na platformie .NET Core 3,0, w niektórych przypadkach Metoda `Copy` nie utworzy nowego ciągu, ale po prostu zwróci odwołanie do istniejącego ciągu z stażystami.</span><span class="sxs-lookup"><span data-stu-id="ba178-1482">In particular, because of changes in string interning in .NET Core 3.0, in some cases the `Copy` method will not create a new string but will simply return a reference to an existing interned string.</span></span>   

<span data-ttu-id="ba178-1483">W zależności od tego, dlaczego chcesz wywołać `Copy` metodę, istnieje szereg alternatyw:</span><span class="sxs-lookup"><span data-stu-id="ba178-1483">Depending on Why you want to call the `Copy` method, there are a number of alternatives:</span></span>

- <span data-ttu-id="ba178-1484">Jeśli chcesz, aby w operacji modyfikującej ciąg użyć innego wystąpienia ciągu, użyj oryginalnego wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1484">If you want a different string instance to use in an operation that modifies the string, use the original string instance.</span></span> <span data-ttu-id="ba178-1485">Ponieważ ciągi są niezmienne, operacja String tworzy nowe wystąpienie ciągu, a oryginalny ciąg pozostaje bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-1485">Because strings are immutable, the string operation creates a new string instance, and the original string remains unaffected.</span></span> <span data-ttu-id="ba178-1486">W tym przypadku nie należy przypisywać nowego ciągu do oryginalnej zmiennej ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1486">In this case, you should not assign the new string reference to the original string variable.</span></span> <span data-ttu-id="ba178-1487">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="ba178-1487">The following example provides an illustration.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   <span data-ttu-id="ba178-1488">W takim przypadku wywołanie `Copy` metody w celu utworzenia nowego ciągu przed <xref:System.String.Substring%2A> wywołaniem metody niepotrzebnie tworzy nowe wystąpienie ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1488">In this case, calling the `Copy` method to create a new string before calling the <xref:System.String.Substring%2A> method unnecessarily creates a new string instance.</span></span> 

- <span data-ttu-id="ba178-1489">Jeśli chcesz utworzyć modyfikowalny bufor o tej samej zawartości co oryginalny ciąg, wywołaj <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> konstruktora or. <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-1489">If you want to create a mutable buffer with the same contents as the original string, call the <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="ba178-1490">Przykład:</span><span class="sxs-lookup"><span data-stu-id="ba178-1490">For example:</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- <span data-ttu-id="ba178-1491">Jeśli chcesz utworzyć modyfikowalną kopię ciągu, aby można było użyć niebezpiecznego kodu do modyfikacji zawartości ciągu, użyj <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1491">If you want to create a mutable copy of the string so that you can use unsafe code to modify the string contents, use <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-1492">Poniższy przykład używa metody, <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> Aby uzyskać wskaźnik do lokalizacji skopiowanego ciągu w pamięci niezarządzanej, zwiększa punkt kodu Unicode każdego znaku w ciągu przez jeden, a następnie kopiuje otrzymany ciąg z powrotem do zarządzanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1492">The following example uses the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method to get a pointer to the location of an copied string in unmanaged memory, increments the Unicode code point of each character in the string by one, and copies the resulting string back to a managed string.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1493"><paramref name="str" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1493"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="ba178-1494">Indeks pierwszego znaku w tym wystąpieniu do skopiowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1494">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="ba178-1495">Tablica znaków Unicode, do których są kopiowane znaki w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1495">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="ba178-1496">Indeks, w <paramref name="destination" /> którym rozpoczyna się operacja kopiowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1496">The index in <paramref name="destination" /> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-1497">Liczba znaków w tym wystąpieniu do skopiowania <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1497">The number of characters in this instance to copy to <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1498">Kopiuje określoną liczbę znaków z określonego położenia w tym wystąpieniu do określonej pozycji w tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-1498">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1499">Ta metoda kopiuje `count` znaki `sourceIndex` z pozycji tego `destination` wystąpienia do `destinationIndex` położenia tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1499">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="ba178-1500">Ta metoda nie zmienia rozmiaru `destination` tablicy znaków; musi mieć wystarczającą liczbę elementów, aby pomieścić skopiowane znaki, lub metoda <xref:System.ArgumentOutOfRangeException>zgłasza.</span><span class="sxs-lookup"><span data-stu-id="ba178-1500">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="ba178-1501">`sourceIndex`i `destinationIndex` są oparte na zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1501">`sourceIndex` and `destinationIndex` are zero-based.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1502">Poniższy przykład demonstruje <xref:System.String.CopyTo%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1502">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1503"><paramref name="destination" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1503"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-1504"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" /> jest ujemna</span><span class="sxs-lookup"><span data-stu-id="ba178-1504"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span> 
<span data-ttu-id="ba178-1505">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1505">-or-</span></span> 
 <span data-ttu-id="ba178-1506"><paramref name="sourceIndex" />nie identyfikuje pozycji w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1506"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>  
  
<span data-ttu-id="ba178-1507">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1507">-or-</span></span> 
 <span data-ttu-id="ba178-1508"><paramref name="destinationIndex" />nie identyfikuje prawidłowego indeksu w <paramref name="destination" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1508"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>  
  
<span data-ttu-id="ba178-1509">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1509">-or-</span></span> 
 <span data-ttu-id="ba178-1510"><paramref name="count" />jest większa niż długość podciągu od <paramref name="sourceIndex" /> do końca tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1510"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span> 
<span data-ttu-id="ba178-1511">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1511">-or-</span></span> 
 <span data-ttu-id="ba178-1512"><paramref name="count" />jest większa niż długość podtablicy od <paramref name="destinationIndex" /> do końca <paramref name="destination" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1512"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba178-1513">Reprezentuje pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-1513">Represents the empty string.</span></span> <span data-ttu-id="ba178-1514">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1514">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1515">Wartość tego pola jest ciągiem o zerowej długości, "".</span><span class="sxs-lookup"><span data-stu-id="ba178-1515">The value of this field is the zero-length string, "".</span></span>  
  
 <span data-ttu-id="ba178-1516">W kodzie aplikacji to pole jest najczęściej używane w przypisaniach do inicjowania zmiennej ciągu do pustego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1516">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="ba178-1517">Aby sprawdzić, czy wartość ciągu jest albo `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, użyj <xref:System.String.IsNullOrEmpty%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1517">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1518">Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1518">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1519">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1519">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-1520">Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1520">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1521"><see langword="true" />w przypadku <paramref name="value" /> dopasowania do końca tego wystąpienia; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1521"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1522">Ta metoda jest `value` porównywana z podciągiem na końcu tego wystąpienia, który ma taką samą długość `value`jak i zwraca wskazanie, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1522">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ba178-1523">`value` Musi być odwołaniem do tego samego wystąpienia lub być zgodne z końcem tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1523">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>  
  
 <span data-ttu-id="ba178-1524">Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1524">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1525">Poniższy przykład wskazuje, czy każdy ciąg w tablicy jest zakończony kropką (".").</span><span class="sxs-lookup"><span data-stu-id="ba178-1525">The following example indicates whether each string in an array ends with a period (".").</span></span>  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 <span data-ttu-id="ba178-1526">W poniższym przykładzie zdefiniowano `StripEndTags` metodę, która <xref:System.String.EndsWith%28System.String%29> używa metody do usuwania tagów końcowych HTML z końca wiersza.</span><span class="sxs-lookup"><span data-stu-id="ba178-1526">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="ba178-1527">Należy zauważyć, `StripEndTags` że metoda jest wywoływana cyklicznie, aby zapewnić usunięcie wielu tagów końcowych HTML na końcu wiersza.</span><span class="sxs-lookup"><span data-stu-id="ba178-1527">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1528"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1528"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-1529">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1529">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-1530">Aby określić, czy ciąg jest kończący się określonym podciągiem przy użyciu reguł porównywania ciągów bieżącej kultury, wywołaj <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1530">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1531">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1531">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1532">Jedna z wartości wyliczenia, która określa, jak ten ciąg <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1532">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="ba178-1533">Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną opcją porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1533">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="ba178-1534"><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z końcem tego ciągu; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="ba178-1534"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1535"><xref:System.String.EndsWith%2A> Metoda porównujeparametrdopodciągunakońcuciąguizwracawartośćwskazującą`value` , czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1535">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ba178-1536">Aby była równa `value` , musi być odwołaniem do tego samego ciągu, musi być pustym ciągiem ("") lub musi być zgodna z końcem tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1536">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="ba178-1537">Typ porównania wykonywanego przez <xref:System.String.EndsWith%2A> metodę zależy od wartości `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-1537">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1538">Poniższy przykład określa, czy ciąg jest kończący się określonym podciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1538">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="ba178-1539">Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1539">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1540"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1540"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1541"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1541"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1542">Ciąg, który ma zostać porównany z podciągiem na końcu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1542">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-1543"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1543"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-1544">Informacje kulturowe, które określają, jak <paramref name="value" /> to wystąpienie i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1544">Cultural information that determines how this instance and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="ba178-1545">Jeśli <paramref name="culture" /> jest<see langword="null" />, używana jest bieżąca kultura.</span><span class="sxs-lookup"><span data-stu-id="ba178-1545">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ba178-1546">Określa, czy koniec tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną kulturą.</span><span class="sxs-lookup"><span data-stu-id="ba178-1546">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-1547"><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z końcem tego ciągu; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="ba178-1547"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1548">Ta metoda porównuje `value` parametr do podciągu na końcu ciągu, który ma taką samą długość jak `value`i zwraca wartość wskazującą, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1548">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ba178-1549">Aby była równa `value` , musi być odwołaniem do tego samego wystąpienia lub być zgodne z końcem tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1549">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>  
  
 <span data-ttu-id="ba178-1550">Ta metoda wykonuje porównanie wyrazu (z uwzględnieniem kultury) przy użyciu określonej wielkości liter i kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1550">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1551">Poniższy przykład określa, czy ciąg występuje na końcu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1551">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="ba178-1552"><xref:System.String.EndsWith%2A> Metoda jest wywoływana kilka razy przy użyciu czułości wielkości liter, nierozróżniania wielkości liter i różnych kultur, które wpływają na wyniki wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1552">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1553"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1553"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-1554">Zwraca Wyliczenie <see cref="T:System.Text.Rune" /> z tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1554">Returns an enumeration of <see cref="T:System.Text.Rune" /> from this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1555">Moduł wyliczający ciągów Rune.</span><span class="sxs-lookup"><span data-stu-id="ba178-1555">A string rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

<span data-ttu-id="ba178-1556">Nieprawidłowe sekwencje są reprezentowane w wyliczeniu przez <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1556">Invalid sequences are represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1557">Określa, czy <see cref="T:System.String" /> dwa obiekty mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1557">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ba178-1558">Ciąg, który ma zostać porównany z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1558">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-1559">Określa, czy to wystąpienie i określony obiekt, który również musi być <see cref="T:System.String" /> obiektem, mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1559">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns><span data-ttu-id="ba178-1560"><see langword="true" />Jeśli <paramref name="obj" /> <see langword="false" />jest i jej wartość jest taka sama jak to wystąpienie; w przeciwnym razie,. <see cref="T:System.String" /></span><span class="sxs-lookup"><span data-stu-id="ba178-1560"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="ba178-1561">Jeśli <paramref name="obj" /> <see langword="false" />jest <see langword="null" />, metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-1561">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1562">Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).</span><span class="sxs-lookup"><span data-stu-id="ba178-1562">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1563">Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1563">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1564">Ciąg, który ma zostać porównany z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1564">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-1565">Określa, czy to wystąpienie i inny <see cref="T:System.String" /> określony obiekt mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1565">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="ba178-1566"><see langword="true" />Jeśli wartość <paramref name="value" /> parametru jest taka sama jak wartość tego wystąpienia; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1566"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ba178-1567">Jeśli <paramref name="value" /> <see langword="false" />jest <see langword="null" />, metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-1567">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1568">Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).</span><span class="sxs-lookup"><span data-stu-id="ba178-1568">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1569">Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1569">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span> <span data-ttu-id="ba178-1570">Porównuje słowo Case z tytułem "plik" z odpowiednikiem wyrazu, jego odpowiednikiem małymi literami, jego wielką literą i słowem zawierającym małe litery w postaci niewielkiej i (U + 0131) zamiast wielkiej litery I (U + 0069).</span><span class="sxs-lookup"><span data-stu-id="ba178-1570">It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="ba178-1571">Ponieważ metoda wykonuje porównanie porządkowe, tylko porównanie z identycznym słowem zwraca `true`. <xref:System.String.Equals%28System.String%29></span><span class="sxs-lookup"><span data-stu-id="ba178-1571">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ba178-1572">Pierwszy ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1572">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ba178-1573">Drugi ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1573">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-1574">Określa, czy dwa <see cref="T:System.String" /> określone obiekty mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1574">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns><span data-ttu-id="ba178-1575"><see langword="true" />Jeśli wartość <paramref name="a" /> jest taka sama jak <paramref name="b" />wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1575"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ba178-1576">Jeśli obie <paramref name="a" /> i <paramref name="b" /> są <see langword="null" />, metoda zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1576">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1577">Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).</span><span class="sxs-lookup"><span data-stu-id="ba178-1577">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1578">Poniższy przykład demonstruje <xref:System.String.Equals%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1578">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-1579">Ciąg, który ma zostać porównany z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1579">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1580">Jedna z wartości wyliczenia, która określa sposób porównywania ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1580">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="ba178-1581">Określa, czy ten ciąg i określony <see cref="T:System.String" /> obiekt mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1581">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="ba178-1582">Parametr określa kulturę, wielkość liter i reguły sortowania używane w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1582">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="ba178-1583"><see langword="true" />Jeśli wartość <paramref name="value" /> parametru jest taka sama jak ten ciąg; w przeciwnym razie, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1583"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1584">`comparisonType` Parametr wskazuje, czy porównanie ma korzystać z bieżącej lub niezmiennej kultury, czy ma być uznawany czy ignorowany w przypadku porównywania dwóch ciągów lub użyć reguł sortowania programu Word lub porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1584">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1585">Poniższy przykład tworzy tablicę ciągów składającą się z wielkich liter "I", litery "i" i z kropką "ı".</span><span class="sxs-lookup"><span data-stu-id="ba178-1585">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="ba178-1586">Następnie wywołuje <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodę w celu porównania ich przy użyciu każdej możliwej <xref:System.StringComparison> wartości wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1586">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 <span data-ttu-id="ba178-1587">Poniższy przykład porównuje cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1587">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ba178-1588">W porównaniach używane są konwencje angielskiej (Stany Zjednoczone) i Lapoński (Wielka Szwecja).</span><span class="sxs-lookup"><span data-stu-id="ba178-1588">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ba178-1589">Należy zauważyć, że ciągi "Encyclopædia" i "Encyclopaedia" są uważane za równoważne w kulturze en-US, ale nie w kulturze sami (Północna Szwecja).</span><span class="sxs-lookup"><span data-stu-id="ba178-1589">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1590"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1590"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ba178-1591">Pierwszy ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1591">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ba178-1592">Drugi ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1592">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-1593">Jedna z wartości wyliczenia, która określa reguły dla porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1593">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-1594">Określa, czy dwa <see cref="T:System.String" /> określone obiekty mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1594">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="ba178-1595">Parametr określa kulturę, wielkość liter i reguły sortowania używane w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1595">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="ba178-1596"><see langword="true" />Jeśli wartość <paramref name="a" /> parametru jest równa wartości <paramref name="b" /> parametru; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1596"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1597">`comparisonType` Parametr wskazuje, czy porównanie ma korzystać z bieżącej lub niezmiennej kultury, czy ma być uznawany czy ignorowany w przypadku porównywania dwóch ciągów lub użyć reguł sortowania programu Word lub porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1597">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1598">Poniższy przykład porównuje cztery zestawy wyrazów za pomocą każdego elementu członkowskiego <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1598">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ba178-1599">W porównaniach używane są konwencje angielskiej (Stany Zjednoczone) i Lapoński (Wielka Szwecja).</span><span class="sxs-lookup"><span data-stu-id="ba178-1599">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ba178-1600">Należy zauważyć, że ciągi "Encyclopædia" i "Encyclopaedia" są uważane za równoważne w kulturze en-US, ale nie w kulturze sami (Północna Szwecja).</span><span class="sxs-lookup"><span data-stu-id="ba178-1600">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-1601"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1601"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-1602">Konwertuje wartość obiektów na ciągi w oparciu o określone formaty i wstawia je do innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1602">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>  
  
<span data-ttu-id="ba178-1603">Jeśli dopiero zaczynasz [korzystać z](#Starting) metody,zobaczsekcjęwprowadzeniedometodyString.format,abyzapoznaćsięzkrótkim`String.Format` omówieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1603">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>  
  
<span data-ttu-id="ba178-1604">Zobacz sekcję [uwagi](#remarks-top) , aby zapoznać się z `String.Format` ogólną dokumentacją dla metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1604">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 <span data-ttu-id="ba178-1605">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="ba178-1605">In this section:</span></span>  
  
 <span data-ttu-id="ba178-1606">[Wprowadzenie do metody String. format](#Starting) </span><span class="sxs-lookup"><span data-stu-id="ba178-1606">[Get started with the String.Format method](#Starting) </span></span>  
 <span data-ttu-id="ba178-1607">[Którą metodę nazywam?](#FTaskList) </span><span class="sxs-lookup"><span data-stu-id="ba178-1607">[Which method do I call?](#FTaskList) </span></span>  
 <span data-ttu-id="ba178-1608">[Metoda formatowania w skrócie](#Format_Brief) </span><span class="sxs-lookup"><span data-stu-id="ba178-1608">[The Format method in brief](#Format_Brief) </span></span>  
 <span data-ttu-id="ba178-1609">[Element formatu](#FormatItem) </span><span class="sxs-lookup"><span data-stu-id="ba178-1609">[The Format item](#FormatItem) </span></span>  
 <span data-ttu-id="ba178-1610">[Jak są formatowane argumenty](#HowFormatted) </span><span class="sxs-lookup"><span data-stu-id="ba178-1610">[How arguments are formatted](#HowFormatted) </span></span>  
 <span data-ttu-id="ba178-1611">[Sformatuj elementy, które mają ten sam indeks](#SameIndex) </span><span class="sxs-lookup"><span data-stu-id="ba178-1611">[Format items that have the same index](#SameIndex) </span></span>  
 <span data-ttu-id="ba178-1612">[Formatowanie i kultura](#Format_Culture) </span><span class="sxs-lookup"><span data-stu-id="ba178-1612">[Formatting and culture](#Format_Culture) </span></span>  
 <span data-ttu-id="ba178-1613">[Niestandardowe operacje formatowania](#Format_Custom) </span><span class="sxs-lookup"><span data-stu-id="ba178-1613">[Custom formatting operations](#Format_Custom) </span></span>  
 [<span data-ttu-id="ba178-1614">Ciąg. format Q & A</span><span class="sxs-lookup"><span data-stu-id="ba178-1614">String.Format Q & A</span></span>](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="ba178-1615">Wprowadzenie do metody String. format</span><span class="sxs-lookup"><span data-stu-id="ba178-1615">Get started with the String.Format method</span></span>  
 <span data-ttu-id="ba178-1616">Użyj <xref:System.String.Format%2A?displayProperty=nameWithType> , jeśli musisz wstawić wartość obiektu, zmiennej lub wyrażenia do innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1616">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="ba178-1617">Na przykład można wstawić wartość <xref:System.Decimal> do ciągu, aby wyświetlić go użytkownikowi jako pojedynczy ciąg:</span><span class="sxs-lookup"><span data-stu-id="ba178-1617">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 <span data-ttu-id="ba178-1618">Możesz kontrolować formatowanie tej wartości:</span><span class="sxs-lookup"><span data-stu-id="ba178-1618">And you can control that value's formatting:</span></span>  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 <span data-ttu-id="ba178-1619">Oprócz formatowania można również kontrolować wyrównanie i odstępy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1619">Besides formatting, you can also control alignment and spacing.</span></span>  
  
 ### <a name="inserting-a-string"></a><span data-ttu-id="ba178-1620">Wstawianie ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-1620">Inserting a string</span></span>  

 <span data-ttu-id="ba178-1621"><xref:System.String.Format%2A?displayProperty=nameWithType>rozpoczyna się od ciągu formatu, po którym następuje co najmniej jeden obiekt lub wyrażenie, które zostanie przekonwertowane na ciągi i wstawione w określonym miejscu w ciągu formatu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1621"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="ba178-1622">Przykład:</span><span class="sxs-lookup"><span data-stu-id="ba178-1622">For example:</span></span>  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 <span data-ttu-id="ba178-1623">`{0}` Ciąg formatu jest elementem formatu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1623">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="ba178-1624">`0`jest indeksem obiektu, którego wartość ciągu zostanie wstawiona w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1624">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="ba178-1625">(Indeksy zaczynają się od 0). Jeśli obiekt, który ma zostać wstawiony nie jest ciągiem, jego `ToString` Metoda jest wywoływana, aby przekonwertować ją na jeden przed wstawieniem go w ciągu wynikowym.</span><span class="sxs-lookup"><span data-stu-id="ba178-1625">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>  
  
 <span data-ttu-id="ba178-1626">Oto inny przykład, w którym są używane dwa elementy formatu i dwa obiekty na liście obiektów:</span><span class="sxs-lookup"><span data-stu-id="ba178-1626">Here's another example that uses two format items and two objects in the object list:</span></span>  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 <span data-ttu-id="ba178-1627">Możesz mieć dowolną liczbę elementów formatu i dowolną liczbę obiektów na liście obiektów, tak długo, jak indeks każdego elementu formatu ma pasujący obiekt na liście obiektów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1627">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="ba178-1628">Nie trzeba również martwić się o to, które Przeciążenie zostało wywołane; Kompilator wybierze odpowiedni dla siebie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1628">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>  
  
 ### <a name="controlling-formatting"></a><span data-ttu-id="ba178-1629">Kontrolowanie formatowania</span><span class="sxs-lookup"><span data-stu-id="ba178-1629">Controlling formatting</span></span>  
 <span data-ttu-id="ba178-1630">Możesz użyć indeksu w elemencie formatu z ciągiem formatu, aby kontrolować sposób formatowania obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1630">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="ba178-1631">Na przykład `{0:d}` stosuje ciąg formatu "d" do pierwszego obiektu na liście obiektów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1631">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="ba178-1632">Oto przykład z pojedynczym obiektem i dwoma elementami formatu:</span><span class="sxs-lookup"><span data-stu-id="ba178-1632">Here is an example with a single object and two format items:</span></span>  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 <span data-ttu-id="ba178-1633">Niektóre typy obsługują ciągi formatujące, w tym wszystkie typy liczbowe (ciągi formatu [standardowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowego](~/docs/standard/base-types/custom-numeric-format-strings.md) ), wszystkie daty i godziny (zarówno w formacie [standardowych](~/docs/standard/base-types/standard-date-and-time-format-strings.md) , jak i niestandardowym) i przedziały czasu (zarówno [standardowe](~/docs/standard/base-types/standard-timespan-format-strings.md) , jak i [](~/docs/standard/base-types/custom-date-and-time-format-strings.md) [niestandardowe](~/docs/standard/base-types/custom-timespan-format-strings.md) ciągi formatujące), wszystkie typy [](~/docs/standard/base-types/enumeration-format-strings.md)wyliczeniowe typów wyliczeniowych i [identyfikatory GUID](https://msdn.microsoft.com/library/97af8hh4.aspx).</span><span class="sxs-lookup"><span data-stu-id="ba178-1633">A number of types support format strings, including all numeric types (both [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span></span> <span data-ttu-id="ba178-1634">Możesz również dodać obsługę ciągów formatowania do własnych typów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1634">You can also add support for format strings to your own types.</span></span>  
  
 ### <a name="controlling-spacing"></a><span data-ttu-id="ba178-1635">Kontrolowanie odstępów</span><span class="sxs-lookup"><span data-stu-id="ba178-1635">Controlling spacing</span></span>  
 <span data-ttu-id="ba178-1636">Można zdefiniować szerokość ciągu, która jest wstawiana do ciągu wynikowego przy użyciu składni takiej jak `{0,12}`, która wstawia 12-znakowy ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-1636">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="ba178-1637">W takim przypadku ciąg reprezentujący pierwszy obiekt jest wyrównany do prawej w polu 12 znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-1637">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="ba178-1638">(Jeśli ciąg reprezentujący pierwszy obiekt ma więcej niż 12 znaków, chociaż Preferowana szerokość pola jest ignorowana, a cały ciąg zostanie wstawiony do ciągu wynikowego.)</span><span class="sxs-lookup"><span data-stu-id="ba178-1638">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>  
  
 <span data-ttu-id="ba178-1639">W poniższym przykładzie zdefiniowano 6-znakowe pole w celu przechowywania ciągu "Year" i niektórych ciągów rok, a także pola 15-znakowego do przechowywania ciągu "populacja" i niektórych danych populacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1639">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="ba178-1640">Należy zauważyć, że znaki w polu są wyrównane do prawej strony.</span><span class="sxs-lookup"><span data-stu-id="ba178-1640">Note that the characters are right-aligned in the field.</span></span>  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a><span data-ttu-id="ba178-1641">Kontrolowanie wyrównania</span><span class="sxs-lookup"><span data-stu-id="ba178-1641">Controlling alignment</span></span>  
 <span data-ttu-id="ba178-1642">Domyślnie ciągi są wyrównane do prawej w polach w przypadku określenia szerokości pola.</span><span class="sxs-lookup"><span data-stu-id="ba178-1642">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="ba178-1643">Aby wyrównać lewe ciągi w polu, należy poprzedzić szerokość pola znakiem minus, `{0,-12}` na przykład w celu zdefiniowania 12-znakowego pola wyrównanego do lewej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1643">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character left-aligned field.</span></span>  
  
 <span data-ttu-id="ba178-1644">Poniższy przykład jest podobny do poprzedniego, z tą różnicą, że wyrównuje zarówno etykiety, jak i dane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1644">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <span data-ttu-id="ba178-1645"><xref:System.String.Format%2A?displayProperty=nameWithType>używa funkcji formatowania złożonego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1645"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="ba178-1646">Aby uzyskać więcej informacji, zobacz [formatowanie złożone](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1646">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ba178-1647">Jaką metodę wywołać?</span><span class="sxs-lookup"><span data-stu-id="ba178-1647">Which method do I call?</span></span>  
  
|<span data-ttu-id="ba178-1648">Zadanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1648">To</span></span>|<span data-ttu-id="ba178-1649">Połączeń</span><span class="sxs-lookup"><span data-stu-id="ba178-1649">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="ba178-1650">Sformatuj jeden lub więcej obiektów przy użyciu Konwencji bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1650">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="ba178-1651">Z wyjątkiem przeciążeń zawierających `provider` parametr, pozostałe <xref:System.String.Format%2A> przeciążenia obejmują <xref:System.String> parametr, po którym następuje co najmniej jeden parametr obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1651">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="ba178-1652">W związku z tym nie trzeba określać <xref:System.String.Format%2A> przeciążenia, które mają być wywoływane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1652">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ba178-1653">Kompilator języka wybiera odpowiednie Przeciążenie z przeciążeń, które nie mają `provider` parametru, na podstawie listy argumentów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1653">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ba178-1654">Na przykład, jeśli lista argumentów ma pięć argumentów, kompilator wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1654">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ba178-1655">Sformatuj jeden lub więcej obiektów przy użyciu konwencji określonej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1655">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="ba178-1656">Każde <xref:System.String.Format%2A> Przeciążenie, które zaczyna `provider` się od <xref:System.String> parametru, następuje przez parametr i jeden lub więcej parametrów obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1656">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="ba178-1657">W związku z tym nie trzeba określać konkretnego <xref:System.String.Format%2A> przeciążenia, które ma być wywoływane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1657">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ba178-1658">Kompilator języka wybiera odpowiednie Przeciążenie z przeciążeń, które mają `provider` parametr oparty na liście argumentów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1658">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ba178-1659">Na przykład, jeśli lista argumentów ma pięć argumentów, kompilator wywołuje <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1659">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ba178-1660">Wykonywanie niestandardowej operacji formatowania z <xref:System.ICustomFormatter> implementacją <xref:System.IFormattable> lub implementacją.</span><span class="sxs-lookup"><span data-stu-id="ba178-1660">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="ba178-1661">Dowolne z czterech przeciążeń z `provider` parametrem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1661">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="ba178-1662">Kompilator wybiera odpowiednie Przeciążenie spośród przeciążeń, które mają `provider` parametr, na podstawie listy argumentów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1662">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a><span data-ttu-id="ba178-1663">Metoda formatowania w skrócie</span><span class="sxs-lookup"><span data-stu-id="ba178-1663">The Format method in brief</span></span> 

 <span data-ttu-id="ba178-1664">Każde Przeciążenie <xref:System.String.Format%2A> metody używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby uwzględniać indeksowane symbole zastępcze oparte na zero, nazywane *elementami formatu*, w ciągu formatu złożonego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1664">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="ba178-1665">W czasie wykonywania każdy element formatu jest zamieniany na ciąg reprezentujący odpowiadający argument na liście parametrów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1665">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="ba178-1666">Jeśli wartość argumentu to `null`, element formatu jest <xref:System.String.Empty?displayProperty=nameWithType>zastępowany.</span><span class="sxs-lookup"><span data-stu-id="ba178-1666">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-1667"><xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Na przykład następujące wywołanie metody zawiera ciąg formatu z trzema elementami formatu, {0}, {1}, i {2}i lista argumentów z trzema elementami.</span><span class="sxs-lookup"><span data-stu-id="ba178-1667">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a><span data-ttu-id="ba178-1668">Element formatu</span><span class="sxs-lookup"><span data-stu-id="ba178-1668">The format item</span></span>  
 <span data-ttu-id="ba178-1669">Element formatu ma następującą składnię:</span><span class="sxs-lookup"><span data-stu-id="ba178-1669">A format item has this syntax:</span></span>  
  
```  
{index[,alignment][:formatString]}  
```  
 
 <span data-ttu-id="ba178-1670">Nawiasy klamrowe oznaczają opcjonalne elementy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1670">Brackets denote optional elements.</span></span> <span data-ttu-id="ba178-1671">Otwierające i zamykające nawiasy klamrowe są wymagane.</span><span class="sxs-lookup"><span data-stu-id="ba178-1671">The opening and closing braces are required.</span></span> <span data-ttu-id="ba178-1672">(Aby dołączyć literał otwierającego lub zamykającego nawiasu klamrowego w ciągu formatu, [](~/docs/standard/base-types/composite-formatting.md#escaping-braces) Zobacz sekcję dotyczącą nawiasów klamrowych w artykule dotyczącym [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) ).</span><span class="sxs-lookup"><span data-stu-id="ba178-1672">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>  
  
 <span data-ttu-id="ba178-1673">Na przykład element formatu służący do formatowania wartości walutowej może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="ba178-1673">For example, a format item to format a currency value might appear like this:</span></span>  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 <span data-ttu-id="ba178-1674">Element formatu ma następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="ba178-1674">A format item has the following elements:</span></span>  
  
 <span data-ttu-id="ba178-1675">*index*</span><span class="sxs-lookup"><span data-stu-id="ba178-1675">*index*</span></span>  
 <span data-ttu-id="ba178-1676">Indeks (liczony od zera) argumentu, którego reprezentacja ciągu ma zostać uwzględniona w tym położeniu w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1676">The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="ba178-1677">Jeśli ten argument ma `null`wartość, pusty ciąg zostanie uwzględniony w tej pozycji w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1677">If this argument is `null`, an empty string will be included at this position in the string.</span></span>  
  
 <span data-ttu-id="ba178-1678">*struktury*</span><span class="sxs-lookup"><span data-stu-id="ba178-1678">*alignment*</span></span>  
 <span data-ttu-id="ba178-1679">Opcjonalna.</span><span class="sxs-lookup"><span data-stu-id="ba178-1679">Optional.</span></span> <span data-ttu-id="ba178-1680">Liczba całkowita ze znakiem, która wskazuje łączną długość pola, do którego wstawiono argument, i określa, czy jest wyrównany do prawej (dodatnia liczba całkowita) czy wyrównany do lewej (ujemna liczba całkowita).</span><span class="sxs-lookup"><span data-stu-id="ba178-1680">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="ba178-1681">W przypadku pominięcia *wyrównania*, reprezentacja odpowiadającego argumentu jest wstawiana w polu bez spacji wiodących i końcowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-1681">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>  
  
 <span data-ttu-id="ba178-1682">Jeśli wartość wyrównania \*\* jest mniejsza niż długość argumentu, który ma zostać wstawiony, *wyrównanie* jest ignorowane i długość ciągu reprezentującego argument jest używana jako szerokość pola.</span><span class="sxs-lookup"><span data-stu-id="ba178-1682">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>  
  
 <span data-ttu-id="ba178-1683">*Formatowanie*</span><span class="sxs-lookup"><span data-stu-id="ba178-1683">*formatString*</span></span>  
 <span data-ttu-id="ba178-1684">Opcjonalny.</span><span class="sxs-lookup"><span data-stu-id="ba178-1684">Optional.</span></span> <span data-ttu-id="ba178-1685">Ciąg określający format ciągu wynikowego odpowiadającego argumentu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1685">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="ba178-1686">W przypadku pominięcia elementu *FormatString*, odpowiednia `ToString` Metoda bezparametrowa argumentu jest wywoływana w celu utworzenia jego reprezentacji w postaci ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1686">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="ba178-1687">W przypadku określenia elementu *FormatString*argument, do którego odwołuje się element formatu, <xref:System.IFormattable> musi implementować interfejs.</span><span class="sxs-lookup"><span data-stu-id="ba178-1687">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="ba178-1688">Typy obsługujące ciągi formatu obejmują:</span><span class="sxs-lookup"><span data-stu-id="ba178-1688">Types that support format strings include:</span></span>  
  
-   <span data-ttu-id="ba178-1689">Wszystkie typy całkowite i zmiennoprzecinkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1689">All integral and floating-point types.</span></span> <span data-ttu-id="ba178-1690">(Zobacz [Standardowe ciągi formatujące liczb](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md)).</span><span class="sxs-lookup"><span data-stu-id="ba178-1690">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ba178-1691"><xref:System.DateTime>i <xref:System.DateTimeOffset>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1691"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="ba178-1692">(Zobacz [ciągi standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md)).</span><span class="sxs-lookup"><span data-stu-id="ba178-1692">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ba178-1693">Wszystkie typy wyliczeniowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1693">All enumeration types.</span></span> <span data-ttu-id="ba178-1694">(Zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md)).</span><span class="sxs-lookup"><span data-stu-id="ba178-1694">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ba178-1695"><xref:System.TimeSpan>wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-1695"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="ba178-1696">(Zobacz [Standardowe ciągi formatujące w formacie TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) oraz [Niestandardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md)).</span><span class="sxs-lookup"><span data-stu-id="ba178-1696">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ba178-1697">GUIDs.</span><span class="sxs-lookup"><span data-stu-id="ba178-1697">GUIDs.</span></span> <span data-ttu-id="ba178-1698">(Zobacz <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> metodę).</span><span class="sxs-lookup"><span data-stu-id="ba178-1698">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>  
  
 <span data-ttu-id="ba178-1699">Należy jednak pamiętać, że dowolny typ niestandardowy może <xref:System.IFormattable> zaimplementować lub zwiększyć <xref:System.IFormattable> implementację istniejącego typu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1699">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>  
  
 <span data-ttu-id="ba178-1700">W poniższym przykładzie za pomocą `alignment` argumentów `formatString` i są generowane sformatowane dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-1700">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="ba178-1701">Sposób formatowania argumentów</span><span class="sxs-lookup"><span data-stu-id="ba178-1701">How arguments are formatted</span></span>  
 <span data-ttu-id="ba178-1702">Elementy formatu są przetwarzane sekwencyjnie od początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1702">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="ba178-1703">Każdy element formatu ma indeks, który odnosi się do obiektu na liście argumentów metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1703">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="ba178-1704"><xref:System.String.Format%2A> Metoda pobiera argument i dziedziczy jego reprezentację w postaci ciągu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-1704">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>  
  
-   <span data-ttu-id="ba178-1705">Jeśli argument ma `null`wartość, Metoda wstawia <xref:System.String.Empty?displayProperty=nameWithType> do ciągu wynikowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1705">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="ba178-1706">Nie trzeba mieć <xref:System.NullReferenceException> potrzeby obsługi dla argumentów o wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-1706">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span> 
  
-   <span data-ttu-id="ba178-1707">Jeśli <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> wywołasz Przeciążenie, <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> `provider` a implementacja obiektu zwróci implementację o wartości innej niż <xref:System.ICustomFormatter> null, argument jest przenoszona do jego <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1707">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-1708">Jeśli element formatu zawiera argument *FormatString* , jest przenoszona jako pierwszy argument do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1708">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="ba178-1709"><xref:System.ICustomFormatter> Jeśli implementacja jest dostępna i tworzy ciąg o wartości innej niż null, ten ciąg jest zwracany jako ciąg reprezentujący argument; w przeciwnym razie wykonywany jest następny krok.</span><span class="sxs-lookup"><span data-stu-id="ba178-1709">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>  
  
-   <span data-ttu-id="ba178-1710">Jeśli argument implementuje <xref:System.IFormattable> interfejs, jego <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementacja jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="ba178-1710">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>  
  
-   <span data-ttu-id="ba178-1711">`ToString` Metoda bez parametrów argumentu, która zastępuje lub dziedziczy z implementacji klasy podstawowej, jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="ba178-1711">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>  
  
 <span data-ttu-id="ba178-1712">Przykład, który przechwytuje wywołania <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> metody i pozwala zobaczyć, <xref:System.String.Format%2A> jakie informacje Metoda przekazuje do metody formatowania dla każdego elementu formatu w ciągu formatu złożonego, zobacz [przykład: Dostawca przechwycenia i program formatujący](#Format7_Example)cyfry rzymskie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1712">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  

 <span data-ttu-id="ba178-1713">Aby uzyskać więcej informacji, zobacz sekcję [kolejność przetwarzania](~/docs/standard/base-types/composite-formatting.md##processing-order) w artykule dotyczącym [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .</span><span class="sxs-lookup"><span data-stu-id="ba178-1713">For more information, see the [Processing Order](~/docs/standard/base-types/composite-formatting.md##processing-order) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.</span></span>  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="ba178-1714">Elementy formatu o tym samym indeksie</span><span class="sxs-lookup"><span data-stu-id="ba178-1714">Format items that have the same index</span></span>  
 <span data-ttu-id="ba178-1715"><xref:System.String.Format%2A> Metoda<xref:System.FormatException> zgłasza wyjątek, jeśli indeks elementu indeksu jest większy lub równy liczbie argumentów na liście argumentów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1715">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="ba178-1716">`format` Jednak może zawierać więcej elementów formatu niż istnieją argumenty, o ile wiele elementów formatu ma ten sam indeks.</span><span class="sxs-lookup"><span data-stu-id="ba178-1716">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="ba178-1717">W wywołaniu <xref:System.String.Format%28System.String%2CSystem.Object%29> metody w poniższym przykładzie lista argumentów ma jeden argument, ale ciąg formatu zawiera dwa elementy formatu: jeden wyświetla wartość dziesiętną liczby, a druga wyświetla wartość szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="ba178-1717">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a><span data-ttu-id="ba178-1718">Formatowanie i kultura</span><span class="sxs-lookup"><span data-stu-id="ba178-1718">Formatting and culture</span></span>  
 <span data-ttu-id="ba178-1719">Ogólnie rzecz biorąc, obiekty na liście argumentów są konwertowane na ich reprezentacje ciągów przy użyciu Konwencji bieżącej kultury, które są zwracane przez <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="ba178-1719">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ba178-1720">Możesz kontrolować to zachowanie, wywołując jedno z przeciążeń <xref:System.String.Format%2A> , które `provider` zawierają parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-1720">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="ba178-1721">`provider` Parametr<xref:System.IFormatProvider> jest implementacją, która dostarcza niestandardowe i specyficzne dla kultury informacje o formatowaniu, które są używane do umiarkowanego procesu formatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1721">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>  
  
 <span data-ttu-id="ba178-1722">Interfejs ma pojedynczy <xref:System.IFormatProvider.GetFormat%2A>element członkowski, który jest odpowiedzialny za zwracanie obiektu, który zawiera informacje o formatowaniu. <xref:System.IFormatProvider></span><span class="sxs-lookup"><span data-stu-id="ba178-1722">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="ba178-1723">Platforma .net ma <xref:System.IFormatProvider> trzy implementacje, które zapewniają formatowanie specyficzne dla kultury:</span><span class="sxs-lookup"><span data-stu-id="ba178-1723">.NET has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>  
  
-   <span data-ttu-id="ba178-1724"><xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1724"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="ba178-1725">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda zwraca obiekt specyficzny <xref:System.Globalization.NumberFormatInfo> dla kultury służący do formatowania wartości liczbowych i obiekt <xref:System.Globalization.DateTimeFormatInfo> specyficzny dla kultury służący do formatowania wartości daty i godziny.</span><span class="sxs-lookup"><span data-stu-id="ba178-1725">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>  
  
-   <span data-ttu-id="ba178-1726"><xref:System.Globalization.DateTimeFormatInfo>, który jest używany do formatowania wartości daty i godziny specyficznej dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1726"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="ba178-1727">Jego <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> Metoda zwraca sam siebie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1727">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>  
  
-   <span data-ttu-id="ba178-1728"><xref:System.Globalization.NumberFormatInfo>, który jest używany do formatowania wartości liczbowych specyficznych dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1728"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="ba178-1729">Jego <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Właściwość zwraca samą siebie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1729">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span> 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a><span data-ttu-id="ba178-1730">Niestandardowe formatowanie operacji</span><span class="sxs-lookup"><span data-stu-id="ba178-1730">Custom formatting operations</span></span>  
 <span data-ttu-id="ba178-1731">Można również wywołać dowolne przeciążenia <xref:System.String.Format%2A> metody, która `provider` ma parametr typu <xref:System.IFormatProvider> do wykonywania niestandardowych operacji formatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1731">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="ba178-1732">Na przykład można sformatować liczbę całkowitą jako numer identyfikacyjny lub numer telefonu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1732">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="ba178-1733">Aby można było zastosować niestandardowe formatowanie `provider` , argument musi implementować <xref:System.IFormatProvider> zarówno <xref:System.ICustomFormatter> interfejs, jak i.</span><span class="sxs-lookup"><span data-stu-id="ba178-1733">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="ba178-1734"><xref:System.String.Format%2A> `provider` <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Gdy metoda jest przenoszona do <xref:System.ICustomFormatter> implementacji jako argument, metoda wywołuje jego implementację i żąda obiektu typu <xref:System.ICustomFormatter>. <xref:System.String.Format%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-1734">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ba178-1735">Następnie wywołuje <xref:System.ICustomFormatter.Format%2A> metodę zwracanego <xref:System.ICustomFormatter> obiektu, aby sformatować każdy element formatu w złożonym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1735">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>  
  
 <span data-ttu-id="ba178-1736">Aby uzyskać więcej informacji na temat udostępniania niestandardowych rozwiązań formatowania [, zobacz How to: Definiowanie i używanie niestandardowych dostawców](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) formatu liczbowego i. <xref:System.ICustomFormatter></span><span class="sxs-lookup"><span data-stu-id="ba178-1736">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ba178-1737">Aby zapoznać się z przykładem, który konwertuje liczby całkowite na sformatowane [wartości niestandardowe, zobacz przykład: Niestandardowa operacja](#Format6_Example)formatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1737">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="ba178-1738">Przykład, który konwertuje bajty bez znaku na cyfry rzymskie, [Zobacz przykład: Dostawca przechwycenia i program formatujący](#Format7_Example)cyfry rzymskie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1738">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="ba178-1739">Przykład: Niestandardowa Operacja formatowania</span><span class="sxs-lookup"><span data-stu-id="ba178-1739">Example: A custom formatting operation</span></span>  
 <span data-ttu-id="ba178-1740">W tym przykładzie zdefiniowano dostawcę formatu, który formatuje wartość całkowitą jako numer konta klienta w postaci x-XXXXX-XX.</span><span class="sxs-lookup"><span data-stu-id="ba178-1740">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="ba178-1741">Przykład: Dostawca przechwycenia i program formatujący cyfry rzymskie</span><span class="sxs-lookup"><span data-stu-id="ba178-1741">Example: An intercept provider and Roman numeral formatter</span></span>  
 <span data-ttu-id="ba178-1742">W tym przykładzie zdefiniowano niestandardowego dostawcę formatu, który <xref:System.ICustomFormatter> implementuje <xref:System.IFormatProvider> interfejsy i, aby wykonać dwie czynności:</span><span class="sxs-lookup"><span data-stu-id="ba178-1742">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>  
  
-   <span data-ttu-id="ba178-1743">Wyświetla parametry przesłane do <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> wdrożenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-1743">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="ba178-1744">Dzięki temu możemy zobaczyć, jakie parametry <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Metoda jest przekazywana do implementacji formatowania niestandardowego dla każdego obiektu, który próbuje sformatować.</span><span class="sxs-lookup"><span data-stu-id="ba178-1744">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="ba178-1745">Może to być przydatne w przypadku debugowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1745">This can be useful when you're debugging your application.</span></span>  
  
-   <span data-ttu-id="ba178-1746">Jeśli obiekt, który ma być sformatowany jest wartością bajtu bez znaku, która ma zostać sformatowana przy użyciu standardowego ciągu formatu "R", niestandardowy program formatujący formatuje wartość liczbową jako cyfrę rzymską.</span><span class="sxs-lookup"><span data-stu-id="ba178-1746">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a><span data-ttu-id="ba178-1747">Ciąg. format Q & A</span><span class="sxs-lookup"><span data-stu-id="ba178-1747">String.Format Q & A</span></span>  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="ba178-1748">Dlaczego zalecane jest Interpolacja ciągów dla `String.Format` wywołań metody?</span><span class="sxs-lookup"><span data-stu-id="ba178-1748">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="ba178-1749">Interpolacja ciągów:</span><span class="sxs-lookup"><span data-stu-id="ba178-1749">String interpolation is:</span></span>

- <span data-ttu-id="ba178-1750">Bardziej elastyczne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1750">More flexible.</span></span> <span data-ttu-id="ba178-1751">Może być używana w dowolnym ciągu bez konieczności wywołania metody, która obsługuje formatowanie złożone.</span><span class="sxs-lookup"><span data-stu-id="ba178-1751">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="ba178-1752">W przeciwnym razie należy wywołać <xref:System.String.Format%2A> metodę lub inną metodę, która obsługuje formatowanie złożone, takie jak <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1752">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span> 

- <span data-ttu-id="ba178-1753">Bardziej czytelne.</span><span class="sxs-lookup"><span data-stu-id="ba178-1753">More readable.</span></span> <span data-ttu-id="ba178-1754">Ponieważ wyrażenie, które ma zostać wstawione do ciągu, pojawia się w wyrażeniu interpolowanym, a nie na liście argumentów, interpolowane ciągi są znacznie łatwiejsze do kodu i odczytywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1754">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="ba178-1755">Ze względu na większą czytelność, interpolowane ciągi mogą zastąpić nie tylko wywołania metod formatu złożonego, ale mogą być również używane w operacjach łączenia ciągów, aby generować bardziej zwięzły, wyraźniejszy kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-1755">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span> 

<span data-ttu-id="ba178-1756">Porównanie następujących dwóch przykładów kodu ilustruje najwyższą liczbę interpolowanych ciągów na łączenie ciągów i wywołania metod formatowania złożonego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1756">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="ba178-1757">Użycie wielu operacji łączenia ciągów w poniższym przykładzie daje pełny i trudny do odczytu kod.</span><span class="sxs-lookup"><span data-stu-id="ba178-1757">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

<span data-ttu-id="ba178-1758">Natomiast użycie ciągów interpolowanych w poniższym przykładzie daje dużo wyraźniejszy, bardziej zwięzły kod niż instrukcja łączenia ciągów i wywołanie <xref:System.String.Format%2A> metody w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1758">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="ba178-1759">Gdzie mogę znaleźć listę wstępnie zdefiniowanych ciągów formatu, które mogą być używane z elementami formatowania?</span><span class="sxs-lookup"><span data-stu-id="ba178-1759">Where can I find a list of the predefined format strings that can be used with format items?</span></span>  
  
-   <span data-ttu-id="ba178-1760">Dla wszystkich typów całkowitych i zmiennoprzecinkowych zobacz [Standardowe ciągi formatujące numeryczne](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1760">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ba178-1761">W przypadku wartości daty i godziny zobacz [ciągi standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1761">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ba178-1762">Aby uzyskać wartości wyliczenia, zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1762">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ba178-1763">Aby <xref:System.TimeSpan> uzyskać wartości, zobacz [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) i [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1763">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ba178-1764">Aby <xref:System.Guid> uzyskać wartości, zobacz sekcję <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> uwagi na stronie referencyjnej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1764">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="ba178-1765">Jak mogę kontrolować wyrównanie ciągów wynikowych, które zastępują elementy formatu?</span><span class="sxs-lookup"><span data-stu-id="ba178-1765">How do I control the alignment of the result strings that replace format items?</span></span>  
 <span data-ttu-id="ba178-1766">Ogólna składnia elementu format jest następująca:</span><span class="sxs-lookup"><span data-stu-id="ba178-1766">The general syntax of a format item is:</span></span>  
  
```  
{index[,alignment][: formatString]}  
```  
  
 <span data-ttu-id="ba178-1767">gdzie *wyrównania* jest ze znakiem liczby całkowitej, która definiuje szerokość pola.</span><span class="sxs-lookup"><span data-stu-id="ba178-1767">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="ba178-1768">Jeśli ta wartość jest ujemna, tekst w polu jest wyrównany do lewej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1768">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="ba178-1769">Jeśli jest dodatnia, tekst jest wyrównany do prawej.</span><span class="sxs-lookup"><span data-stu-id="ba178-1769">If it is positive, text is right-aligned.</span></span>  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="ba178-1770">Jak mogę kontrolować liczbę cyfr po separatorze dziesiętnym?</span><span class="sxs-lookup"><span data-stu-id="ba178-1770">How do I control the number of digits after the decimal separator?</span></span>  
 <span data-ttu-id="ba178-1771">Wszystkie [ciągi standardowego formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) z wyjątkiem "D" (które są używane tylko z liczbami całkowitymi), "G", "R" i "X" zezwalają na specyfikator dokładności, który definiuje liczbę cyfr dziesiętnych w ciągu wynikowym.</span><span class="sxs-lookup"><span data-stu-id="ba178-1771">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="ba178-1772">W poniższym przykładzie użyto standardowych ciągów formatu liczbowego do kontrolowania liczby cyfr dziesiętnych w ciągu wynikowym.</span><span class="sxs-lookup"><span data-stu-id="ba178-1772">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 <span data-ttu-id="ba178-1773">Jeśli używasz [niestandardowego ciągu formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md), użyj specyfikatora formatu "0", aby kontrolować liczbę cyfr dziesiętnych w ciągu wynikowym, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1773">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="ba178-1774">Jak mogę kontrolować liczbę cyfr całkowitych?</span><span class="sxs-lookup"><span data-stu-id="ba178-1774">How do I control the number of integral digits?</span></span>  
 <span data-ttu-id="ba178-1775">Domyślnie operacje formatowania wyświetlają tylko niezerowe cyfry całkowite.</span><span class="sxs-lookup"><span data-stu-id="ba178-1775">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="ba178-1776">Jeśli są formatowane liczby całkowite, można użyć specyfikatora dokładności z ciągami formatu standardowego "D" i "X", aby kontrolować liczbę cyfr.</span><span class="sxs-lookup"><span data-stu-id="ba178-1776">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 <span data-ttu-id="ba178-1777">Można uzupełnić liczbę całkowitą lub liczbową zmiennoprzecinkową zerami wiodącymi, aby utworzyć ciąg wynikowy z określoną liczbą cyfr całkowitych przy użyciu [niestandardowego specyfikatora formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md)"0", jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1777">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="ba178-1778">Ile elementów można uwzględnić na liście Format?</span><span class="sxs-lookup"><span data-stu-id="ba178-1778">How many items can I include in the format list?</span></span>  
 <span data-ttu-id="ba178-1779">Nie ma praktycznego limitu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1779">There is no practical limit.</span></span> <span data-ttu-id="ba178-1780">Drugi parametr <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody jest oznakowany <xref:System.ParamArrayAttribute> atrybutem, który umożliwia dołączenie listy rozdzielanej lub tablicy obiektów jako listy formatów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1780">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="ba178-1781">Jak mogę uwzględnić literały klamrowe ("{" i "}") w ciągu wynikowym?</span><span class="sxs-lookup"><span data-stu-id="ba178-1781">How do I include literal braces ("{" and "}") in the result string?</span></span>  
 <span data-ttu-id="ba178-1782">Na przykład jak zapobiec zgłaszaniu <xref:System.FormatException> wyjątku przez następujące wywołanie metody?</span><span class="sxs-lookup"><span data-stu-id="ba178-1782">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 <span data-ttu-id="ba178-1783">Pojedynczy nawias otwierający lub zamykający jest zawsze interpretowany jako początek lub koniec elementu formatu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1783">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="ba178-1784">Aby można było interpretować dosłownie, musi to być znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="ba178-1784">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="ba178-1785">Nawias klamrowy zostanie dodany przez dodanie kolejnego nawiasu klamrowego ("{{" i "}}" zamiast "{" i "}"), jak w poniższym wywołaniu metody:</span><span class="sxs-lookup"><span data-stu-id="ba178-1785">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 <span data-ttu-id="ba178-1786">Jednak nawet nawiasy klamrowe są łatwo interpretowane nieprawidłowo.</span><span class="sxs-lookup"><span data-stu-id="ba178-1786">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="ba178-1787">Zalecamy dołączenie nawiasów klamrowych na liście Format i użycie elementów formatu do wstawienia ich w ciągu wynikowym, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1787">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="ba178-1788">Dlaczego moje wywołanie metody String. Format powoduje zgłoszenie FormatException?</span><span class="sxs-lookup"><span data-stu-id="ba178-1788">Why does my call to the String.Format method throw a FormatException?</span></span>  
 <span data-ttu-id="ba178-1789">Najczęstszym powodem wyjątku jest to, że indeks elementu formatu nie odpowiada obiektowi na liście Format.</span><span class="sxs-lookup"><span data-stu-id="ba178-1789">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="ba178-1790">Zazwyczaj oznacza to, że liczba indeksów elementów formatowania jest niepograna lub zapomniano dołączyć obiekt z listy format.</span><span class="sxs-lookup"><span data-stu-id="ba178-1790">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="ba178-1791">Próba dołączenia znaku w nawiasie klamrowym w lewo lub w <xref:System.FormatException>prawo powoduje również wyrzucanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-1791">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ba178-1792">Czasami wyjątek jest wynikiem literówki; na przykład typowym błędem jest błąd "[" (lewy nawias) zamiast "{" (lewy nawias klamrowy).</span><span class="sxs-lookup"><span data-stu-id="ba178-1792">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="ba178-1793">Jeśli format (System. IFormatProvider, system. String, system. Object []) obsługuje tablice parametrów, dlaczego mój kod zgłasza wyjątek, gdy używam tablicy?</span><span class="sxs-lookup"><span data-stu-id="ba178-1793">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>  
 <span data-ttu-id="ba178-1794">Na przykład poniższy kod zgłasza <xref:System.FormatException> wyjątek:</span><span class="sxs-lookup"><span data-stu-id="ba178-1794">For example, the following code throws a <xref:System.FormatException> exception:</span></span>  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 <span data-ttu-id="ba178-1795">Jest to problem z rozwiązaniem przeciążenia kompilatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-1795">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="ba178-1796">Ponieważ kompilator nie może przekonwertować tablicy liczb całkowitych na tablicę obiektów, traktuje tablicę liczb całkowitych jako pojedynczy argument, więc wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1796">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="ba178-1797">Wyjątek jest zgłaszany, ponieważ istnieją cztery elementy formatujące, ale tylko jeden element na liście Format.</span><span class="sxs-lookup"><span data-stu-id="ba178-1797">The exception is thrown because there are four format items but only a single item in the format list.</span></span>  
  
 <span data-ttu-id="ba178-1798">Ponieważ ani nie Visual Basic C# ani nie można skonwertować tablicy typu Integer na tablicę obiektów, należy wykonać konwersję samodzielnie przed wywołaniem <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1798">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="ba178-1799">Poniższy przykład zawiera jedną implementację.</span><span class="sxs-lookup"><span data-stu-id="ba178-1799">The following example provides one implementation.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<span data-ttu-id="ba178-1800">Liczne przykłady, które wywołują <xref:System.String.Format%2A> metodę, są przeplatane w sekcji [uwagi](#remarks-top) tego artykułu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1800">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks-top) section of this article.</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

<span data-ttu-id="ba178-1801">Możesz również pobrać `String.Format` kompletny zestaw przykładów, które są dołączone do [projektu .NET Core 2,0 dla C# ](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) i [projektu .NET Core 2,0 dla Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), z repozytorium w witrynie [GitHub/Samples](https://github.com/dotnet/samples).</span><span class="sxs-lookup"><span data-stu-id="ba178-1801">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/samples GitHub repository](https://github.com/dotnet/samples).</span></span>

<span data-ttu-id="ba178-1802">Poniżej przedstawiono niektóre przykłady zawarte w artykule:</span><span class="sxs-lookup"><span data-stu-id="ba178-1802">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="ba178-1803">Utwórz ciąg formatu</span><span class="sxs-lookup"><span data-stu-id="ba178-1803">Create a format string</span></span>

[<span data-ttu-id="ba178-1804">Wstawianie ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-1804">Inserting a string</span></span>](#inserting-a-string)  
[<span data-ttu-id="ba178-1805">Element formatu</span><span class="sxs-lookup"><span data-stu-id="ba178-1805">The format item</span></span>](#the-format-item)  
[<span data-ttu-id="ba178-1806">Sformatuj elementy, które mają ten sam indeks</span><span class="sxs-lookup"><span data-stu-id="ba178-1806">Format items that have the same index</span></span>](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a><span data-ttu-id="ba178-1807">Kontrolowanie danych wyjściowych w formacie</span><span class="sxs-lookup"><span data-stu-id="ba178-1807">Control formatted output</span></span>

[<span data-ttu-id="ba178-1808">Kontrolowanie formatowania</span><span class="sxs-lookup"><span data-stu-id="ba178-1808">Controlling formatting</span></span>](#controlling-formatting)  
[<span data-ttu-id="ba178-1809">Kontrolowanie odstępów</span><span class="sxs-lookup"><span data-stu-id="ba178-1809">Controlling spacing</span></span>](#controlling-spacing)  
[<span data-ttu-id="ba178-1810">Kontrolowanie wyrównania</span><span class="sxs-lookup"><span data-stu-id="ba178-1810">Controlling alignment</span></span>](#controlling-alignment)  
[<span data-ttu-id="ba178-1811">Kontrolowanie liczby cyfr całkowitych</span><span class="sxs-lookup"><span data-stu-id="ba178-1811">Controlling the number of integral digits</span></span>](#how-do-i-control-the-number-of-integral-digits)  
[<span data-ttu-id="ba178-1812">Kontrolowanie liczby cyfr po separatorze dziesiętnym</span><span class="sxs-lookup"><span data-stu-id="ba178-1812">Controlling the number of digits after the decimal separator</span></span>](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[<span data-ttu-id="ba178-1813">Uwzględnianie nawiasów klamrowych w ciągu wynikowym</span><span class="sxs-lookup"><span data-stu-id="ba178-1813">Including literal braces in a result string</span></span>](#braces)  

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="ba178-1814">Wprowadź w formacie ciągi kulturowe</span><span class="sxs-lookup"><span data-stu-id="ba178-1814">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="ba178-1815">Formatowanie z uwzględnieniem kultur</span><span class="sxs-lookup"><span data-stu-id="ba178-1815">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="ba178-1816">Dostosowywanie operacji formatowania</span><span class="sxs-lookup"><span data-stu-id="ba178-1816">Customize the formatting operation</span></span>

[<span data-ttu-id="ba178-1817">Niestandardowa Operacja formatowania</span><span class="sxs-lookup"><span data-stu-id="ba178-1817">A custom formatting operation</span></span>](#example-a-custom-formatting-operation)  
[<span data-ttu-id="ba178-1818">Dostawca przechwycenia i program formatujący cyfry rzymskie</span><span class="sxs-lookup"><span data-stu-id="ba178-1818">An intercept provider and Roman numeral formatter</span></span>](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1819">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1819">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1820">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1820">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ba178-1821">Standardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1821">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ba178-1822">Niestandardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1822">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ba178-1823">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1823">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ba178-1824">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1824">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ba178-1825">Standardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1825">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ba178-1826">Niestandardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1826">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ba178-1827">Wyliczanie ciągów formatujących</span><span class="sxs-lookup"><span data-stu-id="ba178-1827">Enumeration Format Strings</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ba178-1828">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1828">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1829">Obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1829">The object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1830">Zamienia jeden lub więcej elementów formatu ciągu na ciąg reprezentujący określony obiekt.</span><span class="sxs-lookup"><span data-stu-id="ba178-1830">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ba178-1831">Kopia <paramref name="format" /> , w której każdy element formatu jest zamieniany na ciąg <paramref name="arg0" />reprezentujący.</span><span class="sxs-lookup"><span data-stu-id="ba178-1831">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1832">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość wyrażenia na jego reprezentację ciągu i osadzić tę reprezentację w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1832">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="ba178-1833">Przykład: Formatowanie pojedynczego argumentu</span><span class="sxs-lookup"><span data-stu-id="ba178-1833">Example: Formatting a single argument</span></span>  
 
 <span data-ttu-id="ba178-1834">Poniższy przykład używa <xref:System.String.Format%28System.String%2CSystem.Object%29> metody do osadzenia wieku osoby w środku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1834">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1835"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1835"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1836">Element formatu w <paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1836">The format item in <paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1837">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1837">-or-</span></span> 
<span data-ttu-id="ba178-1838">Indeks elementu formatu nie jest równy zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1838">The index of a format item is not zero.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1839">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1839">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1840">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1840">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ba178-1841">Standardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1841">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ba178-1842">Niestandardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1842">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ba178-1843">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1843">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ba178-1844">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1844">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ba178-1845">Standardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1845">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ba178-1846">Niestandardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1846">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ba178-1847">Wyliczanie ciągów formatujących</span><span class="sxs-lookup"><span data-stu-id="ba178-1847">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ba178-1848">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1848">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ba178-1849">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1849">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1850">Zamienia element formatu w określonym ciągu na ciąg reprezentujący odpowiadający obiekt w określonej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1850">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="ba178-1851">Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg reprezentujący odpowiednie obiekty w <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1851">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1852">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość czterech lub więcej wyrażeń na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1852">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ba178-1853">Ponieważ parametr jest oznaczony <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atrybutem, można przekazać obiekty do metody jako <xref:System.Object> pojedyncze argumenty lub jako tablicę. `args`</span><span class="sxs-lookup"><span data-stu-id="ba178-1853">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a><span data-ttu-id="ba178-1854">Przykład: Formatowanie więcej niż trzech argumentów</span><span class="sxs-lookup"><span data-stu-id="ba178-1854">Example: Formatting more than three arguments</span></span>  
 
 <span data-ttu-id="ba178-1855">Ten przykład tworzy ciąg, który zawiera dane z wysoką i niską temperaturą w określonym dniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1855">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="ba178-1856">Ciąg formatu złożonego ma pięć elementów formatu w C# przykładzie i sześć w przykładzie Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ba178-1856">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="ba178-1857">Dwa elementy formatu definiują szerokość odpowiadającego ciągu wartości, a pierwszy element formatu zawiera również ciąg standardowego formatu daty i godziny.</span><span class="sxs-lookup"><span data-stu-id="ba178-1857">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 <span data-ttu-id="ba178-1858">Można również przekazać obiekty do formatowania jako tablicę, a nie jako listę argumentów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1858">You can also pass the objects to be formatted as an array rather than as an argument list.</span></span>  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1859"><paramref name="format" />lub <paramref name="args" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1859"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1860"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1860"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1861">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1861">-or-</span></span> 
<span data-ttu-id="ba178-1862">Indeks elementu formatu jest mniejszy od zera lub jest większy lub równy długości <paramref name="args" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1862">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1863">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1863">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1864">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1864">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ba178-1865">Standardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1865">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ba178-1866">Niestandardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1866">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ba178-1867">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1867">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ba178-1868">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1868">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ba178-1869">Standardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1869">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ba178-1870">Niestandardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1870">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ba178-1871">Wyliczanie ciągów formatujących</span><span class="sxs-lookup"><span data-stu-id="ba178-1871">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-1872">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1872">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ba178-1873">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1873">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1874">Obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1874">The object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1875">Zamienia element formatu lub elementy w określonym ciągu na ciąg reprezentujący odpowiadający obiekt.</span><span class="sxs-lookup"><span data-stu-id="ba178-1875">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="ba178-1876">Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1876">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ba178-1877">Kopia <paramref name="format" /> , w której element formatu lub elementy zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący.</span><span class="sxs-lookup"><span data-stu-id="ba178-1877">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1878">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować wartość wyrażenia na jego reprezentację ciągu i osadzić tę reprezentację w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1878">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="ba178-1879">W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1879">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ba178-1880">Metoda jest konwertowana `arg0` na reprezentację ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** Method.</span><span class="sxs-lookup"><span data-stu-id="ba178-1880">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ba178-1881">Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1881">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1882"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1882"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1883"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1883"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1884">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1884">-or-</span></span> 
<span data-ttu-id="ba178-1885">Indeks elementu formatu nie jest równy zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-1885">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-1886">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1886">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ba178-1887">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1887">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ba178-1888">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1888">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1889">Zamienia elementy formatu w ciągu na ciąg reprezentujący odpowiadające obiekty w określonej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1889">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="ba178-1890">Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1890">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ba178-1891">Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg reprezentujący odpowiednie obiekty w <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1891">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1892">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby skonwertować cztery lub więcej wyrażeń do ich reprezentacji ciągów i osadzić te reprezentacje w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1892">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ba178-1893">W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1893">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ba178-1894">Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** .</span><span class="sxs-lookup"><span data-stu-id="ba178-1894">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ba178-1895">Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1895">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="ba178-1896">Przykład: Formatowanie z uwzględnieniem kultur</span><span class="sxs-lookup"><span data-stu-id="ba178-1896">Example: Culture-sensitive formatting</span></span>

 <span data-ttu-id="ba178-1897">W tym przykładzie użyto <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody, aby wyświetlić reprezentację ciągu niektórych wartości daty i godziny oraz wartości liczbowych przy użyciu kilku różnych kultur.</span><span class="sxs-lookup"><span data-stu-id="ba178-1897">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1898"><paramref name="format" />lub <paramref name="args" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1898"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1899"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1899"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1900">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1900">-or-</span></span> 
<span data-ttu-id="ba178-1901">Indeks elementu formatu jest mniejszy od zera lub jest większy lub równy długości <paramref name="args" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1901">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1902">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1902">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1903">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1903">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ba178-1904">Standardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1904">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ba178-1905">Niestandardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1905">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ba178-1906">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1906">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ba178-1907">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1907">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ba178-1908">Standardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1908">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ba178-1909">Niestandardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1909">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ba178-1910">Wyliczanie ciągów formatujących</span><span class="sxs-lookup"><span data-stu-id="ba178-1910">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ba178-1911">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1911">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1912">Pierwszy obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1912">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1913">Drugi obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1913">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1914">Zamienia elementy formatu ciągu na ciąg reprezentujący dwa określone obiekty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1914">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ba178-1915">Kopia <paramref name="format" /> , w której elementy formatu są zamieniane na ciąg <paramref name="arg0" /> reprezentujący i <paramref name="arg1" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1915">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1916">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) do konwersji wartości dwóch wyrażeń na ich reprezentacje ciągów i osadzania tych reprezentacji w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1916">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a><span data-ttu-id="ba178-1917">Przykład: Formatowanie dwóch argumentów</span><span class="sxs-lookup"><span data-stu-id="ba178-1917">Example: Formatting two arguments</span></span>  
 
 <span data-ttu-id="ba178-1918">Ten przykład używa <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metody do wyświetlania danych czasowych i temperatury przechowywanych w obiekcie ogólnym <xref:System.Collections.Generic.Dictionary%602> .</span><span class="sxs-lookup"><span data-stu-id="ba178-1918">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="ba178-1919">Należy zauważyć, że ciąg formatu ma trzy elementy formatu, chociaż istnieją tylko dwa obiekty do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1919">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="ba178-1920">Wynika to z faktu, że pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy formatu: Pierwszy element formatu wyświetla godzinę, a druga wyświetla datę.</span><span class="sxs-lookup"><span data-stu-id="ba178-1920">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1921"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1921"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1922"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1922"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1923">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1923">-or-</span></span> 
<span data-ttu-id="ba178-1924">Indeks elementu formatu nie jest równy zero lub jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1924">The index of a format item is not zero or one.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1925">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1925">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1926">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1926">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ba178-1927">Standardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1927">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ba178-1928">Niestandardowe ciągi formatujące datę i godzinę</span><span class="sxs-lookup"><span data-stu-id="ba178-1928">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ba178-1929">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1929">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ba178-1930">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="ba178-1930">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ba178-1931">Standardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1931">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ba178-1932">Niestandardowe ciągi formatujące TimeSpan</span><span class="sxs-lookup"><span data-stu-id="ba178-1932">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ba178-1933">Wyliczanie ciągów formatujących</span><span class="sxs-lookup"><span data-stu-id="ba178-1933">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-1934">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1934">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ba178-1935">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1935">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1936">Pierwszy obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1936">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1937">Drugi obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1937">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1938">Zamienia elementy formatu ciągu na ciąg reprezentujący dwa określone obiekty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1938">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="ba178-1939">Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1939">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ba178-1940">Kopia <paramref name="format" /> , w której elementy formatu są zamieniane na ciąg <paramref name="arg0" /> reprezentujący i <paramref name="arg1" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1940">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1941">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować dwa wyrażenia na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1941">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ba178-1942">W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1942">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ba178-1943">Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** .</span><span class="sxs-lookup"><span data-stu-id="ba178-1943">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ba178-1944">Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1944">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1945"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1945"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1946"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1946"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1947">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1947">-or-</span></span> 
<span data-ttu-id="ba178-1948">Indeks elementu formatu nie jest równy zero lub jeden.</span><span class="sxs-lookup"><span data-stu-id="ba178-1948">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ba178-1949">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1949">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1950">Pierwszy obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1950">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1951">Drugi obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1951">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ba178-1952">Trzeci obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1952">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1953">Zamienia elementy formatu ciągu na ciąg reprezentujący trzy określone obiekty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1953">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ba178-1954">Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący, <paramref name="arg1" />, i <paramref name="arg2" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1954">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1955">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) do konwersji wartości trzech wyrażeń do ich reprezentacji ciągów i osadzania tych reprezentacji w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1955">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a><span data-ttu-id="ba178-1956">Przykład: Formatowanie trzech argumentów</span><span class="sxs-lookup"><span data-stu-id="ba178-1956">Example: Formatting three arguments</span></span>  
 
 <span data-ttu-id="ba178-1957">W <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> tym przykładzie zastosowano metodę, aby utworzyć ciąg, który ilustruje wynik operacji logicznej `And` z dwiema wartościami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="ba178-1957">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="ba178-1958">Należy zauważyć, że ciąg formatu zawiera sześć elementów formatu, ale metoda ma tylko trzy elementy na liście parametrów, ponieważ każdy element jest sformatowany na dwa różne sposoby.</span><span class="sxs-lookup"><span data-stu-id="ba178-1958">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1959"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1959"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1960"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1960"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1961">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1961">-or-</span></span> 
<span data-ttu-id="ba178-1962">Indeks elementu formatu jest mniejszy niż zero lub większy niż dwa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1962">The index of a format item is less than zero, or greater than two.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ba178-1963">Formatowanie typów w programie .NET</span><span class="sxs-lookup"><span data-stu-id="ba178-1963">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ba178-1964">Złożone formatowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-1964">Composite Formatting</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-1965">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1965">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ba178-1966">[Ciąg formatu złożonego](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-1966">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ba178-1967">Pierwszy obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1967">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ba178-1968">Drugi obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1968">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ba178-1969">Trzeci obiekt do sformatowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-1969">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ba178-1970">Zamienia elementy formatu ciągu na ciąg reprezentujący trzy określone obiekty.</span><span class="sxs-lookup"><span data-stu-id="ba178-1970">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="ba178-1971">Parametr dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-1971">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ba178-1972">Kopia <paramref name="format" /> , w której elementy formatu zostały zastąpione przez ciąg <paramref name="arg0" />reprezentujący, <paramref name="arg1" />, i <paramref name="arg2" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1972">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ba178-1973">Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) , aby przekonwertować trzy wyrażenia na ich reprezentacje ciągów i osadzić te reprezentacje w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1973">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ba178-1974">W trakcie wykonywania konwersji Metoda używa formatowania z uwzględnieniem kultury lub niestandardowego programu formatującego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1974">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ba178-1975">Metoda konwertuje każdy <xref:System.Object> argument na jego reprezentację w postaci ciągu przez wywołanie metody **ToString (IFormatProvider)** lub, jeśli odpowiedni element formatu obiektu zawiera ciąg formatu, wywołując jego metodę **ToString (String, IFormatProvider)** .</span><span class="sxs-lookup"><span data-stu-id="ba178-1975">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ba178-1976">Jeśli te metody nie istnieją, wywołuje metodę **ToString** bez parametrów obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1976">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-1977"><paramref name="format" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-1977"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-1978"><paramref name="format" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="ba178-1978"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ba178-1979">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-1979">-or-</span></span> 
<span data-ttu-id="ba178-1980">Indeks elementu formatu jest mniejszy niż zero lub większy niż dwa.</span><span class="sxs-lookup"><span data-stu-id="ba178-1980">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-1981">Pobiera obiekt, który może wykonywać iterację poszczególnych znaków w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1981">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1982">Obiekt modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="ba178-1982">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> <span data-ttu-id="ba178-1983">Zamiast wywoływania <xref:System.String.GetEnumerator%2A> metody w celu <xref:System.CharEnumerator> pobrania obiektu, który będzie używany do wyliczenia ciągu, należy zamiast tego użyć konstrukcji iteracji języka (w C#, w C++/CLR i w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ba178-1983">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct (in C#, in C++/CLR, and in Visual Basic).</span></span> <span data-ttu-id="ba178-1984">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) w C++/CLR i [for each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ba178-1984">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR, and [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>
  
 <span data-ttu-id="ba178-1985">Ta metoda umożliwia Powtarzanie pojedynczych znaków w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1985">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="ba178-1986">Na przykład Visual Basic C# `foreach` i instrukcje wywołują tę metodę w celu zwrócenia obiektu,którymożezapewnićdostęptylkodoodczytudoznakówwtymwystąpieniuciągu.<xref:System.CharEnumerator> `For Each`</span><span class="sxs-lookup"><span data-stu-id="ba178-1986">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-1987">Poniższy przykład iteruje znaki w kilku ciągach i wyświetla informacje o ich poszczególnych znakach.</span><span class="sxs-lookup"><span data-stu-id="ba178-1987">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="ba178-1988">Używa konstrukcji iteracji języka, a nie wywołania <xref:System.String.GetEnumerator%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-1988">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-1989">Zwraca kod skrótu dla tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1989">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-1990">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-1990">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-1991">Zachowanie <xref:System.String.GetHashCode%2A> jest zależne od implementacji, która może ulec zmianie z jednej wersji środowiska uruchomieniowego języka wspólnego na inną.</span><span class="sxs-lookup"><span data-stu-id="ba178-1991">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="ba178-1992">Przyczyną tego problemu może być poprawa wydajności programu <xref:System.String.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba178-1992">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba178-1993">Jeśli dwa obiekty String są równe, <xref:System.String.GetHashCode%2A> Metoda zwraca identyczne wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-1993">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="ba178-1994">Nie istnieje jednak unikatowa wartość kodu skrótu dla każdej unikatowej wartości ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1994">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="ba178-1995">Różne ciągi mogą zwracać ten sam kod skrótu.</span><span class="sxs-lookup"><span data-stu-id="ba178-1995">Different strings can return the same hash code.</span></span>  
>   
>  <span data-ttu-id="ba178-1996">Sam kod skrótu nie jest gwarantowany jako stabilny.</span><span class="sxs-lookup"><span data-stu-id="ba178-1996">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="ba178-1997">Kody skrótów dla identycznych ciągów mogą różnić się między implementacjami platformy .NET, różnymi wersjami .NET i między platformami .NET (takimi jak 32-bitowe i 64-bitowe) dla jednej wersji platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="ba178-1997">Hash codes for identical strings can differ across .NET implementations, across .NET versions, and across .NET platforms (such as 32-bit and 64-bit) for a single version of .NET.</span></span> <span data-ttu-id="ba178-1998">W niektórych przypadkach mogą one nawet różnić się w zależności od domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-1998">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="ba178-1999">Oznacza to, że dwa kolejne uruchomienia tego samego programu mogą zwracać różne kody skrótów.</span><span class="sxs-lookup"><span data-stu-id="ba178-1999">This implies that two subsequent runs of the same program may return different hash codes.</span></span>  
>   
>  <span data-ttu-id="ba178-2000">W związku z tym kody skrótów nigdy nie powinny być używane poza domeną aplikacji, w której zostały utworzone, nigdy nie powinny być używane jako pola kluczy w kolekcji i nigdy nie powinny być utrwalane.</span><span class="sxs-lookup"><span data-stu-id="ba178-2000">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>  
>   
>  <span data-ttu-id="ba178-2001">Na koniec nie należy używać kodu skrótu zamiast wartości zwracanej przez kryptograficzną funkcję mieszania, jeśli jest potrzebny kryptograficznie silny skrót.</span><span class="sxs-lookup"><span data-stu-id="ba178-2001">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="ba178-2002">W przypadku skrótów kryptograficznych Użyj klasy pochodnej <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> klasy or. <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-2002">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
>   
>  <span data-ttu-id="ba178-2003">Aby uzyskać więcej informacji na temat kodów skrótu <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>, zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-2003">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba178-2004">W aplikacjach klasycznych można użyć [ \<elementu UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) , aby generować unikatowe kody skrótów dla poszczególnych domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2004">In desktop apps, you can use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="ba178-2005">Może to zmniejszyć liczbę kolizji i zwiększyć ogólną wydajność operacji wstawiania i wyszukiwania, które używają tabel skrótów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2005">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="ba178-2006">Poniższy przykład pokazuje, [ \<jak używać elementu UseRandomizedStringHashAlgorithm >](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-2006">The following example shows how to use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="ba178-2007">Definiuje `DisplayString` klasę, która zawiera ciąg prywatny, `s`, którego wartością jest "to jest ciąg".</span><span class="sxs-lookup"><span data-stu-id="ba178-2007">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="ba178-2008">Zawiera `ShowStringHashCode` również metodę, która wyświetla wartość ciągu i jego kod skrótu wraz z nazwą domeny aplikacji, w której jest wykonywana metoda.</span><span class="sxs-lookup"><span data-stu-id="ba178-2008">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 <span data-ttu-id="ba178-2009">W przypadku uruchomienia tego przykładu bez podawania pliku konfiguracji wyświetlane są dane wyjściowe podobne do poniższych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2009">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="ba178-2010">Należy zauważyć, że kody skrótów dla ciągu są identyczne w obu domenach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2010">Note that the hash codes for the string are identical in the two application domains.</span></span>  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 <span data-ttu-id="ba178-2011">Jeśli jednak dodasz następujący plik konfiguracji do katalogu przykładu, a następnie uruchomisz przykład, kody skrótów dla tego samego ciągu różnią się w zależności od domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2011">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 <span data-ttu-id="ba178-2012">Gdy plik konfiguracji jest obecny, w przykładzie są wyświetlane następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="ba178-2012">When the configuration file is present, the example displays the following output:</span></span>  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba178-2013">Kody skrótów służą do wydajnego wstawiania i pobierania z tabel skrótów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2013">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="ba178-2014">Jednak kody skrótów nie identyfikują jednoznacznie ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2014">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="ba178-2015">Identyczne ciągi mają równe kody skrótów, ale środowisko uruchomieniowe języka wspólnego może również przypisać ten sam kod skrótu do różnych ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2015">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="ba178-2016">Ponadto kody skrótów mogą różnić się w zależności od wersji platformy .NET, platformy w ramach jednej wersji i domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2016">In addition, hash codes can vary by version of .NET, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="ba178-2017">W związku z tym nie należy serializować ani utrwalać wartości kodu skrótu ani używać ich jako kluczy w tabeli lub słowniku skrótów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2017">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>  
  
 <span data-ttu-id="ba178-2018">Aby uzyskać dodatkowe informacje o używaniu kodów skrótów i `GetHashCode` metody, zobacz. <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-2018">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2019">Poniższy przykład demonstruje <xref:System.String.GetHashCode%2A> metodę przy użyciu różnych ciągów wejściowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2019">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2020">Wartość zwrócona przez <see cref="M:System.String.GetHashCode" /> jest zależna od platformy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2020">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="ba178-2021">Różni się on od 32-bitowych i 64-bitowych wersji .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ba178-2021">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="ba178-2022">Może również różnić się między wersjami .NET Framework i .NET Core.</span><span class="sxs-lookup"><span data-stu-id="ba178-2022">It also can differ between versions of the .NET Framework and .NET Core.</span></span></para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630"><span data-ttu-id="ba178-2023">&lt;UseRandomizedStringHashAlgorithm&gt; , element</span><span class="sxs-lookup"><span data-stu-id="ba178-2023">&lt;UseRandomizedStringHashAlgorithm&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2024">Zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2024">A read-only character span.</span></span></param>
        <summary><span data-ttu-id="ba178-2025">Zwraca kod skrótu dla podanego zakresu znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2025">Returns the hash code for the provided read-only character span.</span></span></summary>
        <returns><span data-ttu-id="ba178-2026">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2026">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType"><span data-ttu-id="ba178-2027">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2027">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-2028">Zwraca kod skrótu dla tego ciągu przy użyciu określonych reguł.</span><span class="sxs-lookup"><span data-stu-id="ba178-2028">Returns the hash code for this string using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="ba178-2029">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2029">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2030">Zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2030">A read-only character span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2031">Jedna z wartości wyliczenia, która określa reguły do użycia w porównaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2031">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ba178-2032">Zwraca kod skrótu dla podanego zakresu znaków tylko do odczytu przy użyciu określonych reguł.</span><span class="sxs-lookup"><span data-stu-id="ba178-2032">Returns the hash code for the provided read-only character span using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="ba178-2033">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2033">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-2034">Zwraca odwołanie do elementu ciągu pod indeksem zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-2034">Returns a reference to the element of the string at index zero.</span></span></summary>
        <returns><span data-ttu-id="ba178-2035">Znak reprezentujący odwołanie do elementu ciągu pod indeksem zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-2035">A character representing the reference to the element of the string at index zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ba178-2036">Metoda zwraca znak, który może być używany do <xref:System.String> przypinania w pamięci. `GetPinnableReference`</span><span class="sxs-lookup"><span data-stu-id="ba178-2036">The `GetPinnableReference` method returns a character that can be used for pinning a <xref:System.String> in memory.</span></span> <span data-ttu-id="ba178-2037">Jest to wymagane do obsługi użycia a <xref:System.String> wewnątrz ustalonej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2037">It is required to support the use of a <xref:System.String> within a fixed statement.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="ba178-2038">Ciąg ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="ba178-2038">The string is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-2039"><see cref="T:System.String" />Zwraca klasę <see cref="T:System.TypeCode" /> dla klasy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2039">Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-2040">Stała <see cref="F:System.TypeCode.String" />Wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2040">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ba178-2041">Poniższy przykład przedstawia <xref:System.TypeCode> Wyliczenie stałe dla tego <xref:System.String> typu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2041">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2042">Raportuje indeks pierwszego wystąpienia określonego znaku Unicode lub ciągu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2042">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ba178-2043">Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2043">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2044">Znak Unicode, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2044">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2045">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2045">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2046">Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2046">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2047">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2047">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2048">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2048">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2049">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2049">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2050">W poniższym przykładzie pokazano, jak można wyszukać <xref:System.String> znak <xref:System.String.IndexOf%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2050">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2051">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2051">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2052">Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2052">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="ba178-2053">Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2053">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2054">Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2054">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2055">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2055">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2056">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2056">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ba178-2057">Wyszukiwanie rozpoczyna się od pierwszego położenia znaku tego wystąpienia i jest kontynuowane aż do ostatniego położenia znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2057">The search begins at the first character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ba178-2058">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2058">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2059">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2059">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2060">Jeśli `value` składa się tylko z co najmniej jednego znaku <xref:System.String.IndexOf%28System.String%29> , który można zignorować, Metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2060">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="ba178-2061">W poniższym przykładzie <xref:System.String.IndexOf%28System.String%29> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2061">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ba178-2062">Tylko jeden z ciągów zawiera łącznik nietrwały.</span><span class="sxs-lookup"><span data-stu-id="ba178-2062">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ba178-2063">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ łącznik miękki jest znakiem, który można zignorować, wynik jest taki sam jak w przypadku, gdy łącznik miękki nie został uwzględniony w. `value`</span><span class="sxs-lookup"><span data-stu-id="ba178-2063">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ba178-2064">Podczas wyszukiwania tylko łącznika miękkiego Metoda zwraca wartość 0 (zero), aby wskazać, że znaleziono dopasowanie na początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2064">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2065">Poniższy przykład wyszukuje "n" w "zwierzęciu".</span><span class="sxs-lookup"><span data-stu-id="ba178-2065">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="ba178-2066">Ponieważ indeksy ciągu zaczynają się od zera, a nie <xref:System.String.IndexOf%28System.String%29> jeden, Metoda wskazuje, że "n" znajduje się na pozycji 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2066">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 <span data-ttu-id="ba178-2067">W poniższym przykładzie zastosowano <xref:System.String.IndexOf%2A> metodę, aby określić pozycję początkową nazwy zwierzęcia w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2067">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="ba178-2068">Następnie używa tego położenia, aby wstawić przymiotnik, który opisuje zwierzę w zdaniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2068">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2069"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2069"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2070">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2070">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2071">Aby znaleźć pierwszy indeks podciągu w wystąpieniu ciągu przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2071">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2072">Znak Unicode, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2072">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2073">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2073">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ba178-2074">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2074">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="ba178-2075">Wyszukiwanie rozpocznie się z określoną pozycją znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2075">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ba178-2076">Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku ciągu, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2076">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2077">Numerowanie indeksu rozpoczyna się od 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2077">Index numbering starts from 0.</span></span> <span data-ttu-id="ba178-2078">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2078">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ba178-2079">Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2079">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ba178-2080">Wyszukiwanie zakresów od `startIndex` do końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2080">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ba178-2081">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2081">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2082">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2082">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2083">Poniższy przykład demonstruje <xref:System.String.IndexOf%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2083">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2084"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2084"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2085">Znak, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2085">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2086">Wartość wyliczenia, która określa reguły dla wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2086">An enumeration value that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2087">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku Unicode w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2087">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="ba178-2088">Parametr określa typ wyszukiwania do użycia dla określonego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2088">A parameter specifies the type of search to use for the specified character.</span></span></summary>
        <returns><span data-ttu-id="ba178-2089">Indeks (liczony od zera) <paramref name="value" /> , jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2089">The zero-based index of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="ba178-2090">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2090">Index numbering starts from zero.</span></span>  
  
<span data-ttu-id="ba178-2091">Parametr jest składową wyliczenia, która określa, `value` czy wyszukiwanie argumentu używa bieżącej lub niezmiennej kultury, jest rozróżniana wielkość liter, czy też używa reguł porównania programu Word lub porządkowego. <xref:System.StringComparison> `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2091">The `comparisonType` parameter is a <xref:System.StringComparison> enumeration member that specifies whether the search for the `value` argument uses the current or invariant culture, is case-sensitive or case-insensitive, or uses word or ordinal comparison rules.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2092"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2092"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2093">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2093">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2094">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2094">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ba178-2095">Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2095">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ba178-2096">Wyszukiwanie rozpocznie się z określoną pozycją znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2096">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ba178-2097">Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2097">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2098">Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</span><span class="sxs-lookup"><span data-stu-id="ba178-2098">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2099">Numerowanie indeksu rozpoczyna się od 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2099">Index numbering starts from 0.</span></span> <span data-ttu-id="ba178-2100">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2100">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ba178-2101">Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2101">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ba178-2102">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2102">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ba178-2103">Wyszukiwanie rozpoczyna się od `startIndex` pozycji znaku tego wystąpienia i jest kontynuowane do momentu ostatniej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2103">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ba178-2104">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2104">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2105">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2105">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2106">Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2106">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ba178-2107">W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2107">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="ba178-2108">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2108">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2109">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2109">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="ba178-2110">Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.</span><span class="sxs-lookup"><span data-stu-id="ba178-2110">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2111">Poniższy przykład wyszukuje wszystkie wystąpienia określonego ciągu w ciągu docelowym.</span><span class="sxs-lookup"><span data-stu-id="ba178-2111">The following example searches for all occurrences of a specified string within a target string.</span></span>  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2112"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2112"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2113"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2113"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2114">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2114">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2115">Aby znaleźć pierwszy indeks podciągu, który występuje po określonej pozycji znaku przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2115">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2116">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2116">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2117">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2117">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2118">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2118">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ba178-2119">Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2119">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2120">Pozycja <paramref name="value" /> indeksu parametru, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2120">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2121">Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2121">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2122">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2122">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2123">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2123">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2124">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2124">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2125"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2125"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2126"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2126"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2127">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2127">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2128">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2128">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2129">Jeśli <paramref name="value" /> składa się tylko z co najmniej jednego znaku <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> , który można zignorować, Metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowanie znajduje się na początku bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2129">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>  
  
<span data-ttu-id="ba178-2130">W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2130">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ba178-2131">Tylko jeden z ciągów zawiera łącznik nietrwały.</span><span class="sxs-lookup"><span data-stu-id="ba178-2131">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ba178-2132">Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niewygładzony jest znakiem, którego nie można zignorować, wyszukiwanie z uwzględnieniem kultury zwraca tę samą wartość, która byłaby zwracana, jeśli łącznik miękki nie został uwzględniony w ciągu wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2132">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ba178-2133">Wyszukiwanie porządkowe, jednak pomyślnie znajduje łącznik niewygładzony w jednym ciągu i zgłasza, że nie jest on poza drugim ciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2133">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
<span data-ttu-id="ba178-2134">[! code-CSharp[System. String. IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! code — VB[System. String. IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2134">[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2135">Znak Unicode, który ma zostać przeszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2135">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2136">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2136">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2137">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2137">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2138">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego znaku w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2138">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="ba178-2139">Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2139">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2140">Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku ciągu, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2140">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2141">Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` .</span><span class="sxs-lookup"><span data-stu-id="ba178-2141">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ba178-2142">Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-2142">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ba178-2143">Numerowanie indeksu zaczyna się od 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-2143">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ba178-2144">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2144">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ba178-2145">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2145">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2146">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2146">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2147">Poniższy przykład demonstruje <xref:System.String.IndexOf%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2147">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2148"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="ba178-2148"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2149">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2149">-or-</span></span> 
 <span data-ttu-id="ba178-2150"><paramref name="startIndex" />jest większa niż długość tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2150"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
<span data-ttu-id="ba178-2151">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2151">-or-</span></span> 
 <span data-ttu-id="ba178-2152"><paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2152"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2153">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2153">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2154">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2154">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2155">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2155">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2156">Raportuje indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu liczony od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2156">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ba178-2157">Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2157">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2158">Pozycja indeksu rozpoczynającego się <paramref name="value" /> od zera od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2158">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2159">Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</span><span class="sxs-lookup"><span data-stu-id="ba178-2159">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2160">Numerowanie indeksu zaczyna się od 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-2160">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ba178-2161">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2161">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ba178-2162">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2162">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ba178-2163">Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` .</span><span class="sxs-lookup"><span data-stu-id="ba178-2163">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ba178-2164">Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-2164">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ba178-2165">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2165">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2166">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2166">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2167">Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2167">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ba178-2168">W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego do szóstego znaku w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2168">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ba178-2169">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2169">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2170">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2170">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2171">Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.</span><span class="sxs-lookup"><span data-stu-id="ba178-2171">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2172">Poniższy przykład znajduje indeks wszystkich wystąpień ciągu "mu" w podciągu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2172">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="ba178-2173">Należy zauważyć, że liczba znaków do przeszukania musi być ponownie obliczana dla każdej iteracji wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2173">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2174"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2174"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2175"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="ba178-2175"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2176">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2176">-or-</span></span> 
 <span data-ttu-id="ba178-2177"><paramref name="startIndex" />jest większa niż długość tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2177"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
<span data-ttu-id="ba178-2178">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2178">-or-</span></span> 
 <span data-ttu-id="ba178-2179"><paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2179"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2180">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2180">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2181">Aby użyć reguł porównania bieżącej kultury do wykonania tej operacji, wywołaj <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2181">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2182">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2182">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2183">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2183">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2184">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2184">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2185">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2185">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ba178-2186">Parametry określają początkową pozycję wyszukiwania w bieżącym ciągu i typ wyszukiwania do użycia dla określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2186">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2187">Pozycja indeksu (liczony od zera) <paramref name="value" /> parametru od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2187">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2188">Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</span><span class="sxs-lookup"><span data-stu-id="ba178-2188">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2189">Numerowanie indeksu rozpoczyna się od 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2189">Index numbering starts from 0.</span></span> <span data-ttu-id="ba178-2190">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2190">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ba178-2191">Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2191">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ba178-2192">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2192">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2193">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2193">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2194"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2194"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2195"><paramref name="startIndex" />jest mniejsza niż 0 (zero) lub większa niż długość tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2195"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2196"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2196"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2197">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2197">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2198">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2198">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2199">Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2199">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ba178-2200">W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego położenia znaku w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2200">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="ba178-2201">Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2201">Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2202">Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.</span><span class="sxs-lookup"><span data-stu-id="ba178-2202">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ba178-2203">Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2203">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ba178-2204">[! code-CSharp[System. String. IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! code — VB[System. String. IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2204">[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2205">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2205">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2206">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2206">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2207">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2207">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2208">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2208">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2209">Raportuje indeks (liczony od zera) pierwszego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2209">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ba178-2210">Parametry określają początkową pozycję wyszukiwania w bieżącym ciągu, liczbę znaków w bieżącym ciągu do wyszukania oraz typ wyszukiwania do użycia dla określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2210">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2211">Pozycja indeksu (liczony od zera) <paramref name="value" /> parametru od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2211">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2212">Jeśli <paramref name="value" /> <paramref name="startIndex" />jest <see cref="F:System.String.Empty" />, wartość zwracana to.</span><span class="sxs-lookup"><span data-stu-id="ba178-2212">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2213">Numerowanie indeksu zaczyna się od 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-2213">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ba178-2214">`startIndex` Parametr może mieć wartość z zakresu od 0 do długości wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2214">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ba178-2215">Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` .</span><span class="sxs-lookup"><span data-stu-id="ba178-2215">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ba178-2216">Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-2216">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ba178-2217">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2217">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2218">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.IndexOf%2A> metody, które wyszukują pierwsze wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2218">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2219"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2219"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2220"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="ba178-2220"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2221">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2221">-or-</span></span> 
 <span data-ttu-id="ba178-2222"><paramref name="startIndex" />jest większa niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2222"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ba178-2223">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2223">-or-</span></span> 
 <span data-ttu-id="ba178-2224"><paramref name="count" />jest większa niż długość tego ciągu minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2224"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2225"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2225"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2226">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2226">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2227">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2227">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2228">Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2228">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ba178-2229">W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m" zaczynający się od trzeciego do szóstego znaku w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2229">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ba178-2230">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2230">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2231">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2231">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2232">Gdy wykonuje to porównanie porządkowe, znajduje podciąg tylko w pierwszym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2232">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ba178-2233">Należy zauważyć, że w przypadku pierwszego ciągu, który zawiera Łącznik miękki, po którym następuje "m", metoda nie zwróci indeksu łącznika miękkiego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2233">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2234">Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2234">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ba178-2235">[! code-CSharp[System. String. IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! code — VB[System. String. IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2235">[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2236">Raportuje indeks pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2236">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ba178-2237">Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2237">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2238">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2238">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2239">Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2239">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="ba178-2240">Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2240">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2241">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2241">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2242">W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2242">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="ba178-2243">Jeśli `anyOf` jest tablicą pustą, Metoda znajduje dopasowanie na początku ciągu (czyli przy indeksie zero).</span><span class="sxs-lookup"><span data-stu-id="ba178-2243">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>  
  
 <span data-ttu-id="ba178-2244">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2244">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2245">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2245">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2246">Poniższy przykład odnajduje pierwsze samogłosy w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2246">The following example finds the first vowel in a string.</span></span>  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2247"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2247"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2248">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2248">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2249">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2249">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ba178-2250">Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2250">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ba178-2251">Wyszukiwanie rozpocznie się z określoną pozycją znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2251">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ba178-2252">Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2252">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2253">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2253">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2254">`startIndex` Parametr może napadać w zakresie od 0 do jednego, który jest mniejszy niż długość wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2254">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ba178-2255">Wyszukiwanie zakresów od `startIndex` do końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2255">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ba178-2256">W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2256">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2257">Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="ba178-2257">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ba178-2258">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2258">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2259">Poniższy przykład znajduje indeks wystąpienia dowolnego znaku ciągu "is" w podciągu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2259">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2260"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2260"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2261"><paramref name="startIndex" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-2261"><paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2262">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2262">-or-</span></span> 
 <span data-ttu-id="ba178-2263"><paramref name="startIndex" />jest większa niż liczba znaków w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2263"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2264">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2264">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2265">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2265">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2266">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2266">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2267">Raportuje indeks (liczony od zera) pierwszego wystąpienia w tym wystąpieniu dowolnego znaku w określonej tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2267">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ba178-2268">Wyszukiwanie zaczyna się od określonej pozycji znaku i bada określoną liczbę pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2268">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2269">Pozycja indeksu od zera pierwszego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> .-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2269">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2270">Wyszukiwanie rozpocznie się `startIndex` o `startIndex`  +  -1`count` .</span><span class="sxs-lookup"><span data-stu-id="ba178-2270">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ba178-2271">Znak `startIndex`  +  nie jest uwzględniany w wyszukiwaniu. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-2271">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ba178-2272">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2272">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2273">`startIndex` Parametr może napadać w zakresie od 0 do jednego, który jest mniejszy niż długość wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2273">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ba178-2274">W wyszukiwaniu `anyOf` jest rozróżniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2274">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2275">Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="ba178-2275">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ba178-2276">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2276">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2277">Poniższy przykład znajduje indeks wystąpienia dowolnego znaku ciągu "pomoc" w podciągu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2277">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2278"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2278"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2279"><paramref name="count" />lub <paramref name="startIndex" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="ba178-2279"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2280">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2280">-or-</span></span> 
 <span data-ttu-id="ba178-2281"><paramref name="count" /> + <paramref name="startIndex" />jest większa niż liczba znaków w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2281"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-2282">Pozycja indeksu (liczony od zera) wstawiania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2282">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="ba178-2283">Ciąg do wstawienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2283">The string to insert.</span></span></param>
        <summary><span data-ttu-id="ba178-2284">Zwraca nowy ciąg, w którym zostanie wstawiony określony ciąg w określonym położeniu indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2284">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="ba178-2285">Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale z <paramref name="value" /> wstawionym na <paramref name="startIndex" />pozycji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2285">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2286">Jeśli `startIndex` wartość jest równa długości tego wystąpienia, `value` jest dołączana na końcu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2286">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2287">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2287">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2288">Zamiast tego zwraca nowy ciąg, w którym `value` zostanie wstawiony do bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2288">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>  
  
 <span data-ttu-id="ba178-2289">Na przykład zwracaną wartością `"abc".Insert(2, "XYZ")` jest "abXYZc".</span><span class="sxs-lookup"><span data-stu-id="ba178-2289">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2290">Poniższy przykład wstawia znak spacji w czwartej pozycji znaku (znak przy indeksie 3) ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2290">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 <span data-ttu-id="ba178-2291">Poniższa Aplikacja konsolowa poprosi użytkowników o wprowadzenie jednego lub więcej przymiotników, aby opisać dwa zwierzęta.</span><span class="sxs-lookup"><span data-stu-id="ba178-2291">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="ba178-2292">Następnie wywołuje metodę, <xref:System.String.Insert%2A> aby wstawić tekst wprowadzony przez użytkownika do ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2292">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2293"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2293"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2294"><paramref name="startIndex" />jest ujemna lub większa niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2294"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ba178-2295">Ciąg do wyszukania w puli InterNIC.</span><span class="sxs-lookup"><span data-stu-id="ba178-2295">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ba178-2296">Pobiera odwołanie systemu do określonego <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2296">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-2297">Odwołanie systemu do <paramref name="str" />, jeśli jest InterNIC; w przeciwnym razie, nowe odwołanie do ciągu z <paramref name="str" />wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2297">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2298">Środowisko uruchomieniowe języka wspólnego chroni magazyn ciągów przez utrzymywanie tabeli zwanej pulą InterNIC, która zawiera pojedyncze odwołanie do każdego unikatowego ciągu literału zadeklarowanego lub utworzonego programowo w programie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2298">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="ba178-2299">W związku z tym wystąpienie ciągu literału z określoną wartością występuje tylko raz w systemie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2299">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>  
  
 <span data-ttu-id="ba178-2300">Jeśli na przykład ten sam ciąg literału zostanie przypisany do kilku zmiennych, środowisko uruchomieniowe pobiera te same odwołania do ciągu literału z puli InterNIC i przypisuje je do każdej zmiennej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2300">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>  
  
 <span data-ttu-id="ba178-2301">Metoda używa puli stażyst do wyszukiwania ciągu równego `str`wartości. <xref:System.String.Intern%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-2301">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="ba178-2302">Jeśli taki ciąg istnieje, zwracane jest jego odwołanie w puli stażyst.</span><span class="sxs-lookup"><span data-stu-id="ba178-2302">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="ba178-2303">Jeśli ciąg nie istnieje, odwołanie do `str` jest dodawane do puli InterNIC, to odwołanie zostanie zwrócone.</span><span class="sxs-lookup"><span data-stu-id="ba178-2303">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>  
  
 <span data-ttu-id="ba178-2304">W poniższym przykładzie ciąg S1, który ma wartość ". test", został już wybadany, ponieważ jest to literał w programie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2304">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="ba178-2305"><xref:System.Text.StringBuilder?displayProperty=nameWithType> Klasa generuje nowy obiekt ciągu, który ma taką samą wartość jak S1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2305">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="ba178-2306">Odwołanie do tego ciągu jest przypisane do S2.</span><span class="sxs-lookup"><span data-stu-id="ba178-2306">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="ba178-2307"><xref:System.String.Intern%2A> Metoda wyszukuje ciąg, który ma taką samą wartość jak S2.</span><span class="sxs-lookup"><span data-stu-id="ba178-2307">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="ba178-2308">Ponieważ taki ciąg istnieje, metoda zwraca takie samo odwołanie, które jest przypisane do S1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2308">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="ba178-2309">To odwołanie jest następnie przypisywane do S3.</span><span class="sxs-lookup"><span data-stu-id="ba178-2309">That reference is then assigned to s3.</span></span> <span data-ttu-id="ba178-2310">Odwołania S1 i S2 są nierówne, ponieważ odwołują się do różnych obiektów; odwołuje się do porównania S1 i S3 równego, ponieważ odwołują się do tego samego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2310">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 <span data-ttu-id="ba178-2311">Porównaj tę metodę z <xref:System.String.IsInterned%2A> metodą.</span><span class="sxs-lookup"><span data-stu-id="ba178-2311">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="ba178-2312">Uwagi dotyczące wersji</span><span class="sxs-lookup"><span data-stu-id="ba178-2312">Version Considerations</span></span>  
 <span data-ttu-id="ba178-2313">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] WprogramieMetodaprzywracaswojezachowaniew.NETFramework1,0i1,1wodniesieniudoInterNIC<xref:System.String.Intern%2A> pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2313">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="ba178-2314">W poniższym przykładzie zmienna `str1` jest przypisana odwołanie do <xref:System.String.Empty>, a zmienna `str2` jest przypisana <xref:System.String.Intern%2A> odwołanie do <xref:System.String.Empty> , które jest zwracane przez wywołanie metody po konwersji <xref:System.Text.StringBuilder>obiekt, którego wartością <xref:System.String.Empty> jest ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2314">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string.</span></span> <span data-ttu-id="ba178-2315">Następnie odwołania zawarte w `str1` i `str2` są porównywane pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2315">Then the references contained in `str1` and `str2` are compared for equality.</span></span>  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 <span data-ttu-id="ba178-2316">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]W, [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], i [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] i`str2`są równe. `str1`</span><span class="sxs-lookup"><span data-stu-id="ba178-2316">In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal.</span></span> <span data-ttu-id="ba178-2317">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] W i[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]i nie sąrówne.`str2` `str1`</span><span class="sxs-lookup"><span data-stu-id="ba178-2317">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ba178-2318">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-2318">Performance Considerations</span></span>  
 <span data-ttu-id="ba178-2319">Jeśli próbujesz zmniejszyć łączną ilość pamięci przydzielonej przez aplikację, pamiętaj, że informowanie ciągu ma dwa niepożądane skutki uboczne.</span><span class="sxs-lookup"><span data-stu-id="ba178-2319">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="ba178-2320">Po pierwsze pamięć przydzielona dla <xref:System.String> obiektów InterNIC nie może zostać wydana do momentu zakończenia środowiska uruchomieniowego języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="ba178-2320">First, the memory allocated for interned <xref:System.String> objects is not likely to be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="ba178-2321">Przyczyną jest to, że odwołanie środowiska CLR do <xref:System.String> obiektu InterNIC może być utrwalane po aplikacji, a nawet w domenie aplikacji kończy się.</span><span class="sxs-lookup"><span data-stu-id="ba178-2321">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="ba178-2322">Po drugie, aby InterNIC ciąg, należy najpierw utworzyć ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2322">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="ba178-2323">Pamięć używana przez <xref:System.String> obiekt musi nadal być przydzielone, nawet jeśli pamięć zostanie ostatecznie zebrana.</span><span class="sxs-lookup"><span data-stu-id="ba178-2323">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>  
  
 <span data-ttu-id="ba178-2324">W .NET Framework w wersji 2,0 wprowadzono <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> element członkowski wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2324">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="ba178-2325"><xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Element członkowski oznacza zestaw jako niewymagający, aby InterNIC literał ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2325">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="ba178-2326">Można zastosować <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> do zestawu <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> przy użyciu atrybutu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2326">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="ba178-2327">Ponadto w przypadku korzystania z programu [Ngen. exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) do kompilowania zestawu z wyprzedzeniem czasu wykonywania, ciągi nie są InterNIC między modułami.</span><span class="sxs-lookup"><span data-stu-id="ba178-2327">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2328">W poniższym przykładzie są używane trzy ciągi, które są równe wartości, aby określić, czy nowo utworzony ciąg i ciąg z ośrodeku InterNIC są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2328">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2329"><paramref name="str" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2329"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ba178-2330">Ciąg do wyszukania w puli InterNIC.</span><span class="sxs-lookup"><span data-stu-id="ba178-2330">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ba178-2331">Pobiera odwołanie do określonego <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2331">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-2332">Odwołanie do <paramref name="str" /> , <see langword="null" />jeśli znajduje się w puli stażystów środowiska uruchomieniowego języka wspólnego; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2332">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2333">Środowisko uruchomieniowe języka wspólnego automatycznie utrzymuje tabelę nazywaną pulą InterNIC, która zawiera pojedyncze wystąpienie każdej unikatowej stałej ciągu literału zadeklarowanej w programie, a także wszelkie unikatowe wystąpienia <xref:System.String> dodawane programowo przez wywołanie <xref:System.String.Intern%2A> Metoda.</span><span class="sxs-lookup"><span data-stu-id="ba178-2333">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-2334">Pula stażyst służy do zachowywania magazynu ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2334">The intern pool conserves string storage.</span></span> <span data-ttu-id="ba178-2335">W przypadku przypisywania stałej literału ciągu do kilku zmiennych Każda zmienna jest ustawiana jako odwołująca się do tej samej stałej w puli InterNIC <xref:System.String> zamiast odwoływać się do kilku różnych wystąpień, które mają identyczne wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2335">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>  
  
 <span data-ttu-id="ba178-2336">Ta metoda jest wyszukiwana `str` w puli InterNIC.</span><span class="sxs-lookup"><span data-stu-id="ba178-2336">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="ba178-2337">Jeśli `str` jest już InterNIC, odwołanie do tego wystąpienia jest zwracane; `null` w przeciwnym razie zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-2337">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>  
  
 <span data-ttu-id="ba178-2338">Porównaj tę metodę z <xref:System.String.Intern%2A> metodą.</span><span class="sxs-lookup"><span data-stu-id="ba178-2338">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-2339">Ta metoda nie zwraca wartości logicznej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2339">This method does not return a Boolean value.</span></span> <span data-ttu-id="ba178-2340">Jeśli wywołasz metodę, ponieważ chcesz, aby wartość logiczna wskazywała, czy określony ciąg jest InterNIC, możesz użyć kodu takiego jak poniższe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2340">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2341">Począwszy od .NET Framework w wersji 2,0, można zastąpić użycie puli stażyst w przypadku użycia programu [Ngen. exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) w celu zainstalowania zestawu w pamięci podręcznej obrazów natywnych na komputerze lokalnym.</span><span class="sxs-lookup"><span data-stu-id="ba178-2341">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="ba178-2342">Aby uzyskać więcej informacji, zobacz Zagadnienia dotyczące wydajności w sekcji uwagi <xref:System.String.Intern%2A> dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2342">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2343">W poniższym przykładzie pokazano, że literały ciągów są automatycznie Interni przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="ba178-2343">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2344"><paramref name="str" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2344"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2345">Wskazuje, czy ten ciąg znajduje się w konkretnym formularzu normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2345">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-2346">Wskazuje, czy ten ciąg jest w postaci C normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2346">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="ba178-2347"><see langword="true" />Jeśli ten ciąg jest w postaci normalizacji C; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2347"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2348">Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2348">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ba178-2349">Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.</span><span class="sxs-lookup"><span data-stu-id="ba178-2349">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ba178-2350">W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2350">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ba178-2351">Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły.</span><span class="sxs-lookup"><span data-stu-id="ba178-2351">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ba178-2352">Platforma .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.</span><span class="sxs-lookup"><span data-stu-id="ba178-2352">.NET currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ba178-2353">Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2353">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2354">Poniższy przykład określa, czy ciąg został pomyślnie znormalizowany do różnych formularzy normalizacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2354">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2355">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2355">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2356"><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2356">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ba178-2357">W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2357">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ba178-2358">Formularz normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2358">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ba178-2359">Wskazuje, czy ten ciąg znajduje się w określonym formularzu normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2359">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="ba178-2360"><see langword="true" />Jeśli ten ciąg znajduje się w formularzu normalizacji określonym przez <paramref name="normalizationForm" /> parametr; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2360"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2361">Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2361">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ba178-2362">Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.</span><span class="sxs-lookup"><span data-stu-id="ba178-2362">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ba178-2363">W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2363">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ba178-2364">Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły.</span><span class="sxs-lookup"><span data-stu-id="ba178-2364">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ba178-2365">Platforma .NET obsługuje obecnie normalizacje formularzy C, D, KC i KD.</span><span class="sxs-lookup"><span data-stu-id="ba178-2365">.NET currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ba178-2366">Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2366">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2367">Poniższy przykład ilustruje <xref:System.String.IsNormalized%2A> metody i <xref:System.String.Normalize%2A> .</span><span class="sxs-lookup"><span data-stu-id="ba178-2367">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2368">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2368">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2369"><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2369">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ba178-2370">W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2370">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2371">Ciąg do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2371">The string to test.</span></span></param>
        <summary><span data-ttu-id="ba178-2372">Wskazuje, czy określony ciąg jest <see langword="null" /> lub pustym ciągiem ("").</span><span class="sxs-lookup"><span data-stu-id="ba178-2372">Indicates whether the specified string is <see langword="null" /> or an empty string ("").</span></span></summary>
        <returns><span data-ttu-id="ba178-2373"><see langword="true" />Jeśli parametr jest lub <see langword="null" /> jest ciągiem pustym (""); <paramref name="value" /> w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2373"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2374"><xref:System.String.IsNullOrEmpty%2A>jest wygodną metodą, która umożliwia jednoczesne testowanie, czy <xref:System.String> jest `null` lub jej wartość <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2374"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-2375">Odpowiada to następującemu kodowi:</span><span class="sxs-lookup"><span data-stu-id="ba178-2375">It is equivalent to the following code:</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <span data-ttu-id="ba178-2376">Możesz użyć <xref:System.String.IsNullOrWhiteSpace%2A> metody <xref:System.String.Empty?displayProperty=nameWithType>, aby sprawdzić, czy ciąg jest `null`, jego wartość lub zawiera tylko znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2376">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>  
  
## <a name="what-is-a-null-string"></a><span data-ttu-id="ba178-2377">Co to jest ciąg o wartości null?</span><span class="sxs-lookup"><span data-stu-id="ba178-2377">What is a null string?</span></span>

<span data-ttu-id="ba178-2378">Ciąg jest `null` , jeśli nie ma przypisanej wartości (w C++ i Visual Basic) lub jeśli został jawnie `null`przypisany do wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2378">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if it has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="ba178-2379">Mimo że funkcja [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) może bezpiecznie obsłużyć ciąg o wartości null, jak pokazano w poniższym przykładzie, próba wywołania jednego z nich powoduje, <xref:System.NullReferenceException>że jego członkowie zgłaszają.</span><span class="sxs-lookup"><span data-stu-id="ba178-2379">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a><span data-ttu-id="ba178-2380">Co to jest pusty ciąg?</span><span class="sxs-lookup"><span data-stu-id="ba178-2380">What is an empty string?</span></span>  

<span data-ttu-id="ba178-2381">Ciąg jest pusty, jeśli jest jawnie przypisany do pustego ciągu ("") lub <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2381">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-2382">Pusty ciąg ma <xref:System.String.Length%2A> wartość 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2382">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="ba178-2383">Poniższy przykład tworzy pusty ciąg i wyświetla jego wartość oraz jego długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2383">The following example creates an empty string and displays its value and its length.</span></span>  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 <span data-ttu-id="ba178-2384">Poniższy przykład analizuje trzy ciągi i określa, czy każdy ciąg ma wartość, jest pustym ciągiem lub jest `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-2384">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2385">Ciąg do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2385">The string to test.</span></span></param>
        <summary><span data-ttu-id="ba178-2386">Wskazuje, czy określony ciąg jest <see langword="null" />pusty lub zawiera tylko znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2386">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns><span data-ttu-id="ba178-2387"><see langword="true" />Jeśli parametr jest <see langword="null" /> <paramref name="value" /> lub <see cref="F:System.String.Empty" />lub, lub, jeśli zawiera wyłącznie znaki białych znaków. <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2387"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2388"><xref:System.String.IsNullOrWhiteSpace%2A>jest wygodną metodą podobną do poniższego kodu, z tą różnicą, że oferuje najwyższą wydajność:</span><span class="sxs-lookup"><span data-stu-id="ba178-2388"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 <span data-ttu-id="ba178-2389">Znaki odstępu są definiowane przez standard Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2389">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ba178-2390">Metoda interpretuje dowolny znak, który zwraca `true` wartość, gdy jest przenoszona do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody jako znak odstępu. <xref:System.String.IsNullOrWhiteSpace%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-2390">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2391">Poniższy przykład tworzy tablicę ciągów, a następnie przekazuje każdy element tablicy do <xref:System.String.IsNullOrWhiteSpace%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2391">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2392">Łączy elementy określonej tablicy lub elementów członkowskich kolekcji przy użyciu określonego separatora między każdym elementem lub członkiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2392">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-2393">Ciąg, który ma być używany jako separator.<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2393">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="ba178-2394">jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="ba178-2394">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ba178-2395">Kolekcja zawierająca ciągi do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2395">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-2396">Łączy elementy członkowskie skonstruowanej <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcji typu <see cref="T:System.String" />przy użyciu określonego separatora między poszczególnymi elementami członkowskimi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2396">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ba178-2397">Ciąg, który składa się z składowych <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2397">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ba178-2398">Jeśli <paramref name="values" /> nie ma żadnych elementów członkowskich, Metoda <see cref="F:System.String.Empty" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-2398">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2399">Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu ().</span><span class="sxs-lookup"><span data-stu-id="ba178-2399">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ba178-2400">Jeśli którykolwiek element członkowski `values` jest `null`, zamiast niego zostanie użyty pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2400">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ba178-2401"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów na tablicę ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2401"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ba178-2402">Jest to szczególnie przydatne w przypadku wyrażeń zapytań dotyczących języka (LINQ).</span><span class="sxs-lookup"><span data-stu-id="ba178-2402">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ba178-2403">Poniższy przykład przekazuje `List(Of String)` obiekt zawierający wielkie lub małe litery alfabetu do wyrażenia lambda, które wybiera litery, które są równe lub większe niż określona litera (w tym przykładzie jest to "M").</span><span class="sxs-lookup"><span data-stu-id="ba178-2403">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ba178-2404">Kolekcja zwrócona <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> przez<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę jest przekazana do metody w celu wyświetlenia wyniku jako pojedynczego ciągu. `IEnumerable(Of String)`</span><span class="sxs-lookup"><span data-stu-id="ba178-2404">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2405">W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza.</span><span class="sxs-lookup"><span data-stu-id="ba178-2405">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ba178-2406">Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu <xref:System.String>, który następnie przekazuje <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2406">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2407"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2407"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-2408">Ciąg używany jako separator.</span><span class="sxs-lookup"><span data-stu-id="ba178-2408">The string to use as a separator.</span></span> <span data-ttu-id="ba178-2409"><paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="ba178-2409"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ba178-2410">Tablica zawierająca elementy, które mają być połączone.</span><span class="sxs-lookup"><span data-stu-id="ba178-2410">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-2411">Łączy elementy tablicy obiektów przy użyciu określonego separatora między poszczególnymi elementami.</span><span class="sxs-lookup"><span data-stu-id="ba178-2411">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ba178-2412">Ciąg, który składa się z elementów <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2412">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ba178-2413">Jeśli <paramref name="values" /> jest tablicą pustą, metoda zwraca <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2413">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2414">Jeśli `separator` jest `null` <xref:System.String.Empty?displayProperty=nameWithType>lub jeśli którykolwiek element `null`innego niż pierwszy element ma wartość, zamiast niego zostanie użyty pusty ciąg (). `values`</span><span class="sxs-lookup"><span data-stu-id="ba178-2414">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ba178-2415">Zapoznaj się z sekcją uwagi dla wywołań, jeśli pierwszy `values` element `null`jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2415">See the Notes for Callers section if the first element of `values` is `null`.</span></span>  
  
 <span data-ttu-id="ba178-2416"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów w tablicy obiektów bez jawnej konwersji elementów na ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2416"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="ba178-2417">Ciąg reprezentujący każdy obiekt w tablicy jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2417">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2418">W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza.</span><span class="sxs-lookup"><span data-stu-id="ba178-2418">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ba178-2419">Przypisuje wynik do tablicy liczb całkowitych, która następnie przechodzi do <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2419">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2420"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2420"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2421">Jeśli <paramref name="values" /> pierwszy element <see cref="F:System.String.Empty" />jest <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> Metoda nie łączy elementów w <paramref name="values" /> , ale zamiast tego zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-2421">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ba178-2422">Dostępne są różne obejścia tego problemu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2422">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="ba178-2423">Najprostszym sposobem jest przypisanie wartości <see cref="F:System.String.Empty" /> do pierwszego elementu tablicy, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2423">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>  
  
<span data-ttu-id="ba178-2424">[! code-CSharp[System. String. Join # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code — VB[System. String. Join # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2424">[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span></span></para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-2425">Ciąg używany jako separator.</span><span class="sxs-lookup"><span data-stu-id="ba178-2425">The string to use as a separator.</span></span> <span data-ttu-id="ba178-2426"><paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="value" /> wtedy, gdy ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="ba178-2426"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ba178-2427">Tablica zawierająca elementy, które mają być połączone.</span><span class="sxs-lookup"><span data-stu-id="ba178-2427">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-2428">Łączy wszystkie elementy tablicy ciągów przy użyciu określonego separatora między każdym elementem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2428">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ba178-2429">Ciąg, który składa się z elementów <paramref name="value" /> , które są rozdzielane <paramref name="separator" /> przez ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2429">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ba178-2430">Jeśli <paramref name="value" /> jest tablicą pustą, metoda zwraca <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2430">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2431">Na przykład jeśli `separator` jest "," i `value` elementami są "Apple", "pomarańcze", "grono" i "gruszki", `Join(separator, value)` zwraca "Apple, pomarańcz, winogron, grusze".</span><span class="sxs-lookup"><span data-stu-id="ba178-2431">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>  
  
 <span data-ttu-id="ba178-2432">Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu ().</span><span class="sxs-lookup"><span data-stu-id="ba178-2432">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ba178-2433">Jeśli dowolny element w `value` to `null`, zamiast niego zostanie użyty pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2433">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2434">Poniższy przykład demonstruje <xref:System.String.Join%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2434">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2435"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2435"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-2436">Ciąg używany jako separator.</span><span class="sxs-lookup"><span data-stu-id="ba178-2436">The string to use as a separator.</span></span> <span data-ttu-id="ba178-2437"><paramref name="separator" />jest uwzględniony w zwracanym ciągu tylko <paramref name="value" /> wtedy, gdy ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="ba178-2437"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ba178-2438">Tablica zawierająca elementy, które mają być połączone.</span><span class="sxs-lookup"><span data-stu-id="ba178-2438">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2439">Pierwszy element w <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2439">The first element in <paramref name="value" /> to use.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2440">Liczba elementów <paramref name="value" /> do użycia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2440">The number of elements of <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ba178-2441">Łączy określone elementy tablicy ciągów przy użyciu określonego separatora między każdym elementem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2441">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ba178-2442">Ciąg, który składa się z ciągów <paramref name="value" /> rozdzielanych <paramref name="separator" /> przez ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2442">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>  
  
<span data-ttu-id="ba178-2443">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2443">-or-</span></span> 
 <span data-ttu-id="ba178-2444"><see cref="F:System.String.Empty" />Jeśli <paramref name="count" /> jest równa <paramref name="value" /> zero, nie ma elementów <paramref name="separator" /> ani i wszystkie elementy <paramref name="value" /> <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2444"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2445">Na przykład jeśli `separator` jest "," i `value` elementy są "Apple", "pomarańcze", "grono" i "gruszki", `Join(separator, value, 1, 2)` zwraca "pomarańczowe i winogronowe".</span><span class="sxs-lookup"><span data-stu-id="ba178-2445">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>  
  
 <span data-ttu-id="ba178-2446">Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu ().</span><span class="sxs-lookup"><span data-stu-id="ba178-2446">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ba178-2447">Jeśli dowolny element w `value` to `null`, zamiast niego zostanie użyty pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2447">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2448">Poniższy przykład łączy dwa elementy z tablicy nazw owoców.</span><span class="sxs-lookup"><span data-stu-id="ba178-2448">The following example concatenates two elements from an array of names of fruit.</span></span>  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2449"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2449"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2450"><paramref name="startIndex" />lub <paramref name="count" /> jest mniejsza od 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-2450"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>  
  
<span data-ttu-id="ba178-2451">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2451">-or-</span></span> 
 <span data-ttu-id="ba178-2452"><paramref name="startIndex" />Plus <paramref name="count" /> jest większa niż liczba elementów w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2452"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ba178-2453">Za mało pamięci.</span><span class="sxs-lookup"><span data-stu-id="ba178-2453">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ba178-2454">Typ elementów członkowskich <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2454">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="ba178-2455">Ciąg, który ma być używany jako separator.<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2455">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="ba178-2456">jest uwzględniony w zwracanym ciągu tylko <paramref name="values" /> wtedy, gdy ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="ba178-2456">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ba178-2457">Kolekcja zawierająca obiekty do łączenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2457">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="ba178-2458">Łączy elementy członkowskie kolekcji przy użyciu określonego separatora między poszczególnymi elementami członkowskimi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2458">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ba178-2459">Ciąg, który składa się z składowych <paramref name="values" /> rozdzielanych <paramref name="separator" /> przez ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2459">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ba178-2460">Jeśli <paramref name="values" /> nie ma żadnych elementów członkowskich, Metoda <see cref="F:System.String.Empty" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="ba178-2460">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2461">Jeśli `separator` <xref:System.String.Empty?displayProperty=nameWithType>jest `null`, zamiast tego użyto pustego ciągu ().</span><span class="sxs-lookup"><span data-stu-id="ba178-2461">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ba178-2462">Jeśli którykolwiek element członkowski `values` jest `null`, zamiast niego zostanie użyty pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2462">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ba178-2463"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>jest wygodną metodą, która umożliwia łączenie poszczególnych elementów członkowskich <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania ich na ciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2463"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="ba178-2464">Ciąg reprezentujący każdy obiekt w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest wyprowadzany przez wywołanie `ToString` metody tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2464">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
 <span data-ttu-id="ba178-2465">Ta metoda jest szczególnie przydatna w przypadku wyrażeń zapytań dotyczących języka (LINQ).</span><span class="sxs-lookup"><span data-stu-id="ba178-2465">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ba178-2466">Na przykład poniższy kod definiuje bardzo prostą `Animal` klasę, która zawiera nazwę zwierzęcia i kolejność, do której należy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2466">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ba178-2467">Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, który zawiera `Animal` kilka obiektów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2467">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="ba178-2468">Metoda rozszerzenia jest wywoływana w celu wyodrębnienia `Animal` obiektów, `Order` których właściwość jest równa "gryzonie". <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-2468">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ba178-2469">Wynik jest przesyłany do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2469">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2470">W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza.</span><span class="sxs-lookup"><span data-stu-id="ba178-2470">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ba178-2471">Przypisuje wynik do <xref:System.Collections.Generic.List%601> obiektu typu Integer, który następnie przekazuje <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2471">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2472"><paramref name="values" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2472"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2473">Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode lub ciągu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2473">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ba178-2474">Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2474">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2475">Znak Unicode, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2475">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2476">Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2476">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="ba178-2477">Pozycja indeksu liczony od zera, <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2477">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2478">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2478">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2479">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2479">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2480">Ta metoda rozpoczyna wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku rozpoczęcia do momentu `value` znalezienia lub przeanalizowania pierwszej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2480">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2481">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2481">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2482">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2482">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2483">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2483">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2484">W poniższym przykładzie zdefiniowano `ExtractFilename` metodę, która <xref:System.String.LastIndexOf%28System.Char%29> używa metody do znalezienia ostatniego znaku separatora katalogu w ciągu i wyodrębnienia nazwy pliku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2484">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="ba178-2485">Jeśli plik istnieje, metoda zwraca nazwę pliku bez jego ścieżki.</span><span class="sxs-lookup"><span data-stu-id="ba178-2485">If the file exists, the method returns the file name without its path.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2486">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2486">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2487">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2487">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="ba178-2488">Pozycja początkowego indeksu rozpoczynającego się od zera <paramref name="value" /> , jeśli ten ciąg zostanie znaleziony, lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2488">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2489">Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana jest ostatnim położeniem indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2489">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2490">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2490">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2491">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2491">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2492">Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu `value` jego znalezienia lub przeanalizowania pierwszej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2492">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
 <span data-ttu-id="ba178-2493">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2493">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ba178-2494">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2494">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2495">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2495">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2496">Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%28System.String%29> , które można zignorować, Metoda zawsze zwraca <xref:System.String.Length%2A?displayProperty=nameWithType> wartość-1, która reprezentuje ostatnią pozycję indeksu w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2496">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> - 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="ba178-2497">W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%29> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2497">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ba178-2498">Tylko jeden z ciągów zawiera łącznik nietrwały.</span><span class="sxs-lookup"><span data-stu-id="ba178-2498">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ba178-2499">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ łącznik miękki jest znakiem, który można zignorować, wynik jest taki sam jak w przypadku, gdy łącznik miękki nie został uwzględniony w. `value`</span><span class="sxs-lookup"><span data-stu-id="ba178-2499">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ba178-2500">Podczas wyszukiwania tylko łącznika miękkiego Metoda zwraca wartość 6 i 5.</span><span class="sxs-lookup"><span data-stu-id="ba178-2500">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="ba178-2501">Te wartości odpowiadają indeksowi ostatniego znaku w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2501">These values correspond to the index of the last character in the two strings.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2502">Poniższy przykład usuwa otwierając i zamyka Tagi HTML z ciągu, jeśli Tagi zaczynają się i kończą ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2502">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="ba178-2503">Jeśli ciąg kończy się znakiem zamykającego nawiasu klamrowego (">"), w <xref:System.String.LastIndexOf%2A> przykładzie zostanie użyta metoda lokalizowania początku tagu końcowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-2503">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2504"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2504"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2505">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2505">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2506">Aby znaleźć ostatni indeks podciągu w wystąpieniu ciągu przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodę przeciążenia metody z <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2506">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2507">Znak Unicode, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2507">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2508">Pozycja początkowa wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2508">The starting position of the search.</span></span> <span data-ttu-id="ba178-2509">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2509">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-2510">Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2510">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="ba178-2511">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2511">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2512">Pozycja <paramref name="value" /> indeksu liczony od zera, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2512">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2513">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2513">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2514">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1. Ta metoda rozpoczyna wyszukiwanie `startIndex` na pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku bieżącego wystąpienia do momentu `value` został znaleziony lub pierwsze położenie znaku zostało zbadane.</span><span class="sxs-lookup"><span data-stu-id="ba178-2514">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2515">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2515">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="ba178-2516">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2516">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2517">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2517">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2518">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2518">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2519">W poniższym przykładzie znajduje się indeks wszystkich wystąpień znaku w ciągu, który działa od końca ciągu do początku ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2519">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2520">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż lub równe długości tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2520">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2521">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2521">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2522">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2522">The search starting position.</span></span> <span data-ttu-id="ba178-2523">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2523">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-2524">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2524">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ba178-2525">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2525">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2526">Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest <see cref="F:System.String.Empty" />równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2526">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ba178-2527">Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2527">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2528">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2528">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2529">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2529">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2530">Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku `value` do momentu jego znalezienia lub przeanalizowania pierwszego stanowiska znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2530">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2531">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2531">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ba178-2532">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2532">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ba178-2533">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2533">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2534">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2534">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2535">Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2535">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ba178-2536">W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> Metoda jest używana do znajdowania podciągu, który zawiera Łącznik miękki (U + 00AD), który poprzedza lub zawiera końcową literę "m" w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2536">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="ba178-2537">Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niezbędny w ciągu wyszukiwania jest ignorowany, wywołanie metody w celu znalezienia podciągu, który składa się z łącznika miękkiego i "m" zwraca pozycję "m" w ciągu, podczas gdy wywołanie go w celu znalezienia elementu substrin g, która składa się z łącznika miękkiego i "n" zwraca pozycję "n".</span><span class="sxs-lookup"><span data-stu-id="ba178-2537">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="ba178-2538">Gdy ciąg wyszukiwania zawiera tylko łącznik miękki, metoda zwraca indeks "m", który reprezentuje wartość `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="ba178-2538">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2539">W poniższym przykładzie znajduje się indeks wszystkich wystąpień ciągu w ciągu docelowym, który działa od końca ciągu docelowego do początku ciągu docelowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-2539">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2540"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2540"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2541">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż długość bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2541">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
<span data-ttu-id="ba178-2542">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2542">-or-</span></span> 
<span data-ttu-id="ba178-2543">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze niż-1 lub większe od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2543">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2544">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2544">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2545">Aby znaleźć indeks podciągu, który poprzedza konkretną pozycję znaku przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2545">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2546">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2546">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2547">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2547">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2548">Raportuje indeks od zera ostatniego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2548">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ba178-2549">Parametr określa typ wyszukiwania do użycia dla określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2549">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2550">Pozycja początkowego indeksu rozpoczynającego się od zera w <paramref name="value" /> przypadku znalezienia tego ciągu lub-1, jeśli nie jest.</span><span class="sxs-lookup"><span data-stu-id="ba178-2550">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ba178-2551">Jeśli <paramref name="value" /> jest<see cref="F:System.String.Empty" />, wartość zwracana jest ostatnim położeniem indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2551">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2552">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2552">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2553">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2553">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2554">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2554">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
 <span data-ttu-id="ba178-2555">Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu `value` jego znalezienia lub przeanalizowania pierwszej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2555">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2556">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2556">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2557"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2557"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2558"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2558"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2559">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2559">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2560">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="options" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2560">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2561">Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <see cref="P:System.String.Length" /> wartość-1, która reprezentuje ostatnią pozycję indeksu w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2561">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> - 1, which represents the last index position in the current instance.</span></span>  
  
<span data-ttu-id="ba178-2562">W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Metoda jest używana w celu znalezienia trzech podciągów (łącznika miękkiego (U + 00AD), łącznika miękkiego, a następnie znaku "n" i łącznika miękkiego, po którym następuje znak "m") w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2562">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ba178-2563">Tylko jeden z ciągów zawiera łącznik nietrwały.</span><span class="sxs-lookup"><span data-stu-id="ba178-2563">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ba178-2564">Jeśli przykład jest uruchamiany na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ łącznik niewygładzony jest znakiem, którego nie można zignorować, wyszukiwanie z uwzględnieniem kultury zwraca tę samą wartość, która byłaby zwracana, jeśli łącznik miękki nie został uwzględniony w ciągu wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2564">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ba178-2565">Wyszukiwanie porządkowe, jednak pomyślnie znajduje łącznik niewygładzony w jednym ciągu i zgłasza, że nie jest on poza drugim ciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2565">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
<span data-ttu-id="ba178-2566">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2566">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2567">Znak Unicode, który ma zostać wyszukany.</span><span class="sxs-lookup"><span data-stu-id="ba178-2567">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2568">Pozycja początkowa wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2568">The starting position of the search.</span></span> <span data-ttu-id="ba178-2569">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2569">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2570">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2570">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2571">Raportuje pozycję indeksu (liczony od zera) ostatniego wystąpienia określonego znaku Unicode w podciągu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2571">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="ba178-2572">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2572">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2573">Pozycja <paramref name="value" /> indeksu liczony od zera, jeśli ten znak zostanie znaleziony, lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2573">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2574">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2574">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2575">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2575">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2576">Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku i przechodzi do tyłu w kierunku początku tego wystąpienia `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2576">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ba178-2577">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2577">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="ba178-2578">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2578">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2579">Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="ba178-2579">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ba178-2580">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2580">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2581">Poniższy przykład znajduje indeks wszystkich wystąpień znaku w podciągu, który działa od końca podciągu do początku podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2581">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2582">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż lub równe długości tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2582">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>  
  
<span data-ttu-id="ba178-2583">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2583">-or-</span></span> 
<span data-ttu-id="ba178-2584">Bieżące wystąpienie <see cref="F:System.String.Empty" />nie jest równe, a <paramref name="startIndex" />  -  <paramref name="count" /> + 1 jest mniejsze od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2584">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2585">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2585">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2586">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2586">The search starting position.</span></span> <span data-ttu-id="ba178-2587">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2587">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2588">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2588">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2589">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2589">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ba178-2590">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2590">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2591">Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie znaleziona lub jeśli bieżące wystąpienie jest <see cref="F:System.String.Empty" />równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2591">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ba178-2592">Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2592">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2593">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2593">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2594">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2594">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2595">Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku rozpoczęcia `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2595">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ba178-2596">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2596">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ba178-2597">Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2597">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ba178-2598">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2598">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2599">W przypadku wyszukiwania z uwzględnieniem kultury, `value` jeśli zawiera znak, który można zignorować, wynik jest równoznaczny z usunięciem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2599">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2600">Jeśli `value` zawiera tylko jeden lub więcej znaków <xref:System.String.LastIndexOf%2A> , które można zignorować, Metoda zawsze zwraca `startIndex`wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2600">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ba178-2601">W poniższym przykładzie <xref:System.String.LastIndexOf%2A> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD) w dwóch znakach poprzedzających końcowy "m" dwóch ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2601">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="ba178-2602">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2602">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2603">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2603">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2604">Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.</span><span class="sxs-lookup"><span data-stu-id="ba178-2604">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2605">Poniższy przykład znajduje indeks wszystkich wystąpień ciągu w podciągu, który działa od końca podciągu do początku podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2605">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2606"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2606"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2607"><paramref name="count" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-2607"><paramref name="count" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2608">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2608">-or-</span></span> 
<span data-ttu-id="ba178-2609">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-2609">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2610">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2610">-or-</span></span> 
<span data-ttu-id="ba178-2611">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest większe niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2611">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ba178-2612">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2612">-or-</span></span> 
<span data-ttu-id="ba178-2613">Bieżące wystąpienie <see cref="F:System.String.Empty" />nie jest równe, a <paramref name="startIndex" />  -  <paramref name="count" />+ 1 określa pozycję, która nie znajduje się w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2613">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>  
  
<span data-ttu-id="ba178-2614">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2614">-or-</span></span> 
<span data-ttu-id="ba178-2615">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsze niż-1 lub większe od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2615">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
<span data-ttu-id="ba178-2616">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2616">-or-</span></span> 
<span data-ttu-id="ba178-2617">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większe niż 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2617">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2618">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2618">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-2619">Aby wykonać tę operację przy użyciu reguł porównania bieżącej kultury, wywołaj <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodę przeciążenia metody z <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-2619">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2620">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2620">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2621">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2621">The search starting position.</span></span> <span data-ttu-id="ba178-2622">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2622">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2623">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2623">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2624">Raportuje indeks od zera ostatniego wystąpienia określonego ciągu w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2624">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ba178-2625">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2625">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="ba178-2626">Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2626">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2627">Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie odnaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2627">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ba178-2628">Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2628">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2629">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2629">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2630">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2630">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2631">Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku i przechodzi do tyłu `value` do momentu znalezienia lub przeanalizowania pierwszej pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2631">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2632">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje każdy znak od ostatniego znaku w ciągu do początku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2632">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ba178-2633">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2633">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2634">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2634">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2635"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2635"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2636">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze od zera lub większe niż długość bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2636">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
<span data-ttu-id="ba178-2637">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2637">-or-</span></span> 
<span data-ttu-id="ba178-2638">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest mniejsze niż-1 lub większe od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2638">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2639"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2639"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2640">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2640">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2641">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2641">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2642">Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2642">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ba178-2643">W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje znak "m", począwszy od końcowego "m" w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2643">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="ba178-2644">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2644">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2645">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2645">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2646">Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.</span><span class="sxs-lookup"><span data-stu-id="ba178-2646">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ba178-2647">Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2647">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ba178-2648">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2648">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-2649">Ciąg do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2649">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2650">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2650">The search starting position.</span></span> <span data-ttu-id="ba178-2651">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2651">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2652">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2652">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-2653">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2653">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ba178-2654">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2654">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ba178-2655">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2655">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="ba178-2656">Parametr określa typ porównania do wykonania podczas wyszukiwania określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2656">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2657">Pozycja <paramref name="value" /> początkowego indeksu rozpoczynającego się od zera, jeśli ten ciąg zostanie znaleziony lub-1, jeśli nie zostanie odnaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2657">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ba178-2658">Jeśli <paramref name="value" /> <paramref name="startIndex" /> jest <see cref="F:System.String.Empty" />, wartość zwracana jest mniejsza z i ostatnią pozycją indeksu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2658">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2659">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2659">Index numbering starts from zero.</span></span> <span data-ttu-id="ba178-2660">Oznacza to, że pierwszy znak w ciągu jest przy indeksie równym zero, a ostatni <xref:System.String.Length%2A> ma wartość-1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2660">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ba178-2661">Wyszukiwanie rozpoczyna się na `startIndex` pozycji znaku i przechodzi do tyłu `value` do momentu znalezienia lub `count` przeanalizowania pozycji znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2661">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ba178-2662">Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> -1, Metoda przeszukuje znaki wstecz `count` od ostatniego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2662">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ba178-2663">Parametr określa, aby wyszukać `value` parametr przy użyciu bieżącej lub niezmiennej kultury, przy użyciu rozróżniania wielkości liter lub wyszukiwania bez uwzględniania wielkości liter oraz przy użyciu reguł porównania programu Word lub porządkowego. `comparisonType`</span><span class="sxs-lookup"><span data-stu-id="ba178-2663">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2664">Poniższy przykład ilustruje trzy przeciążenia <xref:System.String.LastIndexOf%2A> metody, która wyszukuje ostatnie wystąpienie ciągu w innym ciągu przy użyciu różnych wartości <xref:System.StringComparison> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2664">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2665"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2665"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2666"><paramref name="count" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-2666"><paramref name="count" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2667">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2667">-or-</span></span> 
<span data-ttu-id="ba178-2668">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-2668">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2669">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2669">-or-</span></span> 
<span data-ttu-id="ba178-2670">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> jest większe niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2670">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ba178-2671">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2671">-or-</span></span> 
<span data-ttu-id="ba178-2672">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />, a <paramref name="startIndex" /> + 1 — <paramref name="count" /> określa pozycję, która nie znajduje się w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2672">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>  
  
<span data-ttu-id="ba178-2673">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2673">-or-</span></span> 
<span data-ttu-id="ba178-2674">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsze niż-1 lub większe od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2674">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
<span data-ttu-id="ba178-2675">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2675">-or-</span></span> 
<span data-ttu-id="ba178-2676">Bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większe niż 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-2676">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2677"><paramref name="comparisonType" />nie jest prawidłową <see cref="T:System.StringComparison" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-2677"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2678">Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-2678">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2679">W przypadku wyszukiwania z uwzględnieniem kultury ( <paramref name="comparisonType" /> Jeśli nie <see cref="F:System.StringComparison.Ordinal" /> jest lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynik jest równoważny z wyszukiwaniem tego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2679">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ba178-2680">Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> , które można zignorować, Metoda zawsze zwraca <paramref name="startIndex" />wartość, która jest pozycją znaku, w której rozpoczyna się wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2680">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ba178-2681">W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Metoda jest używana do znajdowania pozycji łącznika miękkiego (U + 00AD), po którym następuje "m" we wszystkich oprócz pierwszej pozycji znaku przed ostatnim "m" w dwóch ciągach.</span><span class="sxs-lookup"><span data-stu-id="ba178-2681">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="ba178-2682">Tylko jeden z ciągów zawiera wymagany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2682">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ba178-2683">Jeśli przykład jest uruchamiany w [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ łącznik miękki jest znakiem, który można zignorować, metoda zwraca indeks "m" w ciągu, gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2683">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2684">Gdy wykonuje to porównanie porządkowe, znajduje podciąg tylko w pierwszym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2684">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ba178-2685">Należy zauważyć, że w przypadku pierwszego ciągu, który zawiera Łącznik miękki, po którym następuje "m", metoda nie zwróci indeksu łącznika miękkiego, ale zamiast tego zwraca indeks "m", gdy wykonuje porównanie z uwzględnieniem kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2685">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ba178-2686">Metoda ta zwraca indeks łącznika nietrwałego w pierwszym ciągu tylko wtedy, gdy wykonuje porównanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-2686">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ba178-2687">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="ba178-2687">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2688">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2688">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ba178-2689">Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2689">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2690">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2690">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ba178-2691">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2691">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="ba178-2692">Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak w <paramref name="anyOf" /> , lub-1, jeśli nie znaleziono żadnego <paramref name="anyOf" /> znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2692">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2693">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2693">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2694">Ta metoda rozpoczyna wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu znalezienia znaku w `anyOf` lub po sprawdzeniu pierwszego położenia znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2694">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2695">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2695">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2696">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2696">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2697">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2697">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2698">Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w innym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2698">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2699"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2699"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2700">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2700">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2701">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2701">The search starting position.</span></span> <span data-ttu-id="ba178-2702">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2702">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-2703">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2703">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ba178-2704">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2704">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2705">Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak z <paramref name="anyOf" /> ;-1, jeśli nie odnaleziono żadnego <paramref name="anyOf" /> znaku lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2705">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2706">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2706">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2707">Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu znalezienia znaku w `anyOf` lub po sprawdzeniu pierwszego położenia znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2707">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ba178-2708">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2708">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2709">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2709">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2710">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2710">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2711">Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w podciągu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2711">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2712"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2712"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2713">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="startIndex" /> określa pozycję, która nie znajduje się w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2713">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ba178-2714">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2714">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ba178-2715">Pozycja rozpoczęcia wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2715">The search starting position.</span></span> <span data-ttu-id="ba178-2716">Wyszukiwanie przechodzi od <paramref name="startIndex" /> początku tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2716">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2717">Liczba pozycji znaku do zbadania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2717">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ba178-2718">Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2718">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ba178-2719">Wyszukiwanie rozpoczyna się od określonej pozycji znaku i przechodzi do tyłu w kierunku początku ciągu dla określonej liczby pozycji znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2719">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ba178-2720">Pozycja indeksu ostatniego wystąpienia w tym wystąpieniu, w którym znaleziono dowolny znak z <paramref name="anyOf" /> ;-1, jeśli nie odnaleziono żadnego <paramref name="anyOf" /> znaku lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2720">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2721">Indeks numerowania rozpoczyna się od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2721">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ba178-2722">Ta metoda rozpoczyna wyszukiwanie na `startIndex` pozycji znaku tego wystąpienia i przechodzi do tyłu w kierunku początku do momentu, gdy zostanie znaleziony znak w `anyOf` lub `count` pozycje znakowe zostały zbadane.</span><span class="sxs-lookup"><span data-stu-id="ba178-2722">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ba178-2723">W wyszukiwaniu jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-2723">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ba178-2724">Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same.</span><span class="sxs-lookup"><span data-stu-id="ba178-2724">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ba178-2725">Aby przeprowadzić wyszukiwanie z uwzględnieniem kultur, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarna Unicode reprezentująca znak przedłożony, na przykład "Æ" (U + 00C6), może być uważana za odpowiednik dowolnego wystąpienia składników znaku w Popraw sekwencję, taką jak "AE" (U + 0041, U + 0045), w zależności od kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-2725">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2726">Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "pomoc" w podciągu innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2726">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2727"><paramref name="anyOf" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2727"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2728">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />i <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemne.</span><span class="sxs-lookup"><span data-stu-id="ba178-2728">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ba178-2729">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2729">-or-</span></span> 
<span data-ttu-id="ba178-2730">Bieżące wystąpienie nie jest równe <see cref="F:System.String.Empty" />, a <paramref name="startIndex" /> minus <paramref name="count" /> + 1 jest mniejsze od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2730">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba178-2731">Pobiera liczbę znaków w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2731">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ba178-2732">Liczba znaków w bieżącym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2732">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2733"><xref:System.String.Length%2A> Właściwość zwraca<xref:System.Char> liczbę obiektów w tym wystąpieniu, a nie liczbę znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2733">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="ba178-2734">Przyczyną jest to, że znak Unicode może być reprezentowany przez więcej niż jeden <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2734">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ba178-2735">Użyj klasy do pracy z każdym znakiem Unicode zamiast każdego <xref:System.Char>. <xref:System.Globalization.StringInfo?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-2735">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>  
  
 <span data-ttu-id="ba178-2736">W niektórych językach, takich jak C i C++, znak null wskazuje koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2736">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="ba178-2737">W programie .NET znak null może być osadzony w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2737">In .NET, a null character can be embedded in a string.</span></span> <span data-ttu-id="ba178-2738">Gdy ciąg zawiera jeden lub więcej znaków null, są one uwzględnione w długości łącznego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2738">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="ba178-2739">Na przykład, w poniższym ciągu, podciągi "ABC" i "def" są oddzielane znakiem null.</span><span class="sxs-lookup"><span data-stu-id="ba178-2739">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="ba178-2740"><xref:System.String.Length%2A> Właściwość zwraca wartość 7, co oznacza, że zawiera sześć znaków alfabetu, a także znak null.</span><span class="sxs-lookup"><span data-stu-id="ba178-2740">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2741">Poniższy przykład demonstruje <xref:System.String.Length%2A> właściwość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2741">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2742">Zwraca nowy ciąg, którego reprezentacja binarna znajduje się w określonym formularzu normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2742">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-2743">Zwraca nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna jest zgodna z formą normalizacji Unicode C.</span><span class="sxs-lookup"><span data-stu-id="ba178-2743">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="ba178-2744">Nowy, znormalizowany ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale którego reprezentacja binarna jest w postaci C.</span><span class="sxs-lookup"><span data-stu-id="ba178-2744">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2745">Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2745">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ba178-2746">Na przykład dowolny z następujących punktów kodu może reprezentować literę "ắ":</span><span class="sxs-lookup"><span data-stu-id="ba178-2746">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ba178-2747">U+1EAF</span><span class="sxs-lookup"><span data-stu-id="ba178-2747">U+1EAF</span></span>  
  
-   <span data-ttu-id="ba178-2748">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ba178-2748">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ba178-2749">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ba178-2749">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ba178-2750">Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.</span><span class="sxs-lookup"><span data-stu-id="ba178-2750">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ba178-2751">W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2751">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ba178-2752">Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły.</span><span class="sxs-lookup"><span data-stu-id="ba178-2752">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ba178-2753">Platforma .NET obsługuje cztery formy normalizacji (C, D, KC i KD), które są zdefiniowane przez standard Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2753">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="ba178-2754">Gdy dwa ciągi są reprezentowane w tym samym formularzu normalizacji, można je porównać przy użyciu porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-2754">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ba178-2755">Aby znormalizować i porównać dwa ciągi, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="ba178-2755">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ba178-2756">Uzyskaj ciągi do porównania ze źródła danych wejściowych, takie jak plik lub urządzenie wejściowe użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ba178-2756">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ba178-2757">Wywołaj <xref:System.String.Normalize> metodę, aby znormalizować ciągi do normalizacji w postaci C.</span><span class="sxs-lookup"><span data-stu-id="ba178-2757">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>  
  
3.  <span data-ttu-id="ba178-2758">Aby porównać dwa ciągi, należy wywołać metodę, która obsługuje Porównywanie ciągów porządkowych, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> takie jak metoda, i podać <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> wartość lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argument.</span><span class="sxs-lookup"><span data-stu-id="ba178-2758">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ba178-2759">Aby posortować tablicę znormalizowanych ciągów, należy przekazać `comparer` <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> wartość lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2759">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ba178-2760">Emituj ciągi w posortowanych danych wyjściowych na podstawie kolejności wskazanej przez poprzedni krok.</span><span class="sxs-lookup"><span data-stu-id="ba178-2760">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ba178-2761">Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2761">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2762">Poniższy przykład normalizuje ciąg do każdego z czterech formularzy normalizacji, potwierdza, że ciąg został znormalizowany do określonego formularza normalizacji, a następnie wyświetla listę punktów kodu w znormalizowanym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2762">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2763">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2763">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2764"><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2764">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ba178-2765">W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda zgłosi <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />ale zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2765">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ba178-2766">Formularz normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2766">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ba178-2767">Zwraca nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna znajduje się w określonym formularzu normalizacji Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2767">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="ba178-2768">Nowy ciąg, którego wartość tekstowa jest taka sama jak ten ciąg, ale której reprezentacja binarna znajduje się w postaci normalizacji <paramref name="normalizationForm" /> określonej przez parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-2768">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2769">Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2769">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ba178-2770">Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.</span><span class="sxs-lookup"><span data-stu-id="ba178-2770">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ba178-2771">W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-2771">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ba178-2772">Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły.</span><span class="sxs-lookup"><span data-stu-id="ba178-2772">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ba178-2773">Platforma .NET obsługuje cztery formy normalizacji (C, D, KC i KD), które są zdefiniowane przez standard Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2773">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="ba178-2774">Gdy dwa ciągi są reprezentowane w tym samym formularzu normalizacji, można je porównać przy użyciu porównania porządkowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-2774">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ba178-2775">Aby znormalizować i porównać dwa ciągi, wykonaj następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="ba178-2775">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ba178-2776">Uzyskaj ciągi do porównania ze źródła danych wejściowych, takie jak plik lub urządzenie wejściowe użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ba178-2776">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ba178-2777">Wywołaj <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodę, aby znormalizować ciągi do określonego formularza normalizacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2777">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>  
  
3.  <span data-ttu-id="ba178-2778">Aby porównać dwa ciągi, należy wywołać metodę, która obsługuje Porównywanie ciągów porządkowych, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> takie jak metoda, i podać <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> wartość lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argument.</span><span class="sxs-lookup"><span data-stu-id="ba178-2778">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ba178-2779">Aby posortować tablicę znormalizowanych ciągów, należy przekazać `comparer` <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> wartość lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2779">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ba178-2780">Emituj ciągi w posortowanych danych wyjściowych na podstawie kolejności wskazanej przez poprzedni krok.</span><span class="sxs-lookup"><span data-stu-id="ba178-2780">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ba178-2781">Opis obsługiwanych formularzy normalizacji Unicode znajduje się w temacie <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2781">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2782">Poniższy przykład normalizuje ciąg do każdego z czterech formularzy normalizacji, potwierdza, że ciąg został znormalizowany do określonego formularza normalizacji, a następnie wyświetla listę punktów kodu w znormalizowanym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2782">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2783">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2783">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-2784"><see cref="Overload:System.String.IsNormalized" /> Metoda wraca<see langword="false" /> natychmiast po napotkaniu pierwszego nieznormalizowanego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2784">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ba178-2785">W związku z tym, jeśli ciąg zawiera znaki nieznormalizowane, po których następuje nieprawidłowe znaki Unicode <see cref="Overload:System.String.Normalize" /> , Metoda może zgłosić <see cref="T:System.ArgumentException" /> element <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />chociaż zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2785">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ba178-2786">Pierwszy ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2786">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ba178-2787">Drugi ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2787">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-2788">Określa, czy dwa określone ciągi mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-2788">Determines whether two specified strings have the same value.</span></span></summary>
        <returns><span data-ttu-id="ba178-2789"><see langword="true" />Jeśli wartość <paramref name="a" /> jest taka sama jak <paramref name="b" />wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2789"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2790">Metoda definiuje operację operatora równości <xref:System.String> dla klasy. <xref:System.String.op_Equality%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-2790">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="ba178-2791">Umożliwia to kod, taki jak pokazano w sekcji przykład.</span><span class="sxs-lookup"><span data-stu-id="ba178-2791">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="ba178-2792">Operator z kolei wywołuje metodę statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> , która wykonuje numer porządkowy (z uwzględnieniem wielkości liter i bez uwzględniania kultury).</span><span class="sxs-lookup"><span data-stu-id="ba178-2792">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2793">Kompilator Visual Basic nie rozpoznaje operatora równości jako wywołania <xref:System.String.op_Equality%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2793">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="ba178-2794">Zamiast tego operator równości zawija wywołanie <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2794">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2795">Poniższy przykład demonstruje operator równości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2795">The following example demonstrates the equality operator.</span></span>  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ba178-2796">Pierwszy ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2796">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ba178-2797">Drugi ciąg do porównania lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2797">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-2798">Określa, czy dwa określone ciągi mają różne wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2798">Determines whether two specified strings have different values.</span></span></summary>
        <returns><span data-ttu-id="ba178-2799"><see langword="true" />Jeśli wartość <paramref name="a" /> jest różna od <paramref name="b" />wartości; w przeciwnym razie, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2799"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2800">Metoda definiuje operację operatora nierówności <xref:System.String> dla klasy. <xref:System.String.op_Inequality%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-2800">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="ba178-2801">Umożliwia ona wykonywanie kodu, takiego jak pokazano w sekcji przykładów.</span><span class="sxs-lookup"><span data-stu-id="ba178-2801">It enables code such as that shown in the Examples section.</span></span>  
  
 <span data-ttu-id="ba178-2802">Operator z kolei wywołuje metodę statyczną <xref:System.String.Equals%28System.String%2CSystem.String%29> , która wykonuje porównanie porządkowe (z uwzględnieniem wielkości liter i bez uwzględniania kultury). <xref:System.String.op_Inequality%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-2802">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2803">Kompilator Visual Basic nie rozpoznaje operatora nierówności jako wywołania <xref:System.String.op_Inequality%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2803">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="ba178-2804">Zamiast tego operator nierówności otacza wywołanie <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-2804">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2805">Poniższy przykład demonstruje operator nierówności.</span><span class="sxs-lookup"><span data-stu-id="ba178-2805">The following example demonstrates the inequality operator.</span></span>  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2806">Zwraca nowy ciąg o określonej długości, w którym początek bieżącego ciągu jest uzupełniony spacjami lub z określonym znakiem Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2806">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ba178-2807">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2807">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ba178-2808">Zwraca nowy ciąg, który wyrównuje znaki w tym wystąpieniu przez uzupełnienie ich spacjami po lewej stronie, dla określonej całkowitej długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2808">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ba178-2809">Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i uzupełniony po lewej stronie z dowolną liczbą spacji, aby utworzyć długość <paramref name="totalWidth" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2809">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ba178-2810">Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2810">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ba178-2811">Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2811">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2812">Przestrzeń Unicode jest definiowana jako szesnastkowy 0x0020.</span><span class="sxs-lookup"><span data-stu-id="ba178-2812">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ba178-2813"><xref:System.String.PadLeft%28System.Int32%29> Metoda określa początek zwracanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2813">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ba178-2814">Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, w odpowiedniej części ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2814">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2815"><xref:System.String.PadLeft%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2815">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2816">Zamiast tego zwraca nowy ciąg, który jest uzupełniony wiodącym białym znakiem, tak aby łączna długość była `totalWidth` znakiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2816">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2817">Poniższy przykład demonstruje <xref:System.String.PadLeft%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2817">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2818"><paramref name="totalWidth" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2818"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ba178-2819">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2819">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ba178-2820">Znak uzupełniania Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2820">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ba178-2821">Zwraca nowy ciąg, który wyrównuje znaki w tym wystąpieniu przez uzupełnienie ich po lewej stronie z określonym znakiem Unicode, dla określonej całkowitej długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2821">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ba178-2822">Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i uzupełniony po lewej stronie o <paramref name="paddingChar" /> tyle znaków, ile jest potrzebnych do utworzenia <paramref name="totalWidth" />długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2822">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ba178-2823">Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2823">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ba178-2824">Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2824">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2825"><xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Metoda określa początek zwracanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2825">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ba178-2826">Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, w odpowiedniej części ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2826">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2827"><xref:System.String.PadLeft%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2827">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2828">Zamiast tego zwraca nowy ciąg, który jest uzupełniony znakami wiodącymi `paddingChar` , tak aby łączna długość była `totalWidth` znakami.</span><span class="sxs-lookup"><span data-stu-id="ba178-2828">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2829">Poniższy przykład demonstruje <xref:System.String.PadLeft%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2829">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2830"><paramref name="totalWidth" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2830"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2831">Zwraca nowy ciąg o określonej długości, w którym koniec bieżącego ciągu jest uzupełniony spacjami lub z określonym znakiem Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2831">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ba178-2832">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2832">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ba178-2833">Zwraca nowy ciąg, który wyrównuje znaki w tym ciągu przez uzupełnienie ich spacjami po prawej stronie, dla określonej całkowitej długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2833">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ba178-2834">Nowy ciąg, który jest równoznaczny z tym wystąpieniem, ale wyrównany do lewej i uzupełniony po prawej stronie z dowolną liczbą spacji, aby utworzyć długość <paramref name="totalWidth" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2834">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ba178-2835">Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2835">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ba178-2836">Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2836">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2837">Przestrzeń Unicode jest definiowana jako szesnastkowy 0x0020.</span><span class="sxs-lookup"><span data-stu-id="ba178-2837">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ba178-2838"><xref:System.String.PadRight%28System.Int32%29> Metoda określa koniec zwracanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2838">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ba178-2839">Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, po lewej stronie ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2839">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2840"><xref:System.String.PadRight%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2840">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2841">Zamiast tego zwraca nowy ciąg, który zostanie uzupełniony końcowym białym znakiem, tak aby jego łączna długość była `totalWidth` znakami.</span><span class="sxs-lookup"><span data-stu-id="ba178-2841">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2842">Poniższy przykład demonstruje <xref:System.String.PadRight%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2842">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2843"><paramref name="totalWidth" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2843"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ba178-2844">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2844">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ba178-2845">Znak uzupełniania Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2845">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ba178-2846">Zwraca nowy ciąg, który wyrównuje znaki w tym ciągu przez uzupełnienie ich po prawej stronie z określonym znakiem Unicode, dla określonej całkowitej długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2846">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ba178-2847">Nowy ciąg, który jest równoważny z tym wystąpieniem, ale wyrównany do lewej i uzupełniony po prawej stronie o <paramref name="paddingChar" /> tyle znaków, ile jest potrzebnych do utworzenia <paramref name="totalWidth" />długości.</span><span class="sxs-lookup"><span data-stu-id="ba178-2847">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ba178-2848">Jeśli <paramref name="totalWidth" /> jednak wartość jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2848">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ba178-2849">Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest identyczny z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2849">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2850"><xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Metoda określa koniec zwracanego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2850">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ba178-2851">Oznacza to, że w przypadku korzystania z języków pisanych od prawej do lewej, po lewej stronie ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2851">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2852"><xref:System.String.PadRight%2A> Jeśli metoda jest konsolą bieżącego wystąpienia z znakami odstępu, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2852">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2853">Zamiast tego zwraca nowy ciąg, który jest uzupełniony `paddingChar` znakami końcowymi, tak aby łączna długość była `totalWidth` znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2853">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2854">Poniższy przykład demonstruje <xref:System.String.PadRight%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2854">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2855"><paramref name="totalWidth" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2855"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2856">Zwraca nowy ciąg, w którym usunięto określoną liczbę znaków z bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2856">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-2857">Pozycja od zera, aby rozpocząć usuwanie znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2857">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="ba178-2858">Zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu, zaczynając od określonej pozycji i kontynuując ostatnią pozycję, zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="ba178-2858">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ba178-2859">Nowy ciąg, który jest odpowiednikiem tego ciągu, z wyjątkiem usuniętych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2859">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2860">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]W, ciągi są zależne od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2860">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ba178-2861">Wartość `startIndex` parametru może być z zakresu od zera do jednego mniejszego niż długość wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2861">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2862">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2862">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2863">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki od pozycji `startIndex` do końca oryginalnego ciągu zostały usunięte.</span><span class="sxs-lookup"><span data-stu-id="ba178-2863">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2864">Poniższy przykład demonstruje <xref:System.String.Remove%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-2864">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="ba178-2865">W następnym przypadku tekst jest usuwany od określonego indeksu do końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2865">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="ba178-2866">Ostatni przypadek usuwa trzy znaki Zaczynając od określonego indeksu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2866">The last case removes three characters starting from the specified index.</span></span>  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2867"><paramref name="startIndex" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2867"><paramref name="startIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-2868">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2868">-or-</span></span> 
 <span data-ttu-id="ba178-2869"><paramref name="startIndex" />Określa pozycję, która nie znajduje się w tym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2869"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-2870">Pozycja od zera, aby rozpocząć usuwanie znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2870">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-2871">Liczba znaków do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2871">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="ba178-2872">Zwraca nowy ciąg, w którym usunięto określoną liczbę znaków w bieżącym wystąpieniu rozpoczynającym się w określonej pozycji.</span><span class="sxs-lookup"><span data-stu-id="ba178-2872">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ba178-2873">Nowy ciąg, który jest odpowiednikiem tego wystąpienia, z wyjątkiem usuniętych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2873">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2874">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]W, ciągi są zależne od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2874">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ba178-2875">Wartość `startIndex` parametru może być z zakresu od zera do jednego mniejszego niż długość wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2875">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2876">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2876">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2877">Zamiast tego zwraca nowy ciąg, w którym liczba znaków określona przez `count` parametr został usunięty.</span><span class="sxs-lookup"><span data-stu-id="ba178-2877">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="ba178-2878">Znaki są usuwane na pozycji określonej przez `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="ba178-2878">The characters are removed at the position specified by `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2879">W poniższym przykładzie pokazano, jak usunąć nazwę środkową z pełnej nazwy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2879">The following example demonstrates how you can remove the middle name from a complete name.</span></span>  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-2880"><paramref name="startIndex" /> Albo<paramref name="count" /> jest mniejsze od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-2880">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-2881">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-2881">-or-</span></span> 
 <span data-ttu-id="ba178-2882"><paramref name="startIndex" />Plus <paramref name="count" /> określ pozycję poza tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2882"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2883">Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego znaku Unicode lub <see cref="T:System.String" /> w bieżącym ciągu są zamieniane na inny określony znak Unicode lub. <see cref="T:System.String" /></span><span class="sxs-lookup"><span data-stu-id="ba178-2883">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="ba178-2884">Znak Unicode, który ma zostać zastąpiony.</span><span class="sxs-lookup"><span data-stu-id="ba178-2884">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="ba178-2885">Znak Unicode, aby zastąpić wszystkie wystąpienia <paramref name="oldChar" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2885">The Unicode character to replace all occurrences of <paramref name="oldChar" />.</span></span></param>
        <summary><span data-ttu-id="ba178-2886">Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego znaku Unicode w tym wystąpieniu są zamieniane na inny określony znak Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2886">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="ba178-2887">Ciąg, który jest odpowiednikiem tego wystąpienia, z tą różnicą <paramref name="oldChar" /> , że wszystkie <paramref name="newChar" />wystąpienia programu są zastępowane przez.</span><span class="sxs-lookup"><span data-stu-id="ba178-2887">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="ba178-2888">Jeśli <paramref name="oldChar" /> nie można odnaleźć w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-2888">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2889">Ta metoda wykonuje wyszukiwanie w liczbie porządkowej (uwzględniając `oldChar`wielkość liter i bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="ba178-2889">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2890">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2890">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2891">Zamiast tego zwraca nowy ciąg, w którym wszystkie wystąpienia `oldChar` są zastępowane przez. `newChar`</span><span class="sxs-lookup"><span data-stu-id="ba178-2891">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>  
  
 <span data-ttu-id="ba178-2892">Ponieważ ta metoda zwraca zmodyfikowany ciąg, można połączyć kolejne wywołania <xref:System.String.Replace%2A> metody, aby wykonać wiele zamian w oryginalnym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2892">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ba178-2893">Wywołania metod są wykonywane od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2893">Method calls are executed from left to right.</span></span> <span data-ttu-id="ba178-2894">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="ba178-2894">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2895">Poniższy przykład tworzy listę wartości rozdzielanych przecinkami przez podstawianie przecinków dla pustych danych między serią cyfr.</span><span class="sxs-lookup"><span data-stu-id="ba178-2895">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="ba178-2896">Ciąg, który ma zostać zastąpiony.</span><span class="sxs-lookup"><span data-stu-id="ba178-2896">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="ba178-2897">Ciąg, w którym mają zostać zamienione <paramref name="oldValue" />wszystkie wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2897">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <summary><span data-ttu-id="ba178-2898">Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego ciągu w bieżącym wystąpieniu są zastępowane innym określonym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="ba178-2898">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-2899">Ciąg, który jest odpowiednikiem bieżącego ciągu, z wyjątkiem tego, że <paramref name="oldValue" /> wszystkie wystąpienia są <paramref name="newValue" />zastępowane przez.</span><span class="sxs-lookup"><span data-stu-id="ba178-2899">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="ba178-2900">Jeśli <paramref name="oldValue" /> nie można odnaleźć w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-2900">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2901">Jeśli `newValue` jest `null` ,wszystkie`oldValue` wystąpienia są usuwane.</span><span class="sxs-lookup"><span data-stu-id="ba178-2901">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-2902">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-2902">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-2903">Zamiast tego zwraca nowy ciąg, w którym wszystkie wystąpienia `oldValue` są zastępowane przez. `newValue`</span><span class="sxs-lookup"><span data-stu-id="ba178-2903">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>  
  
 <span data-ttu-id="ba178-2904">Ta metoda wykonuje wyszukiwanie w liczbie porządkowej (uwzględniając `oldValue`wielkość liter i bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="ba178-2904">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>  
  
 <span data-ttu-id="ba178-2905">Ponieważ ta metoda zwraca zmodyfikowany ciąg, można połączyć kolejne wywołania <xref:System.String.Replace%2A> metody, aby wykonać wiele zamian w oryginalnym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2905">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ba178-2906">Wywołania metod są wykonywane od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2906">Method calls are executed from left to right.</span></span> <span data-ttu-id="ba178-2907">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="ba178-2907">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ba178-2908">W poniższym przykładzie pokazano, <xref:System.String.Replace%2A> jak można użyć metody w celu naprawienia błędu pisowni.</span><span class="sxs-lookup"><span data-stu-id="ba178-2908">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-2909"><paramref name="oldValue" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2909"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-2910"><paramref name="oldValue" />jest ciągiem pustym ("").</span><span class="sxs-lookup"><span data-stu-id="ba178-2910"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-2911">Zwraca tablicę ciągów zawierającą podciągi w tym wystąpieniu, które są ograniczone przez elementy określonego ciągu lub tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-2911">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2912"><xref:System.String.Split%2A>służy do dzielenia ciągu rozdzielonego na podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2912"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="ba178-2913">Można użyć tablicy znaków, aby określić zero, jeden lub wiele znaków ograniczających ( <xref:System.String.Split%28System.Char%5B%5D%29> Metoda) lub użyć tablicy znakowej, aby określić zero, jeden lub wiele ciągów, które mają być ograniczone.</span><span class="sxs-lookup"><span data-stu-id="ba178-2913">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="ba178-2914">Przeciążenia metody pozwalają ograniczyć liczbę podciągów zwracanych przez metodę <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> (Metoda), aby określić, czy puste ciągi są zawarte w zwracanych podciągach ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodach lub <xref:System.String.Split%2A> Aby wykonać obie metody ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> ).</span><span class="sxs-lookup"><span data-stu-id="ba178-2914">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a><span data-ttu-id="ba178-2915">Alternatywy dla ciągu. Split</span><span class="sxs-lookup"><span data-stu-id="ba178-2915">Alternatives to String.Split</span></span>

 <span data-ttu-id="ba178-2916"><xref:System.String.Split%2A> Metoda nie zawsze jest najlepszym sposobem na rozbicie rozdzielanego ciągu na podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2916">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="ba178-2917">Jeśli nie chcesz wyodrębnić wszystkich podciągów z rozdzielonym ciągiem lub jeśli chcesz przeanalizować ciąg na podstawie wzorca zamiast zestawu znaków ogranicznika, weź pod uwagę następujące alternatywy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2917">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
### <a name="regular-expressions"></a><span data-ttu-id="ba178-2918">Wyrażenia regularne</span><span class="sxs-lookup"><span data-stu-id="ba178-2918">Regular expressions</span></span>  
 <span data-ttu-id="ba178-2919">Jeśli ciągi są zgodne ze stałym wzorcem, można użyć wyrażenia regularnego, aby wyodrębnić i obsłużyć ich elementy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2919">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="ba178-2920">Na przykład, jeśli ciągi przyjmują postać "\*\* \*\* *numer*operandu numeru" można użyć [wyrażenia regularnego](~/docs/standard/base-types/regular-expressions.md) , aby wyodrębnić i obsłużyć elementy ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2920">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="ba178-2921">Oto przykład:</span><span class="sxs-lookup"><span data-stu-id="ba178-2921">Here's an example:</span></span>  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="ba178-2922">Wzorzec `(\d+)\s+([-+*/])\s+(\d+)` wyrażenia regularnego jest zdefiniowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-2922">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="ba178-2923">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="ba178-2923">Pattern</span></span>|<span data-ttu-id="ba178-2924">Opis</span><span class="sxs-lookup"><span data-stu-id="ba178-2924">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="ba178-2925">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2925">Match one or more decimal digits.</span></span> <span data-ttu-id="ba178-2926">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2926">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ba178-2927">Dopasowuje co najmniej jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2927">Match one or more white-space characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="ba178-2928">Dopasowuje znak operatora arytmetycznego (+,-, \* lub/).</span><span class="sxs-lookup"><span data-stu-id="ba178-2928">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="ba178-2929">Jest to druga grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2929">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ba178-2930">Dopasowuje co najmniej jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2930">Match one or more white-space characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="ba178-2931">Dopasowanie do co najmniej jednej cyfry dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="ba178-2931">Match one or more decimal digits.</span></span> <span data-ttu-id="ba178-2932">Jest to trzecia grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2932">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="ba178-2933">Możesz również użyć wyrażenia regularnego, aby wyodrębnić podciągi z ciągu na podstawie wzorca, a nie stałego zestawu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2933">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="ba178-2934">Jest to typowy scenariusz, gdy występuje jeden z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="ba178-2934">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="ba178-2935">Co najmniej jeden znak ogranicznika nie zawsze pełni rolę ogranicznika w <xref:System.String> wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2935">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ba178-2936">Sekwencja i liczba znaków ogranicznika są zmienne lub nieznane.</span><span class="sxs-lookup"><span data-stu-id="ba178-2936">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="ba178-2937">Na przykład <xref:System.String.Split%2A> Metoda nie może być używana do dzielenia poniższego ciągu, ponieważ `\n` liczba znaków (in C#) lub `vbCrLf` (w Visual Basic) jest zmienna i nie zawsze są one ogranicznikami.</span><span class="sxs-lookup"><span data-stu-id="ba178-2937">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 <span data-ttu-id="ba178-2938">Wyrażenie regularne może łatwo podzielić ten ciąg, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2938">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="ba178-2939">Wzorzec `\[([^\[\]]+)\]` wyrażenia regularnego jest zdefiniowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-2939">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="ba178-2940">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="ba178-2940">Pattern</span></span>|<span data-ttu-id="ba178-2941">Opis</span><span class="sxs-lookup"><span data-stu-id="ba178-2941">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="ba178-2942">Dopasowuje nawias otwierający.</span><span class="sxs-lookup"><span data-stu-id="ba178-2942">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="ba178-2943">Dopasowuje dowolny znak, który nie jest otwierającym lub zamykającym nawiasem jeden lub więcej razy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2943">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="ba178-2944">Jest to pierwsza grupa przechwytywania.</span><span class="sxs-lookup"><span data-stu-id="ba178-2944">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="ba178-2945">Dopasowuje nawias zamykający.</span><span class="sxs-lookup"><span data-stu-id="ba178-2945">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="ba178-2946">Metoda jest niemal identyczna z <xref:System.String.Split%2A?displayProperty=nameWithType>, z tą różnicą, że dzieli ciąg na podstawie wzorca wyrażenia regularnego zamiast stałego zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ba178-2946">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="ba178-2947">Na przykład poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metody, aby podzielić ciąg, który zawiera podciągi rozdzielone różnymi kombinacjami łączników i innych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2947">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="ba178-2948">Wzorzec `\s-\s?[+*]?\s?-\s` wyrażenia regularnego jest zdefiniowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-2948">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="ba178-2949">Wzorzec</span><span class="sxs-lookup"><span data-stu-id="ba178-2949">Pattern</span></span>|<span data-ttu-id="ba178-2950">Opis</span><span class="sxs-lookup"><span data-stu-id="ba178-2950">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="ba178-2951">Dopasowuje znak odstępu, po którym następuje łącznik.</span><span class="sxs-lookup"><span data-stu-id="ba178-2951">Match a white-space character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="ba178-2952">Dopasowuje zero lub jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2952">Match zero or one white-space character.</span></span>|  
|`[+*]?`|<span data-ttu-id="ba178-2953">Dopasowanie do zera lub jednego wystąpienia znaku + lub \*.</span><span class="sxs-lookup"><span data-stu-id="ba178-2953">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="ba178-2954">Dopasowuje zero lub jeden znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2954">Match zero or one white-space character.</span></span>|  
|`-\s`|<span data-ttu-id="ba178-2955">Dopasowuje łącznik po którym następuje znak odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2955">Match a hyphen followed by a white-space character.</span></span>|  
  
### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="ba178-2956">Metody wyszukiwania i Metoda substring</span><span class="sxs-lookup"><span data-stu-id="ba178-2956">Search methods and the Substring method</span></span>  
 <span data-ttu-id="ba178-2957">Jeśli nie interesują Cię wszystkie podciągi w ciągu, być może wolisz pracować z jedną z metod porównywania ciągów, która zwraca indeks, w którym rozpoczyna się dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2957">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="ba178-2958">Następnie można wywołać <xref:System.String.Substring%2A> metodę, aby wyodrębnić żądany podciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-2958">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="ba178-2959">Metody porównywania ciągów obejmują:</span><span class="sxs-lookup"><span data-stu-id="ba178-2959">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="ba178-2960"><xref:System.String.IndexOf%2A>, która zwraca indeks (liczony od zera) pierwszego wystąpienia znaku lub ciągu w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2960"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ba178-2961"><xref:System.String.IndexOfAny%2A>, która zwraca indeks (liczony od zera) w bieżącym wystąpieniu ciągu pierwszego wystąpienia dowolnego znaku w tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2961"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="ba178-2962"><xref:System.String.LastIndexOf%2A>, która zwraca indeks (liczony od zera) ostatniego wystąpienia znaku lub ciągu w wystąpieniu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2962"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ba178-2963"><xref:System.String.LastIndexOfAny%2A>, która zwraca indeks (liczony od zera) w bieżącym wystąpieniu ciągu ostatniego wystąpienia dowolnego znaku w tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-2963"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="ba178-2964">W poniższym przykładzie zastosowano <xref:System.String.IndexOf%2A> metodę, aby znaleźć okresy w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-2964">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="ba178-2965">Następnie używa <xref:System.String.Substring%2A> metody do zwracania pełnych zdań.</span><span class="sxs-lookup"><span data-stu-id="ba178-2965">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-2966">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2966">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-2967">Dzieli ciąg na podciągi, które są oparte na znakach w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2967">Splits a string into substrings that are based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ba178-2968">Tablica, której elementy zawierają podciągi z tego wystąpienia, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-2968">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-2969">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2969">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-2970">Jeśli ciąg jest rozdzielany przez znany zestaw znaków, można użyć <xref:System.String.Split%28System.Char%5B%5D%29> metody, aby oddzielić ją na podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-2970">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span>   
  
### <a name="return-value-details"></a><span data-ttu-id="ba178-2971">Szczegóły wartości zwracanej</span><span class="sxs-lookup"><span data-stu-id="ba178-2971">Return value details</span></span>  
 <span data-ttu-id="ba178-2972">Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-2972">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="ba178-2973">Na przykład, jeśli tablica separatora zawiera znak "-", a wartość bieżącego wystąpienia ciągu to "AA-BB-CC", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".</span><span class="sxs-lookup"><span data-stu-id="ba178-2973">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ba178-2974">Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-2974">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ba178-2975">Każdy element `separator` definiuje oddzielny znak ogranicznika.</span><span class="sxs-lookup"><span data-stu-id="ba178-2975">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ba178-2976">Jeśli dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element w zwracanej tablicy zawiera <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="ba178-2976">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty>.</span></span> <span data-ttu-id="ba178-2977">Oto kilka przykładów:</span><span class="sxs-lookup"><span data-stu-id="ba178-2977">Here are some examples:</span></span>  
  
|<span data-ttu-id="ba178-2978">Wartość ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-2978">String value</span></span>|<span data-ttu-id="ba178-2979">Separator</span><span class="sxs-lookup"><span data-stu-id="ba178-2979">Separator</span></span>|<span data-ttu-id="ba178-2980">Tablica zwrócona</span><span class="sxs-lookup"><span data-stu-id="ba178-2980">Returned array</span></span>|  
|------------------|---------------|--------------------|  
|<span data-ttu-id="ba178-2981">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ba178-2981">"42, 12, 19"</span></span>|<span data-ttu-id="ba178-2982">New Char [] {', ', ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-2982">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ba178-2983">Char () = {"," c, "" c}) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-2983">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="ba178-2984">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ba178-2984">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ba178-2985">"42.. 12.. 19"</span><span class="sxs-lookup"><span data-stu-id="ba178-2985">"42..12..19"</span></span>|<span data-ttu-id="ba178-2986">nowy znak [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="ba178-2986">new Char[] {'.'}</span></span> <span data-ttu-id="ba178-2987">(C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-2987">(C#)</span></span><br /><br /> <span data-ttu-id="ba178-2988">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-2988">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ba178-2989">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ba178-2989">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ba178-2990">Banan</span><span class="sxs-lookup"><span data-stu-id="ba178-2990">"Banana"</span></span>|<span data-ttu-id="ba178-2991">nowy znak [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="ba178-2991">new Char[] {'.'}</span></span> <span data-ttu-id="ba178-2992">(C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-2992">(C#)</span></span><br /><br /> <span data-ttu-id="ba178-2993">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-2993">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ba178-2994">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ba178-2994">{"Banana"}</span></span>|  
|<span data-ttu-id="ba178-2995">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-2995">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ba178-2996">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-2996">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ba178-2997">New Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-2997">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ba178-2998">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-2998">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ba178-2999">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ba178-2999">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ba178-3000">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3000">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3001">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3001">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ba178-3002">null (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3002">null (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3003">Nothing (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3003">Nothing (Visual Basic)</span></span>|<span data-ttu-id="ba178-3004">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3004">{"Darb", "Smarba"}</span></span>|  
  
### <a name="the-separator-array"></a><span data-ttu-id="ba178-3005">Tablica separatorów</span><span class="sxs-lookup"><span data-stu-id="ba178-3005">The separator array</span></span>  
 <span data-ttu-id="ba178-3006">Każdy element separatora definiuje oddzielny ogranicznik, który składa się z pojedynczego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-3006">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ba178-3007">Jeśli argument ma `null` lub nie zawiera znaków, Metoda traktuje znaki odstępu jako ograniczniki. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3007">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="ba178-3008">Znaki odstępu są definiowane przez standard Unicode; zwracają `true` one<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> , jeśli są przesyłane do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3008">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="ba178-3009">Ciąg. Split (Char []) i rozwiązanie przeciążenia kompilatora</span><span class="sxs-lookup"><span data-stu-id="ba178-3009">String.Split(Char[]) and compiler overload resolution</span></span>  
 <span data-ttu-id="ba178-3010">Chociaż pojedynczy parametr dla tego przeciążenia <xref:System.String.Split%2A?displayProperty=nameWithType> jest tablicą znaków, można wywołać ją z pojedynczym znakiem, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3010">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 <span data-ttu-id="ba178-3011">Ponieważ parametr ma <xref:System.ParamArrayAttribute> atrybut, kompilatory interpretują pojedynczy znak jako jednoelementowy tablicę znaków. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3011">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="ba178-3012">W przypadku innych <xref:System.String.Split%2A?displayProperty=nameWithType> przeciążeń, które `separator` zawierają parametr; należy jawnie przekazać te przeciążenia tablicę znakową jako `separator` argument.</span><span class="sxs-lookup"><span data-stu-id="ba178-3012">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>  
  
### <a name="comparison-details"></a><span data-ttu-id="ba178-3013">Szczegóły porównania</span><span class="sxs-lookup"><span data-stu-id="ba178-3013">Comparison details</span></span>  
 <span data-ttu-id="ba178-3014">Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków `separator` w tablicy, i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%28System.Char%5B%5D%29></span><span class="sxs-lookup"><span data-stu-id="ba178-3014">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ba178-3015"><xref:System.String.Split%28System.Char%5B%5D%29> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-3015">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ba178-3016">Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3016">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3017">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3017">Performance Considerations</span></span>  
 <span data-ttu-id="ba178-3018">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3018">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3019">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, należy rozważyć <xref:System.String.IndexOf%2A> użycie <xref:System.String.IndexOfAny%2A> metody lub.</span><span class="sxs-lookup"><span data-stu-id="ba178-3019">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="ba178-3020">Istnieje również możliwość użycia <xref:System.String.Compare%2A> metody do lokalizowania podciągu w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3020">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3021">Aby podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3021">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3022">Aby podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3022">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3023">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3023">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3024">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3024">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3025">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3025">This significantly reduces the additional overhead of each method call.</span></span>  
  
## Examples  
 <span data-ttu-id="ba178-3026">Poniższy przykład ilustruje sposób wyodrębniania pojedynczych wyrazów z bloku tekstu przez traktowanie białych znaków i interpunkcji jako ograniczników.</span><span class="sxs-lookup"><span data-stu-id="ba178-3026">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="ba178-3027">Tablica znaków przeniesiona do `separator` parametru <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody składa się z znaku spacji i znaku tabulacji wraz z niektórymi typowymi symbolami interpunkcji.</span><span class="sxs-lookup"><span data-stu-id="ba178-3027">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3028"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3028">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3029">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3029">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-3030">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3030">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-3031">Maksymalna liczba podciągów do zwrócenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3031">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="ba178-3032">Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3032">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="ba178-3033">Należy również określić maksymalną liczbę podciągów do zwrócenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3033">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="ba178-3034">Tablica, której elementy zawierają podciągi w tym wystąpieniu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3034">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-3035">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3035">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3036">Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3036">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ba178-3037">Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3037">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ba178-3038">Jeśli `count` jest równa zero, zwracana jest pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="ba178-3038">If `count` is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ba178-3039">Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3039">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ba178-3040">Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3040">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba178-3041">Każdy element `separator` definiuje oddzielny znak ogranicznika.</span><span class="sxs-lookup"><span data-stu-id="ba178-3041">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ba178-3042">Jeśli dwa ograniczniki są przyległe lub ogranicznik jest znaleziony na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="ba178-3042">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ba178-3043">Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3043">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ba178-3044">Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-3044">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
 <span data-ttu-id="ba178-3045">W poniższej tabeli przedstawiono przykłady.</span><span class="sxs-lookup"><span data-stu-id="ba178-3045">The following table provides examples.</span></span>  
  
|<span data-ttu-id="ba178-3046">Wartość ciągu</span><span class="sxs-lookup"><span data-stu-id="ba178-3046">String value</span></span>|<span data-ttu-id="ba178-3047">Separator</span><span class="sxs-lookup"><span data-stu-id="ba178-3047">Separator</span></span>|<span data-ttu-id="ba178-3048">Count</span><span class="sxs-lookup"><span data-stu-id="ba178-3048">Count</span></span>|<span data-ttu-id="ba178-3049">Tablica zwrócona</span><span class="sxs-lookup"><span data-stu-id="ba178-3049">Returned array</span></span>|  
|------------------|---------------|-----------|--------------------|  
|<span data-ttu-id="ba178-3050">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ba178-3050">"42, 12, 19"</span></span>|<span data-ttu-id="ba178-3051">New Char [] {', ', ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3051">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3052">Char () = {"," c, "" c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3052">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="ba178-3053">2</span><span class="sxs-lookup"><span data-stu-id="ba178-3053">2</span></span>|<span data-ttu-id="ba178-3054">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3054">{"42", " 12, 19"}</span></span>|  
|<span data-ttu-id="ba178-3055">"42.. 12.. 19"</span><span class="sxs-lookup"><span data-stu-id="ba178-3055">"42..12..19"</span></span>|<span data-ttu-id="ba178-3056">nowy znak [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="ba178-3056">new Char[] {'.'}</span></span> <span data-ttu-id="ba178-3057">(C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3057">(C#)</span></span><br /><br /> <span data-ttu-id="ba178-3058">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3058">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ba178-3059">4</span><span class="sxs-lookup"><span data-stu-id="ba178-3059">4</span></span>|<span data-ttu-id="ba178-3060">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3060">{"42", "", "12", ".19"}</span></span>|  
|<span data-ttu-id="ba178-3061">Banan</span><span class="sxs-lookup"><span data-stu-id="ba178-3061">"Banana"</span></span>|<span data-ttu-id="ba178-3062">nowy znak [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="ba178-3062">new Char[] {'.'}</span></span> <span data-ttu-id="ba178-3063">(C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3063">(C#)</span></span><br /><br /> <span data-ttu-id="ba178-3064">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3064">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ba178-3065">2</span><span class="sxs-lookup"><span data-stu-id="ba178-3065">2</span></span>|<span data-ttu-id="ba178-3066">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3066">{"Banana"}</span></span>|  
|<span data-ttu-id="ba178-3067">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3067">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3068">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3068">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ba178-3069">New Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3069">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3070">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3070">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ba178-3071">1</span><span class="sxs-lookup"><span data-stu-id="ba178-3071">1</span></span>|<span data-ttu-id="ba178-3072">{"Darb\nSmarba"} (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3072">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3073">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3073">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|  
|<span data-ttu-id="ba178-3074">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3074">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3075">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3075">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ba178-3076">New Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3076">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3077">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="ba178-3077">Char() = Nothing</span></span>|<span data-ttu-id="ba178-3078">2</span><span class="sxs-lookup"><span data-stu-id="ba178-3078">2</span></span>|<span data-ttu-id="ba178-3079">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3079">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ba178-3080">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3080">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3081">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ba178-3081">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ba178-3082">New Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ba178-3082">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ba178-3083">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="ba178-3083">Char() = Nothing</span></span>|<span data-ttu-id="ba178-3084">100</span><span class="sxs-lookup"><span data-stu-id="ba178-3084">100</span></span>|<span data-ttu-id="ba178-3085">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ba178-3085">{"Darb", "Smarba"}</span></span>|  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3086">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3086">Performance Considerations</span></span>  
 <span data-ttu-id="ba178-3087">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3087">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3088">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3088">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3089">W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3089">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3090">W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3090">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3091">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3091">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3092">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3092">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3093">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3093">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3094">Poniższy przykład ilustruje `count` wpływ liczby ciągów zwracanych przez <xref:System.String.Split%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba178-3094">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3095"><paramref name="count" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-3095"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3096"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3096">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3097">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3097">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-3098">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3098">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-3099"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3099"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ba178-3100">Dzieli ciąg na podciągi w oparciu o znaki w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3100">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="ba178-3101">Można określić, czy podciągi mają zawierać puste elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3101">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ba178-3102">Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3102">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-3103">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3103">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a><span data-ttu-id="ba178-3104">Szczegóły wartości zwracanej</span><span class="sxs-lookup"><span data-stu-id="ba178-3104">Return value details</span></span>  
 <span data-ttu-id="ba178-3105">Znaki ogranicznika (znaki w `separator` tablicy) nie są uwzględniane w elementach zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3105">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="ba178-3106">Na przykład, jeśli `separator` tablica zawiera znak "-", a wartość bieżącego wystąpienia ciągu to "AA-BB-CC", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".</span><span class="sxs-lookup"><span data-stu-id="ba178-3106">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ba178-3107">Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3107">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ba178-3108">Jeśli parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, metoda zwraca pustą tablicę. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3108">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ba178-3109">Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z pojedynczego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-3109">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ba178-3110">Jeśli argument jest <xref:System.StringSplitOptions.None>, a dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3110">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-3111">Na przykład, jeśli `separator` zawiera dwa elementy, "-" i "\_", wartość wystąpienia ciągu to "-\_AA `options` -\_", a wartość argumentu to <xref:System.StringSplitOptions.None>, metoda zwraca tablicę ciągów z pięć następujących elementów:</span><span class="sxs-lookup"><span data-stu-id="ba178-3111">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ba178-3112"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg poprzedzający znak "-" pod indeksem 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-3112"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>  
  
2.  <span data-ttu-id="ba178-3113"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między znakiem "-" w indeksie 0 i znak "_" pod indeksem 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3113"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>  
  
3.  <span data-ttu-id="ba178-3114">"AA",</span><span class="sxs-lookup"><span data-stu-id="ba178-3114">"aa",</span></span>  
  
4.  <span data-ttu-id="ba178-3115"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po znaku "_" przy indeksie 4.</span><span class="sxs-lookup"><span data-stu-id="ba178-3115"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>  
  
5.  <span data-ttu-id="ba178-3116"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po znaku "-" pod indeksem 5.</span><span class="sxs-lookup"><span data-stu-id="ba178-3116"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ba178-3117">Tablica separatorów</span><span class="sxs-lookup"><span data-stu-id="ba178-3117">The separator array</span></span>  
 <span data-ttu-id="ba178-3118">Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3118">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ba178-3119">Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3119">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba178-3120">Jeśli parametr w wywołaniu tego przeciążenia metody jest `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3120">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ba178-3121">Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3121">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ba178-3122">W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3122">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a><span data-ttu-id="ba178-3123">Szczegóły porównania</span><span class="sxs-lookup"><span data-stu-id="ba178-3123">Comparison details</span></span>  
 <span data-ttu-id="ba178-3124">Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden znak `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3124">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ba178-3125"><xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-3125">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ba178-3126">Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3126">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3127">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3127">Performance Considerations</span></span>  
 <span data-ttu-id="ba178-3128">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3128">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3129">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3129">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3130">W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3130">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3131">W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3131">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3132">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3132">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3133">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3133">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3134">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3134">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3135">Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3135">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-3136"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-3136"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3137"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3137">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3138">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3138">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-3139">Tablica ciągów, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3139">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-3140"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3140"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ba178-3141">Dzieli ciąg na podciągi na podstawie ciągów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3141">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="ba178-3142">Można określić, czy podciągi mają zawierać puste elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3142">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ba178-3143">Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3143">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-3144">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3144">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3145">Jeśli ciąg jest rozdzielany przez znany zestaw ciągów, można użyć <xref:System.String.Split%2A> metody, aby oddzielić ją na podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3145">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>  
  
### <a name="return-value-details"></a><span data-ttu-id="ba178-3146">Szczegóły wartości zwracanej</span><span class="sxs-lookup"><span data-stu-id="ba178-3146">Return value details</span></span>  
 <span data-ttu-id="ba178-3147">Ciągi ograniczników nie są uwzględniane w elementach zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3147">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="ba178-3148">Na przykład, jeśli `separator` tablica zawiera ciąg "--", a wartość bieżącego wystąpienia ciągu to "AA--BB-DW", metoda zwraca tablicę zawierającą trzy elementy: "AA", "bb" i "CC".</span><span class="sxs-lookup"><span data-stu-id="ba178-3148">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ba178-3149">Jeśli to wystąpienie nie zawiera żadnych ciągów w `separator`, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3149">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ba178-3150">Jeśli parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, metoda zwraca pustą tablicę. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3150">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ba178-3151">Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z co najmniej jednego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-3151">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ba178-3152">Jeśli argument jest <xref:System.StringSplitOptions.None>, a dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3152">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-3153">Na przykład, jeśli `separator` zawiera dwa elementy, "-" i "\_", wartość wystąpienia ciągu to "-\_AA `options` -\_", a wartość argumentu to <xref:System.StringSplitOptions.None>, metoda zwraca tablicę Sting z pięć następujących elementów:</span><span class="sxs-lookup"><span data-stu-id="ba178-3153">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ba178-3154"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg poprzedzający podciąg "-" pod indeksem 0.</span><span class="sxs-lookup"><span data-stu-id="ba178-3154"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>  
  
2.  <span data-ttu-id="ba178-3155"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg między podciągiem "-" w indeksie 0 i podciąg "_" pod indeksem 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3155"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>  
  
3.  <span data-ttu-id="ba178-3156">"AA",</span><span class="sxs-lookup"><span data-stu-id="ba178-3156">"aa",</span></span>  
  
4.  <span data-ttu-id="ba178-3157"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po podciągu "_" przy indeksie 4.</span><span class="sxs-lookup"><span data-stu-id="ba178-3157"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>  
  
5.  <span data-ttu-id="ba178-3158"><xref:System.String.Empty?displayProperty=nameWithType>, która reprezentuje pusty ciąg, który następuje po podciągu "-" pod indeksem 5.</span><span class="sxs-lookup"><span data-stu-id="ba178-3158"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ba178-3159">Tablica separatorów</span><span class="sxs-lookup"><span data-stu-id="ba178-3159">The separator array</span></span>  
 <span data-ttu-id="ba178-3160">Jeśli którykolwiek z elementów w `separator` składa się z wielu znaków, cały podciąg jest traktowany jako ogranicznik.</span><span class="sxs-lookup"><span data-stu-id="ba178-3160">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ba178-3161">Na przykład, jeśli jeden z elementów w `separator` ma wartość "10", próbuje podzielić ciąg "This10is10a10string".</span><span class="sxs-lookup"><span data-stu-id="ba178-3161">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ba178-3162">zwraca następującą tablicę z czterema elementami: {"This", "is", "a", "String".</span><span class="sxs-lookup"><span data-stu-id="ba178-3162">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ba178-3163">}.</span><span class="sxs-lookup"><span data-stu-id="ba178-3163">}.</span></span>  
  
 <span data-ttu-id="ba178-3164">Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3164">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ba178-3165">Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3165">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba178-3166">Jeśli parametr w wywołaniu tego przeciążenia metody jest `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3166">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ba178-3167">Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3167">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ba178-3168">W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3168">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a><span data-ttu-id="ba178-3169">Szczegóły porównania</span><span class="sxs-lookup"><span data-stu-id="ba178-3169">Comparison details</span></span>  
 <span data-ttu-id="ba178-3170">Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden ciąg `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3170">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ba178-3171"><xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-3171">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ba178-3172">Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3172">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ba178-3173">Metoda ignoruje wszystkie elementy, `separator` których wartość jest `null` lub pusty ciąg (""). <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3173">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ba178-3174">Aby uniknąć niejednoznacznych wyników `separator` <xref:System.String.Split%2A> , gdy ciągi w znaki są wspólne, operacja przechodzi od początku do końca wartości wystąpienia i dopasowuje pierwszy element w `separator` , który jest równy ogranicznikowi w np.</span><span class="sxs-lookup"><span data-stu-id="ba178-3174">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ba178-3175">Kolejność, w której są napotkane podciągi, ma pierwszeństwo przed kolejnością elementów w `separator`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3175">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ba178-3176">Rozważmy na przykład wystąpienie o wartości "abcdef".</span><span class="sxs-lookup"><span data-stu-id="ba178-3176">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ba178-3177">Jeśli pierwszy element w `separator` było "EF", a drugi element miał wartość "bcde", wynikiem operacji Split będzie tablica ciągów zawierająca dwa elementy: "a" i "f".</span><span class="sxs-lookup"><span data-stu-id="ba178-3177">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="ba178-3178">Wynika to z faktu, że podciąg w wystąpieniu ("bcde") został napotkany i pasuje `separator` do elementu w elemencie przed wystąpieniem podciągu "f".</span><span class="sxs-lookup"><span data-stu-id="ba178-3178">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ba178-3179">Jeśli jednak pierwszy element elementu `separator` to "bcd", a drugi element miał wartość "BC", wynikiem operacji Split jest tablica ciągów zawierająca dwa elementy: "a" i "EF".</span><span class="sxs-lookup"><span data-stu-id="ba178-3179">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="ba178-3180">Dzieje się tak, ponieważ "bcd" to pierwszy ogranicznik w programie `separator` , który pasuje do ogranicznika w wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3180">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ba178-3181">Jeśli kolejność separatorów została odwrócona, więc pierwszy element miał wartość "BC", a drugi element to "bcd", wynikiem będzie tablica ciągów zawierająca dwa elementy: "a" i "def".</span><span class="sxs-lookup"><span data-stu-id="ba178-3181">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3182">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3182">Performance considerations</span></span>  
 <span data-ttu-id="ba178-3183">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3183">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3184">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3184">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3185">W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3185">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3186">W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3186">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3187">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3187">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3188">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3188">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3189">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3189">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3190">Poniższy przykład <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> ilustruje różnicę w tablicach zwracanych przez wywołanie metody ciągu z jej `options` parametrem równym <xref:System.StringSplitOptions.None?displayProperty=nameWithType> i <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-3190">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 <span data-ttu-id="ba178-3191">W poniższym przykładzie zdefiniowano tablicę separatorów, które zawierają znaki interpunkcyjne i odstępy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3191">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="ba178-3192">Przekazanie tej tablicy wraz z wartością <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> do metody zwraca tablicę, która składa się z pojedynczych wyrazów z ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3192">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="ba178-3193">Należy zauważyć, że metoda jest wywoływana z `options` argumentem ustawionym na <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba178-3193">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba178-3194">Zapobiega to dołączeniu <xref:System.String.Empty?displayProperty=nameWithType> wartości, które reprezentują puste podciągi między znakami interpunkcyjnymi i znakami odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3194">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-3195"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-3195"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3196"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3196">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3197">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3197">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-3198">Tablica znaków, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3198">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-3199">Maksymalna liczba podciągów do zwrócenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3199">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-3200"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3200"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ba178-3201">Dzieli ciąg na maksymalną liczbę podciągów w oparciu o znaki w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3201">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ba178-3202">Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej znaków w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3202">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-3203">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3203">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3204">Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3204">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ba178-3205">Jeśli to wystąpienie nie zawiera żadnego ze znaków w `separator`, `count` lub parametr ma wartość 1, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3205">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ba178-3206">Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3206">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ba178-3207">Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3207">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-3208">Jeśli `separator` jednak parametr w wywołaniu tego przeciążenia metody ma wartość `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3208">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ba178-3209">Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ wartości null.</span><span class="sxs-lookup"><span data-stu-id="ba178-3209">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="ba178-3210">W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3210">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="ba178-3211">Jeśli parametr ma wartość zero `options` lub parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, zwracana jest pusta tablica. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-3211">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ba178-3212">Każdy element `separator` definiuje oddzielny znak ogranicznika.</span><span class="sxs-lookup"><span data-stu-id="ba178-3212">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ba178-3213">Jeśli parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3213">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ba178-3214">Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3214">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ba178-3215">Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-3215">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3216">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3216">Performance Considerations</span></span>  
 <span data-ttu-id="ba178-3217">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3217">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3218">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3218">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3219">W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3219">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3220">W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3220">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3221">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3221">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3222">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3222">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3223">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3223">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3224">Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3224">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3225"><paramref name="count" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-3225"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-3226"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-3226"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3227"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3227">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3228">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3228">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ba178-3229">Tablica ciągów, która ogranicza podciągi w tym ciągu, pustą tablicę, która nie zawiera ograniczników ani <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3229">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ba178-3230">Maksymalna liczba podciągów do zwrócenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3230">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="ba178-3231"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />Aby pominąć puste elementy tablicy z zwróconej tablicy; lub <see cref="F:System.StringSplitOptions.None" /> , aby uwzględnić puste elementy tablicy w zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3231"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ba178-3232">Dzieli ciąg na maksymalną liczbę podciągów na podstawie ciągów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3232">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="ba178-3233">Można określić, czy podciągi mają zawierać puste elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3233">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ba178-3234">Tablica, której elementy zawierają podciągi w tym ciągu, które są rozdzielane przez jeden lub więcej ciągów w <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3234">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ba178-3235">Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3235">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a><span data-ttu-id="ba178-3236">Szczegóły wartości zwracanej</span><span class="sxs-lookup"><span data-stu-id="ba178-3236">Return value details</span></span>  
 <span data-ttu-id="ba178-3237">Ciągi ograniczników nie są uwzględniane w elementach zwracanej tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3237">Delimiter strings are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ba178-3238">Jeśli to wystąpienie nie zawiera żadnych ciągów w `separator` `count` lub parametr ma wartość 1, zwracana tablica składa się z pojedynczego elementu, który zawiera to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3238">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ba178-3239">Jeśli parametr ma `null` lub nie zawiera znaków, zakłada się, że znaki odstępu są ogranicznikami. `separator`</span><span class="sxs-lookup"><span data-stu-id="ba178-3239">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ba178-3240">Znaki odstępu są definiowane przez standard Unicode i zwracane `true` , jeśli są przesyłane <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3240">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-3241">Jeśli `separator` jednak parametr w wywołaniu tego przeciążenia metody ma wartość `null`, rozpoznawanie przeciążenia kompilatora kończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3241">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ba178-3242">Aby jednoznacznie zidentyfikować wywołaną metodę, kod musi wskazywać typ `null`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3242">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ba178-3243">W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3243">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 <span data-ttu-id="ba178-3244">Jeśli parametr ma wartość zero `options` lub parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długość tego wystąpienia wynosi zero, zwracana jest pusta tablica. `count`</span><span class="sxs-lookup"><span data-stu-id="ba178-3244">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ba178-3245">Każdy element `separator` definiuje oddzielny ogranicznik, który składa się z co najmniej jednego znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-3245">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ba178-3246">Jeśli parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki są przyległe lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający element tablicy zawiera <xref:System.String.Empty>. `options`</span><span class="sxs-lookup"><span data-stu-id="ba178-3246">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ba178-3247">Jeśli w tym wystąpieniu znajduje `count` się więcej niż podciągi, pierwsze `count` minus 1 podciągi są zwracane w pierwszych `count` minus 1 elementów wartości zwracanej, a pozostałe znaki w tym wystąpieniu są zwracane w ciągu ostatnich element wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3247">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ba178-3248">Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągi i nie jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-3248">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ba178-3249">Tablica separatorów</span><span class="sxs-lookup"><span data-stu-id="ba178-3249">The separator array</span></span>  
 <span data-ttu-id="ba178-3250">Jeśli którykolwiek z elementów w `separator` składa się z wielu znaków, cały podciąg jest traktowany jako ogranicznik.</span><span class="sxs-lookup"><span data-stu-id="ba178-3250">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ba178-3251">Na przykład, jeśli jeden z elementów w `separator` ma wartość "10", próbuje podzielić ciąg "This10is10a10string".</span><span class="sxs-lookup"><span data-stu-id="ba178-3251">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ba178-3252">zwraca tablicę czterech elementów: {"This", "is", "a", "String".</span><span class="sxs-lookup"><span data-stu-id="ba178-3252">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ba178-3253">}.</span><span class="sxs-lookup"><span data-stu-id="ba178-3253">}.</span></span>  
  
### <a name="comparison-details"></a><span data-ttu-id="ba178-3254">Szczegóły porównania</span><span class="sxs-lookup"><span data-stu-id="ba178-3254">Comparison details</span></span>  
 <span data-ttu-id="ba178-3255">Metoda wyodrębnia podciągi w tym ciągu, które są rozdzielane przez co najmniej jeden ciąg `separator` w parametrze i zwraca te podciągi jako elementy tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3255">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ba178-3256"><xref:System.String.Split%2A> Metoda szuka ograniczników przez wykonywanie porównań przy użyciu reguł sortowania porządkowego z uwzględnieniem wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-3256">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ba178-3257">Więcej informacji na temat wyrazów, ciągów i sortowania porządkowego znajduje się <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> w wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3257">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ba178-3258">Metoda ignoruje wszystkie elementy, `separator` których wartość jest `null` lub pusty ciąg (""). <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3258">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ba178-3259">Aby uniknąć niejednoznacznych wyników `separator` <xref:System.String.Split%2A> , gdy ciągi w znaki są wspólne, Metoda przechodzi od początku do końca wartości wystąpienia i dopasowuje pierwszy element w `separator` , który jest równy ogranicznikowi w np.</span><span class="sxs-lookup"><span data-stu-id="ba178-3259">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ba178-3260">Kolejność, w której są napotkane podciągi, ma pierwszeństwo przed kolejnością elementów w `separator`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3260">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ba178-3261">Rozważmy na przykład wystąpienie o wartości "abcdef".</span><span class="sxs-lookup"><span data-stu-id="ba178-3261">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ba178-3262">Jeśli pierwszy element w `separator` było "EF", a drugi element miał wartość "bcde", wynikiem operacji podziału byłaby "a" i "f".</span><span class="sxs-lookup"><span data-stu-id="ba178-3262">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="ba178-3263">Wynika to z faktu, że podciąg w wystąpieniu ("bcde") został napotkany i pasuje `separator` do elementu w elemencie przed wystąpieniem podciągu "f".</span><span class="sxs-lookup"><span data-stu-id="ba178-3263">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ba178-3264">Jeśli jednak pierwszy element `separator` to "bcd", a drugi element miał wartość "BC", wynikiem operacji podziału byłaby "a" i "EF".</span><span class="sxs-lookup"><span data-stu-id="ba178-3264">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="ba178-3265">Dzieje się tak, ponieważ "bcd" to pierwszy ogranicznik w programie `separator` , który pasuje do ogranicznika w wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3265">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ba178-3266">Jeśli kolejność separatorów została odwrócona, więc pierwszy element miał wartość "BC", a drugi element to "bcd", wynikiem byłaby "a" i "def".</span><span class="sxs-lookup"><span data-stu-id="ba178-3266">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ba178-3267">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="ba178-3267">Performance considerations</span></span>  
 <span data-ttu-id="ba178-3268">Metody przydzielają pamięć dla zwracanego obiektu array <xref:System.String> i obiektu dla każdego elementu tablicy. <xref:System.String.Split%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3268">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ba178-3269">Jeśli aplikacja wymaga optymalnej wydajności lub jeśli Zarządzanie alokacją pamięci ma krytyczne znaczenie w aplikacji, rozważ użycie <xref:System.String.IndexOf%2A> <xref:System.String.Compare%2A> metody <xref:System.String.IndexOfAny%2A> lub i opcjonalnie metodę, aby zlokalizować podciąg w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3269">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ba178-3270">W przypadku dzielenia ciągu na znak separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować znak separatora w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3270">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ba178-3271">W przypadku dzielenia ciągu na ciąg separatora Użyj <xref:System.String.IndexOf%2A> metody lub <xref:System.String.IndexOfAny%2A> , aby zlokalizować pierwszy znak ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3271">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ba178-3272">Następnie użyj metody <xref:System.String.Compare%2A> , aby określić, czy znaki po pierwszym znaku są równe pozostałym znakom ciągu separatora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3272">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ba178-3273">Ponadto, jeśli ten sam zestaw znaków jest używany do dzielenia ciągów w wielu <xref:System.String.Split%2A> wywołaniach metod, należy rozważyć utworzenie pojedynczej tablicy i odwołanie się do niej w każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3273">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ba178-3274">Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3274">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3275">Poniższy przykład używa <xref:System.StringSplitOptions> wyliczenia do dołączania lub wykluczania podciągów generowanych <xref:System.String.Split%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3275">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3276"><paramref name="count" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="ba178-3276"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-3277"><paramref name="options" />nie jest jedną z <see cref="T:System.StringSplitOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="ba178-3277"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3278"><paramref name="separator" /> <see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> W wersjach <see cref="M:System.String.Split(System.Char[])" /> i starszych, jeśli metoda jest przenoszona lub nie zawiera żadnych znaków, metoda używa nieco innego zestawu znaków, aby podzielić ciąg niż Metoda [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] Przytnij ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3278">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ba178-3279">Począwszy od .NET Framework 4, obie metody używają identycznego zestawu znaków znaku Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3279">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3280">Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3280">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-3281">Ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-3281">The string to compare.</span></span></param>
        <summary><span data-ttu-id="ba178-3282">Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3282">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="ba178-3283"><see langword="true" />Jeśli <paramref name="value" /> pasuje do początku tego ciągu; w przeciwnym razie <see langword="false" />,.</span><span class="sxs-lookup"><span data-stu-id="ba178-3283"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3284">Ta metoda porównuje `value` do podciągu na początku tego wystąpienia, które ma taką samą długość jak `value`i zwraca wskazanie, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-3284">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ba178-3285">Musi być pustym ciągiem (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi być zgodna z początkiem tego wystąpienia. `value`</span><span class="sxs-lookup"><span data-stu-id="ba178-3285">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ba178-3286">Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3286">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3287">W poniższym przykładzie zdefiniowano `StripStartTags` metodę, która <xref:System.String.StartsWith%28System.String%29> używa metody do usuwania tagów początkowych HTML od początku ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3287">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="ba178-3288">Należy zauważyć, `StripStartTags` że metoda jest wywoływana cyklicznie, aby upewnić się, że wiele tagów początkowych HTML na początku wiersza zostanie usuniętych.</span><span class="sxs-lookup"><span data-stu-id="ba178-3288">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="ba178-3289">Przykład nie usuwa tagów HTML osadzonych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3289">The example does not remove HTML tags embedded in a string.</span></span>  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3290"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3290"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3291">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod porównywania ciągów, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3291">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-3292">Aby określić, czy ciąg rozpoczyna się od określonego podciągu przy użyciu reguł porównywania ciągów bieżącej kultury, wywołaj <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> Przeciążenie metody <see cref="F:System.StringComparison.CurrentCulture" /> wartością dla <paramref name="comparisonType" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-3292">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-3293">Ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-3293">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ba178-3294">Jedna z wartości wyliczenia, która określa, jak ten ciąg <paramref name="value" /> i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="ba178-3294">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="ba178-3295">Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną opcją porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-3295">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="ba178-3296"><see langword="true" />Jeśli to wystąpienie zaczyna się <paramref name="value" />od; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3296"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3297"><xref:System.String.StartsWith%2A> Metoda porównujeparametrdopodciągunapoczątkutegociąguizwracawartośćwskazującą`value` , czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-3297">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ba178-3298">Aby była równa `value` , musi być odwołaniem do tego samego ciągu, musi być pustym ciągiem ("") lub musi być zgodna z początkiem tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3298">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="ba178-3299">Typ porównania wykonywanego przez <xref:System.String.StartsWith%2A> metodę zależy od wartości `comparisonType` parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-3299">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="ba178-3300">Porównanie może korzystać z Konwencji bieżącej kultury (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> i <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) lub niezmiennej kultury (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> i <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) lub może składać się z porównania znak po znaku dla punktów kodu (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ba178-3300">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ba178-3301">Wynikiem porównania może być również uwzględnianie wielkości liter<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>( <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>,, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>lub) lub ignorowanie wielkości liter (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ba178-3301">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3302">Poniższy przykład wyszukuje ciąg "The" na początku dłuższego ciągu, który rozpoczyna się od słowa "The".</span><span class="sxs-lookup"><span data-stu-id="ba178-3302">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="ba178-3303">Dane wyjściowe z przykładu pokazują, że wywołanie <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metody, która wykonuje niezależność od wielkości liter, ale nie dopasowuje się do ciągu, podczas gdy wywołanie, które wykonuje porównanie bez uwzględniania wielkości liter, pasuje do ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3303">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 <span data-ttu-id="ba178-3304">Poniższy przykład określa, czy ciąg rozpoczyna się od określonego podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3304">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="ba178-3305">Inicjuje dwuwymiarową tablicę ciągów.</span><span class="sxs-lookup"><span data-stu-id="ba178-3305">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="ba178-3306">Pierwszy element w drugim wymiarze zawiera ciąg, a drugi element zawiera ciąg do wyszukania na początku pierwszego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3306">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="ba178-3307">Na wyniki można wybrać kulturę, niezależnie od tego, czy wielkość liter jest ignorowana i czy jest wykonywane porównywanie porządkowe.</span><span class="sxs-lookup"><span data-stu-id="ba178-3307">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="ba178-3308">Należy zauważyć, że gdy wystąpienie ciągu zawiera ligatury, porównywanie z uwzględnieniem kultury z następującymi po sobie znakami powiodło się.</span><span class="sxs-lookup"><span data-stu-id="ba178-3308">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3309"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3309"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba178-3310"><paramref name="comparisonType" />nie <see cref="T:System.StringComparison" /> jest wartością.</span><span class="sxs-lookup"><span data-stu-id="ba178-3310"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba178-3311">Ciąg do porównania.</span><span class="sxs-lookup"><span data-stu-id="ba178-3311">The string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba178-3312"><see langword="true" />Aby zignorować wielkość liter podczas porównywania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-3312"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ba178-3313">Informacje kulturowe, które określają, jak <paramref name="value" /> ten ciąg i są porównywane.</span><span class="sxs-lookup"><span data-stu-id="ba178-3313">Cultural information that determines how this string and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="ba178-3314">Jeśli <paramref name="culture" /> jest<see langword="null" />, używana jest bieżąca kultura.</span><span class="sxs-lookup"><span data-stu-id="ba178-3314">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ba178-3315">Określa, czy początek tego wystąpienia ciągu pasuje do określonego ciągu w porównaniu z określoną kulturą.</span><span class="sxs-lookup"><span data-stu-id="ba178-3315">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-3316"><see langword="true" />Jeśli parametr <paramref name="value" /> jest zgodny z początkiem tego ciągu; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="ba178-3316"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3317">Ta metoda porównuje `value` parametr do podciągu na początku tego ciągu, który ma taką samą długość jak `value`i zwraca wartość wskazującą, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="ba178-3317">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ba178-3318">Musi być pustym ciągiem (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi być zgodna z początkiem tego wystąpienia. `value`</span><span class="sxs-lookup"><span data-stu-id="ba178-3318">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ba178-3319">Ta metoda wykonuje porównanie przy użyciu określonej wielkości liter i kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3319">This method performs a comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3320">Poniższy przykład określa, czy ciąg występuje na początku innego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3320">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="ba178-3321"><xref:System.String.StartsWith%2A> Metoda jest wywoływana kilka razy przy użyciu czułości wielkości liter, nierozróżniania wielkości liter i różnych kultur, które wpływają na wyniki wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="ba178-3321">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3322"><paramref name="value" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3322"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3323">Pobiera podciąg z tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3323">Retrieves a substring from this instance.</span></span>  
  
 <span data-ttu-id="ba178-3324">Ten element członkowski jest przeciążony.</span><span class="sxs-lookup"><span data-stu-id="ba178-3324">This member is overloaded.</span></span> <span data-ttu-id="ba178-3325">Aby uzyskać pełne informacje dotyczące tego elementu członkowskiego, w tym informacje o jego składni i zastosowaniu oraz odpowiednie przykłady, kliknij nazwę na liście przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="ba178-3325">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-3326">Początkowa pozycja znaku w podciągu w tym wystąpieniu (liczony od zera).</span><span class="sxs-lookup"><span data-stu-id="ba178-3326">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-3327">Pobiera podciąg z tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3327">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ba178-3328">Podciąg zaczyna się od określonej pozycji znaku i przechodzi do końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3328">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="ba178-3329">Ciąg, który jest odpowiednikiem podciągu, który rozpoczyna <paramref name="startIndex" /> się w tym wystąpieniu <paramref name="startIndex" /> lub <see cref="F:System.String.Empty" /> jest równy długości tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3329">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3330">Wywoływana <xref:System.String.Substring%28System.Int32%29> jest metoda wyodrębniania podciągu z ciągu, który rozpoczyna się od określonej pozycji znaku i kończy się na końcu ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3330">You call the <xref:System.String.Substring%28System.Int32%29> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="ba178-3331">Początkowe położenie znaku jest zależne od zera. Innymi słowy, pierwszy znak w ciągu ma indeks 0, a nie indeks 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3331">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ba178-3332">Aby wyodrębnić podciąg, który rozpoczyna się od określonej pozycji znaku i kończy przed końcem ciągu, wywołaj <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3332">To extract a substring that begins at a specified character position and ends before the end of the string, call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3333">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3333">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3334">Zamiast tego zwraca nowy ciąg, który rozpoczyna się w `startIndex` pozycji w bieżącym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3334">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ba178-3335">Aby wyodrębnić podciąg, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołaj metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> , `startIndex`Aby uzyskać wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3335">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="ba178-3336">Drugi przykład ilustruje to; Wyodrębnia wartość klucza rozpoczynającą się jedną pozycją znaku po znaku "=".</span><span class="sxs-lookup"><span data-stu-id="ba178-3336">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>  
  
 <span data-ttu-id="ba178-3337">Jeśli `startIndex` jest równa zero, metoda zwraca oryginalny ciąg niezmieniony.</span><span class="sxs-lookup"><span data-stu-id="ba178-3337">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>  
   
  
## Examples  
 <span data-ttu-id="ba178-3338">Poniższy przykład pokazuje, jak uzyskać podciąg z ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3338">The following example demonstrates obtaining a substring from a string.</span></span>  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 <span data-ttu-id="ba178-3339">W poniższym przykładzie zastosowano <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane znakiem równości ("=").</span><span class="sxs-lookup"><span data-stu-id="ba178-3339">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ba178-3340"><xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycji znaku równości w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3340">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="ba178-3341">Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, która zaczyna się od pierwszego znaku w ciągu i rozszerza liczbę znaków zwracanych przez wywołanie <xref:System.String.IndexOf%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3341">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ba178-3342">Wywołanie <xref:System.String.Substring%28System.Int32%29> metody następnie wyodrębnia wartość przypisaną do klucza.</span><span class="sxs-lookup"><span data-stu-id="ba178-3342">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ba178-3343">Zaczyna się od jednej pozycji znaku poza znakiem równości i rozciąga się na koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3343">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3344"><paramref name="startIndex" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3344"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-3345">Początkowa pozycja znaku w podciągu w tym wystąpieniu (liczony od zera).</span><span class="sxs-lookup"><span data-stu-id="ba178-3345">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-3346">Liczba znaków w podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3346">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="ba178-3347">Pobiera podciąg z tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3347">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ba178-3348">Podciąg zaczyna się od określonej pozycji znaku i ma określoną długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3348">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="ba178-3349">Ciąg, który jest równoznaczny z podciągiem długości <paramref name="length" /> , który <paramref name="startIndex" /> rozpoczyna się w tym wystąpieniu, <see cref="F:System.String.Empty" /> lub <paramref name="startIndex" /> jeśli jest równy długości tego wystąpienia i <paramref name="length" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-3349">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3350">Wywoływana <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> jest metoda wyodrębniania podciągu z ciągu, który rozpoczyna się od określonej pozycji znaku i kończy przed końcem ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3350">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="ba178-3351">Początkowe położenie znaku jest zależne od zera. Innymi słowy, pierwszy znak w ciągu ma indeks 0, a nie indeks 1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3351">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ba178-3352">Aby wyodrębnić podciąg, który rozpoczyna się od określonej pozycji znaku i przechodzi do końca ciągu, wywołaj <xref:System.String.Substring%28System.Int32%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3352">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3353">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3353">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3354">Zamiast tego zwraca nowy ciąg `length` znaków, zaczynając `startIndex` od pozycji w bieżącym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3354">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ba178-3355">`length` Parametr reprezentuje łączną liczbę znaków do wyodrębnienia z bieżącego wystąpienia ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3355">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="ba178-3356">Obejmuje to znak początkowy znaleziony w indeksie `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="ba178-3356">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="ba178-3357"><xref:System.String.Substring%2A> Innymi słowy, metoda próbuje wyodrębnić znaki z indeksu `length` `startIndex` do indeksu `startIndex`  +  -1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3357">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>  
  
 <span data-ttu-id="ba178-3358">Aby wyodrębnić podciąg, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołaj metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> , `startIndex`Aby uzyskać wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3358">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>  
  
 <span data-ttu-id="ba178-3359">Jeśli podciąg rozciąga się od `startIndex` do określonej sekwencji znaków, można wywołać metodę taką jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> , aby uzyskać indeks znaku końcowego lub sekwencji znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3359">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="ba178-3360">Następnie można przekonwertować tę wartość na pozycję indeksu w ciągu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ba178-3360">You can then convert that value to an index position in the string as follows:</span></span>  
  
-   <span data-ttu-id="ba178-3361">Jeśli `length` szukasz pojedynczego znaku, który ma oznaczać koniec podciągu, parametr jest równy `endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex` + 1, gdzie `endIndex` jest wartością zwracaną lub <xref:System.String.IndexOf%2A> Method.</span><span class="sxs-lookup"><span data-stu-id="ba178-3361">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ba178-3362">Poniższy przykład wyodrębnia ciągły blok znaków "b" z ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3362">The following example extracts a continuous block of "b" characters from a string.</span></span>  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   <span data-ttu-id="ba178-3363">Jeśli szukasz wielu znaków, które mają oznaczać koniec podciągu, `length` parametr Equals `endIndex`  +  `startIndex` `endMatchLength`  - ma wartość, gdzie `endIndex` jest wartością zwracaną<xref:System.String.IndexOf%2A> lub Metoda<xref:System.String.IndexOf%2A> oraz`endMatchLength` jest długością sekwencji znaków, która oznacza koniec podciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3363">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method, and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="ba178-3364">Poniższy przykład wyodrębnia blok tekstu, który zawiera element XML `<definition>` .</span><span class="sxs-lookup"><span data-stu-id="ba178-3364">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   <span data-ttu-id="ba178-3365">Jeśli znak lub sekwencja znaków nie `length` jest uwzględniona na końcu podciągu, `endIndex`  -  <xref:System.String.IndexOf%2A> `startIndex`parametr ma wartość, gdzie `endIndex` jest wartością zwracaną lub <xref:System.String.IndexOf%2A> Method.</span><span class="sxs-lookup"><span data-stu-id="ba178-3365">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>  
  
 <span data-ttu-id="ba178-3366">Jeśli `startIndex` jest równa zero i równa długości bieżącego ciągu, metoda zwraca oryginalny ciąg niezmieniony.</span><span class="sxs-lookup"><span data-stu-id="ba178-3366">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3367">Poniższy przykład ilustruje proste wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody, która wyodrębnia dwa znaki z ciągu, zaczynając od szóstej pozycji znaku (czyli przy indeksie pięciu).</span><span class="sxs-lookup"><span data-stu-id="ba178-3367">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 <span data-ttu-id="ba178-3368">W poniższym przykładzie zastosowano <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę w następujących trzech przypadkach w celu wyodrębnienia podciągów w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3368">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="ba178-3369">W dwóch przypadkach podciągi są używane w porównaniach, a w trzecim przypadku wyjątek jest zgłaszany, ponieważ określono nieprawidłowe parametry.</span><span class="sxs-lookup"><span data-stu-id="ba178-3369">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>  
  
-   <span data-ttu-id="ba178-3370">Wyodrębnia pojedynczy znak i trzecią pozycję w ciągu (przy indeksie 2) i porównuje go z literą "c".</span><span class="sxs-lookup"><span data-stu-id="ba178-3370">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="ba178-3371">To porównanie zwraca `true`wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3371">This comparison returns `true`.</span></span>  
  
-   <span data-ttu-id="ba178-3372">Wyodrębnia zero znaków, zaczynając od czwartego pozycji w ciągu (przy indeksie 3) i przekazuje go do <xref:System.String.IsNullOrEmpty%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3372">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="ba178-3373">Zwraca wartość true, ponieważ wywołanie <xref:System.String.Substring%2A> metody zwraca <xref:System.String.Empty?displayProperty=nameWithType>wartość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3373">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ba178-3374">Podejmuje próbę wyodrębnienia jednego znaku, rozpoczynając od czwartej pozycji w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3374">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="ba178-3375">Ponieważ w tym miejscu nie ma żadnego znaku, wywołanie metody zgłasza <xref:System.ArgumentOutOfRangeException> wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ba178-3375">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ba178-3376">W poniższym przykładzie zastosowano <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz/wartość, które są rozdzielane znakiem równości ("=").</span><span class="sxs-lookup"><span data-stu-id="ba178-3376">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ba178-3377"><xref:System.String.IndexOf%2A> Metoda jest używana do pobierania pozycji znaku równości w ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3377">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="ba178-3378">Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, która zaczyna się od pierwszego znaku w ciągu i rozszerza liczbę znaków zwracanych przez wywołanie <xref:System.String.IndexOf%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3378">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ba178-3379">Wywołanie <xref:System.String.Substring%28System.Int32%29> metody następnie wyodrębnia wartość przypisaną do klucza.</span><span class="sxs-lookup"><span data-stu-id="ba178-3379">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ba178-3380">Zaczyna się od jednej pozycji znaku poza znakiem równości i rozciąga się na koniec ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3380">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3381"><paramref name="startIndex" />znak <paramref name="length" /> Plus wskazuje pozycję, która nie znajduje się w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3381"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>  
  
<span data-ttu-id="ba178-3382">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-3382">-or-</span></span> 
 <span data-ttu-id="ba178-3383"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-3383"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3384">Zwraca moduł wyliczający, który wykonuje iterację <see cref="T:System.String" /> bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3384">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3385">Moduł wyliczający z jednoznacznie określonym typem, który może być używany do iteracji <see cref="T:System.String" /> w bieżącym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3385">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3386">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3386">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3387">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.Collections.Generic.IEnumerable%601> na obiekt interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3387">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="ba178-3388">Aby uzyskać więcej informacji, zobacz <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3388">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3389">Zwraca moduł wyliczający, który wykonuje iterację <see cref="T:System.String" /> bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3389">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3390">Moduł wyliczający, który może służyć do iteracji w bieżącym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3390">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3391">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3391">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3392">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3392">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="ba178-3393">Aby uzyskać więcej informacji, zobacz <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3393">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3394">Ten parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="ba178-3394">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="ba178-3395">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3395">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3396"><see langword="true" />Jeśli wartość bieżącego ciągu to <see cref="F:System.Boolean.TrueString" />; wartość bieżącego ciągu to <see cref="F:System.Boolean.FalseString" />. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ba178-3396"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3397">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3397">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3398">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3398">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3399">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3399">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3400">Wartość bieżącego ciągu nie <see cref="F:System.Boolean.TrueString" /> jest lub. <see cref="F:System.Boolean.FalseString" /></span><span class="sxs-lookup"><span data-stu-id="ba178-3400">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3401">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3401">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3402">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3402">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3403">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3403">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3404">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3404">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3405">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3405">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3406">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3406">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3407">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3407">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3408">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Byte.MaxValue" /> większą lub mniejszą niż <see cref="F:System.Byte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3408">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3409">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3409">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3410">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3410">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3411">Znak pod indeksem 0 w bieżącym <see cref="T:System.String" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3411">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3412">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3412">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3413">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3413">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3414">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3414">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3415">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3415">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3416">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3416">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3417">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3417">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3418">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3418">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3419">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3419">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3420">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3420">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3421">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3421">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3422">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3422">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3423">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3423">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3424">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3424">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3425">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3425">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3426">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3426">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3427">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3427">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3428">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniejszą niż <see cref="F:System.Decimal.MinValue" /> lub <see cref="F:System.Decimal.MaxValue" /> większą.</span><span class="sxs-lookup"><span data-stu-id="ba178-3428">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3429">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3429">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3430">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3430">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3431">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3431">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3432">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3432">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3433">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3433">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3434">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3434">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3435">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3435">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3436">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Double.MinValue" /> mniejszą lub większą od <see cref="F:System.Double.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3436">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3437">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3437">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3438">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3438">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3439">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3439">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3440">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3440">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3441">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3441">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3442">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3442">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3443">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3443">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3444">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.Int16.MaxValue" /> większą lub mniejszą niż <see cref="F:System.Int16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3444">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3445">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3445">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3446">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3446">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3447">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3447">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3448">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3448">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3449">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3449">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3450">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3450">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3451">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3451">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3452">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3452">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3453">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3453">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3454">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3454">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3455">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3455">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3456">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3456">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3457">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3457">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3458">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3458">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3459">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3459">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3460">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3460">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3461">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3461">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3462">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3462">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3463">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3463">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3464">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.SByte.MaxValue" /> większą lub mniejszą niż <see cref="F:System.SByte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3464">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3465">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3465">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3466">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3466">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3467">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3467">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3468">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3468">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3469">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3469">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3470">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3470">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="ba178-3471">Typ zwracanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3471">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="ba178-3472">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3472">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3473">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3473">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3474">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3474">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3475">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3475">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3476">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3476">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3477">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3477">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3478"><paramref name="type" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3478"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="ba178-3479">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przekonwertowana na typ określony <paramref name="type" /> przez parametr.</span><span class="sxs-lookup"><span data-stu-id="ba178-3479">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3480">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3480">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3481">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3481">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3482">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3482">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3483">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3483">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3484">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3484">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3485">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3485">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3486">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3486">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3487">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą <see cref="F:System.UInt16.MaxValue" /> większą lub mniejszą niż <see cref="F:System.UInt16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3487">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3488">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3488">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3489">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3489">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3490">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3490">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3491">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3491">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3492">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3492">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3493">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3493">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ba178-3494">Nie można przeanalizować <see cref="T:System.String" /> wartości bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3494">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ba178-3495">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą większą <see cref="F:System.UInt32.MaxValue" /> lub mniejszą niż<see cref="F:System.UInt32.MinValue" /></span><span class="sxs-lookup"><span data-stu-id="ba178-3495">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3496">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3496">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3497">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="ba178-3497">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ba178-3498">Przekonwertowana wartość bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3498">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3499">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3499">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ba178-3500">Może być używana tylko wtedy, <xref:System.String> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3500">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ba178-3501">Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3501">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3502">Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3502">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3503">Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3503">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ba178-3504">Tablica znaków Unicode, której elementy są pojedynczymi znakami tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3504">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="ba178-3505">Jeśli to wystąpienie jest pustym ciągiem, zwracana tablica jest pusta i ma zerową długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3505">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3506">Ta metoda kopiuje każdy znak (czyli każdy <xref:System.Char> obiekt) w ciągu do tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3506">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="ba178-3507">Pierwszy skopiowany znak jest przy indeksie równym zero zwróconej tablicy znaków; Ostatni skopiowany znak ma wartość index <xref:System.Array.Length%2A?displayProperty=nameWithType> -1.</span><span class="sxs-lookup"><span data-stu-id="ba178-3507">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.</span></span>  
  
 <span data-ttu-id="ba178-3508">Aby utworzyć ciąg znaków w tablicy znaków, wywołaj <xref:System.String.%23ctor%28System.Char%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3508">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>  
  
 <span data-ttu-id="ba178-3509">Aby utworzyć tablicę bajtową, która zawiera zakodowane znaki w ciągu, Utwórz wystąpienie <xref:System.Text.Encoding> odpowiedniego obiektu i Wywołaj jego <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3509">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ba178-3510">Niektóre standardowe kodowanie dostępne w programie .NET obejmują następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="ba178-3510">Some of the standard encodings available in .NET include the following:</span></span>  
  
|<span data-ttu-id="ba178-3511">Kodowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-3511">Encoding</span></span>|<span data-ttu-id="ba178-3512">Obiekt</span><span class="sxs-lookup"><span data-stu-id="ba178-3512">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ba178-3513">ASCII</span><span class="sxs-lookup"><span data-stu-id="ba178-3513">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ba178-3514">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ba178-3514">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ba178-3515">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ba178-3515">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ba178-3516">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ba178-3516">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ba178-3517">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ba178-3517">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ba178-3518">Aby uzyskać więcej informacji, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-3518">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3519">Poniższy przykład wywołuje metodę, <xref:System.String.ToCharArray%2A> aby wyodrębnić znaki w ciągu do tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3519">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="ba178-3520">Następnie wyświetla oryginalny ciąg i elementy w tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3520">It then displays the original string and the elements in the array.</span></span>  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 <span data-ttu-id="ba178-3521">W poniższym przykładzie zdefiniowano ciąg zawierający znaki, które pełnią rolę ograniczników w ciągu rozdzielanym.</span><span class="sxs-lookup"><span data-stu-id="ba178-3521">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="ba178-3522">Następnie wywołuje <xref:System.String.ToCharArray%2A> metodę, aby utworzyć tablicę znaków, która może zostać przeniesiona <xref:System.String.Split%28System.Char%5B%5D%29> do metody w celu oddzielenia rozdzielanego ciągu na jego poszczególne podciągi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3522">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ba178-3523">Pozycja początkowa podciągu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3523">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ba178-3524">Długość podciągu w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3524">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ba178-3525">Kopiuje znaki w określonym podciągu w tym wystąpieniu do tablicy znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3525">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ba178-3526">Tablica znaków Unicode, <paramref name="length" /> której elementy to liczba znaków w tym wystąpieniu rozpoczynająca się od pozycji <paramref name="startIndex" />znaku.</span><span class="sxs-lookup"><span data-stu-id="ba178-3526">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3527">Ta metoda kopiuje znaki w części ciągu do tablicy znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3527">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="ba178-3528">Aby utworzyć ciąg z zakresu znaków w tablicy znaków, wywołaj <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="ba178-3528">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="ba178-3529">`startIndex` Parametr jest oparty na zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-3529">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="ba178-3530">Oznacza to, że indeks pierwszego znaku w wystąpieniu ciągu wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="ba178-3530">That is, the index of the first character in the string instance is zero.</span></span>  
  
 <span data-ttu-id="ba178-3531">Jeśli `length` jest równa zero, zwracana tablica jest pusta i ma zerową długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3531">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="ba178-3532">Jeśli to wystąpienie jest `null` lub pustym ciągiem (""), zwracana tablica jest pusta i ma zerową długość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3532">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>  
  
 <span data-ttu-id="ba178-3533">Aby utworzyć tablicę bajtową, która zawiera zakodowane znaki w części ciągu, Utwórz wystąpienie odpowiedniego <xref:System.Text.Encoding> obiektu i Wywołaj jego <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3533">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ba178-3534">Niektóre standardowe kodowanie dostępne w programie .NET obejmują:</span><span class="sxs-lookup"><span data-stu-id="ba178-3534">Some of the standard encodings available in .NET include:</span></span>  
  
|<span data-ttu-id="ba178-3535">Kodowanie</span><span class="sxs-lookup"><span data-stu-id="ba178-3535">Encoding</span></span>|<span data-ttu-id="ba178-3536">Obiekt</span><span class="sxs-lookup"><span data-stu-id="ba178-3536">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ba178-3537">ASCII</span><span class="sxs-lookup"><span data-stu-id="ba178-3537">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ba178-3538">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ba178-3538">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ba178-3539">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ba178-3539">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ba178-3540">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ba178-3540">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ba178-3541">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ba178-3541">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ba178-3542">Aby uzyskać więcej informacji, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-3542">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3543">Poniższy przykład konwertuje podciąg w ciągu na tablicę znaków, a następnie wylicza i wyświetla elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="ba178-3543">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba178-3544"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="ba178-3544"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ba178-3545">—lub—</span><span class="sxs-lookup"><span data-stu-id="ba178-3545">-or-</span></span> 
 <span data-ttu-id="ba178-3546"><paramref name="startIndex" />znak <paramref name="length" /> Plus jest większy niż długość tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3546"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3547">Zwraca kopię tego ciągu przekonwertowaną na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3547">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3548">Zwraca kopię tego ciągu przekonwertowaną na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3548">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="ba178-3549">Ciąg pisany małymi literami.</span><span class="sxs-lookup"><span data-stu-id="ba178-3549">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3550">Ta metoda uwzględnia reguły wielkości liter bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3550">This method takes into account the casing rules of the current culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3551">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3551">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3552">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3552">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3553">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3553">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3554">Operacja uwzględniania wielkości liter, która wynika <xref:System.String.ToLower> z wywołania metody, przyjmuje konwencje wielkości liter w obecnej kulturze.</span><span class="sxs-lookup"><span data-stu-id="ba178-3554">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ba178-3555">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3555">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="ba178-3556">Daje to ten sam wynik w każdej kulturze (w przeciwieństwie do <xref:System.String.ToLower> metody) i wykonuje bardziej wydajne działanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3556">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3557">Poniższy przykład konwertuje kilka mieszanych ciągów wielkości liter na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3557">The following example converts several mixed case strings to lowercase.</span></span>  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3558">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod wielkości liter w ciągu, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3558">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-3559">Aby skonwertować znak na małe litery przy użyciu konwencji wielkości liter w bieżącej kulturze, wywołaj <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> Przeciążenie metody <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> wartością dla <paramref name="culture" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-3559">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ba178-3560">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-3560">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ba178-3561">Zwraca kopię tego ciągu przekonwertowaną na małe litery przy użyciu reguł wielkości liter w określonej kulturze.</span><span class="sxs-lookup"><span data-stu-id="ba178-3561">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-3562">Odpowiednik małymi literami bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3562">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3563">Reguły wielkości liter kultury określonej przez `culture` parametr określają sposób zmiany wielkości liter ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3563">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3564">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3564">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3565">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3565">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3566">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3566">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3567">W przypadku przekazania <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> metody obiektu innego niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja przekroczenia spowoduje uwzględnienie reguł dotyczących kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3567">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ba178-3568">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3568">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ba178-3569">Daje to ten sam wynik w każdej kulturze i wykonuje bardziej wydajne działanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3569">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3570">Poniższy przykład konwertuje dwa ciągi wielkich liter na małe litery przy użyciu kultur Stany Zjednoczone i tureckich, a następnie porównuje ciągi z małymi literami.</span><span class="sxs-lookup"><span data-stu-id="ba178-3570">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="ba178-3571">Wielkie litery są identyczne, z wyjątkiem tego, że dla każdego wystąpienia wielkiej litery Unicode I w jednym ciągu, drugi ciąg zawiera wielką LITERę I z KROPKą powyżej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3571">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3572"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3572"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3573">Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowaną na małe litery przy użyciu reguł wielkości liter dla niezmiennej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3573">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-3574">Odpowiednik małymi literami bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3574">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3575">Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-3575">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ba178-3576">Jest ona skojarzona z językiem angielskim, ale nie z określonym krajem lub regionem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3576">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ba178-3577">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3577">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ba178-3578">Jeśli aplikacja jest zależna od wielkości liter zmiany ciągu w przewidywalny sposób, który nie ma wpływu na bieżącą kulturę, użyj <xref:System.String.ToLowerInvariant%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3578">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="ba178-3579">Metoda jest równoważna z `ToLower(CultureInfo.InvariantCulture)`. <xref:System.String.ToLowerInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3579">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ba178-3580">Metoda jest zalecana, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolce interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ba178-3580">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3581">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3581">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3582">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3582">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3583">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3583">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3584">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3584">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3585">W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczy wyraz w wielu językach.</span><span class="sxs-lookup"><span data-stu-id="ba178-3585">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ba178-3586"><xref:System.String.ToLowerInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległej bez uwzględniania wielkości liter każdego wyrazu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3586">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ba178-3587"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy małych liter, aby zapewnić, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.</span><span class="sxs-lookup"><span data-stu-id="ba178-3587">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3588">Konwertuje wartość tego wystąpienia na <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3588">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3589">Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana żadna rzeczywista konwersja.</span><span class="sxs-lookup"><span data-stu-id="ba178-3589">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ba178-3590">Bieżący ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3590">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3591">Ponieważ ta metoda po prostu zwraca bieżący ciąg niezmieniony, nie ma potrzeby wywoływania go bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="ba178-3591">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="ba178-3592">Jest zazwyczaj wywoływana niejawnie w operacji formatowania złożonego, jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3592">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3593">Poniższy przykład demonstruje <xref:System.String.ToString%2A> metodę. Należy zauważyć, że przykład nie wywołuje <xref:System.String.ToString%2A> jawnie metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3593">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="ba178-3594">Zamiast tego Metoda jest wywoływana niejawnie przez funkcję [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .</span><span class="sxs-lookup"><span data-stu-id="ba178-3594">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ba178-3595">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3595">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ba178-3596">Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana żadna rzeczywista konwersja.</span><span class="sxs-lookup"><span data-stu-id="ba178-3596">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ba178-3597">Bieżący ciąg.</span><span class="sxs-lookup"><span data-stu-id="ba178-3597">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3598">`provider`jest zarezerwowany i nie uczestniczy obecnie w tej operacji.</span><span class="sxs-lookup"><span data-stu-id="ba178-3598">`provider` is reserved, and does not currently participate in this operation.</span></span>  
  
 <span data-ttu-id="ba178-3599">Ponieważ ta metoda po prostu zwraca bieżący ciąg niezmieniony, nie ma potrzeby wywoływania go bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="ba178-3599">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3600">Zwraca kopię tego ciągu przekonwertowaną na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3600">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3601">Zwraca kopię tego ciągu przekonwertowaną na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3601">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="ba178-3602">Wielka litera odpowiadająca bieżącemu ciągowi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3602">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3603">Ta metoda używa reguł wielkości liter bieżącej kultury do konwersji każdego znaku w bieżącym wystąpieniu na jego wielką literę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3603">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="ba178-3604">Jeśli znak nie ma wielkiej litery, jest uwzględniany niezmieniony w zwracanym ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3604">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3605">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3605">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3606">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3606">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
 <span data-ttu-id="ba178-3607"><xref:System.String.ToUpper%2A> Metoda jest często używana do przekonwertowania ciągu na wielkie litery, aby można było go użyć w porównaniu bez uwzględniania wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="ba178-3607">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="ba178-3608">Lepszym sposobem wykonania porównania bez uwzględniania wielkości liter jest wywołanie metody porównywania ciągów, która ma <xref:System.StringComparison> parametr, którego wartość jest <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> ustawiona na potrzeby porównania z uwzględnieniem wielkości kulturowej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3608">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3609">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3609">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3610">Operacja uwzględniania wielkości liter, która wynika <xref:System.String.ToUpper> z wywołania metody, przyjmuje konwencje wielkości liter w obecnej kulturze.</span><span class="sxs-lookup"><span data-stu-id="ba178-3610">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ba178-3611">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3611">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ba178-3612">Daje to ten sam wynik w każdej kulturze (w przeciwieństwie do <xref:System.String.ToUpper> metody) i wykonuje bardziej wydajne działanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3612">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3613">Poniższy przykład wywołuje metodę, <xref:System.String.ToUpper%2A> Aby skonwertować serię ciągów jednoznakowych, które zawierają każdy znak w bazowym języku łaciński, łaciński-1 i łaciński rozszerzony-zestaw znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3613">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="ba178-3614">Następnie wyświetla każdy ciąg, którego wielkie litery różni się od znaku małymi literami.</span><span class="sxs-lookup"><span data-stu-id="ba178-3614">It then displays each string whose uppercase character is different from its lowercase character.</span></span>  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3615">Jak wyjaśniono w [najlepszych rozwiązaniach dotyczących używania ciągów](~/docs/standard/base-types/best-practices-strings.md), zalecamy uniknięcie wywołania metod wielkości liter w ciągu, które zastępują wartości domyślne, a zamiast tego wywołania metod, które wymagają parametrów do jawnego określenia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3615">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ba178-3616">Aby przekonwertować ciąg na wielkie litery przy użyciu konwencji wielkości liter w bieżącej kulturze, wywołaj <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> Przeciążenie metody <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> wartością dla <paramref name="culture" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="ba178-3616">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ba178-3617">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-3617">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ba178-3618">Zwraca kopię tego ciągu przekonwertowaną na wielkie litery przy użyciu reguł wielkości liter w określonej kulturze.</span><span class="sxs-lookup"><span data-stu-id="ba178-3618">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-3619">Wielka litera odpowiadająca bieżącemu ciągowi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3619">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3620">Reguły wielkości liter kultury określonej przez `culture` parametr określają sposób zmiany wielkości liter ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3620">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3621">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3621">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3622">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3622">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3623">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3623">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3624">W przypadku przekazania <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> metody obiektu innego niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja przekroczenia spowoduje uwzględnienie reguł dotyczących kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3624">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ba178-3625">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metody lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3625">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ba178-3626">Daje to ten sam wynik w każdej kulturze i wykonuje bardziej wydajne działanie.</span><span class="sxs-lookup"><span data-stu-id="ba178-3626">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3627">Poniższy przykład konwertuje ciąg małych liter na dwa ciągi wielkich liter przy użyciu kultur Stany Zjednoczone i turecki-Turcja, a następnie porównuje ciągi z wielką literą.</span><span class="sxs-lookup"><span data-stu-id="ba178-3627">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="ba178-3628">Wielkie litery są identyczne, z wyjątkiem tego, że dla każdego wystąpienia wielkiej litery Unicode I w jednym ciągu, drugi ciąg zawiera wielką LITERę I z KROPKą powyżej.</span><span class="sxs-lookup"><span data-stu-id="ba178-3628">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba178-3629"><paramref name="culture" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3629"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3630">Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowaną na wielkie litery przy użyciu reguł wielkości liter dla niezmiennej kultury.</span><span class="sxs-lookup"><span data-stu-id="ba178-3630">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ba178-3631">Wielka litera odpowiadająca bieżącemu ciągowi.</span><span class="sxs-lookup"><span data-stu-id="ba178-3631">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3632">Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych.</span><span class="sxs-lookup"><span data-stu-id="ba178-3632">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ba178-3633">Jest ona skojarzona z językiem angielskim, ale nie z określonym krajem lub regionem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3633">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ba178-3634">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="ba178-3634">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ba178-3635">Jeśli aplikacja jest zależna od wielkości liter zmiany ciągu w przewidywalny sposób, który nie ma wpływu na bieżącą kulturę, użyj <xref:System.String.ToUpperInvariant%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3635">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ba178-3636">Metoda jest równoważna z `ToUpper(CultureInfo.InvariantCulture)`. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3636">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ba178-3637">Metoda jest zalecana, gdy kolekcja ciągów musi znajdować się w przewidywalnej kolejności w kontrolce interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ba178-3637">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3638">Metoda ta nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3638">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3639">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.</span><span class="sxs-lookup"><span data-stu-id="ba178-3639">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ba178-3640">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="ba178-3640">Security Considerations</span></span>  
 <span data-ttu-id="ba178-3641">Jeśli potrzebujesz małej lub Wielkiej litery identyfikatora systemu operacyjnego, takiego jak nazwa pliku, potok nazwany lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> metod lub. <xref:System.String.ToUpperInvariant%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3641">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3642">W poniższym przykładzie zdefiniowano tablicę ciągów, która zawiera pojedynczy wyraz w wielu językach.</span><span class="sxs-lookup"><span data-stu-id="ba178-3642">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ba178-3643"><xref:System.String.ToUpperInvariant%2A> Metoda jest używana do wypełniania elementów tablicy równoległej bez uwzględniania wielkości liter każdego wyrazu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3643">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ba178-3644"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tablicy z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy z wielką literą, aby upewnić się, że elementy są wyświetlane w tej samej kolejności, niezależnie od języka.</span><span class="sxs-lookup"><span data-stu-id="ba178-3644">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba178-3645">Zwraca nowy ciąg, w którym usuwane są wszystkie początkowe i końcowe wystąpienia zestawu określonych znaków z bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3645">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <see cref="T:System.String" /> object are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba178-3646">Usuwa wszystkie wiodące i końcowe znaki białych z bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3646">Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3647">Ciąg, który pozostanie po wszystkich znakach odstępu zostanie usunięty z początku i końca bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3647">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="ba178-3648">Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-3648">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3649"><xref:System.String.Trim%2A> Metoda usuwa z bieżącego ciągu wszystkie wiodące i końcowe znaki białych znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3649">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="ba178-3650">Każda operacja przycinania wiodących i końcowych zostaje zatrzymana, gdy zostanie napotkany znak niebędący odstępem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3650">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="ba178-3651">Na przykład, jeśli bieżącym ciągiem jest "ABC XYZ", <xref:System.String.Trim%2A> Metoda zwraca "ABC XYZ".</span><span class="sxs-lookup"><span data-stu-id="ba178-3651">For example, if the current string is "   abc   xyz   ", the <xref:System.String.Trim%2A> method returns "abc   xyz".</span></span> <span data-ttu-id="ba178-3652">Aby usunąć znaki odstępu między wyrazami w ciągu, użyj [wyrażeń regularnych programu .NET](~/docs/standard/base-types/regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ba178-3652">To remove white-space characters between words in a string, use [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3653"><xref:System.String.Trim%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3653">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3654">Zamiast tego zwraca nowy ciąg, w którym wszystkie początkowe i końcowe białe znaki Znalezione w bieżącym wystąpieniu są usuwane.</span><span class="sxs-lookup"><span data-stu-id="ba178-3654">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ba178-3655">Jeśli bieżący ciąg jest równy <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się ze znaków odstępu, metoda zwraca. <xref:System.String.Empty></span><span class="sxs-lookup"><span data-stu-id="ba178-3655">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ba178-3656">Znaki odstępu są definiowane przez standard Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3656">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ba178-3657">Metoda usuwa wszystkie znaki wiodące i końcowe, które generują `true` wartość zwracaną, gdy są <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> one przesyłane do metody. <xref:System.String.Trim></span><span class="sxs-lookup"><span data-stu-id="ba178-3657">The <xref:System.String.Trim> method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3658">W poniższym przykładzie użyto metody <xref:System.String.Trim?displayProperty=nameWithType> , aby usunąć wszystkie dodatkowe odstępy od ciągów wprowadzonych przez użytkownika przed ich połączeniem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3658">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3659">I [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] starsze wersje zachowują wewnętrzną listę znaków białych, które są przycinane przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="ba178-3659">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="ba178-3660">Począwszy od <see langword="true" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> , metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3660">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ba178-3661">Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]która metoda w i nowszych wersjach. nie usuwaj.</span><span class="sxs-lookup"><span data-stu-id="ba178-3661">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ba178-3662">Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ba178-3662">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ba178-3663">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3663">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-3664">Usuwa wszystkie początkowe i końcowe wystąpienia zestawu znaków określonego w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3664">Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3665">Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z początku i końca bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3665">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="ba178-3666">Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3666">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="ba178-3667">Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-3667">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3668">Metoda usuwa z bieżącego ciągu wszystkie znaki wiodące i końcowe, które znajdują się `trimChars` w parametrze. <xref:System.String.Trim%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3668">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ba178-3669">Każda operacja przycinania wiodących i końcowych zostaje zatrzymana, gdy wystąpił znak, który nie znajduje się w `trimChars` .</span><span class="sxs-lookup"><span data-stu-id="ba178-3669">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ba178-3670">Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.Trim%2A> , metoda zwraca wartość "abc456xyz".</span><span class="sxs-lookup"><span data-stu-id="ba178-3670">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.Trim%2A> method returns "abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3671"><xref:System.String.Trim%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3671">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3672">Zamiast tego zwraca nowy ciąg, w którym wszystkie `trimChars` znaki wiodące i końcowe Znalezione w bieżącym wystąpieniu są usuwane.</span><span class="sxs-lookup"><span data-stu-id="ba178-3672">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ba178-3673">Jeśli bieżący ciąg jest równy <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się z znaków `trimChars` w tablicy, metoda zwraca <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="ba178-3673">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ba178-3674">Jeśli `trimChars` jest `null` lub jest pustą tablicą, ta metoda usuwa wszystkie znaki wiodące lub końcowe, które powodują zwrócenie `true` metody po przekazaniu ich <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> do metody,</span><span class="sxs-lookup"><span data-stu-id="ba178-3674">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method,</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3675">Poniższy przykład używa <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metody do usuwania spacji, gwiazdki (\*) i znaków apostrofu (') z ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3675">The following example uses the <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3676">I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3676">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ba178-3677"><see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3677">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ba178-3678">Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]która metoda w i nowszych wersjach. nie usuwaj.</span><span class="sxs-lookup"><span data-stu-id="ba178-3678">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ba178-3679">Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ba178-3679">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ba178-3680">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3680">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-3681">Usuwa wszystkie końcowe wystąpienia zestawu znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3681">Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3682">Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z końca bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3682">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="ba178-3683">Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu Unicode.</span><span class="sxs-lookup"><span data-stu-id="ba178-3683">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="ba178-3684">Jeśli żadne znaki nie mogą zostać przycięte z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</span><span class="sxs-lookup"><span data-stu-id="ba178-3684">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3685">Metoda usuwa z bieżącego ciągu wszystkie znaki końcowe, które znajdują się `trimChars` w parametrze. <xref:System.String.TrimEnd%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3685">The <xref:System.String.TrimEnd%2A> method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ba178-3686">Operacja Trim zostaje zatrzymana, gdy pierwszy znak, który nie `trimChars` znajduje się na końcu ciągu znaków.</span><span class="sxs-lookup"><span data-stu-id="ba178-3686">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="ba178-3687">Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimEnd%2A> , metoda zwraca wartość "123abc456xyz".</span><span class="sxs-lookup"><span data-stu-id="ba178-3687">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimEnd%2A> method returns "123abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3688"><xref:System.String.TrimEnd%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3688">If the <xref:System.String.TrimEnd%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3689">Zamiast tego zwraca nowy ciąg, w którym wszystkie znaki końcowe Znalezione w programie `trimChars` są usuwane z bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3689">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3690">Poniższy przykład ilustruje, <xref:System.String.TrimEnd%28System.Char%5B%5D%29> jak można użyć metody do przycinania białych znaków lub interpunkcji z końca ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3690">The following example demonstrates how you can use the <xref:System.String.TrimEnd%28System.Char%5B%5D%29> method to trim white space or punctuation marks from the end of a string.</span></span>  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3691">I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3691">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ba178-3692"><see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3692">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ba178-3693">Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] która metoda w i nowszych wersjach. nie usuwaj.</span><span class="sxs-lookup"><span data-stu-id="ba178-3693">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ba178-3694">Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ba178-3694">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ba178-3695">Tablica znaków Unicode do usunięcia lub <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba178-3695">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba178-3696">Usuwa wszystkie wiodące wystąpienia zestawu znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3696">Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba178-3697">Ciąg, który pozostanie po wszystkich wystąpieniach znaków w <paramref name="trimChars" /> parametrze, zostanie usunięty z początku bieżącego ciągu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3697">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="ba178-3698">Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub jest pustą tablicą, zamiast tego są usuwane znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3698">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba178-3699">Metoda usuwa z bieżącego ciągu wszystkie znaki wiodące, które znajdują się `trimChars` w parametrze. <xref:System.String.TrimStart%2A></span><span class="sxs-lookup"><span data-stu-id="ba178-3699">The <xref:System.String.TrimStart%2A> method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ba178-3700">Operacja Trim zostaje zatrzymana, gdy wystąpił znak, `trimChars` który nie znajduje się w.</span><span class="sxs-lookup"><span data-stu-id="ba178-3700">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ba178-3701">Na przykład, jeśli bieżący ciąg ma wartość "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimStart%2A> , metoda zwraca wartość "abc456xyz789".</span><span class="sxs-lookup"><span data-stu-id="ba178-3701">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimStart%2A> method returns "abc456xyz789".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba178-3702"><xref:System.String.TrimStart%2A> Jeśli metoda usuwa wszystkie znaki z bieżącego wystąpienia, ta metoda nie modyfikuje wartości bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="ba178-3702">If the <xref:System.String.TrimStart%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ba178-3703">Zamiast tego zwraca nowy ciąg, w którym zostaną usunięte wszystkie wiodące białe znaki znajdujące się w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="ba178-3703">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba178-3704">W poniższym przykładzie przedstawiono podstawowe funkcje <xref:System.String.TrimStart%2A> metody:</span><span class="sxs-lookup"><span data-stu-id="ba178-3704">The following example demonstrates the basic functionality of the <xref:System.String.TrimStart%2A> method:</span></span>

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 <span data-ttu-id="ba178-3705">W poniższym przykładzie zastosowano <xref:System.String.TrimStart%2A> metodę, aby przyciąć biały znak i znaki komentarza z wierszy kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="ba178-3705">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="ba178-3706">Metoda zawija wywołanie do <xref:System.String.TrimStart%2A> i przekazuje go tablicę znaków, która zawiera spację i znak komentarza, który jest apostrofem (') w Visual Basic i ukośnik (/) w. C# `StripComments`</span><span class="sxs-lookup"><span data-stu-id="ba178-3706">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="ba178-3707">Metoda <xref:System.String.TrimStart%2A> jest również wywoływana, aby usunąć wiodący biały znak podczas oceniania, czy ciąg jest komentarzem.</span><span class="sxs-lookup"><span data-stu-id="ba178-3707">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 <span data-ttu-id="ba178-3708">Poniższy przykład ilustruje wywołanie `StripComments` metody.</span><span class="sxs-lookup"><span data-stu-id="ba178-3708">The following example then illustrates a call to the `StripComments` method.</span></span>  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ba178-3709">I starsze wersje obsługują wewnętrzną listę znaków białych, które ta metoda przycina, jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pustą tablicą. [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3709">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ba178-3710"><see langword="null" /> <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> <see langword="true" /> Rozpoczynając od <paramref name="trimChars" /> , jeśli jest lub pustą tablicę, metoda przycina wszystkie znaki białych znaków Unicode (oznacza to, że znaki, które generują wartość zwracaną, gdy są przesyłane do metody). [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ba178-3710">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ba178-3711">Ze względu na tę zmianę <see cref="M:System.String.Trim" /> Metoda [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w programie i starszych wersjach usuwa dwa znaki, zerowe miejsce szerokości (u + 200B) i zerowej szerokości bez przerwy (u + <see cref="M:System.String.Trim" /> FEFF), [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] która metoda w i nowszych wersjach. nie usuwaj.</span><span class="sxs-lookup"><span data-stu-id="ba178-3711">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ba178-3712">Ponadto <see cref="M:System.String.Trim" /> Metoda[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] w i starszych wersjach nie powoduje przycinania trzech białych znaków Unicode: SEPARATORy MONGOLSKIch samogłosek (U + 180E), WĄSKIe wolne miejsce (U + 202F) i średnie miejsce MATEMATYCZNe (U + 205F).</span><span class="sxs-lookup"><span data-stu-id="ba178-3712">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>

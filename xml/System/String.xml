<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bf2d0223b77d7a3205fcbcc0fc27d643d2e78a8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36432037" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje tekstu jako sekwencja jednostek kodu UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ciąg jest sekwencyjną kolekcją znaków, który jest używany do reprezentowania tekstu. A <xref:System.String> obiektu jest kolekcją sekwencyjnych <xref:System.Char?displayProperty=nameWithType> obiekty reprezentujące; ciąg <xref:System.Char?displayProperty=nameWithType> obiekt odpowiada jednostki kodu UTF-16. Wartość <xref:System.String> obiekt znajduje się odpowiednia zawartość sekwencyjnych kolekcji <xref:System.Char?displayProperty=nameWithType> obiektów, a wartość jest niezmienialny (to znaczy jest tylko do odczytu). Aby uzyskać więcej informacji na temat immutability ciągów, zobacz [Immutability i klasy StringBuilder](#Immutability) później w tym temacie. Maksymalny rozmiar <xref:System.String> obiektu w pamięci to 2 GB lub około 1 miliard znaków.  
  
 W tej sekcji:  
  
 [Utworzenie wystąpienia obiektu ciągu](#Instantiation)   
 [Obiekty CHAR i znaków Unicode](#Characters)   
 [Ciągi i Unicode Standard](#Unicode)   
 [Ciągi i osadzone znaki null](#EmbeddedNulls)   
 [Ciągi i indeksów](#Indexes)   
 [Ciągów o wartości null i puste ciągi](#Nulls)   
 [Immutability i klasy StringBuilder](#Immutability)   
 [Liczba porządkowa a zależne od kultury operacje](#CultureSensitive)   
 [Normalizacji](#Normalization)   
 [Operacje na ciągach według kategorii](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Utworzenie wystąpienia obiektu String  
 Można utworzyć wystąpienia <xref:System.String> obiektu w następujący sposób:  
  
-   Przypisując literału ciągu na <xref:System.String> zmiennej. Jest to metoda najczęściej używane do tworzenia ciągu. W poniższym przykładzie użyto przypisania, aby utworzyć kilka ciągów. Należy pamiętać, że w języku C#, ponieważ kreska ułamkowa odwrócona (\\) jest znak kontrolny, należy użyć znaków ucieczki literału ukośników odwrotnych w ciągu lub cały ciąg musi być @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Wywołując <xref:System.String> konstruktora klasy. Poniższy przykład tworzy ciągów, wywołując kilka konstruktorów klas. Należy pamiętać, że niektóre z konstruktorów są wskaźniki do tablic znak lub bajtu ze znakiem tablic jako parametrów. Visual Basic nie obsługuje wywołań tych konstruktorów. Aby uzyskać szczegółowe informacje o <xref:System.String> konstruktorów, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Za pomocą operatora łączenia ciąg (+ w języku C# i & lub + w języku Visual Basic) można utworzyć jeden ciąg z dowolną kombinację <xref:System.String> wystąpień i literały ciągu. Poniższy przykład przedstawia użycie operatora łączenia ciągu.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Podczas pobierania właściwości lub metody, która zwraca wartość typu ciąg. W poniższym przykładzie użyto metody <xref:System.String> klasy do wyodrębniania podciągu większy ciąg.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Wywołując metodę formatowania można przekonwertować wartości lub obiektów do reprezentacji ciągu. W poniższym przykładzie użyto [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md) funkcji do osadzenia reprezentację ciągu dwa obiekty na ciąg.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Obiekty char i znaki Unicode  
 Każdego znaku w ciągu jest określony przez wartość skalarną Unicode, nazywany również punkt kodu Unicode lub wartości (numeryczną) porządkowej znak Unicode. Każdy punkt kodu jest zakodowany przy użyciu kodowania UTF-16, a wartość numeryczna każdy element kodowanie jest reprezentowana przez <xref:System.Char> obiektu.  
  
> [!NOTE]
>  Należy zauważyć, że ponieważ <xref:System.String> wystąpienia składa się z sekwencyjną kolekcją jednostek kodu UTF-16, istnieje możliwość utworzenia <xref:System.String> obiekt, który nie jest poprawnie sformułowany ciąg Unicode. Na przykład istnieje możliwość tworzenia ciąg, który ma dwuskładnikowego bez odpowiedniego. Mimo że niektóre metody, takie jak metody kodowania i dekodowania obiektów w <xref:System.Text> przestrzeni nazw może przeprowadza kontrole w celu zapewnienia, że parametry są poprawnie sformułowany <xref:System.String> elementów członkowskich klasy nie upewnij się, że ciąg jest poprawnie sformułowany.  
  
 Pojedynczy <xref:System.Char> obiektu zazwyczaj reprezentuje pojedynczy punkt kodu; oznacza to, że wartość liczbową <xref:System.Char> jest równe punkt kodu. Na przykład punkt kodu "znaku a" jest 0061 U +. Jednak punkt kodu może wymagać więcej niż jeden element zakodowanego (więcej niż jeden <xref:System.Char> obiektu). Unicode standard definiują dwa typy znaków, które odnoszą się do wielu <xref:System.Char> obiektów: graphemes i dodatkowe kody znaków Unicode odpowiadające znaków Unicode płaszczyzn dodatkowych.  
  
-   Grafemów jest reprezentowany przez znak podstawowy następuje łączenia znaków. Na przykład znak ä jest reprezentowany przez a <xref:System.Char> obiektu, którego punkt kodu jest U + 0061 następuje a <xref:System.Char> obiektu, którego punkt kodu jest U + 0308. Ten znak może być także definiowane przez jeden <xref:System.Char> obiektu, który ma punkt kodu U + 00E4. Jak w poniższym przykładzie pokazano, zależne od kultury porównania równości wskazuje, że te dwa oświadczenia są równe, mimo że nie ma zwykłych porównanie liczby porządkowej. Jednak jeśli znormalizowany są dwa ciągi, porównanie liczby porządkowej również wskazuje, że są one takie same. (Aby uzyskać więcej informacji na normalizacji ciągów, zobacz [normalizacji](#Normalization) sekcji.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode punkt dodatkowego kodu (para zastępcza) jest reprezentowana przez <xref:System.Char> obiektu, którego punkt kodu jest zastępczym wysokiego poziomu następuje <xref:System.Char> obiektu, którego punkt kodu jest dwuskładnikowego. Jednostki kodu wysokiej surogatów z zakresu od U + D800 do U + DBFF. Jednostki kodu niski surogatów z zakresu od U + DC00 do U + DFFF. Znaki dwuskładnikowe są używane do reprezentowania znaków 16 płaszczyzn dodatkowych Unicode. Poniższy przykład tworzy znaku dwuskładnikowego i przekazuje je do <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metodę, aby określić, czy jest ono para zastępcza.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Ciągi i Unicode Standard  
 Znaki w ciągu są reprezentowane przez jednostek kodu zakodowane UTF-16, które odpowiadają <xref:System.Char> wartości.  
  
 Każdy znak w ciągu ma skojarzone Kategoria znaków Unicode, która jest reprezentowana w programie .NET Framework przez <xref:System.Globalization.UnicodeCategory> wyliczenia. Można określić kategorię znak lub para zastępcza przez wywołanie metody <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> metody.  
  
 .NET obsługuje własnej tabeli znaki i ich odpowiednich kategorii, które zapewnia, że określoną wersję implementacji programu .NET uruchomionych na różnych platformach zwraca informacje o kategorii identyczne znaków. W poniższej tabeli wymieniono wersje programu .NET i w wersji Standard Unicode, na którym bazują ich kategorie znaków.  
  
|Wersja programu .NET Framework|Wersja Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Standard Unicode, wersja 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[Standard Unicode, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|  
|Oprogramowanie .NET core (wszystkie wersje)|[Standard Unicode, wersja 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 Ponadto .NET Framework obsługuje porównania ciągów i sortowanie oparte na standardzie Unicode. W wersjach programu .NET Framework za pomocą [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework zachowuje własną tabelę danych ciągu. Dotyczy to również wersji programu .NET Framework, począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] uruchomiony w systemie Windows 7. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] systemem Windows 8 i nowszych wersjach systemu operacyjnego Windows, delegatów środowiska uruchomieniowego ciągu porównywanie i sortowanie operacji do systemu operacyjnego. W poniższej tabeli wymieniono wersje programu .NET Framework i w wersji Standard Unicode na znak, który jest oparty porównywanie i sortowanie.  
  
|Wersja programu .NET Framework|Wersja Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Standard Unicode, wersja 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszy w systemie Windows 7|[Standard Unicode, wersja 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszy w systemie Windows 8 i nowszych systemów operacyjnych Windows|[Standard Unicode, wersja 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  

W .NET Core operacji sortowania i porównywania są oparte na [wersji 8.0.0 standardu Unicode](https://www.unicode.org/versions/Unicode8.0.0/).

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Ciągi i osadzone znaki o wartości zerowej  
 W programie .NET Framework <xref:System.String> obiektu mogą zawierać osadzonych znaków wartości null, które są liczone jako część długość ciągu. Jednak w przypadku niektórych języków, takich jak C i C++ znak null wskazuje końca ciągu, nie jest uznawany za część ciągu, a nie jest traktowane jako część długość ciągu. Oznacza to, że następujące typowe założeń, które programistów C i C++ i bibliotek napisana C lub C++ może uniemożliwić o ciągów nie są zawsze prawidłowe, gdy jest stosowany do <xref:System.String> obiektów:  
  
-   Wartość zwrócona przez `strlen` lub `wcslen` funkcji nie jest zawsze równa <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Ciąg utworzony w wyniku `strcpy_s` lub `wcscpy_s` funkcji nie jest zawsze taki sam, jak ciąg utworzony w wyniku <xref:System.String.Copy%2A?displayProperty=nameWithType> metody.  
  
 Należy upewnić się, że C i C++ kodu natywnego tworzącym <xref:System.String> obiektów i kod, który jest przekazywany <xref:System.String> obiektów za pomocą platformy wywoływać, nie wolno zakładać, że osadzony znak null oznacza końca ciągu.  
  
 Osadzonych znaków wartości null w ciągu również są traktowane inaczej, gdy ciąg sortowania (lub porównaniu) i gdy jest przeszukiwany ciąg. Znaki null są ignorowane, podczas wykonywania zależne od kultury porównań między dwa ciągi, w tym porównania użyta Niezmienna kultura. Są one uznawane za tylko w przypadku porównań porządkowej porządkowej lub bez uwzględniania wielkości liter. Z drugiej strony, osadzonych znaki null są zawsze brane pod uwagę podczas wyszukiwania ciągu za pomocą metod, takich jak <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, i <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Ciągi i indeksy  
 Indeks znajduje się pozycja <xref:System.Char> obiektu (nie znaku Unicode) w <xref:System.String>. Indeks jest liczony od zera, nieujemna liczba, która rozpoczyna się od pierwszej pozycji w ciągu ma indeks 0. Liczba metod wyszukiwania takie jak <xref:System.String.IndexOf%2A> i <xref:System.String.LastIndexOf%2A>, zwróć indeks znaku lub substring w wystąpienia ciągu.  
  
 <xref:System.String.Chars%2A> Właściwości pozwala uzyskiwać dostęp do poszczególnych <xref:System.Char> obiekty według ich pozycji indeksu ciągu. Ponieważ <xref:System.String.Chars%2A> właściwość jest właściwością domyślną (w języku Visual Basic) lub indeksator (w języku C#), można uzyskać dostępu do poszczególnych <xref:System.Char> obiektów w ciągu przy użyciu następującego kodu. Ten kod szuka spacje lub znaki interpunkcyjne w ciągu, aby określić, ile wyrazów zawiera ciąg.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Ponieważ <xref:System.String> klasa implementuje <xref:System.Collections.IEnumerable> interfejsu, można również wykonać iterację <xref:System.Char> obiektów w ciągu przy użyciu `foreach` konstrukcji, jak przedstawiono na poniższym przykładzie.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Numer kolejny wartości nie może odpowiadać kolejnych znaków Unicode, ponieważ Unicode znak może być zakodowane jako więcej niż jeden <xref:System.Char> obiektu. W szczególności ciąg może zawierać wielu znaków jednostki tekstu utworzonych przez znaku podstawowego zostały wykonane przez co najmniej jeden znak łączenie lub znaki dwuskładnikowe. Aby pracować z znaków Unicode, zamiast <xref:System.Char> obiektów, użyj <xref:System.Globalization.StringInfo?displayProperty=nameWithType> i <xref:System.Globalization.TextElementEnumerator> klasy. Poniższy przykład przedstawia różnicę między kod, który działa z <xref:System.Char> obiektów i kod, który działa z znaków Unicode. Porównuje liczbę znaków ani elementów tekst każdego wyrazu zdania. Ciąg zawiera dwie sekwencje znaku podstawowego, a następnie znaku łączenie.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Ten przykład współdziała z elementów tekstowych przy użyciu <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> — metoda i <xref:System.Globalization.TextElementEnumerator> klasy wyliczyć wszystkie elementy w ciągu tekstowym. Można również pobierać tablicę, która zawiera indeks początkowy każdego elementu text przez wywołanie metody <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat pracy z jednostkami tekstu, a nie poszczególnych <xref:System.Char> wartości, zobacz <xref:System.Globalization.StringInfo> klasy.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Ciągi zerowe i puste ciągi  
 Ciąg, który został zadeklarowany, ale nie zostanie przypisana wartość jest `null`. Próba wywołania metody w tym ciągu zgłasza <xref:System.NullReferenceException>. Ciąg pusty jest inny niż ciąg pusty jest ciągiem o wartości "" lub <xref:System.String.Empty?displayProperty=nameWithType>. W niektórych przypadkach przekazywanie ciąg null lub pusty ciąg jako argument w wywołaniu metody zgłasza wyjątek. Na przykład przekazywanie pusty ciąg na <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metoda zgłasza <xref:System.ArgumentNullException>oraz przekazywanie zwraca pusty ciąg <xref:System.FormatException>. W pozostałych przypadkach argument metody może być ciągiem pustym ani ciągiem pustym. Na przykład, jeśli udostępniasz <xref:System.IFormattable> implementacji klasy chcesz są równoważne zarówno pusty ciąg, jak i pusty ciąg, z ogólnego specyfikator formatu ("G").  
  
 <xref:System.String> Klasa zawiera następujące dwa podręczne metody, które pozwalają sprawdzić, czy ciąg jest `null` lub jest pusty:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, która wskazuje, czy ciąg jest `null` lub jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Tej metody eliminuje konieczność użycia kodu, takie jak następujące:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, która wskazuje, czy ciąg `null`, jest równa <xref:System.String.Empty?displayProperty=nameWithType>, lub składa się wyłącznie z białe znaki. Tej metody eliminuje konieczność użycia kodu, takie jak następujące:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 W poniższym przykładzie użyto <xref:System.String.IsNullOrEmpty%2A> metody w <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementacji niestandardowego `Temperature` klasy. Metoda obsługuje ciągi formatu: "G", "C", "F" i "K". Jeśli ciąg formatu pusty lub format string, którego wartość jest `null` jest przekazywany do metody, jego wartość jest zmieniana na ciąg formatu: "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Niezmienność i klasa StringBuilder  
 A <xref:System.String> obiekt jest nazywany niezmienne (tylko do odczytu), ponieważ jej wartości nie można modyfikować po jego utworzeniu. Metody, które są wyświetlane, aby zmodyfikować <xref:System.String> obiektu faktycznie zwraca nową <xref:System.String> obiekt, który zawiera modyfikacji.  
  
 Ponieważ ciągi są niezmienne, procedury manipulowania ciągu, które wykonują powtórzony dodawania i usuwania do zawartości wyświetlanej jako pojedynczy ciąg można dokładnie zmniejszenie wydajności znaczące. Na przykład następujący kod używa generatora liczb losowych tworzenia ciągu z 1000 znaków w zakresie 0x0001 do 0x052F. Mimo że kod jest dostępna na potrzeby konkatenacji Dołącz nowy znak do istniejących parametrów o nazwie `str`, faktycznie tworzy nową <xref:System.String> obiektu dla każdej operacji łączenia.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Można użyć <xref:System.Text.StringBuilder> klasy zamiast <xref:System.String> klasy dla operacji, które wprowadzić wiele zmian, aby wartość ciągu. W odróżnieniu od wystąpień <xref:System.String> klasy <xref:System.Text.StringBuilder> obiekty są modyfikowalną; podczas łączenia, Dołącz lub usunąć podciągów z ciągu operacje są wykonywane na jeden ciąg. Po zakończeniu modyfikowania wartość <xref:System.Text.StringBuilder> obiektu, można wywołać jej <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować na ciąg. W poniższym przykładzie <xref:System.String> użyty w poprzednim przykładzie do łączenia 1000 losowo wybranych znaków w zakresie do 0x0001 do 0x052F z <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Operacje porządkowe vs. operacje zależne od kultury  
 Elementy członkowskie <xref:System.String> klasy wykonywać porządkowej lub zależne od kultury operacje (językowe) <xref:System.String> obiektu. {Numer porządkowy operacji działania w wartość liczbową każdego <xref:System.Char> obiektu. Działanie zależne od kultury działa na wartość <xref:System.String> obiektu i ma specyficzne dla kultury obudowy, sortowanie, formatowanie i pod uwagę podczas analizowania reguły. Zależne od kultury operacje wykonywany w kontekście jawnie zadeklarowana kultury lub niejawne bieżącej kultury. Dwa rodzaje operacji można utworzyć różne wyniki, gdy są one wykonywane na ten sam ciąg.  
  
 .NET Framework obsługuje również operacji niezależnych od kultury językowej ciągu przy użyciu kulturą niezmienną (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), która jest luźno oparta na ustawieniach kultury w języku angielskim niezależnie od regionu. W odróżnieniu od innych <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> ustawienia, ustawienia Niezmienna kultura dotrą chcesz zachować spójność na jednym komputerze z system do systemu, a także w wersjach programu .NET Framework. Niezmienna kultura może być widoczna jako rodzaj czarne pole, który zapewnia stabilność porównywania ciągów i porządkowania we wszystkich języków.  
  
> [!IMPORTANT]
>  Jeśli aplikacja sprawia, że zabezpieczenia decyzję o symboliczną identyfikator, takie jak nazwa pliku lub nazwany potok, lub o utrwalonych danych, takich jak danych tekstowych w pliku XML, operacji należy używać porównanie liczby porządkowej zamiast porównania z uwzględnieniem kultury. Jest to spowodowane porównanie zależne od kultury może spowodować uzyskanie innych wyników w zależności od kultury w efekcie porównanie liczby porządkowej wyłącznie zależy od wartości binarnej porównaniu znaków.  
  
> [!IMPORTANT]
>  Większości metod, które wykonują operacje na ciągach zawierać przeciążenia, które ma parametr typu <xref:System.StringComparison>, która umożliwia określenie, czy metoda wykonuje operację porządkowej lub zależne od kultury. Ogólnie rzecz biorąc należy wywołać tego przeciążenia, aby celem metodę wywołania Wyczyść. Aby uzyskać najlepsze rozwiązania i wskazówki dotyczące korzystania z liczby porządkowej i zależne od kultury operacje na ciągach, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operacje [wielkości liter](#casing), [formatowanie i analizowania](#parsing), [porównywanie i sortowanie](#comparison), i [testowanie pod kątem równości](#equality) może być albo numer lub zależne od kultury. W poniższych sekcjach omówiono każdego z tych operacji.  
  
> [!TIP]
>  Zawsze należy wywołać przeciążenie metody, która sprawia, że celem metodę wywołania Wyczyść. Na przykład zamiast wywoływać metodę <xref:System.String.Compare%28System.String%2CSystem.String%29> metodę w celu porównania zależne od kultury dwa ciągi za pomocą Konwencji bieżącej kultury, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody o wartości <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> dla `comparisonType` argument. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
<a name="casing"></a>   
### <a name="casing"></a>Wielkość znaków  
 Wielkość liter reguły określają, jak zmienić wielkość liter znaku Unicode; na przykład z małymi literami na wielkie litery. Często operacji wielkość liter jest wykonywane przed porównania ciągów. Na przykład ciąg może być przekonwertowany na wielkie litery, dzięki czemu można porównać z innego ciągu wielkie litery. Można konwertować znaków w ciągu na małe litery, wywołując <xref:System.String.ToLower%2A> lub <xref:System.String.ToLowerInvariant%2A> metody, na które można konwertować na wielkie litery, wywołując <xref:System.String.ToUpper%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. Ponadto można użyć <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metody do przekonwertowania ciągu na wielkość liter.  
  
 Operacje wielkość liter może bazować na reguły bieżącej kultury, określonej kultury lub Niezmienna kultura. Mapowanie przypadków może się różnić w zależności od kultura używana, wynik operacji wielkość liter może różnić w zależności od kultury. Rzeczywiste różnice w wielkości liter są trzy typy:  
  
-   Różnice w mapowaniu wielkość LATIN litera i (U + 0049), LATIN małe litery I (U + 0069), LATIN litera I kropka nad (U + 0130) i ŁACIŃSKA MAŁA litera bez kropki I (U + 0131). Tr-TR (turecki (Turcja)) i kultur az-Latn-AZ (Azerbejdżanu, Łacińska) i w tr az i az Latn neutralne kultury odpowiednikiem małe litery alfabetu ŁACIŃSKIEGO WIELKĄ LITERĄ I jest alfabetu ŁACIŃSKIEGO MAŁA litera bez kropki I i jest odpowiednikiem wielkie litery alfabetu ŁACIŃSKIEGO małe litery I WIELKA LITERA I Z KROPKĄ POWYŻEJ. W innych kultur w tym Niezmienna kultura LATIN małe litery I i litera LATIN I są odpowiedniki małych i wielkich.  
  
     W poniższym przykładzie pokazano sposób porównania ciągów zaprojektowane aby uniemożliwić dostęp do systemu plików może zakończyć się niepowodzeniem, jeśli zależy od porównanie zależne od kultury, wielkości liter. (Konwencje wielkości liter z kulturą niezmienną należało.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Różnice w przypadku mapowania między Niezmienna kultura i wszystkich innych kultur. W takich przypadkach Zmienianie znaki na wielkie lub małe litery przy użyciu reguł wielkości liter z kulturą niezmienną zwraca ten sam znak. Dla wszystkich innych kultur zwraca innego znaku. Niektóre znaki dotyczy są wymienione w poniższej tabeli.  
  
    |Znak|Zmieniony na|Zwraca|  
    |---------------|-------------------|-------------|  
    |ZNAK MICRON (U + 00B5)|Wielkie litery|GRECKI LITERA MU (U +-39C)|  
    |WIELKA LITERA I Z KROPKĄ POWYŻEJ (U + 0130)|Małe litery|MAŁA LITERA I (U + 0069)|  
    |MAŁA LITERA BEZ KROPKI I (U + 0131)|Wielkie litery|WIELKA LITERA I (U + 0049)|  
    |MAŁA LITERA S DŁUGI (U + 017F)|Wielkie litery|WIELKA LITERA S (U + 0053)|  
    |WIELKA LITERA D Z MAŁA LITERA Z ZE ZNAKIEM CARON (U + 01C 5)|Małe litery|DZ MAŁA LITERA Z CARON (U + 01C 6)|  
    |ŁĄCZENIE YPOGEGRAMMENI GRECKI (U + 0345)|Wielkie litery|GRECKI LITERA IOTA (U + 0399)|  
  
-   Różnice w mapowanie przypadków par dwuliterowych wielkie i małe litery w zakresie znaków ASCII. W większości kultur parę wielkie i małe litery dwuliterowych jest równa dwuliterowych równoważne pary wielkich i małych liter. Nie dotyczy następujących par dwuliterowych w następujących kultury, ponieważ w każdym przypadku są porównywane z dwuznaku:  
  
    -   "arkusza finansowego" i "nJ" w kultury hr-HR (Chorwacki (Chorwacja)).  
  
    -   "cH" cs-CZ (czeski (Czechy)) i kultur sk-SK (Słowacki (Słowacja)).  
  
    -   "aA" w kultury da k (duński (Dania)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "BR" i "zS" w kultury hu-HU (węgierski (Węgierskiej)).  
  
    -   "cH" i "wszystko" w kultury es-ES_tradnl (Hiszpański (Hiszpania, tradycyjny)).  
  
    -   "cH", "gI", "kH", "m" "nH", "ciąg", "Ustawienia kol", "przed" i "tR" w kultury vi-VN (Wietnamski (Wietnam)).  
  
     Jest jednak nietypowe wystąpienia sytuacji, w którym porównanie zależne od kultury te pary stwarza problemy, ponieważ te pary występują rzadko w ciągów stałym lub identyfikatorów.  
  
 Poniższy przykład przedstawia niektóre różnice w regułach wielkości liter od kultury podczas konwertowania ciągów na wielkie litery.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Formatowanie i analizowanie  
 Formatowanie i analizowania to odwrotność operacje. Reguły formatowania określić, w jaki można przekonwertować wartości, takich jak daty i godziny lub liczby do reprezentacji ciągu, natomiast podczas analizowania reguły określają, jak przekonwertować reprezentację ciągu na wartość daty i godziny. Zarówno formatowania ani do analizowania reguły są zależne od kultury Konwencji. Poniższy przykład przedstawia niejednoznaczności, które mogą wystąpić przy interpretowaniu ciągu daty specyficzne dla kultury. Bez wiedzy o konwencje kultury, którego użyto do utworzenia ciągu daty, nie jest możliwość sprawdzenia, czy 2011-03-01, 2011-3-1 i 2011-01-03 reprezentować 3 stycznia 2011 lub 1 marca 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Podobnie jak w poniższym przykładzie pokazano, pojedynczy ciąg może utworzyć różne dni, w zależności od kultury, na których konwencje są używane w ramach operacji analizy.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Porównanie ciągów i sortowanie  
 Konwencje dotyczące porównywanie i sortowanie ciągów różnią się od kultury kultury. Na przykład kolejność sortowania może opierać się na informacje fonetyczne lub wizualną reprezentację znaków. W językach wschodnioazjatyckich znaki są sortowane według obrysu i radykalne usprawnienie z ideogramami. Również sortowanie zależy od kolejności języków i kultur na użytek alfabetu. Na przykład w języku duńskim ma się od znaku "Æ" sortujące po "Z", alfabetu. Ponadto można porównania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter, a w niektórych przypadkach reguły wielkości liter również różnią się kultury. {Numer porządkowy porównania z drugiej strony, używa punktów kodowych Unicode dla poszczególnych znaków w ciągu podczas porównywanie i sortowanie ciągów.  
  
 Określa reguły sortowania znaków Unicode w porządku alfabetycznym i jak dwa ciągi porównać ze sobą. Na przykład <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metoda porównuje dwa ciągi na podstawie <xref:System.StringComparison> parametru. Jeśli wartość parametru jest <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, metoda przeprowadza językowe porównanie, które używa konwencji bieżącej kultury; Jeśli wartość parametru jest <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, metoda przeprowadza porównanie liczby porządkowej. W związku z tym jak w poniższym przykładzie pokazano, w przypadku bieżącej kultury stany USA Angielski, pierwsze wywołanie w celu <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> — metoda (przy użyciu porównania z uwzględnieniem kultury) uwzględnia "" większe niż "A", ale uzna, drugie wywołanie tej samej metody (przy użyciu porównanie liczby porządkowej) "a" większe niż "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework obsługuje word, typ string i reguły porządkową sortowania:  
  
-   Sortowanie programu word wykonuje porównanie zależne od kultury ciągów, w którym niektórych znaków innych niż alfanumeryczne Unicode może mieć specjalne wagi przypisanej. Na przykład łącznik (-) może być bardzo małych wagi przypisane do niego "coop" oraz "zawiera" będą wyświetlane obok siebie w posortowaną listę. Aby uzyskać listę <xref:System.String> metod, które porównuje dwa ciągi, przy użyciu reguły sortowania programu word, zobacz [ciągu operacji według kategorii](#ByCategory) sekcji.  
  
-   Ciąg sortowania wykonuje także porównanie zależne od kultury. Jest on podobny do sortowania programu word, z tą różnicą, że nie żadnych szczególnych przypadkach i wszystkie symbole innych niż alfanumeryczne występować przed wszystkie alfanumeryczne znaki Unicode. Dwa ciągi, które można porównać przy użyciu reguły sortowania ciąg przez wywołanie metody <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> przeciążenia metody, które mają `options` parametr, który jest dostarczona wartość <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Należy pamiętać, że jest jedyną metodą programu .NET Framework zapewnia do porównywania dwóch ciągów za pomocą reguły sortowania ciągu.  
  
-   Porządkową sortowania porównuje ciągi na podstawie wartości liczbowe każdego <xref:System.Char> obiektu w ciągu. Porównanie liczby porządkowej jest automatycznie z uwzględnieniem wielkości liter, ponieważ wersje małych i wielkich znaku ma inny kod punktów. Jednak case nie jest ważna, można określić liczby porządkowej porównania, który ignoruje wielkość liter. Jest to równoważne konwertowania ciągu na wielkie litery użyta Niezmienna kultura, a następnie wykonuje porządkowej porównanie wyniku. Aby uzyskać listę <xref:System.String> metod, które porównuje dwa ciągi, przy użyciu reguł porządkowych sortowania, zobacz [ciągu operacji według kategorii](#ByCategory) sekcji.  
  
 Porównanie zależne od kultury jest wszelkie porównania, która jawnie lub niejawnie używa <xref:System.Globalization.CultureInfo> obiektu, w tym Niezmienna kultura, która jest określona przez <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości. Niejawne kultury jest bieżącej kultury, które jest określone przez <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Istnieje znaczne zmiany w kolejności sortowania znaków alfabetu (czyli znaków, dla którego <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> zwraca właściwości `true`) między kultur. Można określić porównanie zależne od kultury, które używa konwencji określoną kulturę, podając <xref:System.Globalization.CultureInfo> obiekt do metodę porównywania ciągów, takich jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Można określić porównanie zależne od kultury, które używa konwencji bieżącej kultury, podając <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, lub dowolny element członkowski <xref:System.Globalization.CompareOptions> wyliczenie innych niż <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> lub <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> do odpowiedniej przeciążenia z <xref:System.String.Compare%2A> metody. Porównanie zależne od kultury jest zazwyczaj sortować według liczby porządkowej porównania nie jest. Porównanie liczby porządkowej jest zazwyczaj odpowiednie do określenia, czy dwa ciągi są takie same (to znaczy określania tożsamości) porównania z uwzględnieniem kultury nie jest.  
  
 Poniższy przykład przedstawia różnicę między porównania z uwzględnieniem kultury i liczby porządkowej. Oblicza przykładzie trzy ciągi, "Apple", "Æble" i "AEble", przy użyciu porównanie liczby porządkowej i konwencje kultur da k i en US (w czasie z których każdy jest domyślną kulturą <xref:System.String.Compare%2A> metoda jest wywoływana). Ponieważ języku duńskim traktuje znak "Æ" jako jednej litery i sortuje ją po "Z" alfabetu, ciąg "Æble" jest większa niż "Apple". Jednak "Æble" jest uważana za równoważne "AEble", "Æble" również jest większa niż "AEble". Kultura en US nie zawierają litery "Æ", ale traktuje je jako odpowiednik "AE", który wyjaśnia, dlaczego "Æble" jest mniejsza niż "Apple", ale równa "AEble". {Numer porządkowy porównania z drugiej strony uwzględnia "Apple" jest mniejsza niż "Æble" i "Æble" powinien być większy niż "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Umożliwia wybieranie odpowiedniej metody porównania sortowanie lub ciąg ogólne wytyczne:  
  
-   Jeśli ciągi może zostać określona ma zależności od kultury użytkownika, należy je oparte na Konwencji bieżącej kultury zamówienia. W przypadku zmiany kultury użytkownika, kolejność posortowane ciągi spowoduje również zmianę odpowiednio. Na przykład aplikacji tezaurusa zawsze należy sortować słowa oparte na kulturę użytkownika.  
  
-   Jeśli chcesz ciągi może zostać określona oparte na Konwencji określoną kulturę, należy zamówić je podając <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje metodę porównywania tej kultury. Na przykład w aplikacji przeznaczony do nauki studentów konkretnego języka ma ciągi może zostać określona oparte na Konwencji jednego kultur, które mówi tego języka.  
  
-   Jeśli chcesz, aby pozostają niezmienione między kultur ciągów, należy zamówić oparte na Konwencji Niezmienna kultura lub użyj porównanie liczby porządkowej. Na przykład użyje porządkową sortowania, aby organizować nazwy plików, procesów, muteksy, lub nazwanych potoków.  
  
-   Do porównania, która obejmuje decyzji zabezpieczeń (na przykład tego, czy nazwa użytkownika jest nieprawidłowy), należy zawsze wykonać porządkowej testowanie równości wywołując przeciążenia <xref:System.String.Equals%2A> metody.  
  
> [!NOTE]
>  Zależne od kultury sortowania i wielkość liter reguły używane w ciągu porównania są zależne od wersji programu .NET Framework. W programie .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] systemem [!INCLUDE[win8](~/includes/win8-md.md)] systemu operacyjnego, sortowanie, wielkości liter, normalizacji i informacje o znaku Unicode jest zgodny ze standardem Unicode w wersji 6.0. W innych systemach operacyjnych działa zgodnie ze standardem Unicode 5.0.  
  
 Aby uzyskać więcej informacji dotyczących programu word, typ string i reguły porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tematu. Aby dodatkowe zalecenia o tym, kiedy należy używać każdej reguły, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Zwykle nie wywołujesz ciąg porównanie metod, takich jak <xref:System.String.Compare%2A> bezpośrednio do określania porządku sortowania ciągów. Zamiast tego metody porównania są nazywane sortując metod, takich jak <xref:System.Array.Sort%2A?displayProperty=nameWithType> lub <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. Cztery różne operacje sortowania (przy użyciu bieżącej kultury, sortowanie programu word użyta Niezmienna kultura, porządkową sortowania i ciąg sortowania użyta Niezmienna kultura sortowania programu word) w poniższym przykładzie jest wykonywane bez jawnego wywołania metodę porównywania ciągów Mimo że określają typ porównania do użycia. Należy pamiętać, że każdy typ sortowania tworzy unikatowy kolejności ciągów w jego tablicy.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Wewnętrznie środowiska.NET Framework używa klucze sortowania do obsługi culturallysensitive porównywania ciągów. Każdego znaku w ciągu znajduje się kilka kategorii sortowania wagi, tym alfabetyczne, wielkości i diakrytycznych. Klucz, reprezentowany przez <xref:System.Globalization.SortKey> klasy, zapewnia repozytorium te wagi dla określonego ciągu. Jeśli aplikacja przeprowadza dużą liczbę wyszukiwanie i sortowanie operacji na tym samym zestawie ciągów, jego wydajność można poprawić przez generowanie i przechowywanie kluczy sortowania dla wszystkich ciągów, których używa. Gdy wymagana jest operacja sortowania i porównywania, można użyć klucze sortowania zamiast ciągów. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.SortKey> klasy.  
  
 Jeśli nie określisz Konwencji porównanie ciągu sortowanie metody takie jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> wykonać sortowania zależne od kultury, z uwzględnieniem wielkości liter na ciągach. Poniższy przykład przedstawia, jak bieżąca kultura wpływają kolejność posortowane ciągów w tablicy. Tworzy tablicę trzy ciągi. Po pierwsze, ustawia `System.Threading.Thread.CurrentThread.CurrentCulture` właściwości en US i wywołania <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> metody. Wynikowa kolejność sortowania jest oparta na sortowanie konwencje dla kultury angielski (Stany Zjednoczone). Następnie w przykładzie `System.Threading.Thread.CurrentThread.CurrentCulture` właściwości da k i wywołania <xref:System.Array.Sort%2A?displayProperty=nameWithType> metody ponownie. Zwróć uwagę, jak wynikowy porządek sortowania różni się od wyników en US, ponieważ używa konwencji sortowania duński (Dania).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Jeśli Twoje podstawowym celem w porównywanie ciągów ma na celu określenie, czy są one takie same, należy wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metody. Zwykle należy używać <xref:System.String.Equals%2A> do przeprowadzenia porównania porządkowych. <xref:System.String.Compare%2A?displayProperty=nameWithType> Metody jest przeznaczony głównie w celu sortowania ciągów.  
  
 Ciąg metody wyszukiwania, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, można przeprowadzić porównania ciągu zależne od kultury lub liczby porządkowej. Poniższy przykład przedstawia różnice między numerem porządkowym i zależne od kultury porównań, przy użyciu <xref:System.String.IndexOf%2A> metody. Wyszukiwanie zależne od kultury, w którym bieżącej kultury jest angielski (Stany Zjednoczone) uwzględnia podciągu "oe", aby dopasować ligatury "o". Ponieważ nietrwałego łącznik (U + 00AD) jest znak zerowej szerokości, wyszukiwanie traktuje nietrwałego łącznik jako odpowiednik <xref:System.String.Empty> i znalezienia dopasowania na początku ciąg. {Numer porządkowy wyszukiwania z drugiej strony, nie znaleziono dopasowania w każdym przypadku.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Wyszukiwanie ciągów  
 Ciąg metody wyszukiwania, takie jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType> i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, można przeprowadzić zależne od kultury lub porównywanie ciągów porządkowej do ustalenia, czy znak lub substring został znaleziony w określonego ciągu.  
  
 Metody wyszukiwania w <xref:System.String> klasy, która wyszukiwania poszczególnych znaków, takich jak <xref:System.String.IndexOf%2A> metody lub jednej z zestawu znaków, takich jak <xref:System.String.IndexOfAny%2A> metody, wszystkie wyszukiwaniu porządkowych. Aby wykonać wyszukiwanie zależne od kultury znaku, należy wywołać <xref:System.Globalization.CompareInfo> metody, takie jak <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> lub <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Należy pamiętać, że wyniki wyszukiwania przy użyciu porównanie liczby porządkowej i zależne od kultury znak może być bardzo różnią się. Na przykład wyszukiwanie złożony znaków Unicode, takie jak ligatury "Æ" (U + 00 C 6) mogą być zgodne z jego składników w odpowiedniej kolejności, takie jak "AE" dowolne wystąpienie (U + 041U + 0045), w zależności od kultury. Poniższy przykład przedstawia różnice między <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> i <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> metody podczas wyszukiwania poszczególnych znaków. Ligatury "æ" (U + 00E6) znajduje się w ciągu "satelitarnej" podczas korzystania z Konwencją kultury en US, ale nie w przypadku, gdy za pomocą Konwencji kultury da Ciemny lub wykonywania porównanie liczby porządkowej.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Z drugiej strony <xref:System.String> metody, które wyszukaj ciąg zamiast znak wyszukiwanie zależne od kultury Jeśli opcje wyszukiwania nie są jawnie określone przez parametr typu klasy <xref:System.StringComparison>. Jedynym wyjątkiem jest <xref:System.String.Contains%2A>, który wykonuje porządkowej wyszukiwania.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testowanie pod kątem równości  
 Użyj <xref:System.String.Compare%2A?displayProperty=nameWithType> metodę, aby określić relacji dwa ciągi w kolejności sortowania. Zazwyczaj jest to operacja zależne od kultury. Z kolei wywołać <xref:System.String.Equals%2A?displayProperty=nameWithType> metody do testowania pod kątem równości. Ponieważ testowanie równości zwykle porównuje dane wejściowe użytkownika z niektórych znanym ciągu, takie jak prawidłową nazwę użytkownika, hasło lub ścieżka systemu plików, jest zazwyczaj porządkowej operacji.  
  
> [!WARNING]
>  Umożliwia testowanie równości przez wywołanie metody <xref:System.String.Compare%2A?displayProperty=nameWithType> — metoda i określania, czy wartość zwracana jest wartość zero. Jednak takie rozwiązanie nie jest zalecane. Aby ustalić, czy dwa ciągi są takie same, należy wywołać jednego z przeciążeń <xref:System.String.Equals%2A?displayProperty=nameWithType> metody. Preferowany przeciążenia wywołać jest albo wystąpienie <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metody lub statycznego <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody, ponieważ obu metod uwzględnić <xref:System.StringComparison?displayProperty=nameWithType> parametr jawnie określający typ porównania.  
  
 Poniższy przykład przedstawia zagrożenia wykonania porównania z uwzględnieniem kultury pod kątem równości, gdy numeru porządkowego przez jedną należy użyć. W takim przypadku celem kodu jest Zabroń używania dostępu do systemu plików z adresów URL, które zaczynają się od "FILE://" lub "file://", wykonując porównania bez uwzględniania wielkości liter na początku adresu URL z ciągiem "FILE://". Jednak jeśli porównania z uwzględnieniem kultury jest wykonywana przy użyciu kultury turecki (Turcja) przy użyciu adresu URL, który rozpoczyna się od "file://", porównania równości nie powiedzie się, ponieważ tureckiego wielkie odpowiednikiem małe litery "i" jest "İ" zamiast "I". W związku z tym przypadkowo jest dozwolony dostęp do systemu plików. Z drugiej strony jeśli wykonywane jest porównanie liczby porządkowej, porównania równości zakończy się pomyślnie, a odmowa dostępu do systemu plików.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalizacja  
 Niektóre znaki Unicode mają wiele oświadczeń. Na przykład żadnego z następujących punktów kodowych reprezentują litery "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Wiele oświadczeń dla pojedynczego znaku skomplikować wyszukiwania, sortowania, dopasowywania i inne operacje na ciągach.  
  
 Standardu Unicode definiuje w procesie nazywanym normalizacji zwracające binarna reprezentacja jednego znaku Unicode dla każdego z jego odpowiednik reprezentacje binarnego. Normalizacji można użyć kilku algorytmów, nazywany normalizacji formularze, które należy wykonać różne zasady. .NET Framework obsługuje formuły normalizacji Unicode C, D KC i KD. Ciągi mają zostały znormalizowane do tego samego formularza normalizacji, można można porównać przy użyciu porównanie liczby porządkowej.  
  
 {Numer porządkowy wynik porównania ma porównanie binarne wartości skalarne Unicode odpowiadającego <xref:System.Char> obiektów w każdym ciągu. <xref:System.String> Klasa zawiera kilka różnych metod, które można wykonać porównania porządkowej, takie jak:  
  
-   Wszystkie przeciążenia <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, i <xref:System.String.LastIndexOf%2A> metod, które obejmuje <xref:System.StringComparison> parametru. Metoda przeprowadza porównanie liczby porządkowej, jeśli podana wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase> dla tego parametru.  
  
-   Przeciążeń <xref:System.String.CompareOrdinal%2A> metody.  
  
-   Metody, które używają porównanie liczby porządkowej domyślnie, takich jak <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, i <xref:System.String.Split%2A>.  
  
-   Metody, które Wyszukaj <xref:System.Char> wartość lub dla elementów w <xref:System.Char> tablicy w wystąpienia ciągu. Tych metod uwzględnić <xref:System.String.IndexOf%28System.Char%29> i <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Można określić, czy ciąg jest znormalizowany forma normalizacji C, wywołując <xref:System.String.IsNormalized?displayProperty=nameWithType> można wywołać metody, lub <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodę, aby określić, czy ciąg jest znormalizować do formularza określonego normalizacji. Możesz także wywołać <xref:System.String.Normalize?displayProperty=nameWithType> można wywołać metody do przekonwertowania ciągu forma normalizacji C, lub <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metody do przekonwertowania ciągu do formularza określonego normalizacji. Aby uzyskać szczegółowe informacje na temat normalizacji i porównywanie ciągów, zobacz <xref:System.String.Normalize> i <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metody.  
  
 Poniżej przedstawiono prosty przykładową normalizacji ciągu. Określa literę "ố" na trzy różne sposoby w trzech różnych ciągów i używa porządkowej porównania równości w celu określenia, że każdy ciąg różni się od dwóch ciągów. Następnie konwertuje każdy ciąg do formularzy obsługiwanych normalizacji i ponownie wykonuje porządkowej porównania każdego ciągu w postaci określonego normalizacji. W każdym przypadku drugi test równości pokazuje, czy ciągi są takie same.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Aby uzyskać więcej informacji na temat normalizacji i formularze normalizacji, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, jak również [Unicode standardowe załącznika 15: formuły normalizacji Unicode](https://unicode.org/reports/tr15/) i [normalizacji — często zadawane pytania](https://www.unicode.org/faq/normalization.html) na stronie Unicode.org witryny sieci Web.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operacje na ciągach według kategorii  
 <xref:System.String> Klasy zawiera elementy członkowskie porównywanie ciągów, testowanie ciągów pod kątem równości, znajdowanie znaków lub podciągów w ciągu modyfikowanie ciąg wyodrębniania podciągów z ciągu łączenie ciągów, formatowanie wartości ciągu, kopiowanie i normalizacji ciąg.  
  
### <a name="comparing-strings"></a>Porównywanie ciągów  
 Możesz porównać ciągów, aby określić ich położenia w porządku sortowania zgodnie z następującym <xref:System.String> metod:  
  
-   <xref:System.String.Compare%2A> Zwraca liczbę całkowitą wskazującą relacji jeden ciąg na ciąg drugiej w porządku sortowania.  
  
-   <xref:System.String.CompareOrdinal%2A> Zwraca liczbę całkowitą wskazującą relacji jeden ciąg na drugi ciąg na podstawie porównania ich punktów kodowych.  
  
-   <xref:System.String.CompareTo%2A> Zwraca liczbę całkowitą wskazującą relacji bieżącego wystąpienia ciągu na drugi ciąg w kolejności sortowania. <xref:System.String.CompareTo%28System.String%29> Metoda zapewnia <xref:System.IComparable> i <xref:System.IComparable%601> implementacji dla <xref:System.String> klasy.  
  
### <a name="testing-strings-for-equality"></a>Testowanie ciągów pod kątem równości  
 Należy wywołać <xref:System.String.Equals%2A> metodę, aby określić, czy dwa ciągi są takie same. Wystąpienie <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> i statycznych <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> przeciążenia pozwalają określić, czy wynikiem porównania jest zależne od kultury lub numer porządkowy i czy jest uznawany za lub ignorowane. Większość testy równości są porządkowej i porównania równości określające dostęp do zasobu systemu (na przykład obiektu systemu plików) powinna być zawsze porządkowych.  
  
### <a name="finding-characters-in-a-string"></a>Znajdowanie znaków w ciągu  
 <xref:System.String> Klasa zawiera dwa rodzaje metod wyszukiwania:  
  
-   Metody zwracające <xref:System.Boolean> wartości wskazującej, czy danego podciągu znajduje się w wystąpienia ciągu. Obejmują one <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, i <xref:System.String.StartsWith%2A> metody.  
  
-   Metody, które wskazują położenie początkowe podciągu w wystąpienia ciągu. Obejmują one <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, i <xref:System.String.LastIndexOfAny%2A> metody.  
  
> [!WARNING]
>  Jeśli chcesz wyszukać ciąg dla określonego wzorca zamiast określonych podciąg, należy użyć wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modyfikowanie ciągu  
 <xref:System.String> Klasa zawiera następujące metody, które wydają się zmodyfikować wartość ciągu:  
  
-   <xref:System.String.Insert%2A> Wstawia ciąg do bieżącego <xref:System.String> wystąpienia.  
  
-   <xref:System.String.PadLeft%2A> Wstawia jedną lub więcej wystąpień określony znak na początku ciąg.  
  
-   <xref:System.String.PadRight%2A> Wstawia jedną lub więcej wystąpień określony znak na końcu ciągu.  
  
-   <xref:System.String.Remove%2A> Usuwa podciągu z bieżącego <xref:System.String> wystąpienia.  
  
-   <xref:System.String.Replace%2A> zastępuje podciąg inny podciąg w bieżącym <xref:System.String> wystąpienia.  
  
-   <xref:System.String.ToLower%2A> i <xref:System.String.ToLowerInvariant%2A> konwersji wszystkich znaków w ciągu na małe litery.  
  
-   <xref:System.String.ToUpper%2A> i <xref:System.String.ToUpperInvariant%2A> konwersji wszystkich znaków w ciągu na wielkie litery.  
  
-   <xref:System.String.Trim%2A> Usuwa wszystkie wystąpienia znaku od początku i końca ciągu.  
  
-   <xref:System.String.TrimEnd%2A> Usuwa wszystkie wystąpienia znaku od końca ciągu.  
  
-   <xref:System.String.TrimStart%2A> Usuwa wszystkie wystąpienia znaku od początku ciągu.  
  
> [!IMPORTANT]
>  Wszystkie metody modyfikacji ciągu zwraca nową <xref:System.String> obiektu. Ich wartość bieżącego wystąpienia nie należy modyfikować.  
  
### <a name="extracting-substrings-from-a-string"></a>Wyodrębnianie podciągów z ciągu znaków  
 <xref:System.String.Split%2A?displayProperty=nameWithType> Metody oddziela jednego ciągu w wielu ciągów. Przeciążenia metody umożliwiają określenie wielu ograniczników, aby określić maksymalną liczbę podciągów wyodrębnia metody i do ustalenia, czy puste ciągi (które wystąpić, gdy ograniczniki znajdują się obok siebie) są dołączane do zwracanych ciągów.  
  
### <a name="combining-strings"></a>Łączenie ciągów  
 Następujące <xref:System.String> metody mogą być używane dla ciągów:  
  
-   <xref:System.String.Concat%2A> łączy podciągów co najmniej w jednym ciągu.  
  
-   <xref:System.String.Join%2A> argument podciągów co najmniej jeden do jednego elementu i dodaje separatora między każdym podciąg.  
  
### <a name="formatting-values"></a>Formatowanie wartości  
 <xref:System.String.Format%2A?displayProperty=nameWithType> — Metoda korzysta z złożonych funkcji formatowania należy zastąpić symbole zastępcze co najmniej jeden w ciągu reprezentację ciągu niektórych obiektów lub wartość. <xref:System.String.Format%2A> Metoda jest często używana do wykonaj następujące czynności:  
  
-   Aby osadzić reprezentację ciągu wartości numerycznej w ciągu.  
  
-   Aby osadzić reprezentację ciągu wartość daty i godziny w ciągu.  
  
-   Aby osadzić reprezentacja ciągu wartości wyliczenia w ciągu.  
  
-   Aby osadzić reprezentację ciągu niektórych obiekt, który obsługuje <xref:System.IFormattable> interfejsu w ciągu.  
  
-   Do prawej lub lewej substring w polu ciągu większy.  
  
 Aby uzyskać szczegółowe informacje dotyczące formatowania operacji i przykłady, zobacz <xref:System.String.Format%2A> przeciążenia podsumowanie.  
  
### <a name="copying-a-string"></a>Kopiowanie ciągu  
 Możesz wywołać następujące <xref:System.String> metod do skopiowania ciąg:  
  
-   <xref:System.String.Clone%2A> Zwraca odwołanie do istniejącej <xref:System.String> obiektu.  
  
-   <xref:System.String.Copy%2A> Tworzy kopię istniejącego ciągu.  
  
-   <xref:System.String.CopyTo%2A> kopiuje część ciągu do tablicy znaków.  
  
### <a name="normalizing-a-string"></a>Normalizowanie ciągu  
 W formacie Unicode pojedynczy znak mogą mieć wiele punktów kodu. Normalizacji konwertuje równoważne znaków na tej samej binarna reprezentacja. <xref:System.String.Normalize%2A?displayProperty=nameWithType> Metoda przeprowadza normalizacji i <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> Metoda określa, czy znormalizowany jest ciąg.  
  
 Aby uzyskać więcej informacji i przykład zobacz [normalizacji](#Normalization) wcześniej w tym temacie.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
 [Składnia przeciążonego konstruktora](#Syntax)   
 [Parametry](#Params)   
 [Wyjątki](#Exceptions)   
 [Która metoda zostanie wywołana?](#Tasks)   
 [Tworzenie ciągów](#Creating_Strings)   
 [Obsługa powtarzających się ciągów](#Repetitive)   
 Przykłady tworzenia wystąpienia ciągów:   
 [Przy użyciu ciągu przypisania](#Ctor1_Example)  
 [Przy użyciu tablicy znaków](#Ctor2_Example)  
 [Przy użyciu części tablicy znaków i powtarzając pojedynczy znak](#Ctor3_Example)  
 [Przy użyciu wskaźnika do tablicy znaków](#Ctor4_Example)  
 [Przy użyciu wskaźnik i zakresu tablicy](#Ctor5_Example)  
 [Przy użyciu wskaźnika do tablicy bajtu ze znakiem](#Ctor6_Example)  
[Informacje o wersji](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Przeciążona składnia konstruktora  
 Konstruktory ciągu można podzielić na dwie kategorie: te bez parametry wskaźnika, a także z parametrami wskaźnika. Konstruktory, które używają wskaźniki nie są zgodne ze specyfikacją CLS. Ponadto program Visual Basic nie obsługuje użycia wskaźników i C# wymaga kod, który używa wskaźników do uruchomienia w niebezpiecznym kontekście. Aby uzyskać więcej informacji, zobacz [niebezpieczne](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Aby uzyskać dodatkowe wskazówki dotyczące wybierania przeciążenia, zobacz [która metoda zostanie wywołana?](#Tasks)  
  
 `String(Char[] value)`  
 Inicjuje nowe wystąpienie do wartości wskazywane przez tablicę znaków Unicode. Ten konstruktor kopiuje znaków Unicode ([przykład](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicjuje nowe wystąpienie do wartości wskazywane przez tablicę znaków Unicode, pozycji początkowej znaków w tablicy i długości ([przykład](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicjuje nowe wystąpienie do wartości wskazywane przez określony znak Unicode powtórzone określoną liczbę razy ([przykład](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Nie zgodne z CLS) ** Inicjuje nowe wystąpienie do wartość wskazywana przez wskaźnik do tablicy znaków Unicode, który zostanie zakończony znakiem null (U + 0000 lub '\0'). ([przykład](#Ctor4_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Nie zgodne z CLS) ** Inicjuje nowe wystąpienie do wartość wskazywana przez wskaźnik do tablicy znaków Unicode, pozycji początkowej znaków w tablicy i długości. Konstruktor kopiuje znaki Unicode z `value` począwszy od indeksu `startIndex` i kończący się pod indeksem `startIndex`  +  `length` -1 ([przykład](#Ctor5_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value)`  
 **(Nie zgodne z CLS) ** Inicjuje nowe wystąpienie do wartość wskazywana przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem. Przyjęto, że tablica reprezentują ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowanie określone przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaków z `value` od lokalizacji określonej przez wskaźnik, aż do osiągnięcia znak null (0x00) ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Nie zgodne z CLS) ** Inicjuje nowe wystąpienie do wartość wskazywana przez wskaźnik do tablicy, 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tablicy i długości.  Przyjęto, że tablica reprezentują ciąg zakodowany przy użyciu bieżącej strony kodowej systemu (czyli kodowanie określone przez <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Konstruktor przetwarza znaki z wartości, zaczynając od `startIndex` i kończący się na `startIndex`  +  `length` -1 ([przykład](#Ctor6_Example)).  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Nie zgodne z CLS) ** Inicjuje nowe wystąpienie do wartość wskazywana przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tablicy, długość, a <xref:System.Text.Encoding> obiektu.  
  
 Uprawnienie: <xref:System.Security.SecurityCriticalAttribute>, wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametry  
 Poniżej przedstawiono pełną listę parametrów używanych przez <xref:System.String> konstruktorów, które nie zawierają parametr wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Tablica znaków Unicode.|  
|`c`|<xref:System.Char>|Znak Unicode.|  
|`startIndex`|<xref:System.Int32>|Położenie początkowe w `value` pierwszego znaku w nowych parametrów.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba znaków w `value` do uwzględnienia w nowych parametrów.<br /><br /> Wartość domyślna: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Liczba znaków `c` jest powtarzany w nowych parametrów. Jeśli `count` wynosi zero, wartość nowego obiektu jest <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Poniżej przedstawiono pełną listę parametrów używanych przez <xref:System.String> konstruktorów, które obejmują parametr wskaźnika. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> —lub—<br /><br /> <xref:System.SByte>\*|Wskaźnik do zerem tablicy znaków Unicode lub tablicę 8-bitowych liczb całkowitych ze znakiem. Jeśli `value` jest `null` lub pusta tablica, wartość nowego ciągu jest <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Indeks elementu tablicy, definiujący pierwszy znak w nowych parametrów.<br /><br /> Wartość domyślna: 0|  
|`length`|<xref:System.Int32>|Liczba elementów tablicy używać do tworzenia nowych parametrów. Jeśli długość wynosi zero, konstruktora tworzy ciąg, którego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Wartość domyślna: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Obiekt, który określa sposób `value` tablicy jest zaszyfrowana.<br /><br /> Wartość domyślna: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, lub systemu bieżącej strony kodowej ANSI|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Wyjątki  
 Poniżej przedstawiono listę wyjątków zgłaszanych przez konstruktorów, które nie zawierają parametry wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` jest `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, lub `count` jest mniejsza od zera.<br /><br /> —lub—<br /><br /> Suma `startIndex` i `length` jest większa niż liczba elementów w `value`.<br /><br /> —lub—<br /><br /> `count` jest mniejsza od zera.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Poniżej przedstawiono listę wyjątków zgłaszanych przez konstruktorów zawierających parametry wskaźnika.  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Określa tablicę, która zawiera nieprawidłowy znak Unicode.<br /><br /> —lub—<br /><br /> `value` lub `value`  +  `startIndex` Określa adres, który jest mniej niż 64 KB.<br /><br /> —lub—<br /><br /> Nowy <xref:System.String> nie można zainicjować wystąpienia z `value` tablicy typu byte, ponieważ `value` nie używa domyślnego kodu kodowania strony.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.ArgumentNullException>|`value` ma wartość null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Bieżący proces nie ma dostęp do odczytu do wszystkich zaadresowane znaków.<br /><br /> —lub—<br /><br /> `startIndex` lub `length` jest mniejszy od zera, `value`  +  `startIndex` spowodować przepełnienie wskaźnika lub bieżący proces nie ma dostęp do odczytu do wszystkich zaadresowane znaków.<br /><br /> —lub—<br /><br /> Długość nowego ciągu jest zbyt duży, aby przydzielić.|Wszystkie konstruktory ze wskazówkami.|  
|<xref:System.AccessViolationException>|`value`, lub `value`  +  `startIndex`  +  `length` — 1, określa nieprawidłowy adres.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Do|Wywołanie lub użyj|  
|--------|-----------------|  
|Tworzenie ciągu.|Przypisanie z literału ciągu lub istniejący ciąg ([przykład](#Ctor1_Example))|  
|Tworzenie ciągu z tablicy całego znaku.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([przykład](#Ctor2_Example))|  
|Tworzy ciąg z części tablicy znaków.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([przykład](#Ctor3_Example))|  
|Utwórz ciąg, który powtarza się wielokrotnie ten sam znak.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([przykład](#Ctor3_Example))|  
|Tworzenie ciągu z wskaźnika do tablicy znaków typu wide lub Unicode.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Tworzenie ciągu z części Unicode lub znaków typu wide tablicy przy użyciu jego wskaźnika.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Tworzenie ciągu z C++ `char` tablicy.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> —lub—<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Tworzenie ciągu z znaki ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Tworzenie ciągów  
 Najczęściej używane techniki programowe tworzenie ciągów jest przypisanie proste, jak pokazano na [w tym przykładzie](#Ctor1_Example). <xref:System.String> Klasa zawiera także cztery typy przeciążeń konstruktora, które pozwalają tworzyć ciągów z następujących wartości:  
  
-   Z tablicy znaków (tablicy algorytmem UTF-16 znaków). Można utworzyć nowy <xref:System.String> obiektu na podstawie znaków w całej tablicy lub jego część. <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiuje wszystkie znaki w tablicy do nowych parametrów. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor kopiuje znaki z indeksu `startIndex` do indeksu `startIndex`  +  `length` — od 1 do nowych parametrów. Jeśli `length` wynosi zero, wartość nowego ciągu jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Jeśli kod tworzy wielokrotnie ciągów, które mają taką samą wartość, może zwiększyć wydajność aplikacji przy użyciu alternatywne metody tworzenia ciągów. Aby uzyskać więcej informacji, zobacz [obsługi ciągi powtarzających się](#Repetitive).  
  
-   Z jednej znaków będący zduplikowanych zero, co, lub więcej razy, używając <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> konstruktora. Jeśli `count` wynosi zero, wartość nowego ciągu jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Ze wskaźnika do tablicy znaków zakończony znakiem null, za pomocą <xref:System.String.%23ctor%28System.Char%2A%29> lub <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> konstruktora. Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Konstruktor kopiuje sekwencji znaków Unicode, uruchamianie z określonym wskaźnika lub określony wskaźnik plus `startIndex` i kontynuowanie do końca tablicy lub dla `length` znaków. Jeśli `value` jest wskaźnika o wartości null lub `length` wynosi zero, konstruktora tworzy ciąg, którego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli tablica nie jest zerem operacji kopiowania przechodzi do końca tablicy, zachowanie Konstruktor jest zależny od systemu. Taki stan może spowodować naruszenie zasad dostępu.  
  
     Jeśli tablica zawiera osadzony znaków wartości null (U + 0000 lub '\0') i <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> wywołać przeciążenia, wystąpienie ciągu zawiera `length` znaków, wraz ze wszystkimi osadzone wartości null. W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów zawiera dwa znaki null została przekazana do <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest na początku tablicy i wszystkich elementów w tablicy, które mają być dodawane do ciągu, konstruktora tworzy wystąpienie ciągu z 10 znaków, łącznie z dwóch osadzone wartości. Z drugiej strony, jeśli w tej samej tablicy jest przekazywana do <xref:System.String.%23ctor%28System.Char%2A%29> konstruktora, wynik jest ciągiem czterech znaków, który nie obejmuje pierwszy znak wartości null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Tablica musi zawierać znaki Unicode. W języku C++, oznacza to, że tablica znaków musi być zdefiniowana jako zarządzanego <xref:System.Char>[] typu lub niezarządzanej`wchar_t`[] typu.  
  
     Jeśli <xref:System.String.%23ctor%28System.Char%2A%29> wywołać przeciążenia i Tablica nie jest zerem, lub jeśli <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> wywołać przeciążenia i `startIndex`  +  `length`zakres, który go poza ilość pamięci przydzielona dla sekwencji znaków, zawiera wartość -1 zachowanie Konstruktor jest zależny od systemu i może wystąpić naruszenie dostępu. Ponadto na procesorze Intel Itanium wywołań <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor może zgłaszać <xref:System.DataMisalignedException> wyjątku. W takim przypadku wywołania <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> zamiast tego.  
  
-   Ze wskaźnika na tablicę bajtów podpisem. Do zainicjowania ciągu można wykorzystać macierz w całości lub w określonym zakresie. Może zostać zinterpretowany sekwencję bajtów za pomocą domyślną stronę kodową kodowania lub kodowania może być określone w wywołaniu konstruktora. Jeśli Konstruktor podejmie próbę utworzenia wystąpienia ciągu z tablicy całego, który nie jest zakończony wartością null lub zakresu tablicy z `value`  +  `startIndex` do `value`  +  `startIndex`  +  `length` -1 jest poza pamięć przydzielona dla tablicy, zachowanie tego konstruktora jest zależny od systemu i może wystąpić naruszenie dostępu.  
  
     Trzy konstruktorów, obejmujących tablicę bajtów podpisem jako parametr są przeznaczone głównie w celu konwersji C++ `char` tablicy na ciąg, jak pokazano w poniższym przykładzie:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Jeśli tablica zawiera wszystkie znaki null ('\0') lub bajtów, którego wartość jest równa 0 i <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> wywołać przeciążenia, wystąpienie ciągu zawiera `length` znaków, wraz ze wszystkimi osadzone wartości null. W poniższym przykładzie pokazano, co się dzieje, gdy wskaźnik do tablicy 10 elementów zawiera dwa znaki null została przekazana do <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> metody. Ponieważ adres jest na początku tablicy i wszystkich elementów w tablicy, które mają być dodawane do ciągu, konstruktora tworzy wystąpienie ciągu z 10 znaków, łącznie z dwóch osadzone wartości. Z drugiej strony, jeśli w tej samej tablicy jest przekazywana do <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora, wynik jest ciągiem czterech znaków, który nie obejmuje pierwszy znak wartości null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Ponieważ <xref:System.String.%23ctor%28System.SByte%2A%29> i <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> zinterpretować konstruktorów `value` przy użyciu domyślnej strony kodowej ANSI, wywoływania te konstruktorów z tablic bajtowych identyczne może utworzyć ciągów, które mają różne wartości w różnych systemach.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Obsługa powtarzających się ciągów  
 Użyj aplikacji, które przeanalizować lub dekodowania strumienie tekstu często <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora lub <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> do przekonwertowania na ciąg sekwencje znaków. Wielokrotnie tworzenie nowych ciągów o tej samej wartości zamiast tworzenia i ponowne użycie jednego ciągu marnuje pamięci. Jeśli jesteś mogących utworzyć taką samą wartość ciągu wielokrotnego przez wywołanie metody <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora, nawet jeśli nie znasz w poprawić, co może być tych wartości identycznych ciągów, można użyć tabeli wyszukiwania.  
  
 Załóżmy na przykład, przeczytaj i przeanalizować strumienia znaków z pliku, który zawiera tagi XML oraz atrybuty. Podczas analizy strumienia, wystąpią wielokrotnie niektórych tokeny (to znaczy sekwencji znaków, które mają znaczenie symboliczne). Tokeny równoważne do ciągów "0", "1", "true" i "false" są często występuje w strumieniu XML.  
  
 Zamiast konwertowania każdy token na nowe parametry, można utworzyć <xref:System.Xml.NameTable?displayProperty=nameWithType> obiektu do przechowywania często występującą ciągów. <xref:System.Xml.NameTable> Obiektu zwiększa wydajność, ponieważ jego pobiera ciągi przechowywane bez przydziału pamięci tymczasowej. Gdy wystąpią token, użyj <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metoda pobierania tokenu z tabeli. Jeśli token istnieje, metoda zwraca odpowiedni ciąg. Jeśli token nie istnieje, użyj <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody, aby wstawić token do tabeli, a także aby uzyskać odpowiedni ciąg.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Przykład 1: Zastosowanie przypisania ciągu  
 Poniższy przykład tworzy nowe parametry, przypisując literału ciągu. Tworzy drugi ciąg przez przypisanie wartość ciągu pierwszego. Są dwa sposoby najczęściej używane do tworzenia wystąpienia nowy <xref:System.String> obiektu.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Przykład 2: Zastosowanie tablicy znaków  
 W poniższym przykładzie pokazano, jak utworzyć nową <xref:System.String> obiektu z tablicy znaków.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Przykład 3: Wykorzystanie części tablicy znaków i powtarzanie pojedynczego znaku  
 W poniższym przykładzie pokazano, jak utworzyć nową <xref:System.String> obiektu z części tablicy znaków oraz sposobu tworzenia nowego <xref:System.String> obiekt, który zawiera wiele wystąpień jednego znaku.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Przykład 4: Wykorzystywanie wskaźnika na tablicy znaków  
 W poniższym przykładzie pokazano, jak utworzyć nową <xref:System.String> obiekt ze wskaźnika do tablicy znaków. Przykład C#, muszą być skompilowane przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Przykład 5: Utworzenie wystąpienia ciągu ze wskaźnika i zakresu tablicy  
 Poniższy przykład sprawdza, czy elementy tablicy znaków dla ciągu lub ze znakiem wykrzyknika. Jeśli nie zostanie znalezione, tworzy wystąpienie ciągu z tablicy znaków poprzedzających symbol interpunkcyjny. Jeśli nie, metoda tworzy ciąg zawierający całą zawartość tablicy. Przykład C# musi być kompilowana przy użyciu `/unsafe` przełącznika kompilatora.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Przykład 6: Utworzenie wystąpienia ciągu ze wskaźnika na podpisanej tablicy bajtowej  
 W poniższym przykładzie pokazano, jak można utworzyć wystąpienia <xref:System.String> klasy z <xref:System.String.%23ctor%28System.SByte%2A%29> konstruktora.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informacje o wersji  
 .NET Framework  
 Wszystkie przeciążenia są obsługiwane w wersjach: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Wszystkie przeciążenia są obsługiwane w wersjach: 4, 3.5 z dodatkiem SP1  
  
 Biblioteka klas przenośnych  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane.  
  
 Środowisko .NET dla aPLikacji do Sklepu Windows  
 Wszystkie przeciążenia bez <xref:System.SByte> `*` parametru są obsługiwane w: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode zakończonym znakiem null.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywanym przez określony wskaźnika do tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżący proces nie ma dostęp do odczytu do wszystkich zaadresowane znaków.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Określa tablicę, która zawiera nieprawidłowy znak Unicode, lub <paramref name="value" /> Określa adres mniejszy niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywanym przez tablicę znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy zerem z 8-bitowych liczb całkowitych ze znakiem. Liczby całkowite interpretowania przy użyciu bieżącego systemu kodu strony kodowania (to znaczy kodowanie określone przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywane przez wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany w formacie ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu nowe zainicjować, który jest określany przez znak null zakończenia <paramref name="value" />, jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> Określa nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Znak Unicode.</param>
        <param name="count">Ile razy <c>c</c> występuje.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartość wskazywana przez określony znak Unicode powtórzone określoną liczbę razy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków Unicode.</param>
        <param name="startIndex">Położenie początkowe w <c>wartość</c>.</param>
        <param name="length">Liczba znaków w ciągu <c>wartość</c> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> znaki klasy wartość wskazywana przez określony wskaźnika do tablicy znaków Unicode, pozycji początkowej znaków w tablicy i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejszy od zera, <paramref name="value" />  +  <paramref name="startIndex" /> spowodować przepełnienie wskaźnika lub bieżący proces nie ma dostęp do odczytu do wszystkich zaadresowane znaków.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Określa tablicę, która zawiera nieprawidłowy znak Unicode, lub <paramref name="value" />  +  <paramref name="startIndex" /> Określa adres mniejszy niż 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków Unicode.</param>
        <param name="startIndex">Położenie początkowe w <c>wartość</c>.</param>
        <param name="length">Liczba znaków w ciągu <c>wartość</c> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> znaki klasy wartości wskazywane przez tablicę znaków Unicode, pozycji początkowej znaków w tablicy i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.  - lub - sumę <paramref name="startIndex" /> i <paramref name="length" /> jest większa niż liczba elementów w <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem. Liczby całkowite interpretowania przy użyciu bieżącego systemu kodu strony kodowania (to znaczy kodowanie określone przez <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Położenie początkowe w <c>wartość</c>.</param>
        <param name="length">Liczba znaków w ciągu <c>wartość</c> do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartości wskazywanym przez określony wskaźnika do tablicy, 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tablicy i długości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.  - lub - adresem określonym przez <paramref name="value" />  +  <paramref name="startIndex" /> jest zbyt duży dla bieżącej platformy; oznacza to, że nastąpiło przepełnienie obliczenia adresu.  - lub - długość nowego ciągu inicjowania jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Określony przez adres <paramref name="value" />  +  <paramref name="startIndex" /> jest mniejsza niż 64 KB.  - lub - nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany w formacie ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, i <paramref name="length" /> wspólnie określić nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy 8-bitowych liczb całkowitych ze znakiem.</param>
        <param name="startIndex">Położenie początkowe w <c>wartość</c>.</param>
        <param name="length">Liczba znaków w ciągu <c>wartość</c> do użycia.</param>
        <param name="enc">Obiekt, który określa sposób tablicy odwołuje się <c>wartość</c> jest zaszyfrowana. Jeśli <c>enc</c> jest <see langword="null" />, zakłada, że kodowania ANSI.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.String" /> klasy wartość wskazywana przez określony wskaźnika do tablicy 8-bitowych liczb całkowitych ze znakiem, pozycji początkowej w tablicy, długość, a <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych `String` przeciążeń konstruktora, zobacz <xref:System.String.%23ctor%2A> Konstruktor podsumowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.  - lub - adresem określonym przez <paramref name="value" />  +  <paramref name="startIndex" /> jest zbyt duży dla bieżącej platformy; oznacza to, że nastąpiło przepełnienie obliczenia adresu.  - lub - długość nowego ciągu inicjowania jest zbyt duży, aby przydzielić.</exception>
        <exception cref="T:System.ArgumentException">Określony przez adres <paramref name="value" />  +  <paramref name="startIndex" /> jest mniejsza niż 64 KB.  - lub - nowe wystąpienie klasy <see cref="T:System.String" /> nie można zainicjować za pomocą <paramref name="value" />, przyjmuje <paramref name="value" /> jest zakodowany określone przez <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, i <paramref name="length" /> wspólnie określić nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w ciągu bieżącej.</param>
        <summary>Pobiera <see cref="T:System.Char" /> obiekt na określonej pozycji w bieżącym <see cref="T:System.String" /> obiektu.</summary>
        <value>Obiekt w pozycji <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest liczony od zera.  
  
 Ta właściwość zwraca <xref:System.Char> obiektu pozycji określonej przez `index` parametru. Jednak znaku Unicode może być reprezentowany przez więcej niż jedną <xref:System.Char>. Użyj <xref:System.Globalization.StringInfo?displayProperty=nameWithType> znaki klasy do pracy z Unicode <xref:System.Char> obiektów. Aby uzyskać więcej informacji, zobacz sekcję "Char obiektów i znaków Unicode" w <xref:System.String> Przegląd klasy.  
  
 W języku C# <xref:System.String.Chars%2A> właściwość jest indeksatora. W języku Visual Basic, jest domyślną właściwość <xref:System.String> klasy. Każdy <xref:System.Char> obiektu w ciągu jest możliwy przy użyciu następującego kodu.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używasz ten indeksator w procedury do sprawdzania ciągu.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest większe niż lub równa długości tego obiektu lub mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>To wystąpienie <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrotna nie jest niezależna kopia tego wystąpienia; jest po prostu innego widoku tych samych danych. Użyj <xref:System.String.Copy%2A> lub <xref:System.String.CopyTo%2A> metodę, aby utworzyć oddzielne <xref:System.String> obiektu z taką samą wartość jak to wystąpienie.  
  
 Ponieważ <xref:System.String.Clone%2A> metoda po prostu zwraca istniejące wystąpienie ciągu, Brak wyboru wywołują go bezpośrednio.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skompilowanie wszystkich przeciążeń <xref:System.String.Compare%2A> całkowita 32-bitowy wskazujący leksykalne relację między dwiema comparands zwracany przez metodę.  
  
|Wartość|Warunek|  
|-----------|---------------|  
|Mniej niż zero|Pierwszy podciąg poprzedza podciąg drugi w kolejności sortowania.|  
|Zero|Podciągów występują w tej samej pozycji w kolejności sortowania ani `length` wynosi zero.|  
|Większe od zera|Pierwszy podciąg następuje podciąg drugiej w porządku sortowania.|  
  
> [!WARNING]
>  Jeśli to możliwe, powinny wywoływać przeciążenia <xref:System.String.Compare%2A> metodę, która obejmuje <xref:System.StringComparison> parametru. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Zero </term><description><paramref name="strA" /> odbywa się w tym samym miejscu <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.String.Compare%28System.String%2CSystem.String%29> metody do porównania trzech zestawów parametrów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 W poniższym przykładzie `ReverseStringComparer` klasy pokazano, jak można ocenić dwa ciągi ze <xref:System.String.Compare%2A> metody.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Na przykład następujący kod jest uruchamiany na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, porównanie zależne od kultury "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika miękkie, lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  [! kodu csharp [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare21.cs#21)] [! kodu vb [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare21.vb#21)] rozpoznawanie znaków do pominięcia porównania ciągów, wywołanie <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> — metoda i podaj wartości <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla parametru "typ porównania".</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów, ignorowanie lub zachowaniu ich przypadku i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Zero </term><description><paramref name="strA" /> odbywa się w tym samym miejscu <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodę, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, że <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> jest odpowiednikiem przy użyciu metody <xref:System.String.ToUpper%2A> lub <xref:System.String.ToLower%2A> podczas porównywania ciągów.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Na przykład następujący kod jest uruchamiany na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, zależne od kultury, bez uwzględniania wielkości liter porównanie "zwierzę" z "Ani nieprawidłowo" (przy użyciu łącznika miękkie, lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  [! kodu csharp [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare22.cs#22)] [! kodu vb [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare22.vb#22)] rozpoznawanie znaków do pominięcia porównania ciągów, wywołanie <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> — metoda i podaj wartości <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa zasady służące do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów za pomocą określonych reguł i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Zero </term><description><paramref name="strA" /> znajduje się w tym samym miejscu <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie należy używać bieżącego lub Niezmienna kultura, uznawać Ignoruj wielkość liter comparands lub użyć programu word (zależne od kultury) lub reguły porządkową sortowania (niezależne od kultury).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jednak jeśli porównanie dwóch ciągów w celu jednego ciągu, a inny ciąg zawiera znaki, które pozostały, ciąg z pozostałych znaków jest uważany za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Poniższy przykład porównuje wersje trzy litery "I". Wyniki są zagrożone wybór kultury, czy wielkość liter jest ignorowana i czy jest wykonywane porównanie liczby porządkowej.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> nie jest obsługiwane.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Rozpoznawanie znaków do pominięcia porównania, należy podać wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Obiekt, który dostarcza informacje specyficzne dla kultury porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiekty, ignorowanie lub zachowaniu ich przypadku oraz przy użyciu informacje specyficzne dla kultury wpływ porównania i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Zero </term><description><paramref name="strA" /> odbywa się w tym samym miejscu <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametr, aby uzyskać informacje specyficzne dla kultury, takie jak reguły wielkość liter i znaki w porządku alfabetycznym. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak kultury wpływa na porównanie. W czeski - kultury Czechy "ch" jest pojedynczym znakiem, która jest większa niż "d". Jednak w języku angielskim - kultury Stanów Zjednoczonych "ch" składa się z dwóch znaków i "c" jest mniejsza niż "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Na przykład następujący kod jest uruchamiany na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, bez uwzględniania wielkości liter porównanie "zwierzę" z "Ani nieprawidłowo" (przy użyciu łącznika miękkie, lub U + 00AD) przy użyciu niezmiennej kultury wskazuje, czy dwa ciągi są równoważne.  [! kodu csharp [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare23.cs#23)] [! kodu vb [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare23.vb#23)] rozpoznawanie znaków do pominięcia porównania ciągów, wywołanie <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> — metoda i podaj wartości <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <param name="culture">Kultura, który dostarcza informacje specyficzne dla kultury porównania.</param>
        <param name="options">Opcje używane podczas wykonywania porównania (np. ignorowanie liter i symboli).</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów przy użyciu określonego porównanie opcji i informacje specyficzne dla kultury wpływ porównania i zwraca liczbę całkowitą wskazującą relacji dwa ciągi ze sobą w kolejności sortowania.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem wskazuje leksykalne relację między <paramref name="strA" /> i <paramref name="strB" />, jak pokazano w poniższej tabeli <list type="table"><listheader><term> wartość </term><description> warunku </description></listheader><item><term> Mniejsza od zera </term><description><paramref name="strA" /> poprzedza <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Zero </term><description><paramref name="strA" /> odbywa się w tym samym miejscu <paramref name="strB" /> w kolejności sortowania.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> następuje <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównanie używa `culture` parametr, aby uzyskać informacje specyficzne dla kultury, takie jak reguły wielkość liter i znaki w kolejności alfabetycznej. Na przykład określonej kultury można określić, że niektórych kombinacji znaków być traktowane jako pojedynczy znak, porównać wielkich i małych liter w określony sposób, lub zależny od sortowania znaku znaki który przed lub po nim.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> — Metoda jest przeznaczony głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Należy nie używane, jeśli głównym celem wywołania metody, które ma na celu określenie, czy dwa ciągi, które są równoważne (podczas wywołania metody, które służy do testowania dla wartości zwracanej zero). Aby ustalić, czy dwa ciągi, które są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Porównanie można dodatkowo określić za `options` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.CompareOptions> wyliczenia. Jednakże, ponieważ ta metoda służy do przeprowadzania porównania ciągów zależne od kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> wartości nie mają żadnego skutku.  
  
 Może być jeden lub oba comparands `null`. Zgodnie z definicją dowolny ciąg, w tym <xref:System.String.Empty?displayProperty=nameWithType>, porównanie porównuje większa niż odwołanie o wartości null i dwa puste odwołania do siebie.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba ciągi. Jednak jeśli porównanie dwóch ciągów w celu jednego ciągu, a inny ciąg zawiera znaki, które pozostały, ciąg z pozostałych znaków jest uważany za większy.  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa ciągi na trzy sposoby: za pomocą porównania językowe en US kultury; przy użyciu językowe porównania z uwzględnieniem wielkości liter dla kultury en US; i przy użyciu porównanie liczby porządkowej. Przedstawia on, jak trzy metody porównania wygenerować trzy różne wyniki.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest <see cref="T:System.Globalization.CompareOptions" /> wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Rozpoznawanie znaków do pominięcia porównania, należy podać wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja substring w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja substring w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiekty i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowe całkowita wskazująca leksykalne relację między dwiema comparands.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządek sortowania.  </description></item><item><term> Zero </term><description> podciągów występują w tej samej pozycji w kolejności sortowania ani <paramref name="length" /> wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchom podciągów do porównania w `strA` w `indexA` i `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera; oznacza to pierwszy znak w `strA` i `strB` na pozycji zero. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciąg jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejszy długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągów.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  - lub - albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa od zera.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> — Metoda nie należy wziąć pod uwagę tych znaków podczas porównywania językowe lub zależne od kultury. Aby rozpoznać do pominięcia znaków porównania, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> — metoda i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja substring w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja substring w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiektów, ignorowanie lub zachowaniu ich przypadku i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządek sortowania.  </description></item><item><term> Zero </term><description> podciągów występują w tej samej pozycji w kolejności sortowania ani <paramref name="length" /> wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Start podciągów do porównania `strA` w `indexA`, a następnie w `strB` w `indexB`. Zarówno `indexA` i `indexB` są liczony od zera; oznacza to pierwszy znak w `strA` i `strB` na pozycji zero. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciąg jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejszy długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 Porównanie używa bieżącej kultury, aby uzyskać informacje specyficzne dla kultury, takie jak reguły obudowy porządkiem alfabetycznym poszczególnych znaków. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Podczas porównywania ciągów, należy wywołać <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodę, która wymaga jawnie określić typ porównania ciągów, która używa metody. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące ciągów za pomocą](~/docs/standard/base-types/best-practices-strings.md).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Nazwa ścieżki musi być porównywane w sposób niezmiennej. Prawidłowy kod w tym celu ma następującą składnię.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Poniższy przykład wykonuje dwa porównania dwóch podciągów, które różnią się tylko wielkością liter. Porównanie pierwszego ignoruje wielkość liter i drugi porównania uważa case.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  - lub - albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa od zera.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> — Metoda nie należy wziąć pod uwagę tych znaków podczas porównywania językowe lub zależne od kultury. Aby rozpoznać do pominięcia znaków porównania, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> — metoda i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja substring w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja substring w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa zasady służące do porównania.</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiektów za pomocą określonych reguł i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządek sortowania.  </description></item><item><term> Zero </term><description> podciągów występują w tej samej pozycji w kolejności sortowania lub <paramref name="length" /> parametru wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> follllows podciąg w <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchom podciągów do porównania w `strA` w `indexA` i `strB` na `indexB`. Zarówno `indexA` i `indexB` są liczony od zera; oznacza to pierwszy znak w `strA` i `strB` jest w pozycji zero, nie umieść jeden. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciąg jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejszy długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 `comparisonType` Parametr wskazuje, czy porównanie należy używać bieżącego lub Niezmienna kultura, uznawać Ignoruj wielkość liter comparands lub użyć programu word (zależne od kultury) lub reguły porządkową sortowania (niezależne od kultury).  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jednak jeśli porównanie dwóch ciągów w celu jednego ciągu, a inny ciąg zawiera znaki, które pozostały, ciąg z pozostałych znaków jest uważany za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągów.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  - lub - albo <paramref name="indexA" /> lub <paramref name="indexB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> — Metoda nie należy wziąć pod uwagę tych znaków podczas porównywania językowe lub zależne od kultury. Rozpoznawanie znaków do pominięcia porównania, należy podać wartość <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> dla <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja substring w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja substring w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Obiekt, który dostarcza informacje specyficzne dla kultury porównania.</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiekty, ignorowanie lub zachowaniu ich przypadku oraz przy użyciu informacje specyficzne dla kultury wpływ porównania i zwraca liczbę całkowitą, która wskazuje ich położenia w porządku sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalne relację między dwiema comparands.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządek sortowania.  </description></item><item><term> Zero </term><description> podciągów występują w tej samej pozycji w kolejności sortowania ani <paramref name="length" /> wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Start podciągów do porównania `strA` w `indexA`, a następnie w `strB` w `indexB`. Zarówno `indexA` i `indexB` są liczony od zera; oznacza to pierwszy znak w `strA` i `strB` jest w pozycji zero, nie umieść jeden. Długość pierwszego podciągu jest równa długości `strA` minus `indexA` plus jeden. Długość drugiego podciąg jest równa długości `strB` minus `indexB` plus jeden.  
  
 Liczba znaków do porównania jest mniejszy długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 Porównanie używa `culture` parametr, aby uzyskać informacje specyficzne dla kultury, takie jak reguły wielkość liter i znaki w porządku alfabetycznym. Kultura może na przykład określać, że niektóre kombinacje znaków mogą być traktowane jako pojedynczy znak albo że wielkie i małe litery mają być porównywane w określony sposób, albo że porządek sortowania znaków zależy od znaków poprzedzających lub następnych.  
  
 Porównanie jest wykonywane przy użyciu reguł sortowania wyrazów. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Może być jeden lub oba comparands `null`. Według definicji dowolny ciąg, w tym ciąg pusty (""), porównuje odwołania o wartości większej niż zerowa; wskazuje też, że dwa odwołania zerowe są sobie równe.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jeśli jednak dwa porównywane ciągi są równe do końca jednego z nich, a drugi ciąg ma jeszcze pozostałe znaki, wówczas ciąg z pozostałymi znakami uznaje się za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
 Gdy na porównania wpływają reguły uwzględniające ustawienia kulturowe, mogą wystąpić nieoczekiwane rezultaty. Na przykład w języku tureckim poniższy przykład daje błędne wyniki, ponieważ system plików w tym języku nie używa reguł wielkich liter dla litery „i” w wyrazie „plik”.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Porównaj nazwę ścieżki, aby „uporządkować” według porównania porządkowego. Poprawny kod będzie następujący:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Poniższy przykład porównuje dwa podciągów przy użyciu innych kultur i ignoruje wielkość liter podciągów. Wybór kultury wpływa na sposób litery "I" są porównywane.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  - lub - albo <paramref name="strA" /> lub <paramref name="strB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa od zera.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> — Metoda nie należy wziąć pod uwagę tych znaków podczas porównywania językowe lub zależne od kultury. Aby rozpoznać do pominięcia znaków porównania, należy wywołać <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> — metoda i podaj wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Pozycja początkowa podciągu w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Pozycja początkowa podciągu w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <param name="culture">Obiekt, który dostarcza informacje specyficzne dla kultury porównania.</param>
        <param name="options">Opcje używane podczas wykonywania porównania (np. ignorowanie liter i symboli).</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiektów przy użyciu określonego porównanie opcji i informacje specyficzne dla kultury wpływ porównania i zwraca liczbę całkowitą, która wskazuje relację dwóch podciągów ze sobą w porządek sortowania.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalne relację między dwiema podciągów, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> poprzedza podciągu w <paramref name="strB" /> w porządek sortowania.  </description></item><item><term> Zero </term><description> podciągów występują w tej samej pozycji w kolejności sortowania ani <paramref name="length" /> wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> następuje podciągu w <paramref name="strB" /> w kolejności sortowania.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchom podciągów do porównania w `strA` na pozycji `indexA` i `strB` na pozycji `indexB`. Długość pierwszego podciągu jest długość `strA` minus `indexA`. Długość drugiego podciąg jest długość `strB` minus `indexB`.  
  
 Liczba znaków do porównania jest mniejszy długości dwóch podciągów i `length`. `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 Porównanie używa `culture` parametr, aby uzyskać informacje specyficzne dla kultury, takie jak reguły wielkość liter i znaki w kolejności alfabetycznej. Na przykład określonej kultury można określić, że niektórych kombinacji znaków być traktowane jako pojedynczy znak, porównać wielkich i małych liter w określony sposób, lub zależny od sortowania znaku znaki który przed lub po nim.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> — Metoda jest przeznaczony głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Należy nie używane, jeśli głównym celem wywołania metody, które ma na celu określenie, czy dwa podciągów są równoważne (podczas wywołania metody, które służy do testowania dla wartości zwracanej zero). Aby ustalić, czy dwa ciągi, które są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Jedno lub oba `strA` i `strB` może być `null`. Zgodnie z definicją dowolny ciąg, w tym <xref:System.String.Empty?displayProperty=nameWithType>, porównanie porównuje większa niż odwołanie o wartości null i dwa puste odwołania do siebie.  
  
 Porównanie można dodatkowo określić za `options` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia. Jednakże, ponieważ ta metoda służy do przeprowadzania porównania ciągów zależne od kultury, <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> i <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> wartości nie mają żadnego skutku.  
  
 Porównanie kończy się po wykryciu nierówności lub gdy zostały porównane oba podciągi. Jednak jeśli porównanie dwóch ciągów w celu jednego ciągu, a inny ciąg zawiera znaki, które pozostały, ciąg z pozostałych znaków jest uważany za większy. Zwracana wartość jest wynikiem ostatniego wykonanego porównania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metody do porównania nazwisk osób dwa. Zawiera także je w kolejności alfabetycznej.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest <see cref="T:System.Globalization.CompareOptions" /> wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> jest większa niż <paramref name="strA" /><see langword=".Length" />.  - lub - <paramref name="indexB" /> jest większa niż <paramref name="strB" /><see langword=".Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.  - lub - albo <paramref name="strA" /> lub <paramref name="strB" /> jest <see langword="null" />, i <paramref name="length" /> jest większa od zera.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> — Metoda nie należy wziąć pod uwagę tych znaków podczas porównywania językowe lub zależne od kultury. Rozpoznawanie znaków do pominięcia porównania, należy podać wartość <see cref="F:System.Globalization.CompareOptions.Ordinal" /> lub <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> dla <paramref name="options" /> parametru.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwa <see cref="T:System.String" /> obiektów w wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do porównania.</param>
        <param name="strB">Drugi ciąg do porównania.</param>
        <summary>Porównuje dwa określone <see cref="T:System.String" /> obiektów w wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdym ciągu.</summary>
        <returns>Liczba całkowita, która wskazuje leksykalne relację między dwiema comparands.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="strA" /> jest mniejsza niż <paramref name="strB" />.  </description></item><item><term> Zero </term><description><paramref name="strA" /> i <paramref name="strB" /> są takie same.  </description></item><item><term> Większa od zera </term><description><paramref name="strA" /> jest większa niż <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównania z uwzględnieniem wielkości liter, przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Do wykonania porównania bez uwzględniania wielkości liter, przy użyciu reguł porządkowych sortowania, wywołaj <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody z `comparisonType` argument wartość <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest metodą statyczną `strA` i `strB` może być `null`. Jeśli obie wartości są `null`, metoda zwraca wartość 0 (zero), który wskazuje, że `strA` i `strB` są takie same. Jeśli jest tylko jeden z wartości `null`, metoda uwzględnia wartość inną niż null na większą.  
  
   
  
## Examples  
 Poniższy przykład wykonuje i liczby porządkowej porównywania dwóch ciągów, które różnią się tylko wielkością liter.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Pierwszy ciąg do użycia w porównaniu.</param>
        <param name="indexA">Indeks początkowy podciągu w <c>Ciąg_a</c>.</param>
        <param name="strB">Drugi ciąg do użycia w porównaniu.</param>
        <param name="indexB">Indeks początkowy podciągu w <c>Ciąg_b</c>.</param>
        <param name="length">Maksymalna liczba znaków w podciągach do porównania.</param>
        <summary>Porównuje podciągów dwa określone <see cref="T:System.String" /> obiektów w wyniku obliczenia wartości liczbowych odpowiadającego <see cref="T:System.Char" /> obiektów w każdej podciąg.</summary>
        <returns>32-bitowa oznaczona liczba całkowita wskazująca relację leksykalną między dwoma argumentami porównania.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> podciągu w <paramref name="strA" /> jest mniejsza niż podciągu w <paramref name="strB" />.  </description></item><item><term> Zero </term><description> podciągów są takie same, lub <paramref name="length" /> wynosi zero.  </description></item><item><term> Większa od zera </term><description> podciągu w <paramref name="strA" /> jest większa niż podciągu w <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`, `indexB`, I `length` parametrów musi być nieujemna.  
  
 Liczba znaków w porównaniu jest mniejsza od długości `strA` mniej `indexA`, długość `strB` mniej `indexB`, i `length`.  
  
 Ta metoda wykonuje porównania z uwzględnieniem wielkości liter, przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Do wykonania porównania bez uwzględniania wielkości liter, przy użyciu reguł porządkowych sortowania, wywołaj <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metody z `comparisonType` argument wartość <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Ponieważ <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> jest metodą statyczną `strA` i `strB` może być `null`. Jeśli obie wartości są `null`, metoda zwraca wartość 0 (zero), który wskazuje, że `strA` i `strB` są takie same. Jeśli jest tylko jeden z wartości `null`, metoda uwzględnia wartość inną niż null na większą.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, który <xref:System.String.CompareOrdinal%2A> i <xref:System.String.Compare%2A> Użyj innego sortowania.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> nie jest <see langword="null" /> i <paramref name="indexA" /> jest większa niż <paramref name="strA" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="strB" /> nie jest <see langword="null" /> i <paramref name="indexB" /> jest większa niż <paramref name="strB" />.<see cref="P:System.String.Length" />.  - lub - <paramref name="indexA" />, <paramref name="indexB" />, lub <paramref name="length" /> jest ujemna.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje tego wystąpienia z określonego obiektu lub <see cref="T:System.String" /> i zwraca liczbę całkowitą, wskazującą, czy to wystąpienie poprzedza, następuje lub pojawia się w tym samym miejscu porządku określony obiekt lub <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno przeciążeń <xref:System.String.CompareTo%2A> — metoda przeprowadzenia porównania z uwzględnieniem kultury i z uwzględnieniem wielkości liter. Nie można użyć tej metody do wykonania porównania niezależnych od kultury lub liczbą porządkową. Dla jasności kodu, firma Microsoft zaleca, aby uniknąć <xref:System.String.CompareTo%2A> — metoda i wywołanie <xref:System.String.Compare%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który daje w wyniku <see cref="T:System.String" />.</param>
        <summary>Porównuje tego wystąpienia z określonym <see cref="T:System.Object" /> i wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tej samej pozycji w porządek sortowania określonych <see cref="T:System.Object" />.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tej samej pozycji w kolejności sortowania jako <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> poprzedza tego wystąpienia <paramref name="value" />.  </description></item><item><term> Zero </term><description> to wystąpienie ma taką samą pozycję w kolejności sortowania jako <paramref name="value" />.  </description></item><item><term> Większa od zera </term><description> następuje to wystąpienie <paramref name="value" />.  - lub - <paramref name="value" /> jest <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` musi być <xref:System.String> obiektu.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metodę zaprojektowano głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Należy nie używane, jeśli głównym celem wywołania metody, które ma na celu określenie, czy dwa ciągi, które są równoważne. Aby ustalić, czy dwa ciągi, które są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję uwag <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.CompareTo%2A> metody z <xref:System.Object>. Ponieważ próbuje on porównania <xref:System.String> wystąpienie do `TestClass` obiektów, metoda wygeneruje <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.CompareTo(System.Object)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Na przykład następujący kod jest uruchamiany na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, porównanie "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika miękkie, lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  [! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  Aby rozpoznać do pominięcia znaków porównania ciągów, należy wywołać <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metody.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Porównuje tego wystąpienia z określonym <see cref="T:System.String" /> obiektu i wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tym samym miejscu porządku określonego ciągu.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem wskazuje, czy to wystąpienie poprzedza, następuje czy pojawia się w tej samej pozycji w kolejności sortowania jako <paramref name="strB" /> parametru.  
  
 <list type="table"><listheader><term> Wartość </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description> poprzedza tego wystąpienia <paramref name="strB" />.  </description></item><item><term> Zero </term><description> to wystąpienie ma taką samą pozycję w kolejności sortowania jako <paramref name="strB" />.  </description></item><item><term> Większa od zera </term><description> następuje to wystąpienie <paramref name="strB" />.  - lub - <paramref name="strB" /> jest <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> Metodę zaprojektowano głównie do użytku w sortowaniu lub w kolejności alfabetycznej operacji. Należy nie używane, jeśli głównym celem wywołania metody, które ma na celu określenie, czy dwa ciągi, które są równoważne. Aby ustalić, czy dwa ciągi, które są równoważne, należy wywołać <xref:System.String.Equals%2A> metody.  
  
 Aby uzyskać więcej informacji o zachowaniu tej metody, zobacz sekcję uwag <xref:System.String.Compare%28System.String%2CSystem.String%29> metody.  
  
 Implementuje tę metodę <xref:System.IComparable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> metody, ponieważ nie trzeba określić czy `strB` argumentu jest typem wartości modyfikowalne, który musi zostać opakowany i nie ma można rzutować jego Parametr od <xref:System.Object> do <xref:System.String>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.CompareTo%2A> metody do porównania bieżące wystąpienie ciągu z innego ciągu.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 W poniższym przykładzie pokazano wersje ogólne i inny niż ogólny metody CompareTo dla kilku typów wartości i odwołania.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zestawy znaków zawierają znaki do pominięcia. <see cref="M:System.String.CompareTo(System.String)" /> — Metoda nie należy wziąć pod uwagę takich znaków podczas porównywania zależne od kultury. Na przykład następujący kod jest uruchamiany na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, porównanie "zwierzę" z "ani nieprawidłowo" (przy użyciu łącznika miękkie, lub 00AD U +) wskazuje, czy dwa ciągi są równoważne.  [! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  Aby rozpoznać do pominięcia znaków porównania ciągów, należy wywołać <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metody.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy jednego lub więcej wystąpień <see cref="T:System.String" />, lub <see cref="T:System.String" /> reprezentacje wartości jednego lub więcej wystąpień <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> i którego argument typu ogólnego jest <see cref="T:System.String" />.</param>
        <summary>Łączy elementy członkowskie skonstruowane <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcję typu <see cref="T:System.String" />.</summary>
        <returns>Połączonych ciągów w <paramref name="values" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="values" /> jest pusta <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdego obiektu w `values`; nie dodaje żadnych ograniczników. Aby określić ogranicznik między każdy element członkowski `values`, wywołaj <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego elementu null `values`.  
  
 Jeśli `values` jest pusta `IEnumerable(Of String)`, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `values` jest `null`, metoda wygeneruje <xref:System.ArgumentNullException> wyjątku.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> jest to metoda wygody, która umożliwia łączenie każdego elementu w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów do tablicy ciągów. Jest to szczególnie przydatne w przypadku wyrażenia zapytania język Language-Integrated zapytania (LINQ). W poniższym przykładzie `List(Of String)` obiekt, który zawiera wielkie i małe litery alfabetu Wyrażenie lambda, który wybiera litery, która jest równa lub większa od określonej literą (czyli, w tym przykładzie "M"). `IEnumerable(Of String)` Kolekcji, która jest zwracana w wyniku <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> metody jest przekazywany do <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę w celu wyświetlenia wynik jako pojedynczy ciąg.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> typu obiektu <xref:System.String>, który następnie przekazuje do <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Obiekt reprezentujący, lub <see langword="null" />.</param>
        <summary>Tworzy reprezentację ciągu określonego obiektu.</summary>
        <returns>Reprezentacja ciągu wartości <paramref name="arg0" />, lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="arg0" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29> Reprezentuje metodę `arg0` jako ciąg przez wywołanie jego bezparametrowy `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, który zawiera elementy do połączenia.</param>
        <summary>Łączy reprezentacji ciągu elementów w określonym <see cref="T:System.Object" /> tablicy.</summary>
        <returns>Reprezentacje połączony ciąg wartości elementów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdego obiektu w `args` przez wywołanie metody bez parametrów `ToString` metody tego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast dowolnego obiektu null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.String.Concat%2A> metody z <xref:System.Object> tablicy.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda nie jest wywoływany przez kod w języku C++. Kompilator języka C++ rozpoznaje wywołania <see cref="Overload:System.String.Concat" /> zawierających cztery lub więcej parametrów obiektu jako wywołanie <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Tablica wystąpień ciągu.</param>
        <summary>Łączy elementy określonej <see cref="T:System.String" /> tablicy.</summary>
        <returns>Połączone elementy <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdego obiektu w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.String.Concat%2A> metody z <xref:System.String> tablicy.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <summary>Łączy reprezentacji ciągu dwóch określonych obiektów.</summary>
        <returns>Reprezentacje połączony ciąg wartości <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0` i `arg1` przez wywołanie metody bez parametrów `ToString` metody `arg0` i `arg1`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast żadnych argumentu o wartości null.  
  
 Jeśli albo argumentów jest odwołaniem do tablicy, metoda łączy ciąg reprezentujący tablicy, a nie jej elementów członkowskich "(na przykład System.String[]").  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do połączenia.</param>
        <param name="str1">Drugi ciąg do połączenia.</param>
        <summary>Łączy dwa określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie z <paramref name="str0" /> i <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0` i `str1`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągu danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast żadnych argumentu o wartości null.  
  
   
  
## Examples  
 Poniższy przykład łączy nazwę pierwszego, drugie imię i nazwisko osoby.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <param name="arg2">Trzeci obiekt do połączenia.</param>
        <summary>Łączy reprezentacji ciągu trzech określonych obiektów.</summary>
        <returns>Reprezentacje połączony ciąg wartości <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `arg0`, `arg1`, i `arg2` przez wywołanie metody bez parametrów `ToString` metody każdego obiektu; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast żadnych argumentu o wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Concat%2A> metody.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do połączenia.</param>
        <param name="str1">Drugi ciąg do połączenia.</param>
        <param name="str2">Trzeci ciąg do połączenia.</param>
        <summary>Łączy trzy określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie z <paramref name="str0" />, <paramref name="str1" />, i <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`, i `str2`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągu danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast żadnych argumentu o wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Concat%2A> metody do łączenia trzy ciągi i wyświetla wyniki.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwszy obiekt do połączenia.</param>
        <param name="arg1">Drugi obiekt do połączenia.</param>
        <param name="arg2">Trzeci obiekt do połączenia.</param>
        <param name="arg3">Obiekt czwarty do połączenia.</param>
        <summary>Łączy reprezentacji ciągu czterech określonego obiekty i wszystkie obiekty określone na liście parametrów opcjonalnych o zmiennej długości.</summary>
        <returns>Reprezentacja ciągu połączonych każdej wartości na liście parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywnym, zgodnym ze specyfikacją CLS jest <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory języka C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Metoda łączy każdy obiekt na liście parametrów przez wywołanie jego bezparametrowy `ToString` metody; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> jest używany zamiast żadnych argumentu o wartości null.  
  
> [!NOTE]
>  Ostatni parametr <xref:System.String.Concat%2A> — metoda to opcjonalna rozdzielana przecinkami lista jednego lub więcej obiektów dodatkowe do łączenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodę do listy zmiennych parametrów połączenia. W tym przypadku metoda jest wywoływana z dziewięciu parametrów.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest oznaczona atrybutem <see langword="vararg" /> — słowo kluczowe, które oznacza, że obsługuje ona zmienną liczbą parametrów. Metoda może zostać wywołana z języka Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory języka C# i Visual Basic rozwiązać wywołania <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> jako wywołań <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Pierwszy ciąg do połączenia.</param>
        <param name="str1">Drugi ciąg do połączenia.</param>
        <param name="str2">Trzeci ciąg do połączenia.</param>
        <param name="str3">Czwarty ciąg do połączenia.</param>
        <summary>Łączy cztery określone wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Łączenie z <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, i <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy `str0`, `str1`, `str2`, i `str3`; nie dodaje żadnych ograniczników.  
  
> [!NOTE]
>  Można również użyć operatora łączenia ciągu danego języka, takich jak `+` w języku C# lub `&` i `+` w języku Visual Basic)  
>   
>  , aby ciągów.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast dowolnego obiektu null w tablicy.  
  
   
  
## Examples  
 W poniższym przykładzie definiuje tablicę czterech — litery słów i przechowuje ich poszczególne koperty na tablicę ciągów w celu szyfrują je. Następnie wywołuje <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodę, aby ponownie połączyć zaszyfrowane słów.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <c>wartości</c>.</typeparam>
        <param name="values">Obiekt kolekcji, który implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> interfejsu.</param>
        <summary>Łączy elementy członkowskie <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementacji.</summary>
        <returns>W połączonych elementów członkowskich <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy każdego obiektu w `values`; nie dodaje żadnych ograniczników.  
  
 <xref:System.String.Empty> Ciąg jest używany zamiast żadnych argumentu o wartości null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> jest to metoda wygody, która umożliwia łączenie każdego elementu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania elementy na ciągi. Jest szczególnie przydatne w przypadku wyrażenia zapytania język Language-Integrated zapytania (LINQ), jak pokazano w przykładzie. Reprezentacja ciągu każdego obiektu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest uzyskiwany w wyniku wywołania tego obiektu `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano bardzo proste `Animal` klasy, która zawiera nazwę zwierzę i określania kolejności, do którego on należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiektu zawiera szereg `Animal` obiektów. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Rozszerzenia metoda jest wywoływana w celu wyodrębnienia `Animal` obiekty, których `Order` właściwości jest równa "Gryzoni". Wynik jest przekazywany do <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> — metoda i wyświetlane w konsoli.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Zwraca wartość wskazującą, czy wskazany podciąg występuje w tym ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru występuje w tym ciągu, lub jeśli <paramref name="value" /> jest pustym ciągiem (""); w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe). Wyszukiwanie rozpoczyna się od pozycji pierwszego znaku tego ciągu i kontynuuje za pomocą ostatniej pozycji znaku.  
  
 Aby określić, czy ciąg zawiera wskazany podciąg przy użyciu inną niż {numer porządkowy porównania (na przykład porównania z uwzględnieniem kultury lub liczby porządkowej porównania bez uwzględniania wielkości liter), można utworzyć niestandardowy — metoda. Poniższy przykład przedstawia jeden z nich. Definiuje <xref:System.String> — metoda rozszerzenia, która obejmuje <xref:System.StringComparison> parametru i wskazuje, czy ciąg zawierający podciąg, korzystając z podanym formularzu porównania ciągów.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Poniższy przykład wywołuje `Contains` — metoda rozszerzenia, aby określić, czy podciągu znajduje się w ciągu, korzystając z liczby porządkowej porównania i porównanie porządkowych bez uwzględniania wielkości liter.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Jeśli interesuje Cię w pozycji podciąg `value` w bieżącym wystąpieniu, można wywołać <xref:System.String.IndexOf%2A> można wywołać metodę, aby pobrać pozycji początkowej jego pierwsze wystąpienie, lub <xref:System.String.LastIndexOf%2A> metodę, aby pobrać początkowe położenie z jego ostatnie wystąpienie. Przykład zawiera wywołanie <xref:System.String.IndexOf%28System.String%29> metodę, jeśli ciąg zostanie znaleziony w wystąpienia ciągu.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg "fox" jest podciągiem znanych oferty. W przypadku znalezienia "lis" w ciągu, jest również wyświetlana punktu początkowego.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do skopiowania.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.String" /> z taką samą wartość jak określonej <see cref="T:System.String" />.</summary>
        <returns>Nowe parametry z taką samą wartość jak <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A> Metoda zwraca <xref:System.String> obiekt, który ma taką samą wartość jak oryginalny ciąg znaków, ale reprezentuje odwołanie do innego obiektu. Różni się od operatora przypisania, który przypisuje istniejących odwołania do zmiennej obiektu dodatkowe. Różnica pokazano w przykładzie.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa obiekty ciąg o różnych wartościach. Gdy wywołuje <xref:System.String.Copy%2A> metodę przypisania pierwszą wartość na drugi ciąg, dane wyjściowe wskazuje ciągi reprezentowania odwołań do różnych obiektów, mimo że teraz są takie same wartości. Z drugiej strony Jeśli pierwszy ciąg jest przypisany do drugi ciąg, dwa ciągi ma takie same wartości, ponieważ stanowią one odwołanie do tego samego obiektu.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Indeks pierwszego znaku w tym wystąpieniu do skopiowania.</param>
        <param name="destination">Tablica znaków Unicode, do których są kopiowane znaków w tym wystąpieniu.</param>
        <param name="destinationIndex">Indeks w <c>docelowego</c> od którego rozpoczyna się operacja kopiowania.</param>
        <param name="count">Liczba znaków w tym wystąpieniu można skopiować do <c>docelowego</c>.</param>
        <summary>Kopiuje określoną liczbę znaków od określonej pozycji w tym wystąpieniu do określonej pozycji w tablicy znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia skopiowanie `count` znaki `sourceIndex` pozycji tego wystąpienia `destinationIndex` pozycji `destination` tablicy znaków. Ta metoda nie zmienia rozmiaru `destination` tablicy znaków; musi mieć wystarczającą liczbę elementów do uwzględnienia kopiowane znaki lub metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` i `destinationIndex` jest liczony od zera.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.CopyTo%2A> metody.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" /> jest ujemny - lub - <paramref name="sourceIndex" /> nie będzie rozpoznawał pozycji w bieżącego wystąpienia.  - lub - <paramref name="destinationIndex" /> nie będzie rozpoznawał prawidłowym indeksem w <paramref name="destination" /> tablicy.  - lub - <paramref name="count" /> jest większa niż długość podciąg <paramref name="sourceIndex" /> na końcu tego wystąpienia - lub - <paramref name="count" /> jest większa niż długość subarray z <paramref name="destinationIndex" /> na końcu <paramref name="destination" /> tablicy.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pusty ciąg. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest ciągiem o zerowej długości, "".  
  
 W kodzie aplikacji to pole jest najczęściej używane w przypisaniach można zainicjować zmiennej ciągu jako ciąg pusty. Aby sprawdzić, czy wartość ciągu jest albo `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, użyj <xref:System.String.IsNullOrEmpty%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy zakończenie tego wystąpienia ciągu zgodny określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania podciąg na końcu tego wystąpienia.</param>
        <summary>Określa, czy koniec tego wystąpienia ciągu zgodny określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> pasuje do końca tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` do podciągu na końcu tego wystąpienia, która jest równa długości `value`i zwraca wskazuje, czy są równe. Aby być równe `value` musi być odwołaniem do tego samego wystąpienia albo znaleźć dopasowanie do zakończenia tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy każdy ciąg w tablicy kończy się kropką (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `StripEndTags` metody, która używa <xref:System.String.EndsWith%28System.String%29> metodę, aby usunąć tagi końcowe HTML na końcu linii. Należy pamiętać, że `StripEndTags` metoda jest wywoływana rekursywnie się upewnić, że wiele tagów końcowych HTML na końcu linii.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby ustalić, czy ciąg kończy podciąg określonego za pomocą reguł porównanie ciągu z bieżącej kultury, należy wywołać <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania podciąg na końcu tego wystąpienia.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa, jak te parametry i <c>wartość</c> są porównywane.</param>
        <summary>Określa, czy zakończenie tego wystąpienia ciągu zgodny określonego ciągu w porównaniu przy użyciu opcji porównania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru pasuje do końca tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A> Metoda porównuje `value` parametr podciąg na końcu tego ciągu i zwraca wartość wskazującą, czy są one takie same. Równe, `value` musi być odwołaniem do tego samego ciągu, musi być ciągiem pustym (""), lub musi odpowiadać końca tego ciągu. Typ porównania z zastosowaniem <xref:System.String.EndsWith%2A> metoda zależy od wartości `comparisonType` parametru.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg kończy się określonym podciąg. Wyniki są zagrożone wybór kultury, czy wielkość liter jest ignorowana i czy jest wykonywane porównanie liczby porządkowej.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania podciąg na końcu tego wystąpienia.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Wiele języków informacje, które określa, jak to wystąpienie i <c>wartość</c> są porównywane. Jeśli <c>kultury</c> jest <see langword="null" />, bieżącej kultury jest używany.</param>
        <summary>Określa, czy zakończenie tego wystąpienia ciągu zgodny określonego ciągu w porównaniu z użyciem kultury określonej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru pasuje do końca tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` parametr podciąg na końcu tego ciągu, która jest równa długości `value`i zwraca wartość wskazującą, czy są one takie same. Aby być równe `value` musi być odwołaniem do tego samego wystąpienia albo znaleźć dopasowanie do końca tego ciągu.  
  
 Ta metoda wykonuje word porównanie (zależne od kultury) przy użyciu określonego wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na końcu innego ciągu. <xref:System.String.EndsWith%2A> Metoda jest wywoływana kilka razy przy użyciu uwzględniana wielkość liter, liter i innych kultur wpływające na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa <see cref="T:System.String" /> obiekty mają taką samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie oraz określony obiekt musi być również <see cref="T:System.String" /> obiektów, mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest <see cref="T:System.String" /> i jego wartość jest taka sama, jak to wystąpienie; w przeciwnym razie <see langword="false" />.  Jeśli <paramref name="obj" /> jest <see langword="null" />, metoda zwraca <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy to wystąpienie i inny określone <see cref="T:System.String" /> obiektu mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="value" /> parametru jest taka sama jak wartość tego wystąpienia; w przeciwnym razie <see langword="false" />. Jeśli <paramref name="value" /> jest <see langword="null" />, metoda zwraca <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody. Porównuje word liter tytułu "File" z równoważne word, jego odpowiednik małe litery, jego odpowiednik wielkie i słowa zawierającego ŁACIŃSKA MAŁA litera bez kropki I (U + 0131) zamiast LATIN małe litery I (U + 0069). Ponieważ <xref:System.String.Equals%28System.String%29> metoda przeprowadza porównanie liczby porządkowej, zwraca tylko porównanie z identycznymi word `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania, lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania, lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.String" /> obiekty mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> jest taka sama jak wartość <paramref name="b" />; w przeciwnym razie <see langword="false" />. Jeśli oba <paramref name="a" /> i <paramref name="b" /> są <see langword="null" />, metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe (wielkość liter i niewrażliwość na ustawienia kulturowe).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Equals%2A> metody.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania z tym wystąpieniem.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa, jak można porównywać ciągi.</param>
        <summary>Określa, czy ten ciąg i określonej <see cref="T:System.String" /> obiektu mają taką samą wartość. Parametr określa kultury, liter i reguł sortowania używana do porównania.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="value" /> parametru jest taki sam jak ten ciąg; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie należy używać bieżącego lub Niezmienna kultura, uznawać Ignoruj wielkość liter porównywane dwa ciągi lub użycie programu word lub reguły porządkową sortowania.  
  
   
  
## Examples  
 Poniższy przykład tworzy składający się z wielkich "I", małe litery "i" i bez kropki "ı" tablicy ciągów. Następnie wywołuje <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodę, aby porównać je za pomocą każdej możliwości <xref:System.StringComparison> wartości wyliczenia.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 Poniższy przykład porównuje cztery zestawy słów przy użyciu każdy element członkowski <xref:System.StringComparison> wyliczenia.  Porównanie Użyj konwencji angielski (Stany Zjednoczone) i kultur Sami (Szwecja górny). Należy pamiętać, że wartości ciągów "Słownik" i "encyklopedii" są traktowane jako równoważne kultury en US, ale nie w kultury Sami (Szwecja Północna).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania, lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania, lub <see langword="null" />.</param>
        <param name="comparisonType">Jedna z wartości wyliczenia, które określa reguły do porównania.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.String" /> obiekty mają taką samą wartość. Parametr określa kultury, liter i reguł sortowania używana do porównania.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> parametru jest równa wartości <paramref name="b" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` Parametr wskazuje, czy porównanie należy używać bieżącego lub Niezmienna kultura, uznawać Ignoruj wielkość liter porównywane dwa ciągi lub użycie programu word lub reguły porządkową sortowania.  
  
   
  
## Examples  
 Poniższy przykład porównuje cztery zestawy słów przy użyciu każdy element członkowski <xref:System.StringComparison> wyliczenia.  Porównanie Użyj konwencji angielski (Stany Zjednoczone) i kultur Sami (Szwecja górny). Należy pamiętać, że wartości ciągów "Słownik" i "encyklopedii" są traktowane jako równoważne kultury en US, ale nie w kultury Sami (Szwecja Północna).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość obiektów na ciągi oparte na określone formaty i wstawia je do innego ciągu.  Jeśli dopiero zaczynasz do metody "String.Format", zobacz [Rozpoczynanie pracy z sekcji method](#Starting) String.Format, aby szybko zapoznać.  W sekcji [Remarks](#remarks-top) Dokumentacja ogólna dla metody "String.Format".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 W tej sekcji:  
  
 [Rozpoczynanie pracy z String.Format — metoda](#Starting)   
 [Która metoda zostanie wywołana?](#FTaskList)   
 [Metoda Format brief](#Format_Brief)   
 [Element formatu](#FormatItem)   
 [Jak są sformatowane argumentów](#HowFormatted)   
 [Format elementy, które mają ten sam indeks](#SameIndex)   
 [Formatowanie i kultury.](#Format_Culture)   
 [Niestandardowe formatowanie operacji](#Format_Custom)   
 [String.Format pytań i odpowiedzi](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Rozpoczynanie pracy z String.Format — metoda  
 Użyj <xref:System.String.Format%2A?displayProperty=nameWithType> Aby wstawić wartości obiektu, zmiennej lub wyrażenie w innym ciągu. Na przykład można wstawić wartości <xref:System.Decimal> wartość na ciąg w celu wyświetlenia go do użytkownika jako pojedynczy ciąg:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 I możesz kontrolować formatowanie tej wartości:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Oprócz formatowania, można też kontrolować wyrównanie i odstępy.  
  
 ### <a name="inserting-a-string"></a>Wstawianie ciąg  

 <xref:System.String.Format%2A?displayProperty=nameWithType> rozpoczyna się od ciągu formatu następuje obiektów lub wyrażeń, które zostanie przekonwertowane na ciągi i wstawiać w określonym miejscu w ciągu formatu. Na przykład:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` w formacie ciągu jest element formatu. `0` jest indeksem obiektu, którego wartość ciągu zostanie wstawiony na tej pozycji. (Indeksy liczone od 0.) Jeśli obiekt do wstawienia nie jest ciągiem, jego `ToString` metoda jest wywoływana przekonwertować go do jednego przed wstawieniem w ciągu wynik.  
  
 Oto przykład innego, która używa dwóch elementów formatu i dwa obiekty na liście obiektów:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Może mieć dowolną liczbę elementów w formacie i dowolną liczbę obiektów na liście obiektów jako użytkownik ma, dopóki indeks każdy element format ma pasującego obiektu z listy obiektów. Również nie trzeba martwić się o przeciążeniu, które należy wywołać; kompilator będzie zaznacz odpowiednie dla Ciebie.  
  
 ### <a name="controlling-formatting"></a>Kontrolowanie, formatowanie  
 Możesz wykonać indeks w elemencie formatu z ciągiem formatu, aby kontrolować sposób formatowania obiektu. Na przykład `{0:d}` dotyczy ciąg formatu "d" pierwszy obiekt z listy obiektów. Oto przykład z jednego obiektu i sformatować dwóch elementów:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Numer pomocy technicznej typy formatowania ciągów, w tym wszystkie typy liczbowe (zarówno [standardowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md) ciągi formatujące), wszystkie daty i godziny (zarówno [standardowe](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ciągi formatujące) i przedziały czasu (zarówno [standardowe](~/docs/standard/base-types/standard-timespan-format-strings.md) i [niestandardowych](~/docs/standard/base-types/custom-timespan-format-strings.md) ciągi formatujące), wszystkie typy wyliczeniowe [Typy wyliczeniowe ](~/docs/standard/base-types/enumeration-format-strings.md), i [identyfikatorów GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Można również dodać obsługę ciągi formatujące do własnych typów.  
  
 ### <a name="controlling-spacing"></a>Kontrolowanie odstępy  
 Można określić szerokość ciąg, który jest umieszczona w ciągu wyników przy użyciu składni, takich jak `{0,12}`, która wstawia ciąg 12 znaków. W takim przypadku reprezentację ciągu pierwszy obiekt jest wyrównany do prawej w polu 12 znaków.  (Jeśli reprezentacja ciągu pierwszy obiekt jest więcej niż 12 znaków długości, jednak szerokość pola preferowany jest ignorowana, a cały ciąg jest umieszczona w ciągu wynik.)  
  
 W poniższym przykładzie zdefiniowano pola 6 znaków, aby pomieścić ciąg "Year" i niektórych ciągów roku, a także pole 15-znakową do przechowywania ciąg "Populacji", a niektóre dane populacji. Należy pamiętać, że znaki są wyrównane do lewej w polu.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Kontrolowanie wyrównania  
 Domyślnie ciągów jest wyrównany do prawej w swoich pól określenia szerokość pola. Do lewej align ciągów w polu, poprzedzony szerokość pola ze znakiem minus, takich jak `{0,-12}` Aby zdefiniować pole wyrównany 12 znaków.  
  
 Poniższy przykład jest podobny do poprzedniego, z wyjątkiem tego, że jego lewej wyrównuje zarówno etykiet, jak i dane.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> wykorzystuje funkcję formatowania złożonego. Aby uzyskać więcej informacji, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Do|wywołania|  
|--------|----------|  
|Format jednego lub większej liczby obiektów przy użyciu konwencji bieżącej kultury.|Z wyjątkiem przeciążeń, które obejmują `provider` parametru pozostałych <xref:System.String.Format%2A> obejmują przeciążenia <xref:System.String> parametru następuje co najmniej jeden parametr obiektu. W związku z tym nie trzeba określić, które <xref:System.String.Format%2A> przeciążenia, które zamierzasz wywołać. Twoje kompilatora języka wybiera odpowiedniego przeciążenia spośród przeciążeń, które nie mają `provider` parametrów, na podstawie tej listy argumentów. Na przykład, jeśli lista argumentów zawiera argumenty, kompilator wywołuje <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody.|  
|Format jednego lub większej liczby obiektów przy użyciu konwencji określoną kulturę.|Każdy <xref:System.String.Format%2A> przeciążenia, który rozpoczyna się od `provider` następuje parametru <xref:System.String> parametru i co najmniej jeden obiekt parametrów. W związku z tym nie trzeba ustalić, jakie szczególne <xref:System.String.Format%2A> przeciążenia, które zamierzasz wywołać. Twoje kompilatora języka wybiera odpowiedniego przeciążenia spośród przeciążeń, które mają `provider` parametrów, na podstawie tej listy argumentów. Na przykład, jeśli lista argumentów zawiera argumenty, kompilator wywołuje <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody.|  
|Operacja niestandardowego formatowania za pomocą <xref:System.ICustomFormatter> implementacji lub <xref:System.IFormattable> implementacji.|Jedną z czterech przeciążeń z `provider` parametru. Kompilator wybiera odpowiedniego przeciążenia spośród przeciążeń, które mają `provider` parametrów, na podstawie tej listy argumentów.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Metoda formatowania w skrócie 

 Każdy przeciążenia <xref:System.String.Format%2A> używa metody [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) uwzględnienie liczony od zera indeksowanego symboli zastępczych, zwanych *formatu elementów*, w ciągu formatu złożonego. W czasie wykonywania każdy element formatu jest zastępowany reprezentację ciągu odpowiadającego mu argumentu na liście parametrów. Jeśli wartość argumentu jest `null`, jest zastępowany przez element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład następujące wywołanie do <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metoda zawiera ciąg formatu z trzema elementami format, {0}, {1}, i {2}i z trzema elementami listy argumentów.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Element formatu  
 Element formatu ma następującą składnię:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Nawiasy kwadratowe określa opcjonalne elementy. Otwieranie i klamrowe nawiasy zamykające są wymagane. (Aby dołączyć literału otwierający lub zamykający nawias klamrowy w ciągu formatu, zobacz [anulowanie nawiasów klamrowych](~/docs/standard/base-types/composite-formatting.md#escaping-braces) w sekcji [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md) artykułu.)  
  
 Na przykład elementu formatu do formatowania wartości waluty może wyglądać następująco:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Element formatu zawiera następujące elementy:  
  
 *index*  
 Liczony od zera indeks argumentu reprezentacji ciągu, których ma być uwzględniony w tym miejscu w ciągu. Jeśli ten argument jest `null`, ciągiem pustym zostaną uwzględnione w tym miejscu w ciągu.  
  
 *Wyrównanie*  
 Opcjonalna. Całkowita wskazującą całkowita długość pola, do którego argument zostanie wstawiony i czy jest wyrównany do prawej (dodatnia liczba całkowita) lub wyrównanego do lewej (ujemna liczba całkowita). W przypadku pominięcia *wyrównanie*, w polu bez spacji wiodących lub końcowych dodaje się reprezentację ciągu odpowiadającego mu argumentu.  
  
 Jeśli wartość *wyrównanie* jest mniejsza niż długość argumentu, który ma zostać wstawiony *wyrównanie* jest ignorowana, a długość ciągu reprezentującego argument jest używany jako szerokość pola.  
  
 *formatString*  
 Opcjonalna. Ciąg, który określa format odpowiedni argument ciągu wynik. W przypadku pominięcia *formatString*, bez parametrów do odpowiadającego mu argumentu `ToString` metoda jest wywoływana w celu utworzenia reprezentacji ciągu. Jeśli określisz *formatString*, argument odwołuje się element formatu musi implementować <xref:System.IFormattable> interfejsu. Typy, które obsługują ciągi formatu:  
  
-   Wszystkich typów całkowitych i zmiennoprzecinkowych. (Zobacz [standardowe ciągi formatujące liczby](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> i <xref:System.DateTimeOffset>. (Zobacz [standardowa Data i godzina ciągi formatujące](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowa data i godzina ciągi formatujące](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Wszystkie typy wyliczeniowe. (Zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan> wartości. (Zobacz [standardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) i [niestandardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Zobacz <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> metody.)  
  
 Jednak należy pamiętać, że można wdrożyć dowolnego typu niestandardowego <xref:System.IFormattable> lub rozszerzyć istniejący typ <xref:System.IFormattable> implementacji.  
  
 W poniższym przykładzie użyto `alignment` i `formatString` argumentów, aby wygenerować sformatowane dane wyjściowe.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Sposób formatowania argumentów  
 Format elementy są przetwarzane sekwencyjnie od początku ciągu. Każdy element formatu ma indeks, który odpowiada liście argumentów metody obiektu. <xref:System.String.Format%2A> Metoda pobiera argument i pochodzi z reprezentacji ciągu w następujący sposób:  
  
-   Jeśli argument ma `null`, metoda wstawia <xref:System.String.Empty?displayProperty=nameWithType> w ciągu wynik. Nie trzeba zajmować się obsługa <xref:System.NullReferenceException> dla argumentów wartości null. 
  
-   Wywołanie <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> przeciążenia i `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementacja zwraca wartość inną niż null <xref:System.ICustomFormatter> implementacji argument jest przekazywany do jego <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody. Jeśli element formatu zawiera *formatString* argumentu, przekazywana jako pierwszy argument do metody. Jeśli <xref:System.ICustomFormatter> implementacji jest dostępna i tworzy ciągiem niepustym, zwracany ciąg jako argument reprezentację ciągu; w przeciwnym razie wykonuje następnego kroku.  
  
-   Jeśli argument implementuje <xref:System.IFormattable> interfejsu, jego <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> nosi nazwę wdrożenia.  
  
-   Argument obiektu bez parametrów `ToString` nosi nazwę metody, która zastępuje albo dziedziczy implementacji klasy podstawowej,.  
  
 Na przykład, który przechwytuje wywołania <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> — metoda i pozwala zobaczyć, jakie informacje <xref:System.String.Format%2A> Zobacz metoda przekazuje do metody formatowania dla każdego elementu formatu ciągu formatu złożonego [przykład: Dostawca przechwycenia i Program formatujący liczbowy łaciński](#Format7_Example).  

 Aby uzyskać więcej informacji, zobacz [kolejność przetwarzania](~/docs/standard/base-types/composite-formatting.md##processing-order) sekcji [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md) artykułu.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementy formatu o tym samym indeksie  
 <xref:System.String.Format%2A> Metoda zgłasza <xref:System.FormatException> wyjątek, jeśli indeks elementu indeksu jest większa lub równa liczbie argumentów listy argumentów. Jednak `format` mogą obejmować więcej elementów formatu niż argumentów, tak długo, jak wiele elementów format mają ten sam indeks. W wywołaniu <xref:System.String.Format%28System.String%2CSystem.Object%29> metoda w poniższym przykładzie lista argumentów ma jeden argument, ale ciąg formatu zawiera dwa elementy format: jeden Wyświetla wartość dziesiętna liczby oraz innych jego wartość szesnastkową.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatowanie i kultura  
 Ogólnie rzecz biorąc, obiekty na liście argumentów są konwertowane na ich reprezentacji ciągu przy użyciu konwencji bieżącej kultury, który jest zwracany przez <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości. To zachowanie można kontrolować, wywołując jedną z przeciążeń <xref:System.String.Format%2A> zawierającą `provider` parametru. `provider` Parametr jest <xref:System.IFormatProvider> przetworzyć implementację, która dostarcza niestandardowe i specyficzne dla kultury formatowania informacje, które jest używane do średnie formatowania.  
  
 <xref:System.IFormatProvider> Interfejs ma jeden element członkowski <xref:System.IFormatProvider.GetFormat%2A>, który jest odpowiedzialny za zwraca obiekt, który zawiera informacje dotyczące formatowania. .NET Framework ma trzy <xref:System.IFormatProvider> implementacje, które zapewniają specyficzne dla kultury formatowania:  
  
-   <xref:System.Globalization.CultureInfo>. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca wartość określonej kultury <xref:System.Globalization.NumberFormatInfo> obiektu do formatowania wartości liczbowych i specyficzne dla kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu do formatowania wartości daty i godziny.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, które jest używane na potrzeby specyficzne dla kultury formatowania wartości daty i godziny. Jego <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> metoda zwraca siebie.  
  
-   <xref:System.Globalization.NumberFormatInfo>, które jest używane na potrzeby specyficzne dla kultury formatowania wartości liczbowych. Jego <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> właściwość zwraca siebie. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Niestandardowe formatowanie operacji  
 Można również wywołać dowolny z przeciążeń <xref:System.String.Format%2A> metodę, która ma `provider` parametr typu <xref:System.IFormatProvider> wykonywanie niestandardowych operacji formatowania. Można na przykład sformatować całkowitą jako numer identyfikacyjny lub numer telefonu. Aby wykonać niestandardowe formatowanie Twojej `provider` argumentu musi implementować zarówno <xref:System.IFormatProvider> i <xref:System.ICustomFormatter> interfejsów. Gdy <xref:System.String.Format%2A> metody jest przekazywany <xref:System.ICustomFormatter> implementacji jako `provider` argumentu, <xref:System.String.Format%2A> wywołania metody jej <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementacji oraz żądania, typu obiektu <xref:System.ICustomFormatter>. Następnie wywołuje zwróconego <xref:System.ICustomFormatter> obiektu <xref:System.ICustomFormatter.Format%2A> przekazywania metody do każdego elementu formatu złożone ciągu formatowania.  
  
 Aby uzyskać więcej informacji na temat rozwiązań formatowania niestandardowych, zobacz [porady: definiowanie i dostawców formatu liczbowego niestandardowych użyj](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) i <xref:System.ICustomFormatter>. Na przykład, który konwertuje liczb całkowitych sformatowany niestandardowe liczby, zobacz [przykład: niestandardowych operacji formatowania](#Format6_Example). Na przykład, który konwertuje łacińskich liczby bajtów bez znaku, zobacz [przykład: Dostawca przechwycenia i program formatujący liczbowy łaciński](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Przykład: Formatowania operacja niestandardowa  
 W tym przykładzie definiuje dostawcy formatu, który formatuje wartość całkowitą jako konta odbiorcy w formularzu x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Przykład: Dostawca przechwycenia i program formatujący liczbowy łaciński  
 W tym przykładzie definiuje dostawcy formatu niestandardowego, który implementuje <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsy zrobić dwie rzeczy:  
  
-   Wyświetla parametrów przekazanych do jego <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementacji. Pozwala to wyświetlić w jakich parametrów <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metody jest przekazanie niestandardowych implementacji formatowania dla każdego obiektu, który próbuje formatowania. Może to być przydatne, gdy debugowanie aplikacji.  
  
-   Jeśli obiekt zostanie sformatowany jest wartość bajtu bez znaku, który ma być sformatowany przy użyciu standardowego formatu ciągu "R", niestandardowego elementu formatującego formatuje wartość liczbową jako łaciński liczb.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format pytań i odpowiedzi  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Dlaczego polecisz interpolacji ciąg za pośrednictwem wywołania `String.Format` metody?

Ciąg interpolacji jest:

- Bardziej elastyczne. Może służyć w dowolnym ciągiem bez konieczności wywołanie do metody, która obsługuje złożone formatowanie. W przeciwnym razie trzeba wywołać <xref:System.String.Format%2A> metody lub innej metody, która obsługuje złożone formatowanie, takie jak <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Bardziej czytelne. Wyrażenie, które można umieścić w ciągu pojawi się w wyrażeniu interpolowane, a nie w liście argumentów, ciągi interpolowane są znacznie łatwiejsze do kodu i do odczytu. Ze względu na ich czytelność większa ciągi interpolowane można zastąpić nie tylko wywołania metod format złożonego, ale ich można również w operacji łączenia ciąg do tworzenia bardziej zwięzły, jaśniejszy kodu. 

Porównanie w poniższych przykładach dwóch kodu przedstawiono wysokiej jakości z ciągi interpolowane przez łączenie ciągów i wywołania metod formatowania złożonego. Wiele operacji łączenia ciągu w poniższym przykładzie tworzy kod pełne i twardych do odczytu.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Z kolei stosowania ciągi interpolowane w poniższym przykładzie tworzenia znacznie jaśniejszy i bardziej precyzyjnie kodu niż ciąg instrukcji łączenia i wywołanie <xref:System.String.Format%2A> metody w poprzednim przykładzie.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Gdzie można znaleźć listę ciągów wstępnie zdefiniowanego formatu, które mogą być używane z formatu elementów?  
  
-   Dla wszystkich typów całkowitych i zmiennoprzecinkowych, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Dla wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Dla wartości wyliczenia [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać <xref:System.TimeSpan> wartości, zobacz [standardowe ciągi formatujące TimeSpan](~/docs/standard/base-types/standard-timespan-format-strings.md) i [ciągi formatujące TimeSpan niestandardowe](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Aby uzyskać <xref:System.Guid> wartości, zobacz sekcję uwag <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> strony odwołania.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Metody kontrolowania wyrównanie ciągów wynikowych, które zastępują elementy formatu?  
 Ogólna składnia elementu formatu jest:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 gdzie *wyrównanie* jest całkowita, która definiuje szerokość pola. Jeśli ta wartość jest wartością ujemną, tekst w polu jest wyrównany. Jeśli jest dodatnia, tekst jest wyrównany do prawej.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Jak kontrolować liczbę cyfr po separatorze dziesiętnym?  
 Wszystkie [standardowe ciągi formatujące liczby](~/docs/standard/base-types/standard-numeric-format-strings.md) z wyjątkiem "D" (która jest używana z tylko liczby całkowite), "G", "R" i "X" Zezwalaj na Specyfikator dokładności, który definiuje liczbę miejsc po przecinku w ciągu wynik. W poniższym przykładzie użyto standardowe ciągi formatujące liczby kontrolować liczbę miejsc po przecinku w ciągu wynik.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Jeśli używasz [ciąg niestandardowego formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md), użycie specyfikatora formatu "0" do sterowania liczbę miejsc po przecinku w ciągu wynik, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Jak kontrolować liczbę miejsc po przecinku integralną?  
 Domyślnie operacji formatowania wyświetlane tylko cyfr całkowity równy zero. W przypadku formatowania liczby całkowite, można użyć Specyfikator dokładności, "D" i "X" standardowe ciągi formatujące kontrolować liczbę miejsc po przecinku.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Można dodać liczbą całkowitą lub zmiennoprzecinkowe liczby zerami prowadzącymi do tworzenia ciągu wyników z określonej liczby miejsc po przecinku integralną za pomocą "0" [specyfikator formatu liczbowego niestandardowego](~/docs/standard/base-types/custom-numeric-format-strings.md), jak pokazano na poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Ile elementów mogą obejmować na liście formatu?  
 Nie ma żadnego limitu praktyczne. Drugi parametr funkcji <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metoda są oznaczone <xref:System.ParamArrayAttribute> atrybut, który umożliwia rozdzielanej listy lub tablicy obiektów jako listy format.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Jak dołączyć literału nawiasy klamrowe ("{" i "}") w ciągu wynik?  
 Na przykład, jak uniemożliwienie następujące wywołanie metody z zgłaszanie <xref:System.FormatException> wyjątek?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Otwierający lub zamykający nawias klamrowy zawsze jest interpretowany jako początek lub koniec elementu formatu. Interpretowane jako literału, musi być wyjściowym. Escape nawiasu klamrowego, dodając inny nawias klamrowy ("{{" i "}}" zamiast "{" i "}") w następujące wywołanie metody:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Jednak nawet zmienionym nawiasy klamrowe są łatwo misinterpreted. Firma Microsoft zaleca obejmują nawiasy klamrowe w formacie listy, a następnie użyj formatu elementów wstawić je w ciągu wynik, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Dlaczego moja wywołanie do metody String.Format throw FormatException?  
 Najczęstszą przyczyną tego wyjątku jest indeks elementu formatu nie odpowiada liście format obiektu. Zwykle oznacza to, że zostały misnumbered indeksów elementów format lub pamiętasz dołączyć obiekt na liście formatu. Próby dołączenia niezmienionym znaczeniu lewego lub prawego nawiasu klamrowego znak również zgłasza <xref:System.FormatException>. Czasami wyjątek jest wynikiem Literówka; na przykład typowa błędu jest błędnie "[" (nawias otwierający) zamiast "{" (lewy nawias klamrowy).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Jeśli metoda Format(System.IFormatProvider,System.String,System.Object[]) obsługuje tablic parametrów, dlaczego mojego kodu Zgłoś wyjątek podczas używania tablicy?  
 Na przykład poniższy kod zgłasza <xref:System.FormatException> wyjątek:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Jest to problem Rozpoznanie przeciążenia kompilatora. Ponieważ kompilator nie można przekonwertować tablicy liczb całkowitych na tablicę obiektów, tablicy całkowitą traktuje jako jeden argument, aby wywoływał <xref:System.String.Format%28System.String%2CSystem.Object%29> metody. Jest zwracany wyjątek, ponieważ istnieją cztery elementy formatu, ale tylko jeden element na liście formatu.  
  
 Ponieważ Visual Basic ani C# można przekonwertować tablicy całkowitą na tablicę obiektów, należy wykonać konwersję, samodzielnie przed wywołaniem <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metody. W poniższym przykładzie przedstawiono jeden implementacji.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Wiele przykłady, które wywołują <xref:System.String.Format%2A> rozmieszczonymi za pomocą metody [uwagi](#remarks) sekcji tego artykułu.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Możesz również pobrać kompletny zestaw `String.Format` przykłady, które są uwzględniane [projekt .NET Core 2.0 C#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) i [projekt Visual Basic .NET Core 2.0](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip), z [dotnet/docs Repozytorium GitHub](https://github.com/dotnet/docs).

Poniżej przedstawiono przykłady zawarte w artykule:

### <a name="create-a-format-string"></a>Tworzenie ciągu formatu

[Wstawianie ciąg](#inserting-a-string)  
[Element formatu](#the-format-item)  
[Format elementy, które mają ten sam indeks](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Dane wyjściowe w formacie formantu

[Kontrolowanie, formatowanie](#controlling-formatting)  
[Kontrolowanie odstępy](#controlling-spacing)  
[Kontrolowanie wyrównania](#controlling-alignment)  
[Kontrolowanie liczbę miejsc po przecinku wartości całkowitych](#how-do-i-control-the-number-of-integral-digits)  
[Kontrolowanie liczbę cyfr po separatorze dziesiętnym](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[W tym literału nawiasy klamrowe w ciągu wyników](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Wprowadź ciągi formatujące zależne od kultury

[Formatowanie zależne od kultury](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Dostosowywanie operacji formatowania

[Niestandardowe operacji formatowania](#example-a-custom-formatting-operation)  
[Dostawca przechwycenia i program formatujący liczbowy łaciński](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Obiekt do formatu.</param>
        <summary>Zamienia jeden lub więcej elementów format w ciągu reprezentację ciągu określonego obiektu.</summary>
        <returns>Kopię <paramref name="format" /> format wszystkie elementy są zastępowane przez reprezentację ciągu <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości wyrażenia do reprezentacji ciągu i osadzanie tego reprezentacja w ciągu. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Przykład: Formatowanie jeden argument  
 
 W poniższym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%29> metody do osadzenia wiek danej osoby w środku ciągu.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Element formatu w <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie jest równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia element formatu w określonym ciągu reprezentację ciągu odpowiedni obiekt w określonej tablicy.</summary>
        <returns>Kopię <paramref name="format" /> , w której elementy formatu zostały zastąpione reprezentację ciągu odpowiednich obiektów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) przekonwertować wartości co najmniej czterema wyrażeń na ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. Ponieważ `args` parametr jest oznaczony atrybutem <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atrybutu, można przekazać obiekty do metody jako oddzielne argumenty lub <xref:System.Object> tablicy. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Przykład: Formatowanie więcej niż trzech argumentów  
 
 W tym przykładzie tworzy ciąg, który zawiera dane o najwyższej i najniższej temperatury w określonym dniu. Ciąg formatu złożonego ma format pięć w przykładzie C# i sześć w przykładzie Visual Basic. Dwa elementy format zdefiniuj szerokość reprezentacji ciągu ich odpowiadającej jej wartości, a pierwszy element formatu zawiera również standardowa Data i godzina ciąg formatu.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Można również przekazać obiekt zostanie sformatowany jako tablica zamiast listy argumentów.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od zera, lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Obiekt do formatu.</param>
        <summary>Zamienia element formatu lub elementów w określonym ciągu reprezentację ciągu odpowiedni obiekt. Parametru zapewnia formatowania informacje specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> w którym format element lub elementy zostały zastąpione przez reprezentację ciągu <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości wyrażenia do reprezentacji ciągu i osadzanie tego reprezentacja w ciągu. Wykonywanie konwersji, metoda używa do formatowania zależne od kultury lub niestandardowy program formatujący. Metoda konwertuje `arg0` do reprezentacji ciągu przez wywołanie jego **ToString(IFormatProvider)** — metoda lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu przez wywołanie jego **ToString ( Ciąg, IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie jest równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="args">Tablica obiektów zawiera zero lub więcej obiektów do sformatowania.</param>
        <summary>Zamienia elementów formatu ciągu reprezentacji ciągu odpowiednie obiekty w określonej tablicy. Parametru zapewnia formatowania informacje specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> , w której elementy formatu zostały zastąpione reprezentację ciągu odpowiednich obiektów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wyrażenia co najmniej czterema na ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. Wykonywanie konwersji, metoda używa do formatowania zależne od kultury lub niestandardowy program formatujący. Metoda konwertuje każdego <xref:System.Object> argument reprezentacji ciągu przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Przykład: Zależne od kultury formatowania  
 W tym przykładzie użyto <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodę w celu wyświetlenia reprezentację ciągu niektóre wartości daty i godziny i wartości liczbowych za pomocą kilku różnych kultur.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od zera, lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia elementów formatu ciągu reprezentację ciągu dwóch określonych obiektów.</summary>
        <returns>Kopię <paramref name="format" /> format elementy są zastępowane przez reprezentacji ciągu <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wartości dwóch wyrażeń ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Przykład: Formatowanie dwa argumenty  
 
 W tym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metodę w celu wyświetlenia czasu i temperatury danych przechowywanych w ogólnej metodzie <xref:System.Collections.Generic.Dictionary%602> obiektu. Pamiętaj, że ciąg formatu, który ma trzy elementy formatu, mimo że istnieją tylko dwa obiekty do formatowania. Wynika to z faktu pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy w formacie: pierwszy wyświetla elementu format czasu, a druga Wyświetla datę.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie jest zero lub jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Zamienia elementów formatu ciągu reprezentację ciągu dwóch określonych obiektów. Parametru zapewnia formatowania informacje specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> format elementy są zastępowane przez reprezentacji ciągu <paramref name="arg0" /> i <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować dwóch wyrażeń na ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. Wykonywanie konwersji, metoda używa do formatowania zależne od kultury lub niestandardowy program formatujący. Metoda konwertuje każdego <xref:System.Object> argument reprezentacji ciągu przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie jest zero lub jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia elementów formatu ciągu reprezentację ciągu trzech określonych obiektów.</summary>
        <returns>Kopię <paramref name="format" /> , w której elementy formatu zostały zastąpione reprezentacji ciągu <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) przekonwertować wartości trzech wyrażeń na ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Przykład: Formatowanie trzech argumentów  
 
 W tym przykładzie użyto <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodę w celu utworzenia ciąg, który przedstawia wynik wartość logiczną `And` operację z dwóch wartości całkowite. Należy pamiętać, ciąg formatu, który obejmuje sześć elementów format, że metoda ma tylko trzy elementy liście parametrów, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie może być większa niż zero, więcej niż dwa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">[String](~/docs/standard/base-types/composite-formatting.md) format złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Zamienia elementów formatu ciągu reprezentację ciągu trzech określonych obiektów. Parametr dostarcza informacje dotyczące formatowania specyficzne dla kultury.</summary>
        <returns>Kopię <paramref name="format" /> , w której elementy formatu zostały zastąpione reprezentacji ciągu <paramref name="arg0" />, <paramref name="arg1" />, i <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) można przekonwertować wyrażenia trzy na ich reprezentacji ciągu i do osadzenia w ciągu tych oświadczeń. Wykonywanie konwersji, metoda używa do formatowania zależne od kultury lub niestandardowy program formatujący. Metoda konwertuje każdego <xref:System.Object> argument reprezentacji ciągu przez wywołanie jego **ToString(IFormatProvider)** metody lub, jeśli obiekt i odpowiadający jej element formatu zawiera ciąg formatu przez wywołanie jego **ToString(String,IFormatProvider)** metody. Jeśli te metody nie istnieją, wywołuje metodę obiektu bez parametrów **ToString** metody.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu nie może być większa niż zero, więcej niż dwa.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który można wykonać iterację poszczególnych znaków w tym ciągu.</summary>
        <returns>Obiekt enumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Zamiast wywoływania <xref:System.String.GetEnumerator%2A> metoda pobierania <xref:System.CharEnumerator> obiekt, aby następnie użyć do wyliczania ciąg, zamiast tego należy użyć konstrukcji iteracji swój język (C# w języku C + +/ CLR, a w języku Visual Basic). [Instrukcja foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) w języku C# [dla każdego](/cpp/dotnet/for-each-in) w języku C + +/ CLR, i [dla każdego](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) w języku Visual Basic).
  
 Ta metoda umożliwia iteracyjne znaki w ciągu. Na przykład Visual Basic `For Each` i C# `foreach` instrukcje wywołać tę metodę, aby zwrócić <xref:System.CharEnumerator> obiektu, który może zapewnić dostęp tylko do odczytu do znaków w tym wystąpieniu ciągu.  
  
   
  
## Examples  
 Poniższy przykład iteruje znaków w ciągach kilka i wyświetla informacje o ich znaki. Używa języka konstrukcja iteracji zamiast wywołanie <xref:System.String.GetEnumerator%2A> metody.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tych parametrów.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie <xref:System.String.GetHashCode%2A> jest zależny od jego wdrożenie, które mogą ulec zmianie od jednej wersji środowiska CLR do innego. Przyczyny, dlaczego może się to zdarzyć się zwiększyć wydajność <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Jeśli dwa obiekty ciągu są takie same, <xref:System.String.GetHashCode%2A> metoda zwraca identyczne wartości. Jednak nie istnieje wartość kodu unikatowy skrót dla każdej unikatowej wartości ciągu. Różne ciągi może zwracać taki sam skrót.  
>   
>  Wartość skrótu, sam nie gwarantuje to stabilna. Skrótu dla identycznych ciągów może się różnić w różnych wersjach programu .NET Framework i różnych platformy (na przykład 32-bitowe i 64-bitowe) dla jednej wersji programu .NET Framework. W niektórych przypadkach może nawet różnią się one domeny aplikacji. To wymaga dwóch kolejnych uruchomieniach ten sam program może zwracać różne skrótu.  
>   
>  W wyniku wyznaczania wartości skrótu, który nigdy nie powinny być używane kody spoza domeny aplikacji, w której zostały utworzone, nigdy nie powinny być używane jako pola klucza w kolekcji i nigdy nie powinien być utrwalona.  
>   
>  Ponadto nie należy używać skrótu zamiast wartości zwróconej przez kryptograficznych funkcji skrótu, jeśli potrzebujesz silną kryptograficznie wyznaczania wartości skrótu. Skróty kryptograficzne, można użyć klasy pochodzącej od <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> klasy.  
>   
>  Aby uzyskać więcej informacji na temat kodów skrótów, zobacz <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 W aplikacjach klasycznych, można użyć [ \<userandomizedstringhashalgorithm — > element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) do generowania unikatowych skrótu na poszczególnych domen aplikacji. Może to zmniejszyć liczbę konfliktów i zwiększyć ogólną wydajność wstawienia i wyszukiwania, które tabele wyznaczania wartości skrótu. Poniższy przykład przedstawia użycie [ \<userandomizedstringhashalgorithm — > elementu](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definiuje do generowania unikatowych skrótu na poszczególnych domen aplikacji. Może to zmniejszyć liczbę konfliktów i zwiększyć ogólną wydajność wstawienia i wyszukiwania, które tabele wyznaczania wartości skrótu. Poniższy przykład przedstawia sposób użycia. Definiuje `DisplayString` klasy, który obejmuje stałą typu string prywatne, `s`, którego wartość wynosi "Jest ciągiem". Zawiera także `ShowStringHashCode` metodę, która wyświetla wartość ciągu i jego skrótu wraz z nazwą domeny aplikacji, w którym jest wykonywany metody.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Po uruchomieniu przykładzie bez podawania plik konfiguracji, wyświetla dane wyjściowe podobne do następującego. Należy zauważyć, że skrótu ciągu identyczne w domenach dwóch aplikacji.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Jednak jeśli dodać następującego pliku konfiguracji do katalogu w tym przykładzie, a następnie uruchomić przykład, kodów skrótów dla tych samych parametrach różnią się według domeny aplikacji.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Gdy plik konfiguracji jest obecny, w przykładzie przedstawiono następujące dane wyjściowe:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Skrótu są używane do wstawiania i wydajne pobrać kluczem obiektów z tabel wyznaczania wartości skrótu. Jednak skrótu nie identyfikują ciągów. Identycznych ciągów mają takie same skrótu, ale środowisko uruchomieniowe języka wspólnego można także przypisać taki sam skrót do różnych ciągów. Ponadto skrótu może różnić się w wersji programu .NET Framework, platformy w ramach jednej wersji i domeny aplikacji. W związku z tym nie powinien serializacji lub utrwalić wartości skrótu kodu ani należy użyć ich jako klucze w tablicy skrótów ani w słowniku.  
  
 Aby uzyskać dodatkowe informacje o wykorzystaniu skrótu i `GetHashCode` metody, zobacz <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.GetHashCode%2A> przy użyciu różnych metod wejściowych ciągów.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Wartość zwrócona przez <see cref="M:System.String.GetHashCode" /> jest zależny od platformy. Różni się w 32-bitowych i 64-bitowych wersjach programu .NET Framework. On również może się różnić między wersjami programu .NET Framework.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla klasy <see cref="T:System.String" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.TypeCode> wyliczany stałą dla <xref:System.String> typu.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode lub ciąg w ramach tego wystąpienia. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode w tym ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub wartość -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można wyszukiwać <xref:System.String> dla znaku przy użyciu <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od pozycji pierwszego znaku tego wystąpienia i jest kontynuowane do ostatniej pozycji znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.IndexOf%28System.String%29> metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowania znajduje się na początku bieżącego wystąpienia. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%29> metoda jest używana do znajdowania trzy podciągów (nietrwałego łącznik (U + 00AD), myślnik słabe następuje "n" i nietrwałego łącznik następuje "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ nietrwałego łącznik jest znak do pominięcia wynik jest taka sama tak, jakby nietrwałego łącznik gdyby nie zostały uwzględnione w `value`. Podczas wyszukiwania tylko nietrwałego łącznika, metoda zwraca wartość 0 (zero), aby wskazać, że na początku ciąg Znaleziono dopasowanie.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład wyszukuje "n" u"". Ponieważ indeksy ciąg zaczyna się na zero, a nie z nich <xref:System.String.IndexOf%28System.String%29> metody oznacza, że "n" na pozycji 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 W poniższym przykładzie użyto <xref:System.String.IndexOf%2A> metody do określenia pozycji początkowej zwierząt nazwy w zdaniu na wyraz. Następnie używa tej pozycji do wstawienia przymiotnik opisujący zwierzę do zdanie.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby znaleźć indeks pierwszego podciągu w ramach wystąpienia ciągu za pomocą reguł porównanie bieżącej kultury, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> jej parametru "typ porównania".</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak Unicode w tym ciągu. Wyszukiwanie rozpoczyna się od pozycji określony znak.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku ciągu, jeśli zostanie znaleziony ten znak lub -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowanie rozpoczyna się od 0. `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 Wyszukiwanie zakresów z `startIndex` do końca ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu. Wyszukiwanie rozpoczyna się od pozycji określony znak.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowanie rozpoczyna się od 0. `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od `startIndex` znak pozycji tego wystąpienia, aby kontynuować do momentu ostatniej pozycji znaku.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m" w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Poniższy przykład wyszukuje wszystkie wystąpienia określonego ciągu w ciągu docelowego.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość tego ciągu.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby znaleźć indeks pierwszego podciągu występujący po pozycji określonego znaku za pomocą reguł porównanie bieżącej kultury, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> jej parametru "typ porównania".</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącej <see cref="T:System.String" /> obiektu. Parametr określa typ wyszukiwania dla określonego ciągu.</summary>
        <returns>Indeks <paramref name="value" /> parametru, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="comparisonType" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metoda zawsze zwraca wartość 0 (zero), aby wskazać, że dopasowania znajduje się na początku bieżącego wystąpienia.  W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metoda jest używana do znajdowania trzy podciągów (nietrwałego łącznik (U + 00AD), myślnik słabe następuje "n" i nietrwałego łącznik następuje "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, ponieważ nietrwałego łącznik jest znak do pominięcia, wyszukiwanie zależne od kultury zwraca tę samą wartość, która zwróci, jeśli łącznik słabe nie zostały uwzględnione w ciągu wyszukiwania. {Numer porządkowy wyszukiwania, jednak pomyślnie znajdzie nietrwałego łącznik w ciągu jednego i zgłasza, że jest nieobecny z drugi ciąg.  [! kodu csharp [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable26.cs#26)] [! kodu vb [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określony znak w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonego znaku na pozycji i analizuje określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku ciągu, jeśli zostanie znaleziony ten znak lub -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Indeks numerowanie rozpoczyna się od 0 (zero). `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IndexOf%2A> metody.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  - lub - <paramref name="startIndex" /> jest większa niż długość tego ciągu.  - lub - <paramref name="count" /> jest większa niż długość ciągu to minus <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonego znaku na pozycji i analizuje określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowanie rozpoczyna się od 0 (zero). `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury. Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m" począwszy od trzeciego do szóstego pozycji znaku w ciągu dwóch. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkie wystąpienia ciągu "he" w ramach podciąg z innego ciągu. Należy pamiętać, że liczba znaków, które mają być wyszukiwane musi być obliczany ponownie dla każdej iteracji wyszukiwania.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  - lub - <paramref name="startIndex" /> jest większa niż długość tego ciągu.  - lub - <paramref name="count" /> jest większa niż długość ciągu to minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby użyć reguł porównanie bieżącej kultury do wykonania tej operacji, należy wywołać <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> jej parametru "typ porównania".</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącej <see cref="T:System.String" /> obiektu. Parametry określają pozycja początkowa wyszukiwania w bieżącej ciągu i typu wyszukiwania dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> parametr od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowanie rozpoczyna się od 0. `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu. Jeśli `startIndex` jest równa długości wystąpienia ciągu, metoda zwraca wartość -1.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od 0 (zero) lub większa niż długość tego ciągu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="comparisonType" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie.  W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m" począwszy od trzeciego pozycja znaku w dwóch ciągów. Tylko jeden z parametrów zawiera wymagane podciąg. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda zwraca indeks nietrwałego łącznik w ciągu pierwszego tylko wtedy, gdy wykonuje porównanie liczby porządkowej.  [! kodu csharp [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable25.cs#25)] [! kodu vb [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia określonego ciągu w bieżącej <see cref="T:System.String" /> obiektu. Parametry określają pozycja początkowa wyszukiwania w ciągu bieżącej liczba znaków w bieżącym ciąg do wyszukania i typ wyszukiwania dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> parametr od początku bieżącego wystąpienia, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, jest zwracana wartość <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowanie rozpoczyna się od 0 (zero). `startIndex` Parametr zakresu od 0 do długości wystąpienia ciągu.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.IndexOf%2A> metodę, która znaleźć pierwsze wystąpienie ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  - lub - <paramref name="startIndex" /> jest większa niż długość tego wystąpienia.  - lub - <paramref name="count" /> jest większa niż długość ciągu to minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="comparisonType" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie.  W poniższym przykładzie <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m" począwszy od trzeciego do szóstego pozycji znaku w ciągu dwóch. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Podczas wykonywania porównanie liczby porządkowej, jednak znalezieniu podciąg tylko pierwszy ciąg. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik miękkie, następuje "m", metoda nie powiedzie się Zwróć indeks nietrwałego łącznik ale zamiast tego zwraca indeks "m" podczas wykonywania porównania z uwzględnieniem kultury. Metoda zwraca indeks nietrwałego łącznik w ciągu pierwszego tylko wtedy, gdy wykonuje porównanie liczby porządkowej.  [! kodu csharp [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable24.cs#24)] [! kodu vb [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Wyszukiwanie `anyOf` jest rozróżniana wielkość liter. Jeśli `anyOf` jest pusta tablica, znajduje metody a dopasowania na początku ciąg (to znaczy w indeksu zero).  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje pierwszy samogłosek w ciągu.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Wyszukiwanie rozpoczyna się od pozycji określony znak.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametr zakresu od 0 do jednego mniejszą niż długość wystąpienia ciągu.  
  
 Wyszukiwanie zakresów z `startIndex` do końca ciągu.  
  
 Wyszukiwanie `anyOf` jest rozróżniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wystąpienia dowolnego znaku w ciągu "is" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest ujemna.  - lub - <paramref name="startIndex" /> jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu dowolny znak w określonej tablicy znaków Unicode. Wyszukiwanie rozpoczyna się od określonego znaku na pozycji i analizuje określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie rozpoczyna się od `startIndex` i w dalszym ciągu `startIndex`  +  `count` -1. Znak na pozycji `startIndex`  +  `count` nie jest uwzględniany w wyszukiwaniu.  
  
 Indeks numerowania rozpoczyna się od zera. `startIndex` Parametr zakresu od 0 do jednego mniejszą niż długość wystąpienia ciągu.  
  
 Wyszukiwanie `anyOf` jest rozróżniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wystąpienia dowolnego znaku ciągu "pomoc", w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  - lub - <paramref name="count" />  +  <paramref name="startIndex" /> jest większa niż liczba znaków w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera indeks wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Zwraca nowy ciąg, w której określony ciąg jest umieszczony na pozycji indeksu określonego w tym wystąpieniu.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale z <paramref name="value" /> wstawione w pozycji <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `startIndex` jest równa długości tego wystąpienia `value` jest dołączany na końcu tego wystąpienia.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w którym `value` są wstawiane do bieżącego wystąpienia.  
  
 Na przykład, wartość zwracana `"abc".Insert(2, "XYZ")` jest "abXYZc".  
  
   
  
## Examples  
 Poniższy przykład powoduje wstawienie znaku spacji czwarty pozycji znaku (znak na pozycji indeksu 3) w ciągu.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Następującej aplikacji konsoli monit o wprowadzenie co najmniej jeden określeniem do opisania dwóch zwierząt. Następnie wywołuje <xref:System.String.Insert%2A> metodę, aby wstawić tekst wprowadzony przez użytkownika na ciąg.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest liczbą ujemną ani przekraczać długości tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli intern.</param>
        <summary>Pobiera odwołanie systemu do określonego <see cref="T:System.String" />.</summary>
        <returns>System odniesienia do <paramref name="str" />, jeśli jest on interned; w przeciwnym razie nowe odwołanie do ciągu z wartością <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego oszczędza Magazyn ciągów, przechowując tabeli o nazwie puli intern, który zawiera jedno odwołanie do każdego unikatowy ciąg literału zadeklarowane lub programowo utworzone w programie. W związku z tym wystąpienie literału ciągu z konkretną wartość istnieje tylko jeden raz w systemie.  
  
 Na przykład po przypisaniu tego samego literału ciągu do kilku zmiennych środowiska uruchomieniowego pobiera tego samego odwołania do literału z puli intern i przypisuje go do każdej zmiennej.  
  
 <xref:System.String.Intern%2A> Metoda używa puli intern do wyszukania ciągu równa wartości `str`. Jeśli taki ciąg istnieje, zwracany jest odwołanie w puli intern. Jeśli ciąg nie istnieje odwołanie do `str` jest dodawane do puli intern, zwracana jest tego odwołania.  
  
 W poniższym przykładzie s1 ciąg, który ma wartość "Test", jest już interned, ponieważ jest literałem w programie. <xref:System.Text.StringBuilder?displayProperty=nameWithType> Klasy generuje nowy obiekt ciąg, który ma taką samą wartość jak s1. Odwołanie do tego ciągu jest przypisany do s2. <xref:System.String.Intern%2A> Metody wyszukuje ciąg, który ma taką samą wartość jak s2. Ponieważ istnieje taki ciąg, metoda zwraca tego samego odwołanie, które jest przypisane do s1. Czy odwołanie jest przypisywana do s3. Odwołania s1 i s2 porównania nierówne, ponieważ odwołują się do różnych obiektów; s1 odwołań i s3 porównanie ponieważ odnoszą się do tych samych parametrach.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Tę metodę, aby porównać <xref:System.String.IsInterned%2A> metody.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> metoda wraca do swojego zachowania w .NET Framework 1.0 i 1.1 względem interning pusty ciąg. W poniższym przykładzie zmienna `str1` przypisano odwołanie do <xref:System.String.Empty>, a zmienna `str2` przypisano odwołanie do <xref:System.String.Empty> który jest zwracany przez wywołanie metody <xref:System.String.Intern%2A> metody po przekonwertowaniu <xref:System.Text.StringBuilder>obiektu, którego wartość jest <xref:System.String.Empty> na ciąg. Odwołania do zawartych w `str1` i `str2` są porównywane pod kątem równości.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 W [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], i [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` i `str2` są takie same. W [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] i [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` i `str2` nie są takie same.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli chcesz ograniczyć łączna ilość pamięci przydziela aplikacji, należy pamiętać o tym, które interning ciąg ma dwa niepożądane skutki uboczne. Po pierwsze, pamięć przydzielona dla interned <xref:System.String> obiektów jest nie może zostać zwolnione aż do zakończenia środowisko uruchomieniowe języka wspólnego (CLR). Przyczyną jest to, że odwołania CLR do interned <xref:System.String> obiekt przetrwają aplikacji lub nawet domeny aplikacji, kończy. Po drugie aby intern ciąg, należy najpierw utworzyć ciąg. Pamięć używana przez <xref:System.String> obiektu musi nadal można przydzielić, mimo że pamięć zostanie ostatecznie bezużytecznych.  
  
 .NET Framework w wersji 2.0 wprowadzono <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> element członkowski wyliczenia. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Zestawu jako niewymagające interning literał ciągu znaków elementu członkowskiego. Możesz zastosować <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> do zestawu przy użyciu <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atrybutu. Ponadto, kiedy należy używać [Ngen.exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) do kompilowania zestawu klienta z wyprzedzeniem czasie wykonywania, ciągi nie są interned we wszystkich modułach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto trzy ciągi, które są takie same wartości, aby określić, czy nowo utworzony ciąg, a ciąg interned są takie same.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do wyszukania w puli intern.</param>
        <summary>Pobiera odwołanie do określonej <see cref="T:System.String" />.</summary>
        <returns>Odwołanie do <paramref name="str" /> Jeśli wspólnego języka środowiska uruchomieniowego intern puli; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego również automatycznie obsługuje tabeli o nazwie puli intern, która zawiera jedno wystąpienie każdego stała unikatowy ciąg literału zadeklarowany w programu, a także dowolne wystąpienie unikatowy <xref:System.String> dodać programowo przez wywołanie metody <xref:System.String.Intern%2A> metody.  
  
 Pula intern oszczędza magazynu ciągów. Po przypisaniu stała literału ciągu do kilku zmiennych każdej zmiennej ustawiono odwołania do tej samej stałej w puli intern zamiast odwołania do kilku różnych wystąpień <xref:System.String> który ma takie same wartości.  
  
 Ta metoda wyszukuje `str` w puli intern. Jeśli `str` została już interned, odwołanie do tego wystąpienia jest zwracane; w przeciwnym razie `null` jest zwracany.  
  
 Tę metodę, aby porównać <xref:System.String.Intern%2A> metody.  
  
 Ta metoda zwraca wartość logiczną. Jeśli należy wywołać metodę, ponieważ ma wartość logiczną wskazującą, czy określony ciąg jest interned, można użyć kodu podobne do poniższych.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  W programie .NET Framework w wersji 2.0, można zastąpić użycie puli intern korzystając z [Ngen.exe (Generator obrazu natywnego)](~/docs/framework/tools/ngen-exe-native-image-generator.md) można zainstalować zestawu w pamięci podręcznej obrazów natywnych na komputerze lokalnym. Aby uzyskać więcej informacji, zobacz zagadnienia dotyczące wydajności w sekcji uwag dla <xref:System.String.Intern%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, że ciągi tekstowe są automatycznie interned przez kompilator.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest w szczególności forma normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest w formie normalizacji Unicode C.</summary>
        <returns>
          <see langword="true" /> Jeśli ten ciąg jest w formie normalizacji C; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Środowisko .NET Framework obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Opis obsługiwanych formuły normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg jest pomyślnie znormalizowane do różne formy normalizacji.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego nieznormalizowanej znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowanej następuje nieprawidłowe znaki Unicode, <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> chociaż <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Forma normalizacji Unicode.</param>
        <summary>Wskazuje, czy ten ciąg jest w podanym formularzu normalizacji Unicode.</summary>
        <returns>
          <see langword="true" /> Jeśli ten ciąg jest w formie normalizacji określonej przez <paramref name="normalizationForm" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. Środowisko .NET Framework obsługuje obecnie normalizacje formularzy C, D, KC i KD.  
  
 Opis obsługiwanych formuły normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.IsNormalized%2A> i <xref:System.String.Normalize%2A> metody.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego nieznormalizowanej znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowanej następuje nieprawidłowe znaki Unicode, <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> chociaż <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do testowania.</param>
        <summary>Wskazuje, czy określony ciąg <see langword="null" /> lub <see cref="F:System.String.Empty" /> ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr jest <see langword="null" /> lub ciąg pusty (""); w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> jest to metoda wygody, która umożliwia testowanie jednocześnie czy <xref:System.String> jest `null` lub jego wartość wynosi <xref:System.String.Empty>. Odpowiada to następującemu kodowi:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Można użyć <xref:System.String.IsNullOrWhiteSpace%2A> metodę, aby sprawdzić, czy ciąg jest `null`, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>, lub zawiera tylko białe znaki.  
  
## <a name="what-is-a-null-string"></a>Co to jest pusty ciąg?  
 Ciąg jest `null` Jeśli go nie przypisano wartość (w języku C++ i Visual Basic) lub jawnie zostanie przypisana wartość `null`. Mimo że [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md) funkcji bezpiecznie może obsłużyć pusty ciąg, jak w poniższym przykładzie pokazano, próby wywołania jedną, jeśli zgłasza jej elementów członkowskich <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Co to jest pustym ciągiem?  
 Ciąg jest pusty, jeśli przypisano jawnie ciąg pusty ("") lub <xref:System.String.Empty?displayProperty=nameWithType>. Pusty ciąg ma <xref:System.String.Length%2A> 0.  Poniższy przykład tworzy pustego ciągu i wyświetla jego wartość i jej długość.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie trzy ciągi sprawdza i określa, czy każdy ciąg ma wartość, to ciąg pusty lub jest `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do testowania.</param>
        <summary>Wskazuje, czy określony ciąg <see langword="null" />, pusty lub zawiera tylko białe znaki.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr jest <see langword="null" /> lub <see cref="F:System.String.Empty" />, lub jeśli <paramref name="value" /> składa się wyłącznie z białe znaki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> jest to metoda wygody, która jest podobna do następujący kod, z wyjątkiem tego, że zapewnia lepszą wydajność:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Białe znaki są zdefiniowane w standardzie Unicode. <xref:System.String.IsNullOrWhiteSpace%2A> Metody interpretuje dowolny znak, który zwraca wartość `true` gdy są przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodę jako biały znak.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę ciągów, a następnie przekazuje każdy element tablicy, tak aby <xref:System.String.IsNullOrWhiteSpace%2A> metody.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy elementy określonej tablicy lub elementów członkowskich kolekcji, przy użyciu określonego separatora między każdy element lub elementu członkowskiego.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <c>separatora</c> znajduje się w ciągu zwracane tylko wtedy, gdy <c>wartości</c> ma więcej niż jeden element.</param>
        <param name="values">Kolekcja, która zawiera ciągi do połączenia.</param>
        <summary>Łączy elementy członkowskie skonstruowane <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcję typu <see cref="T:System.String" />, przy użyciu określonego separatora między każdym elemencie członkowskim.</summary>
        <returns>Ciąg, który składa się z elementów członkowskich <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> nie ma elementów członkowskich, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null`, ciąg pusty (<xref:System.String.Empty?displayProperty=nameWithType>) zamiast niego jest używana. Jeśli dowolny element członkowski `values` jest `null`, zamiast niego jest używana ciągiem pustym.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> jest to metoda wygody, która umożliwia łączenie każdego elementu w `IEnumerable(Of String)` kolekcji bez uprzedniego przekonwertowania elementów do tablicy ciągów. Jest to szczególnie przydatne w przypadku wyrażenia zapytania język Language-Integrated zapytania (LINQ). W poniższym przykładzie `List(Of String)` obiekt, który zawiera wielkie i małe litery alfabetu Wyrażenie lambda, który wybiera litery, która jest równa lub większa od określonej literą (czyli, w tym przykładzie "M"). `IEnumerable(Of String)` Kolekcji zwróconej przez <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> metody jest przekazywany do <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodę w celu wyświetlenia wynik jako pojedynczy ciąg.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> typu obiektu <xref:System.String>, który następnie przekazuje do <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <c>separator</c> znajduje się w ciągu zwracane tylko wtedy, gdy <c>wartości</c> ma więcej niż jeden element.</param>
        <param name="values">Tablica zawiera elementy do połączenia.</param>
        <summary>Łączy elementy tablicy obiektów przy użyciu określonego separatora między każdego elementu.</summary>
        <returns>Ciąg, który składa się z elementów <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> jest pusta tablica, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null` lub, jeśli jakiś element `values` innego niż pierwszy element jest `null`, ciąg pusty (<xref:System.String.Empty?displayProperty=nameWithType>) zamiast niego jest używana. Zobacz uwagi dotyczące obiektów wywołujących sekcji, jeśli pierwszy element `values` jest `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> jest to metoda wygody, umożliwiające łączenie każdego elementu w tablicy obiektów bez jawnie konwertowanie na ciągi swoich elementów. Reprezentacja ciągu każdego obiektu w tablicy jest uzyskiwany w wyniku wywołania tego obiektu `ToString` metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik do tablicy liczba całkowita, która następnie przekazuje do <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> metody.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Jeśli pierwszy element <paramref name="values" /> jest <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> metody łącz elementów w <paramref name="values" /> , ale zamiast tego zwraca <see cref="F:System.String.Empty" />. Dostępnych jest kilka obejścia tego problemu. Jest najprostsza można przypisać wartość <see cref="F:System.String.Empty" /> pierwszy element tablicy, jak w poniższym przykładzie przedstawiono.  [! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <c>separator</c> znajduje się w ciągu zwracane tylko wtedy, gdy <c>wartość</c> ma więcej niż jeden element.</param>
        <param name="value">Tablica zawiera elementy do połączenia.</param>
        <summary>Łączy wszystkie elementy tablicy ciągów, przy użyciu określonego separatora między każdego elementu.</summary>
        <returns>Ciąg, który składa się z elementów w <paramref name="value" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="value" /> jest pusta tablica, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i elementy `value` "apple", "pomarańczowy", "moszcz" i "gruszkowa" `Join(separator, value)` zwraca "firmy apple, orange, moszcz, gruszkowa".  
  
 Jeśli `separator` jest `null`, ciąg pusty (<xref:System.String.Empty?displayProperty=nameWithType>) zamiast niego jest używana. Jeśli dowolny element w `value` jest `null`, zamiast niego jest używana ciągiem pustym.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Join%2A> metody.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ciąg używany jako separator. <c>separator</c> znajduje się w ciągu zwracane tylko wtedy, gdy <c>wartość</c> ma więcej niż jeden element.</param>
        <param name="value">Tablica zawiera elementy do połączenia.</param>
        <param name="startIndex">Pierwszym elementem w <c>wartość</c> do użycia.</param>
        <param name="count">Liczba elementów <c>wartość</c> do użycia.</param>
        <summary>Łączy określone elementy tablicy ciągów, przy użyciu określonego separatora między każdego elementu.</summary>
        <returns>Ciąg, który składa się z ciągów <paramref name="value" /> rozdzielone <paramref name="separator" /> ciągu.  - lub - <see cref="F:System.String.Empty" /> Jeśli <paramref name="count" /> wynosi zero, <paramref name="value" /> nie ma żadnych elementów lub <paramref name="separator" /> i wszystkie elementy <paramref name="value" /> są <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli `separator` jest "," i elementy `value` "apple", "pomarańczowy", "moszcz" i "gruszkowa" `Join(separator, value, 1, 2)` zwraca "pomarańczowy, moszcz".  
  
 Jeśli `separator` jest `null`, ciąg pusty (<xref:System.String.Empty?displayProperty=nameWithType>) zamiast niego jest używana. Jeśli dowolny element w `value` jest `null`, zamiast niego jest używana ciągiem pustym.  
  
   
  
## Examples  
 Poniższy przykład łączy dwa elementy z tablicę nazw owocu.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejszy niż 0.  - lub - <paramref name="startIndex" /> plus <paramref name="count" /> jest większa niż liczba elementów w <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów członkowskich <c>wartości</c>.</typeparam>
        <param name="separator">Ciąg używany jako separator. <c>separatora</c> znajduje się w ciągu zwracane tylko wtedy, gdy <c>wartości</c> ma więcej niż jeden element.</param>
        <param name="values">Kolekcja, która zawiera obiekty do połączenia.</param>
        <summary>Łączy elementy członkowskie kolekcji, przy użyciu określonego separatora między każdym elemencie członkowskim.</summary>
        <returns>Ciąg, który składa się z elementów członkowskich <paramref name="values" /> rozdzielone <paramref name="separator" /> ciągu. Jeśli <paramref name="values" /> nie ma elementów członkowskich, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `separator` jest `null`, ciąg pusty (<xref:System.String.Empty?displayProperty=nameWithType>) zamiast niego jest używana. Jeśli dowolny element członkowski `values` jest `null`, zamiast niego jest używana ciągiem pustym.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jest to metoda wygody, która umożliwia łączenie każdy element członkowski <xref:System.Collections.Generic.IEnumerable%601> kolekcji bez uprzedniego przekonwertowania je na ciągi. Reprezentacja ciągu każdego obiektu w <xref:System.Collections.Generic.IEnumerable%601> kolekcji jest uzyskiwany w wyniku wywołania tego obiektu `ToString` metody.  
  
 Ta metoda jest konkretnym przydatne w przypadku wyrażenia zapytania język Language-Integrated zapytania (LINQ). Na przykład poniższy kod definiuje bardzo proste `Animal` klasy, która zawiera nazwę zwierzę i określania kolejności, do którego on należy. Następnie definiuje <xref:System.Collections.Generic.List%601> obiekt, który zawiera szereg `Animal` obiektów. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Rozszerzenia metoda jest wywoływana w celu wyodrębnienia `Animal` obiekty, których `Order` właściwości jest równa "Gryzoni". Wynik jest przekazywany do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto algorytmu nazwanego sitem Eratostenesa do obliczania liczb pierwszych, których wartość jest równa 100 lub mniejsza. Przypisuje wynik, który ma <xref:System.Collections.Generic.List%601> obiektu typu integer, który następnie przekazuje do <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metody.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony znak Unicode lub ciąg w ramach tego wystąpienia. Metoda zwraca wartość -1, jeśli znak lub ciąg nie zostaną znalezione w tym wystąpieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony znak Unicode w tym wystąpieniu.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub wartość -1, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Ta metoda rozpocznie się wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i jest przeprowadzane wstecz początku aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ExtractFilename` metody, która używa <xref:System.String.LastIndexOf%28System.Char%29> metody można znaleźć w ciągu ostatnich znakiem separatora katalogu i wyodrębnić string jako nazwę pliku. Jeśli plik istnieje, metoda zwraca nazwę pliku bez ścieżki.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i jest przeprowadzane wstecz początku aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.LastIndexOf%28System.String%29> metoda zawsze zwraca <xref:System.String.Length%2A?displayProperty=nameWithType> — 1, który reprezentuje ostatniej pozycji indeksu w bieżącego wystąpienia. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%29> metoda jest używana do znajdowania trzy podciągów (nietrwałego łącznik (U + 00AD), myślnik słabe następuje "n" i nietrwałego łącznik następuje "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w każdym przypadku, ponieważ nietrwałego łącznik jest znak do pominięcia wynik jest taka sama tak, jakby nietrwałego łącznik gdyby nie zostały uwzględnione w `value`. Podczas wyszukiwania tylko nietrwałego łącznika, metoda zwraca 6 i 5. Te wartości odpowiadają indeks ostatni znak w dwóch ciągów.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Poniższy przykład umożliwia usunięcie otwierające i zamykające znaczniki HTML ciąg zaczyna się znaczniki i na końcu ciągu. Jeśli ciąg kończy zamknięcia nawiasów znak (">"), w przykładzie użyto <xref:System.String.LastIndexOf%2A> metodą lokalizowania początek tagu końcowego.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby odnaleźć ostatniego indeksu podciągu w ramach wystąpienia ciągu za pomocą reguł porównanie bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony znak Unicode w tym wystąpieniu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> -1. Ta metoda rozpocznie się wyszukiwanie w `startIndex` znak położenie tego wystąpienia i będzie kontynuowane z poprzednimi wersjami na początku bieżącego wystąpienia aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatni znak w ciągu na początku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkich wystąpień znaku w ciągu pracy od końca ciągu na początku ciąg.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa niż zero lub większa niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest mniejsza od <paramref name="startIndex" /> i ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak położenie tego wystąpienia i będzie kontynuowane z poprzednimi wersjami początku aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatni znak w ciągu na początku.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metoda zawsze zwraca `startIndex`, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metoda jest używana do znajdowania podciąg zawierającą nietrwałego łącznik (U + 00AD) i które poprzedza lub ostatecznego "m" w ciągu. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, ponieważ nietrwałego łącznik w ciągu wyszukiwania są ignorowane, podczas wywoływania metody do znalezienia podciągu, który składa się z łącznika elastyczne i "m" zwraca pozycję "m" w ciągu, podczas gdy wywoływania w tym celu substrin g, która składa się z łącznika elastyczne i "n" zwraca pozycję "n". Jeśli ciąg wyszukiwania zawiera tylko nietrwałego łącznik, metoda zwraca indeks "m", który reprezentuje wartość `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkie wystąpienia ciągu w ciągu docelowego pracy od końca ciągu docelowego na początku ciąg docelowego.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza od zera lub większa niż długość bieżącego wystąpienia.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż -1 lub większa od zera.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby znaleźć indeksu podciągu, który poprzedza pozycji określonego znaku za pomocą reguł porównanie bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony ciąg w bieżącym <see cref="T:System.String" /> obiektu. Parametr określa typ wyszukiwania dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ten ciąg zostanie znaleziony, lub wartość -1, jeśli nie jest. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
 Wyszukiwanie rozpoczyna się od ostatniej pozycji znaku tego wystąpienia i jest przeprowadzane wstecz początku aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.LastIndexOf%2A> metodę, która odnaleźć ostatniego wystąpienia ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="options" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metoda zawsze zwraca <see cref="P:System.String.Length" /> — 1, który reprezentuje ostatniej pozycji indeksu w bieżącego wystąpienia.  W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metoda jest używana do znajdowania trzy podciągów (nietrwałego łącznik (U + 00AD), myślnik słabe następuje "n" i nietrwałego łącznik następuje "m") w dwóch ciągów. Tylko jeden z ciągów zawiera łącznik nietrwały. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, ponieważ nietrwałego łącznik jest znak do pominięcia, wyszukiwanie zależne od kultury zwraca tę samą wartość, która zwróci, jeśli łącznik słabe nie zostały uwzględnione w ciągu wyszukiwania. {Numer porządkowy wyszukiwania, jednak pomyślnie znajdzie nietrwałego łącznik w ciągu jednego i zgłasza, że jest nieobecny z drugi ciąg.  [! kodu csharp [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof26.cs#26)] [! kodu vb [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak Unicode do wyszukania.</param>
        <param name="startIndex">Pozycja początkowa wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony znak Unicode w podciągu w ramach tego wystąpienia. Wyszukiwanie rozpoczyna się od pozycji określony znak i jest przeprowadzane wstecz początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> Jeśli ten znak zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Ta metoda rozpoczyna wyszukiwanie `startIndex` znak pozycji i będzie kontynuowane z poprzednimi wersjami na początku tego wystąpienia aż do otrzymania `value` znajduje się lub `count` zostały zbadane pozycji znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatni znak w ciągu. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (bez uwzględniania ustawień kulturowych), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartość skalarna Unicode jest taka sama. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkich wystąpień znaku w podciąg, Praca z końcem podciągu na początku podciąg.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa niż zero lub większa niż długość tego wystąpienia.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" />  -  <paramref name="count" /> + 1 jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od pozycji określony znak i jest przeprowadzane wstecz początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> Jeśli ten ciąg zostanie znaleziony, lub wartość -1 Jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest mniejsza od <paramref name="startIndex" /> i ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak położenie tego wystąpienia i będzie kontynuowane z poprzednimi wersjami początku aż do otrzymania `value` zostanie znaleziony lub `count` zostały zbadane pozycji znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatni znak w ciągu.  
  
 Ta metoda przeprowadza wyszukiwanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
 Zestawy znaków zawierają znaki do pominięcia. Są to znaki nieuwzględniane podczas porównywania pod względem językowym lub z uwzględnieniem ustawień kulturowych. W wyszukiwaniu zależne od kultury Jeśli `value` zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli `value` zawiera tylko jeden lub więcej znaków do pominięcia <xref:System.String.LastIndexOf%2A> metoda zawsze zwraca `startIndex`, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie. W poniższym przykładzie <xref:System.String.LastIndexOf%2A> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) w dwa znaki, które należy poprzedzić final "m" w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks wszystkie wystąpienia ciągu w podciąg, Praca z końcem podciągu na początku podciąg.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest ujemna.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest ujemna.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa niż długość tego wystąpienia.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" />  -  <paramref name="count" />+ 1 określa położenie, który nie znajduje się w tym wystąpieniu.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsza niż -1 lub większa od zera.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większa niż 1.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby wykonać tę operację za pomocą reguł porównanie bieżącej kultury, należy wywołać <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty liczony od zera indeks ostatniego wystąpienia określony ciąg w bieżącym <see cref="T:System.String" /> obiektu. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków. Parametr określa typ porównania do wykonania podczas wyszukiwania dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ten ciąg zostanie znaleziony lub -1, jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest mniejsza od <paramref name="startIndex" /> i ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak pozycji i będzie kontynuowane z poprzednimi wersjami, aż do otrzymania `value` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka każdego znaku z ostatni znak w ciągu na początku.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.LastIndexOf%2A> metodę, która odnaleźć ostatniego wystąpienia ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza od zera lub większa niż długość bieżącego wystąpienia.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest mniejsza niż -1 lub większa od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="comparisonType" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie.  W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m", zaczynając od final "m" w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik nietrwały, a po nim „m”, metoda nie zwraca indeksu łącznika nietrwałego, ale zamiast tego zwraca indeks „m”. Metoda zwraca indeks nietrwałego łącznik w ciągu pierwszego tylko wtedy, gdy wykonuje porównanie liczby porządkowej.  [! kodu csharp [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof25.cs#25)] [! kodu vb [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do wyszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa reguły dotyczące wyszukiwania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia określonego ciągu w tej instancji. Wyszukiwanie rozpoczyna się od pozycji określony znak i jest przeprowadzane wstecz początku ciągu określoną liczbę pozycji znaku. Parametr określa typ porównania do wykonania podczas wyszukiwania dla określonego ciągu.</summary>
        <returns>Liczony od zera indeks pozycji początkowej <paramref name="value" /> parametru, jeśli ten ciąg zostanie znaleziony lub -1, jeśli nie zostanie znaleziony, lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />. Jeśli <paramref name="value" /> jest <see cref="F:System.String.Empty" />, zwracana wartość jest mniejsza od <paramref name="startIndex" /> i ostatniej pozycji indeksu w tym wystąpieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera. Oznacza to pierwszy znak w ciągu o indeksie zero a ostatnią jest w <xref:System.String.Length%2A> - 1.  
  
 Wyszukiwanie rozpoczyna się od `startIndex` znak pozycji i będzie kontynuowane z poprzednimi wersjami, aż do otrzymania `value` zostanie znaleziony lub `count` zostały zbadane pozycji znaku. Na przykład jeśli `startIndex` jest <xref:System.String.Length%2A> - 1, metoda szuka Wstecz `count` znaków z ostatni znak w ciągu.  
  
 `comparisonType` Parametr określa, aby wyszukać `value` parametr przy użyciu bieżących lub Niezmienna kultura, za pomocą wyszukiwania z uwzględnieniem wielkości liter lub bez uwzględniania wielkości liter i przy użyciu programu word lub reguł porządkowych porównania.  
  
   
  
## Examples  
 Overloads exampledemonstrates następujące trzy z <xref:System.String.LastIndexOf%2A> metodę, która odnaleźć ostatniego wystąpienia ciągu w innym ciągu przy użyciu innej wartości <xref:System.StringComparison> wyliczenia.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest ujemna.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest ujemna.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> jest większa niż długość tego wystąpienia.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> + 1 - <paramref name="count" /> Określa położenie, który nie znajduje się w tym wystąpieniu.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="start" /> jest mniejsza niż -1 lub większa od zera.  - lub - bieżące wystąpienie jest równe <see cref="F:System.String.Empty" /> i <paramref name="count" /> jest większa niż 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
        <block subset="none" type="usage">
          <para>Zestawy znaków obejmują do pominięcia znaki, które są znaki, które nie są uznawane za przeprowadzania porównania językowe lub zależne od kultury. W wyszukiwaniu zależne od kultury (to znaczy, jeśli <paramref name="comparisonType" /> nie jest <see cref="F:System.StringComparison.Ordinal" /> lub <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), jeśli <paramref name="value" /> zawiera znak do pominięcia, wynikiem jest odpowiednikiem wyszukiwanie znakiem usunięte. Jeśli <paramref name="value" /> zawiera tylko jeden lub więcej znaków do pominięcia <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda zawsze zwraca <paramref name="startIndex" />, która jest pozycji znaku, od której rozpoczyna się wyszukiwanie.  W poniższym przykładzie <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metoda jest używana do znajdowania pozycja nietrwałego łącznik (U + 00AD) następuje "m" we wszystkich, ale pozycji pierwszego znaku przed final "m" w dwóch ciągów. Tylko jeden z ciągów zawiera wymagany podciąg. Jeśli na przykład jest uruchamiane na [! INCLUDE[netfx40_short](~/includes/netfx40-Short-MD.MD)] lub później, w obu przypadkach, ponieważ nietrwałego łącznik jest znak do pominięcia metoda zwraca indeks "m" w ciągu podczas wykonywania porównania z uwzględnieniem kultury. Podczas wykonywania porównanie liczby porządkowej, jednak znalezieniu podciąg tylko pierwszy ciąg. Należy pamiętać, że w przypadku pierwszego ciągu, który zawiera łącznik miękkie, następuje "m", metoda nie powiedzie się Zwróć indeks nietrwałego łącznik ale zamiast tego zwraca indeks "m" podczas wykonywania porównania z uwzględnieniem kultury. Metoda zwraca indeks nietrwałego łącznik w ciągu pierwszego tylko wtedy, gdy wykonuje porównanie liczby porządkowej.  [! kodu csharp [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof24.cs#24)] [! kodu vb [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Metoda zwraca wartość -1, jeśli znaki w tablicy nie znajdują się w tej instancji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode.</summary>
        <returns>Indeks ostatniego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpocznie się wyszukiwanie od ostatniej pozycji znaku tego wystąpienia i jest przeprowadzane wstecz początku do znaku w `anyOf` zostanie znaleziony lub zbadaniu pozycja pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w innym ciągu.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od określonej pozycji znaku i jest przeprowadzane w kierunku początku ciągu znaków.</summary>
        <returns>Indeks ostatniego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Ta metoda rozpoczyna wyszukiwanie `startIndex` położenie tego wystąpienia i będzie kontynuowane z poprzednimi wersjami na początku dnia znak w znaku `anyOf` znajduje się lub zbadaniu pozycja pierwszego znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "is" w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> Określa położenie, który nie znajduje się w tym wystąpieniu.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tablica znaków Unicode, zawierająca jeden znak lub więcej do odszukania.</param>
        <param name="startIndex">Pozycja rozpoczęcia wyszukiwania. Wyszukiwanie rozpoczynające się od <c>startIndex</c> początku tego wystąpienia.</param>
        <param name="count">Liczba pozycji znaku do zbadania.</param>
        <summary>Raporty pozycji indeksu zaczynającego się od zera dla ostatniego wystąpienia — w tym przypadku jeden znak lub więcej, określone w tablicy Unicode. Wyszukiwanie rozpoczyna się od pozycji określony znak i jest przeprowadzane wstecz początku ciągu określoną liczbę pozycji znaku.</summary>
        <returns>Indeks ostatniego wystąpienia w tym wystąpieniu, w którym dowolny znak z <paramref name="anyOf" /> znaleziono; -1, jeśli żadne znaki w <paramref name="anyOf" /> został znaleziony lub jeśli bieżące wystąpienie jest równe <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks numerowania rozpoczyna się od zera.  
  
 Tej metody, rozpocznie się wyszukiwanie w `startIndex` położenie tego wystąpienia i będzie kontynuowane z poprzednimi wersjami na początku dnia znak w znaku `anyOf` zostanie znaleziony lub `count` zostały zbadane pozycji znaku. W wyszukiwaniu jest uwzględniana wielkość liter.  
  
 Ta metoda przeprowadza wyszukiwanie porządkowe (niewrażliwość na ustawienia kulturowe), gdzie znak jest uważany za równoważny innemu znakowi tylko wtedy, gdy ich wartości skalarne Unicode są takie same. Aby wykonać wyszukiwanie zależne od kultury, użyj <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> metody, gdzie wartość skalarną Unicode reprezentującą znak złożony, takich jak ligatury "Æ" (U + 00 C 6), może zostać uznane za równoważne dowolne wystąpienie składników znaku w Popraw sekwencji, takie jak "AE" (U + 0041, U + 0045), w zależności od kultury.  
  
   
  
## Examples  
 Poniższy przykład znajduje indeks ostatniego wystąpienia dowolnego znaku w ciągu "pomoc", w ramach podciąg z innego ciągu.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Bieżące wystąpienie nie jest równa <see cref="F:System.String.Empty" />, i <paramref name="count" /> lub <paramref name="startIndex" /> jest ujemna.  bieżące wystąpienie nie jest równa - lub - <see cref="F:System.String.Empty" />, i <paramref name="startIndex" /> minus <paramref name="count" /> + 1 jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaków w bieżącym <see cref="T:System.String" /> obiektu.</summary>
        <value>Liczba znaków w ciągu bieżącej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> Właściwość zwraca liczbę <xref:System.Char> obiektów w tym wystąpieniu, nie liczbę znaków Unicode. Przyczyną jest to, że znaku Unicode może być reprezentowany przez więcej niż jedną <xref:System.Char>. Użyj <xref:System.Globalization.StringInfo?displayProperty=nameWithType> klasy do pracy z każdego znaku Unicode zamiast poszczególnych <xref:System.Char>.  
  
 W przypadku niektórych języków, takich jak C i C++ znak null wskazuje końca ciągu. W programie .NET Framework znak null można ją osadzić w ciągu. Jeśli ciąg zawiera co najmniej jeden znak null, są objęte długość całkowita ciągu. Na przykład w następujący ciąg podciągów, który "abc" i "def" są oddzielone znakiem null. <xref:System.String.Length%2A> Właściwość zwraca 7, co oznacza, że zawiera on sześć znaki alfabetyczne, a także znakiem pustym.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Length%2A> właściwości.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, którego reprezentacja binarna jest w szczególności forma normalizacji Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna jest forma normalizacji Unicode C.</summary>
        <returns>Nowy, znormalizowany ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których binarna reprezentacja w formie normalizacji C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Na przykład żadnego z następujących punktów kodowych reprezentują litery "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET Framework obsługuje cztery normalizacji formularzy (C, D KC i KD) zdefiniowanych w standardzie Unicode. Gdy dwa ciągi, które są przedstawione w tym samym formularzu normalizacji, theycan można porównać przy użyciu porównanie liczby porządkowej.  
  
 Normalizuj i porównuje dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągów, które ma być porównywana ze źródła danych wejściowych, na przykład pliku lub urządzenia wejściowego użytkownika.  
  
2.  Wywołanie <xref:System.String.Normalize> metodę NORMALIZUJ ciągi do forma normalizacji C.  
  
3.  Aby porównać dwa ciągi, wywołaj metodę, która obsługuje porównanie liczby porządkowej ciągów, takich jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody i podaj wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argumentu. Aby posortować tablica ciągów znormalizowane, należy przekazać `comparer` wartość <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągów w posortowane dane wyjściowe na podstawie kolejności wskazanej w poprzednim kroku.  
  
 Opis obsługiwanych formuły normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularze normalizacji, sprawdza ciąg został znormalizowane do forma normalizacji określony, a następnie określa punktów kodowych w ciągu znormalizowana.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego nieznormalizowanej znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowanej następuje nieprawidłowe znaki Unicode, <see cref="Overload:System.String.Normalize" /> metoda zgłosi <see cref="T:System.ArgumentException" /> chociaż <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Forma normalizacji Unicode.</param>
        <summary>Zwraca nowy ciąg, którego wartość tekstowa jest taki sam jak ten ciąg, ale których reprezentacja binarna jest w podanym formularzu normalizacji Unicode.</summary>
        <returns>Nowe parametry, których wartość tekstowa jest taka sama jak tych parametrów, ale których binarna reprezentacja w formie normalizacji określonej przez <paramref name="normalizationForm" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre znaki Unicode mają wiele równoważnych reprezentacji binarnych, składających się z zestawów łączonych i/lub złożonych znaków Unicode. Istnienie wielu reprezentacji dla pojedynczego znaku komplikuje wyszukiwanie, sortowanie, dopasowanie i inne operacje.  
  
 W standardzie Unicode definiuje się proces zwany normalizacją, która zwraca jedną reprezentację binarną, gdy podano którąkolwiek z równoważnych reprezentacji binarnych znaku. Normalizację można wykonać za pomocą wielu algorytmów, nazywanych formularzami normalizacji, które spełniają różne reguły. .NET Framework obsługuje cztery normalizacji formularzy (C, D KC i KD) zdefiniowanych w standardzie Unicode. Dwa ciągi, które są przedstawione w tym samym formularzu normalizacji, można można porównać przy użyciu porównanie liczby porządkowej.  
  
 Normalizuj i porównuje dwa ciągi, wykonaj następujące czynności:  
  
1.  Uzyskaj ciągów, które ma być porównywana ze źródła danych wejściowych, na przykład pliku lub urządzenia wejściowego użytkownika.  
  
2.  Wywołanie <xref:System.String.Normalize%28System.Text.NormalizationForm%29> NORMALIZUJ ciągi do formularza normalizacji określonej metody.  
  
3.  Aby porównać dwa ciągi, wywołaj metodę, która obsługuje porównanie liczby porządkowej ciągów, takich jak <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metody i podaj wartość <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> jako <xref:System.StringComparison> argumentu. Aby posortować tablica ciągów znormalizowane, należy przekazać `comparer` wartość <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> lub <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> do odpowiedniego przeciążenia <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emituj ciągów w posortowane dane wyjściowe na podstawie kolejności wskazanej w poprzednim kroku.  
  
 Opis obsługiwanych formuły normalizacji Unicode, zobacz <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład normalizuje ciąg do każdego z czterech formularze normalizacji, sprawdza ciąg został znormalizowane do forma normalizacji określony, a następnie określa punktów kodowych w ciągu znormalizowana.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżące wystąpienie zawiera nieprawidłowe znaki Unicode.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" /> Metoda zwraca <see langword="false" /> zaraz po napotkaniu pierwszego nieznormalizowanej znaku w ciągu. W związku z tym, jeśli ciąg zawiera znaki nieznormalizowanej następuje nieprawidłowe znaki Unicode, <see cref="Overload:System.String.Normalize" /> metoda może generować <see cref="T:System.ArgumentException" /> chociaż <see cref="Overload:System.String.IsNormalized" /> zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania, lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania, lub <see langword="null" />.</param>
        <summary>Określa, czy dwa ciągi określonego mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> jest taka sama jak wartość <paramref name="b" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.String> klasy. Umożliwia on kodu, takim jak pokazano w przykładzie. Operatora z kolei wywołuje statycznych <xref:System.String.Equals%28System.String%2CSystem.String%29> metodę, która wykonuje porządkowej porównanie (z uwzględnieniem wielkości liter i niezależnych od kultury).  
  
> [!NOTE]
>  Kompilator Visual Basic nie jest rozpoznawany jako wywołanie operator równości <xref:System.String.op_Equality%2A> metody. Zamiast tego operatora równości opakowuje wywołanie <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano operatora równości.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy ciąg do porównania, lub <see langword="null" />.</param>
        <param name="b">Drugi ciąg do porównania, lub <see langword="null" />.</param>
        <summary>Określa, czy dwa ciągi określonego mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="a" /> różni się od wartości <paramref name="b" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.String> klasy.   Umożliwia on kodu, takim jak pokazano w sekcji przykładów.  
  
 <xref:System.String.op_Inequality%2A> Operatora z kolei wywołuje statycznych <xref:System.String.Equals%28System.String%2CSystem.String%29> metodę, która wykonuje porządkowej porównanie (z uwzględnieniem wielkości liter i niezależnych od kultury).  
  
> [!NOTE]
>  Kompilator Visual Basic nie jest rozpoznawany jako wywołanie operator nierówności <xref:System.String.op_Inequality%2A> metody. Zamiast tego wywołania jest zawijana operator nierówności <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano operator nierówności.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym na początku ciąg bieżącego jest uzupełniana spacjami lub określony znak Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który prawej wyrównuje znaków w tym wystąpieniu dopełniając spacjami po lewej stronie, dla określonego całkowita długość.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i dopełniane po lewej stronie z dowolną liczbę spacji potrzebne do utworzenia długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest taki sam jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Miejsce na Unicode jest zdefiniowany jako 0x0020 szesnastkową.  
  
 <xref:System.String.PadLeft%28System.Int32%29> Metody dopełnia początku zwracany ciąg. Oznacza to, że w przypadku użycia z języków od prawej do lewej, dopełnia prawej części ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadLeft%2A> metody dopełnia bieżącego wystąpienia znakami odstępu, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest wypełniane Spacja wiodąca tak, aby jego długość całkowita `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadLeft%2A> metody.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Dopełnienie znak Unicode.</param>
        <summary>Zwraca nowy ciąg, który prawej wyrównuje znaków w tym wystąpieniu dopełniając po lewej stronie do określonego znaku Unicode dla określonej długości całkowitej.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównany do prawej i dopełniane po lewej stronie z dowolną liczbę <paramref name="paddingChar" /> znaki potrzebne do utworzenia długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest taki sam jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Metody dopełnia początku zwracany ciąg. Oznacza to, że w przypadku użycia z języków od prawej do lewej, dopełnia prawej części ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadLeft%2A> metody dopełnia bieżącego wystąpienia znakami odstępu, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest wypełniane wiodące `paddingChar` znaki tak, aby jego długość całkowita `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadLeft%2A> metody.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg o określonej długości, w którym końca bieżącego ciągu jest uzupełniana spacjami lub określony znak Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <summary>Zwraca nowy ciąg, który lewej wyrównuje znaków w tym ciągu dopełniając spacjami po prawej stronie dla określonej długości całkowitej.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównane do lewej i dopełniane po prawej stronie dowolną liczbę spacji potrzebne do utworzenia długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest taki sam jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Miejsce na Unicode jest zdefiniowany jako 0x0020 szesnastkową.  
  
 <xref:System.String.PadRight%28System.Int32%29> Metody dopełnia koniec zwracany ciąg. Oznacza to, że w przypadku użycia z języków od prawej do lewej, dopełnia po lewej stronie część ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadRight%2A> metody dopełnia bieżącego wystąpienia znakami odstępu, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest wypełniane wiodących znaków odstępu tak, aby jego długość całkowita `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadRight%2A> metody.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Liczba znaków w ciągu wynikowym, równa liczbie oryginalnych znaków i znaków dodatkowych dopełnienia.</param>
        <param name="paddingChar">Dopełnienie znak Unicode.</param>
        <summary>Zwraca nowy ciąg, który lewej wyrównuje znaków w tym ciągu dopełniając w prawo o określony znak Unicode dla określonego całkowita długość.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, ale wyrównane do lewej i dopełniane po prawej stronie z dowolną liczbę <paramref name="paddingChar" /> znaki potrzebne do utworzenia długości <paramref name="totalWidth" />. Jednak jeśli <paramref name="totalWidth" /> jest mniejsza niż długość tego wystąpienia, metoda zwraca odwołanie do istniejącego wystąpienia. Jeśli <paramref name="totalWidth" /> jest równa długości tego wystąpienia, metoda zwraca nowy ciąg, który jest taki sam jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Metody dopełnia koniec zwracany ciąg. Oznacza to, że w przypadku użycia z języków od prawej do lewej, dopełnia po lewej stronie część ciągu.  
  
> [!NOTE]
>  Jeśli <xref:System.String.PadRight%2A> metody dopełnia bieżącego wystąpienia znakami odstępu, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który jest uzupełniana spacją `paddingChar` znaki tak, aby jego długość całkowita `totalWidth` znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.PadRight%2A> metody.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> jest mniejsza od zera.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg usunięto określoną liczbę znaków z ciągu bieżącego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera pozycja ma rozpocząć się usuwanie znaków.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu, zaczynając od określonej pozycji i kontynuowanie przy użyciu ostatniej pozycji zostały usunięte.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem ten ciąg, z wyjątkiem znaków usunięte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], ciągów jest liczony od zera. Wartość `startIndex` parametru może należeć do zakresu od zero do jeden mniejszą niż długość wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w których wszystkie znaki od pozycji `startIndex` na końcu oryginalnego ciągu zostały usunięte.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.Remove%2A> metody. W przypadku dalej do ostatniego usuwa cały tekst, zaczynając od określonego indeksu do końca ciągu. Ostatnim przypadku usuwa trzy znaki, zaczynając od określonego indeksu.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> Określa położenie, który nie jest w tym ciągu.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera pozycja ma rozpocząć się usuwanie znaków.</param>
        <param name="count">Liczba znaków do usunięcia.</param>
        <summary>Zwraca nowy ciąg, w której usunięto określoną liczbę znaków w bieżącym wystąpieniu, zaczynając od określonej pozycji.</summary>
        <returns>Nowy ciąg, który jest odpowiednikiem tego wystąpienia, z wyjątkiem znaków usunięte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], ciągów jest liczony od zera. Wartość `startIndex` parametru może należeć do zakresu od zero do jeden mniejszą niż długość wystąpienia ciągu.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, w których liczba znaków, określony przez `count` parametr został usunięty. Znaki zostaną usunięte w miejscu określonym przez `startIndex`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak usunąć drugie imię z pełną nazwą.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> plus <paramref name="count" /> Określ pozycji poza tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg w których wszystkie wystąpienia określony znak Unicode lub <see cref="T:System.String" /> w ciągu bieżącej są zamieniane na inny określony znak Unicode lub <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak Unicode, które mają zostać zastąpione.</param>
        <param name="newChar">Znak Unicode, aby zastąpić wszystkie wystąpienia <c>oldChar</c>.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia określonej Unicode znaków w tym wystąpieniu są zamieniane na inny określony znak Unicode.</summary>
        <returns>Ciąg, który jest odpowiednikiem to wystąpienie, z wyjątkiem wszystkie wystąpienia <paramref name="oldChar" /> są zastępowane <paramref name="newChar" />. Jeśli <paramref name="oldChar" /> nie znajduje się w bieżącym wystąpieniu, metoda zwraca niezmieniony bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porządkowej wyszukiwania (z uwzględnieniem wielkości liter i niezależnych od kultury) można znaleźć `oldChar`.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w których wszystkie wystąpienia `oldChar` zastępuje `newChar`.  
  
 Ponieważ ta metoda zwraca ciąg zmodyfikowane, można połączonych w łańcuch kolejnych wywołań <xref:System.String.Replace%2A> metody do wykonywania wielu zamiany na oryginalnego ciągu. Wywołania metody są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład tworzy rozdzielana przecinkami lista wartości, zastępując przecinkami puste wartości zakresu liczb.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg, który można zastąpić.</param>
        <param name="newValue">Ciąg, aby zastąpić wszystkie wystąpienia <c>oldValue</c>.</param>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia określonego ciągu w bieżącym wystąpieniu są zamieniane na inny określony ciąg.</summary>
        <returns>Ciąg, który jest odpowiednikiem danego ciągu z wyjątkiem wszystkie wystąpienia <paramref name="oldValue" /> są zastępowane <paramref name="newValue" />. Jeśli <paramref name="oldValue" /> nie znajduje się w bieżącym wystąpieniu, metoda zwraca niezmieniony bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `newValue` jest `null`, wszystkie wystąpienia `oldValue` zostaną usunięte.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w których wszystkie wystąpienia `oldValue` zastępuje `newValue`.  
  
 Ta metoda wykonuje porządkowej wyszukiwania (z uwzględnieniem wielkości liter i niezależnych od kultury) można znaleźć `oldValue`.  
  
 Ponieważ ta metoda zwraca ciąg zmodyfikowane, można połączonych w łańcuch kolejnych wywołań <xref:System.String.Replace%2A> metody do wykonywania wielu zamiany na oryginalnego ciągu. Wywołania metody są wykonywane od lewej do prawej. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używasz <xref:System.String.Replace%2A> metodę, aby poprawić błąd pisowni.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> jest pustym ciągiem ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca tablicę ciągów, który zawiera podciągów w tym wystąpieniu, które są rozdzielane elementów określony ciąg lub tablica znaków Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> Służy do podzielić ciąg rozdzielany podciągów. Tablicy znaków można użyć do określenia zero, jeden lub wiele znaki rozdzielające ( <xref:System.String.Split%28System.Char%5B%5D%29> metodę), lub można określić zero, jednego lub wielu ciągów rozdzielające tablicy znaków. Overloads z <xref:System.String.Split%2A> metody pozwalają ograniczyć liczbę podciągów zwracany przez metodę ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> metody), aby ustalić, czy puste ciągi znajdują się w zwracanych podciągów ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metody, lub Aby wykonać obie czynności ( <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> i <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> metody).  
  
> [!IMPORTANT]
>  Aby uzyskać szczegółowe informacje na <xref:System.String.Split%2A> metody, jak również podobnie jak w przypadku przykłady, które wywołują przeciążenia każdego można znaleźć w dokumentacji dla poszczególnych przeciążeń <xref:System.String.Split%2A>.  
  
 <xref:System.String.Split%2A> — Metoda nie zawsze jest najlepszy sposób, aby podzielić ciąg rozdzielany podciągów. Jeśli nie chcesz wyodrębnić wszystkie podciągów ciąg rozdzielany lub jeśli chcesz przeanalizować ciągu na podstawie wzorca zamiast zestaw znaków ogranicznik, należy wziąć pod uwagę następujące alternatyw.  
  
## <a name="regular-expressions"></a>Wyrażenia regularne  
 Jeśli Twoje ciągów jest zgodny ze stałego wzorca, można użyć wyrażenia regularnego wyodrębnić i ich elementy. Na przykład, jeśli ciągi mieć postać "*numer* *operand* *numer*" można użyć [wyrażenia regularnego](~/docs/standard/base-types/regular-expressions.md) wyodrębnić i obsługi elementy parametrów. Oto przykład:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Wzorzec wyrażenia regularnego `(\d+)\s+([-+*/])\s+(\d+)` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Zgodne z co najmniej jeden znak odstępu.|  
|`([-+*/])`|Pasuje do znaku operatora arytmetycznego (+, -, *, lub /). Jest to druga grupa przechwytywania.|  
|`\s+`|Zgodne z co najmniej jeden znak odstępu.|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to trzecia grupa przechwytywania.|  
  
 Można również użycie wyrażenia regularnego do wyodrębnienia podciągów z ciągu na podstawie wzorca zamiast ustalony zbiór znaków. Jest to typowy scenariusz, jeśli występuje którykolwiek z tych warunków:  
  
-   Co najmniej jeden znak ogranicznika nie zawsze służy jako ogranicznik w <xref:System.String> wystąpienia.  
  
-   Sekwencja i liczbę znaków ogranicznik jest zmienna lub nieznany.  
  
 Na przykład <xref:System.String.Split%2A> metody nie można użyć do dzielenia następujący ciąg, ponieważ liczba `\n` (w języku C#) lub `vbCrLf` (w języku Visual Basic) znaków jest zmienną i zawsze nie służą jako ograniczników.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Wyrażenie regularne można podzielić łatwe w poniższym przykładzie przedstawiono ten ciąg.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Wzorzec wyrażenia regularnego `\[([^\[\]]+)\]` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\[`|Zgodny z nawiasem otwierającym.|  
|`([^\[\]]+)`|Dopasowuje dowolny znak, który nie jest otwierający lub zamykający nawias kwadratowy jeden lub więcej razy. Jest to pierwsza grupa przechwytywania.|  
|`\]`|Zgodne nawiasu zamykającego.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody jest niemal identyczny <xref:System.String.Split%2A?displayProperty=nameWithType>, ale dzieli na podstawie wzorca wyrażenia regularnego zamiast zestawu znaków w stałej ciągu. Na przykład w poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodę, aby podzielić ciąg, który zawiera podciągów ograniczonej przez różne kombinacje łączniki i znaki.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Wzorzec wyrażenia regularnego `\s-\s?[+*]?\s?-\s` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\s-`|Odpowiada znak odstępu, a następnie łącznika.|  
|`\s?`|Dopasowuje zero lub jeden biały znak.|  
|`[+*]?`|Zgodne wystąpienie zero lub jeden z dwóch + lub * znaków.|  
|`\s?`|Dopasowuje zero lub jeden biały znak.|  
|`-\s`|Zgodne łącznik, a następnie znaku odstępu.|  
  
## <a name="search-methods-and-the-substring-method"></a>Metody wyszukiwania i Substring — metoda  
 Jeśli nie chcesz we wszystkich podciągów w ciągu, warto korzystać z metod porównania ciągów, które zwraca indeks, od której rozpoczyna się dopasowania. Następnie można wywołać <xref:System.String.Substring%2A> metodę, aby wyodrębnić podciągu, który chcesz. Metody porównanie ciągu obejmują:  
  
-   <xref:System.String.IndexOf%2A>, która zwraca liczony od zera indeks pierwszego wystąpienia znak lub ciąg wystąpienia ciągu.  
  
-   <xref:System.String.IndexOfAny%2A>, która zwraca liczony od zera indeks bieżącego wystąpienia ciągu pierwszego wystąpienia dowolnego znaku w tablicy znaków.  
  
-   <xref:System.String.LastIndexOf%2A>, która zwraca liczony od zera indeks ostatniego wystąpienia znak lub ciąg wystąpienia ciągu.  
  
-   <xref:System.String.LastIndexOfAny%2A>, która zwraca liczony od zera indeks bieżącego wystąpienia ciągu ostatniego wystąpienia dowolnego znaku w tablicy znaków.  
  
 W poniższym przykładzie użyto <xref:System.String.IndexOf%2A> metody do znalezienia w ciągu okresu. Następnie używa <xref:System.String.Substring%2A> metody do zwrócenia pełnych zdań.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <summary>Dzieli ciąg na podciągów, które są oparte na znaki w tablicy.</summary>
        <returns>Tablica której elementy zawierają podciągów z tym wystąpieniem, które są rozdzielone przez co najmniej jeden znak w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg jest rozdzielone znanego zestawu znaków, możesz użyć <xref:System.String.Split%28System.Char%5B%5D%29> metodę, aby oddzielić go do podciągów. Inne sposoby wyodrębnić podciągów z ciągu, zobacz [Alternatywami String.Split](#Alternatives) sekcji.  
  
## <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy. Na przykład, jeśli tablica separatora zawiera znak "-" i "aa-bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia.  
  
 Każdy element `separator` definiuje znak ogranicznika oddzielne. Ograniczniki dwóch znajdują się obok siebie, czy ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający mu element w tablicy zwrócony zawiera <xref:System.String.Empty>. Oto kilka przykładów:  
  
|Wartość ciągu|Separator|Tablica zwrócona|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nowe Char [] {",", ""} (C#)<br /><br /> Char() = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Bananów"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>Tablica separatora  
 Każdy element separatora definiuje oddzielne ogranicznik składający się z jednego znaku. Jeśli `separator` argument jest `null` lub nie zawiera znaków, metoda traktuje spacji jako ograniczników. Białe znaki są definiowane przez Unicode standard. zwracają `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Rozpoznanie przeciążenia String.Split(Char[]) i kompilatora  
 Mimo że jeden parametr tego przeciążenia <xref:System.String.Split%2A?displayProperty=nameWithType> to tablica znaków, można wywołać z pojedynczym znakiem, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Ponieważ `separator` parametr zostanie nadany <xref:System.ParamArrayAttribute> atrybutu kompilatory zinterpretuje pojedynczy znak jako tablica znaków pojedynczego elementu. Nie jest to w przypadku innych <xref:System.String.Split%2A?displayProperty=nameWithType> przeciążenia, które obejmują `separator` parametru; należy jawnie przekazać te przeciążenia tablicy znaków, jako `separator` argumentu.  
  
## <a name="comparison-details"></a>Szczegóły porównania  
 <xref:System.String.Split%28System.Char%5B%5D%29> Metody wyodrębnia podciągów w tym ciągu, które są rozdzielone przez jedną lub więcej znaków w `separator` tablicy i zwraca tych podciągów jako elementy tablicy.  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> Metoda szuka ograniczniki, wykonując porównania przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternatywy dla String.Split  
 <xref:System.String.Split%2A> — Metoda nie zawsze jest najlepszy sposób, aby podzielić ciąg rozdzielany podciągów. Jeśli nie chcesz wyodrębnić wszystkie podciągów ciąg rozdzielany lub jeśli chcesz przeanalizować ciągu na podstawie wzorca zamiast zestaw znaków ogranicznik, należy wziąć pod uwagę następujące alternatyw.  
  
### <a name="regular-expressions"></a>Wyrażenia regularne  
 Jeśli Twoje ciągów jest zgodny ze stałego wzorca, można użyć wyrażenia regularnego wyodrębnić i ich elementy. Na przykład, jeśli ciągi mieć postać "*numer* *operand* *numer*" można użyć [wyrażenia regularnego](~/docs/standard/base-types/regular-expressions.md) wyodrębnić i obsługi elementy parametrów. Oto przykład:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Wzorzec wyrażenia regularnego `(\d+)\s+([-+*/])\s+(\d+)` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Zgodne z co najmniej jeden znak odstępu.|  
|`([-+*/])`|Pasuje do znaku operatora arytmetycznego (+, -, *, lub /). Jest to druga grupa przechwytywania.|  
|`\s+`|Zgodne z co najmniej jeden znak odstępu.|  
|`(\d+)`|Dopasowanie do co najmniej jednej cyfry dziesiętnej. Jest to trzecia grupa przechwytywania.|  
  
 Można również użycie wyrażenia regularnego do wyodrębnienia podciągów z ciągu na podstawie wzorca zamiast ustalony zbiór znaków. Jest to typowy scenariusz, jeśli występuje którykolwiek z tych warunków:  
  
-   Co najmniej jeden znak ogranicznika nie zawsze służy jako ogranicznik w <xref:System.String> wystąpienia.  
  
-   Sekwencja i liczbę znaków ogranicznik jest zmienna lub nieznany.  
  
 Na przykład <xref:System.String.Split%2A> metody nie można użyć do dzielenia następujący ciąg, ponieważ liczba `\n` (w języku C#) lub `vbCrLf` (w języku Visual Basic) znaków jest zmienną i zawsze nie służą jako ograniczników.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Wyrażenie regularne można podzielić łatwe w poniższym przykładzie przedstawiono ten ciąg.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Wzorzec wyrażenia regularnego `\[([^\[\]]+)\]` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\[`|Zgodny z nawiasem otwierającym.|  
|`([^\[\]]+)`|Dopasowuje dowolny znak, który nie jest otwierający lub zamykający nawias kwadratowy jeden lub więcej razy. Jest to pierwsza grupa przechwytywania.|  
|`\]`|Zgodne nawiasu zamykającego.|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody jest niemal identyczny <xref:System.String.Split%2A?displayProperty=nameWithType>, ale dzieli na podstawie wzorca wyrażenia regularnego zamiast zestawu znaków w stałej ciągu. Na przykład w poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodę, aby podzielić ciąg, który zawiera podciągów ograniczonej przez różne kombinacje łączniki i znaki.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Wzorzec wyrażenia regularnego `\s-\s?[+*]?\s?-\s` jest zdefiniowany w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\s-`|Odpowiada znak odstępu, a następnie łącznika.|  
|`\s?`|Dopasowuje zero lub jeden biały znak.|  
|`[+*]?`|Zgodne wystąpienie zero lub jeden z dwóch + lub * znaków.|  
|`\s?`|Dopasowuje zero lub jeden biały znak.|  
|`-\s`|Zgodne łącznik, a następnie znaku odstępu.|  
  
### <a name="search-methods-and-the-substring-method"></a>Metody wyszukiwania i Substring — metoda  
 Jeśli nie chcesz we wszystkich podciągów w ciągu, warto korzystać z metod porównania ciągów, które zwraca indeks, od której rozpoczyna się dopasowania. Następnie można wywołać <xref:System.String.Substring%2A> metodę, aby wyodrębnić podciągu, który chcesz. Metody porównanie ciągu obejmują:  
  
-   <xref:System.String.IndexOf%2A>, która zwraca liczony od zera indeks pierwszego wystąpienia znak lub ciąg wystąpienia ciągu.  
  
-   <xref:System.String.IndexOfAny%2A>, która zwraca liczony od zera indeks bieżącego wystąpienia ciągu pierwszego wystąpienia dowolnego znaku w tablicy znaków.  
  
-   <xref:System.String.LastIndexOf%2A>, która zwraca liczony od zera indeks ostatniego wystąpienia znak lub ciąg wystąpienia ciągu.  
  
-   <xref:System.String.LastIndexOfAny%2A>, która zwraca liczony od zera indeks bieżącego wystąpienia ciągu ostatniego wystąpienia dowolnego znaku w tablicy znaków.  
  
 W poniższym przykładzie użyto <xref:System.String.IndexOf%2A> metody do znalezienia w ciągu okresu. Następnie używa <xref:System.String.Substring%2A> metody do zwrócenia pełnych zdań.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody. Masz również opcję użycia <xref:System.String.Compare%2A> metodą lokalizowania podciąg ciągu.  
  
 Aby podzielić ciąg na znak separatora, należy użyć <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Aby podzielić ciąg na ciąg separatora, należy użyć <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można wyodrębnić poszczególnych wyrazów z bloku tekstu, traktując biały znak i znaków interpunkcyjnych jako ograniczników. Tablica znaków przekazany do `separator` parametr <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metoda polega na znak spacji i znak tabulacji, wraz z niektórych typowych znaków specjalnych.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów na podstawie znaków w tablicy. Możesz również określić maksymalną liczbę podciągów do zwrócenia.</summary>
        <returns>Tablica której elementy zawierają podciągów w tym wystąpieniu, które są rozdzielone przez co najmniej jeden znak w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia. Jeśli `count` wynosi zero, zwracana jest pusta tablica.  
  
 Jeśli `separator` parametr jest `null` lub nie zawiera znaków, znaków odstępu są przyjmowane jako ograniczników. Białe znaki są zdefiniowane w standardzie Unicode, standard i zwracany `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Każdy element `separator` definiuje znak ogranicznika oddzielne. Ograniczniki dwóch znajdują się obok siebie, czy ogranicznik znajduje się na początku lub na końcu tego wystąpienia, odpowiadający mu element tablicy zawiera <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wystąpieniu pierwszy `count` minus 1 podciągów są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej i pozostałych znaków w tym wystąpieniu są zwracane w ciągu ostatnich Element zwracanej wartości.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i nie jest wyjątek.  
  
 W poniższej tabeli przedstawiono przykłady.  
  
|Wartość ciągu|Separator|Liczba|Tablica zwrócona|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nowe Char [] {",", ""} (C#)<br /><br /> Char() = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Bananów"|nowe Char [] {"."} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] null (C#)<br /><br /> Char() = nic nie|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|nowe Char [] null (C#)<br /><br /> Char() = nic nie|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg ciągu.  
  
 Jeśli są podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Jeśli są podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób `count` wpływa na liczbę ciągów zwrócony przez <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest ujemna.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> uwzględnienie pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na podciągów na podstawie znaków w tablicy. Można określić, czy podciągów uwzględniać pustą tablicę elementów.</summary>
        <returns>Tablica której elementy zawierają podciągów w tym ciągu, które są rozdzielone przez co najmniej jeden znak w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Ogranicznik znaków (znaki w `separator` tablicy) nie są objęte elementy tablicy zwracane. Na przykład jeśli `separator` tablica zawiera znak "-" i "aa-bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia.  
  
 Jeśli `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, metoda zwraca pustą tablicę.  
  
 Każdy element `separator` definiuje oddzielne ogranicznik składający się z jednego znaku. Jeśli `options` argument jest <xref:System.StringSplitOptions.None>i dwa ograniczniki znajdują się obok siebie lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia zawiera odpowiadającego mu elementu tablicy <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład jeśli `separator` zawiera dwa elementy "-" i "\_", wartość wystąpienia ciągu jest "-\_aa -\_", a wartością `options` argument jest <xref:System.StringSplitOptions.None>, metoda zwraca tablicy ciągów z pięć następujące elementy:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, który poprzedza "-" znak pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg między "-" pod indeksem 0 i znaku "_" pod indeksem 1 znak.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, który następuje po znaku "_" od indeksu 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, który następuje "-" znak w indeksie 5.  
  
## <a name="the-separator-array"></a>Tablica separatora  
 Jeśli `separator` parametr jest `null` lub nie zawiera znaków, znaków odstępu są przyjmowane jako ograniczników. Białe znaki są zdefiniowane w standardzie Unicode, standard i zwracany `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Jeśli `separator` parametr w wywołaniu przeciążenie tej metody jest `null`, kompilator Rozpoznanie przeciążenia nie powiodło się. Aby jednoznacznie zidentyfikować wywołaną metodę, kodu musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Szczegóły porównania  
 <xref:System.String.Split%2A> Metody wyodrębnia podciągów w tym ciągu, które są rozdzielone przez jedną lub więcej znaków w `separator` parametru i zwraca tych podciągów jako elementy tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczniki, wykonując porównania przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg ciągu.  
  
 Jeśli są podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Jeśli są podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenie do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica ciągów ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> uwzględnienie pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na podciągów na podstawie ciągów w tablicy. Można określić, czy podciągów uwzględniać pustą tablicę elementów.</summary>
        <returns>Tablica której elementy zawierają podciągów w tym ciągu, które są rozdzielone przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg jest rozdzielone znanego zestawu ciągi, możesz użyć <xref:System.String.Split%2A> metodę, aby oddzielić go do podciągów.  
  
## <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Elementy tablicy zwracane nie są objęte ciągi ograniczników. Na przykład jeśli `separator` tablica zawiera ciąg "--" i "aa - bb-cc" ma wartość bieżącego wystąpienia ciągu, metoda zwraca tablicę, która zawiera trzy elementy: "aa", "bb" i "cc".  
  
 Jeśli to wystąpienie nie zawiera żadnego z ciągów `separator`, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia.  
  
 Jeśli `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, metoda zwraca pustą tablicę.  
  
 Każdy element `separator` definiuje oddzielne ogranicznik, który składa się z co najmniej jeden znak. Jeśli `options` argument jest <xref:System.StringSplitOptions.None>i dwa ograniczniki znajdują się obok siebie lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia zawiera odpowiadającego mu elementu tablicy <xref:System.String.Empty?displayProperty=nameWithType>. Na przykład jeśli `separator` zawiera dwa elementy "-" i "_", wartość wystąpienia ciągu jest "- _aa -\_" i wartość `options` argument jest <xref:System.StringSplitOptions.None>, metoda zwraca tablicę ciągu z pięciu następujące elementy:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, który poprzedza "-" substring pod indeksem 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg między "-" substring pod indeksem 0 i substring "_" pod indeksem 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, znajdujący się pod indeksem 4 podciąg "_".  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, który reprezentuje pusty ciąg, który następuje "-" substring w indeksie 5.  
  
## <a name="the-separator-array"></a>Tablica separatora  
 Jeśli jeden z elementów w `separator` składa się wielu znaków cały podciąg jest uznawany za ogranicznika. Na przykład, jeśli jeden z elementów w `separator` jest "10" próby podzielić ciąg "This10is10a10string." zwraca następujące tablicy elementu czterech: {"", "to", "", "string". }.  
  
 Jeśli `separator` parametr jest `null` lub nie zawiera znaków, znaków odstępu są przyjmowane jako ograniczników. Białe znaki są zdefiniowane w standardzie Unicode, standard i zwracany `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
 Jeśli `separator` parametr w wywołaniu przeciążenie tej metody jest `null`, kompilator Rozpoznanie przeciążenia nie powiodło się. Aby jednoznacznie zidentyfikować wywołaną metodę, kodu musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Szczegóły porównania  
 <xref:System.String.Split%2A> Metody wyodrębnia podciągów w tym ciągu, które są rozdzielone przez jedną lub więcej ciągów w `separator` parametru i zwraca tych podciągów jako elementy tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczniki, wykonując porównania przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
 <xref:System.String.Split%2A> Metody ignoruje żadnym elementem `separator` o wartości `null` lub ciąg pusty ("").  
  
 Aby uniknąć Niejednoznaczne wyniki podczas ciągów w `separator` mają cechy wspólne, znaki <xref:System.String.Split%2A> operacji przechodzi od początku do końca wartości wystąpienia oraz jest zgodny z pierwszym elementem w `separator` jest taki sam, jak ogranicznik w wystąpienie. Kolejność wystąpił podciągów w wystąpieniu mają pierwszeństwo przed kolejność elementów `separator`.  
  
 Rozważmy na przykład wystąpienie, którego wartość wynosi "abcdef". Jeśli pierwszym elementem w `separator` został "ef", a drugi element "bcde", wynik operacji podziału byłoby tablicy ciągów, która zawiera dwa elementy "a" i "f". Wynika to z faktu substring w wystąpieniu "bcde" napotkano i zgodny z elementem w `separator` przed napotkano podciągu "f".  
  
 Jednak jeśli pierwszy element `separator` został "bcd", a drugi element "bc", wynik operacji podziału byłoby tablicy ciągów, która zawiera dwa elementy "a" i "ef". Jest to spowodowane "bcd" jest pierwszym ogranicznik w `separator` odpowiadającego ogranicznik w wystąpieniu. Jeśli kolejność separatorów została odwrócona, więc pierwszym elementem została "bc", a drugi element został "bcd", wynikiem byłby tablicy ciągów, która zawiera dwa elementy "a" i "def".  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg ciągu.  
  
 Jeśli są podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Jeśli są podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w tablicach zwrócony przez wywołanie metody ciąg <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> metody z jego `options` parametru równa <xref:System.StringSplitOptions.None?displayProperty=nameWithType> i <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 W poniższym przykładzie zdefiniowano tablicę separatorów, które zawierają znaki interpunkcyjne i białe znaki. Przekazywanie tej tablicy wraz z wartością <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> do <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metoda zwraca tablicę, która składa się z poszczególnych wyrazów z ciągu.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Należy pamiętać, że metoda jest wywoływana z `options` argument wartość <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Zapobiega to tablica zwrócona z tym <xref:System.String.Empty?displayProperty=nameWithType> wartości, które reprezentują dopasowań podciągów pusty między znaki interpunkcyjne i białe znaki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica znaków, ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> uwzględnienie pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów na podstawie znaków w tablicy.</summary>
        <returns>Tablica której elementy zawierają podciągów w tym ciągu, które są rozdzielone przez co najmniej jeden znak w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ogranicznika nie są uwzględnione w elementach zwróconej tablicy.  
  
 Jeśli to wystąpienie nie zawiera znaków w `separator`, lub `count` parametru to 1, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia. Jeśli `separator` parametr jest `null` lub nie zawiera znaków, znaków odstępu są przyjmowane jako ograniczników. Białe znaki są zdefiniowane w standardzie Unicode, standard i zwracany `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody. Jednak jeśli `separator` parametr w wywołaniu przeciążenie tej metody jest `null`, kompilator Rozpoznanie przeciążenia nie powiodło się. Aby jednoznacznie zidentyfikować wywołaną metodę, kodu musi wskazywać typ wartości null. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Jeśli `count` parametru wynosi zero, lub `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, zwrócił pustą tablicę.  
  
 Każdy element `separator` definiuje znak ogranicznika oddzielne. Jeśli `options` parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki znajdują się obok siebie lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia zawiera odpowiadającego mu elementu tablicy <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wystąpieniu pierwszy `count` minus 1 podciągów są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej i pozostałych znaków w tym wystąpieniu są zwracane w ciągu ostatnich Element zwracanej wartości.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i nie jest wyjątek.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg ciągu.  
  
 Jeśli są podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Jeśli są podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenie do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tablica ciągów ograniczającego podciągów w tym ciągu, pustą tablicę zawierającą nie ograniczników lub <see langword="null" />.</param>
        <param name="count">Maksymalna liczba podciągów do zwrócenia.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> Aby pominąć pustą tablicę elementów w tablicy zwracanej; lub <see cref="F:System.StringSplitOptions.None" /> uwzględnienie pustą tablicę elementów w tablicy zwracanej.</param>
        <summary>Dzieli ciąg na maksymalną liczbę podciągów na podstawie ciągów w tablicy. Można określić, czy podciągów uwzględniać pustą tablicę elementów.</summary>
        <returns>Tablica której elementy zawierają podciągów w tym ciągu, które są rozdzielone przez jeden lub więcej ciągów w <paramref name="separator" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Szczegóły wartości zwracanej  
 Elementy tablicy zwracane nie są objęte ciągi ograniczników.  
  
 Jeśli to wystąpienie nie zawiera żadnego z ciągów `separator`, lub `count` parametru to 1, zwracana tablica składa się z pojedynczym elementem zawierający tego wystąpienia. Jeśli `separator` parametr jest `null` lub nie zawiera znaków, znaków odstępu są przyjmowane jako ograniczników. Białe znaki są zdefiniowane w standardzie Unicode, standard i zwracany `true` jeśli są one przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody. Jednak jeśli `separator` parametr w wywołaniu przeciążenie tej metody jest `null`, kompilator Rozpoznanie przeciążenia nie powiodło się. Aby jednoznacznie zidentyfikować wywołaną metodę, kodu musi wskazywać typ `null`. W poniższym przykładzie pokazano kilka sposobów na jednoznaczną identyfikację tego przeciążenia.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Jeśli `count` parametru wynosi zero, lub `options` parametr jest <xref:System.StringSplitOptions.RemoveEmptyEntries> i długości tego wystąpienia wynosi zero, zwrócił pustą tablicę.  
  
 Każdy element `separator` definiuje oddzielne ogranicznik, który składa się z co najmniej jeden znak. Jeśli `options` parametr jest <xref:System.StringSplitOptions.None>i dwa ograniczniki znajdują się obok siebie lub ogranicznik znajduje się na początku lub na końcu tego wystąpienia zawiera odpowiadającego mu elementu tablicy <xref:System.String.Empty>.  
  
 Jeśli istnieje więcej niż `count` podciągów w tym wystąpieniu pierwszy `count` minus 1 podciągów są zwracane w pierwszym `count` minus 1 elementy wartości zwracanej i pozostałych znaków w tym wystąpieniu są zwracane w ciągu ostatnich Element zwracanej wartości.  
  
 Jeśli `count` jest większa niż liczba podciągów, zwracane są dostępne podciągów i nie jest wyjątek.  
  
## <a name="the-separator-array"></a>Tablica separatora  
 Jeśli jeden z elementów w `separator` składa się wielu znaków cały podciąg jest uznawany za ogranicznika. Na przykład, jeśli jeden z elementów w `separator` jest "10" próby podzielić ciąg "This10is10a10string." Zwraca tablicę ten element czterech: {"", "to", "", "string". }.  
  
## <a name="comparison-details"></a>Szczegóły porównania  
 <xref:System.String.Split%2A> Metody wyodrębnia podciągów w tym ciągu, które są rozdzielone przez jedną lub więcej ciągów w `separator` parametru i zwraca tych podciągów jako elementy tablicy.  
  
 <xref:System.String.Split%2A> Metoda szuka ograniczniki, wykonując porównania przy użyciu reguł porządkowych sortowania. Aby uzyskać więcej informacji dotyczących programu word, typ string i porządkową sortowania, zobacz <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> wyliczenia.  
  
 <xref:System.String.Split%2A> Metody ignoruje żadnym elementem `separator` o wartości `null` lub ciąg pusty ("").  
  
 Aby uniknąć Niejednoznaczne wyniki podczas ciągów w `separator` mają cechy wspólne, znaki <xref:System.String.Split%2A> metoda przechodzi od początku do końca wartości wystąpienia i zgodny z pierwszym elementem w `separator` jest taki sam, jak ogranicznik w wystąpienie. Kolejność wystąpił podciągów w wystąpieniu mają pierwszeństwo przed kolejność elementów `separator`.  
  
 Rozważmy na przykład wystąpienie, którego wartość wynosi "abcdef". Jeśli pierwszym elementem w `separator` został "ef", a drugi element "bcde", wynik operacji podziału byłoby "a" i "f". Wynika to z faktu substring w wystąpieniu "bcde" napotkano i zgodny z elementem w `separator` przed napotkano podciągu "f".  
  
 Jednak jeśli pierwszy element `separator` został "bcd", a drugi element "bc", wynik operacji podziału byłoby "a" i "ef". Jest to spowodowane "bcd" jest pierwszym ogranicznik w `separator` odpowiadającego ogranicznik w wystąpieniu. Jeśli kolejność separatorów została odwrócona, więc pierwszym elementem została "bc", a drugi element został "bcd", wynikiem będzie "a" i "def".  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 <xref:System.String.Split%2A> Metody przydzielić pamięci dla obiekt array zwrócony i <xref:System.String> obiekt dla każdego elementu tablicy. Jeśli aplikacja wymaga optymalnej wydajności lub zarządzanie alokacji pamięci jest szczególnie ważne w aplikacji, należy rozważyć użycie <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metody i opcjonalnie <xref:System.String.Compare%2A> metody, aby zlokalizować podciąg ciągu.  
  
 Jeśli są podzielić ciąg na znak separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania znak separatora w ciągu. Jeśli są podzielić ciąg na ciąg separatora, użyj <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOfAny%2A> metodą lokalizowania pierwszego znaku ciągu separatora. Następnie użyj <xref:System.String.Compare%2A> metodę, aby ustalić, czy znaki po pierwszym znaku pozostałych znaków ciągu separatora.  
  
 Ponadto, jeśli ten sam zestaw znaków umożliwia dzielenie ciągów w wielu <xref:System.String.Split%2A> wywołania metody, należy rozważyć utworzenie pojedynczej tablicy i odwołuje się do każdego wywołania metody. Pozwala to znacznie ograniczyć dodatkowe obciążenie każdego wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.StringSplitOptions> wyliczenie do dołączania lub wykluczania podciągów generowane przez <xref:System.String.Split%2A> metody.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> nie jest jednym z <see cref="T:System.StringSplitOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, jeśli <see cref="M:System.String.Split(System.Char[])" /> metody jest przekazywany <paramref name="separator" /> czyli <see langword="null" /> lub nie zawiera znaków, metoda używa nieco inny zestaw znaków podziału ciąg niż <see cref="M:System.String.Trim(System.Char[])" /> metoda wykonuje przyciąć ciąg. W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] obie metody użycia identyczne zestawu Unicode białe znaki.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy na początku tego wystąpienia ciągu zgodny określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <summary>Określa, czy na początku tego wystąpienia ciągu zgodny określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> dopasowuje początek tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` do podciągu na początku tego wystąpienia, która jest równa długości `value`i zwraca wskazuje, czy są równe. Aby być równe `value` musi być ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi odpowiadać na początku tego wystąpienia.  
  
 Ta metoda przeprowadza porównanie wyrazów (wielkość liter i z uwzględnieniem ustawień kulturowych) przy użyciu bieżącej kultury.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `StripStartTags` metody, która używa <xref:System.String.StartsWith%28System.String%29> metodę, aby usunąć HTML tagi początkowe od początku ciągu. Należy pamiętać, że `StripStartTags` metoda jest wywoływana cyklicznie, aby się upewnić, że wiele początkowe tagi HTML na początku wiersza. Przykład nie powoduje usunięcia tagów HTML osadzone w ciągu.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod porównania ciągów, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby ustalić, czy ciąg rozpoczyna się od określonego podciąg za pomocą reguł porównanie ciągu z bieżącej kultury, należy wywołać <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> przeciążenie metody o wartości <see cref="F:System.StringComparison.CurrentCulture" /> dla jego <paramref name="comparisonType" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="comparisonType">Jedną z wartości wyliczenia, które określa, jak te parametry i <c>wartość</c> są porównywane.</param>
        <summary>Określa, czy na początku tego wystąpienia ciągu zgodny określonego ciągu w porównaniu przy użyciu opcji porównania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli to wystąpienie rozpoczyna się od <paramref name="value" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A> Metoda porównuje `value` parametr podciąg na początku tego ciągu i zwraca wartość wskazującą, czy są one takie same. Aby być równe `value` musi być odwołaniem do tego samego ciągu, musi być ciągiem pustym (""), lub musi odpowiadać na początku tego ciągu. Typ porównania z zastosowaniem <xref:System.String.StartsWith%2A> metoda zależy od wartości `comparisonType` parametru. Porównania można użyć konwencji bieżącej kultury (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> i <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) lub kulturą niezmienną (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> i <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), lub może zawierać znak po znaku porównania punktów kodowych (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> lub <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Porównanie może również być uwzględniana wielkość liter (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, lub <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), lub jego Ignoruj wielkość liter (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Poniższy przykład wyszukuje ciąg "" na początku ciąg dłuższy, który rozpoczyna się od słowa "". Jako dane wyjściowe w przykładzie, wywołanie <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metody, które dokonuje porównania niezależnych od kultury, ale z uwzględnieniem wielkości liter nie powiedzie się zgodny z ciągiem, gdy wywołanie, które wykonuje porównanie insensitive kultury i przypadkami pasującej do ciągu.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Poniższy przykład określa, czy ciąg rozpoczyna się od określonego podciąg. Inicjuje on tablicą dwuwymiarową ciągu. Pierwszym elementem w drugi wymiar zawiera ciąg, a drugi element zawiera ciąg do wyszukania w chwili rozpoczęcia pierwszy ciąg. Wyniki są zagrożone wybór kultury, czy wielkość liter jest ignorowana i czy jest wykonywane porównanie liczby porządkowej. Należy pamiętać, że gdy wystąpienia ciągu zawiera ligatury, zależne od kultury porównań z jego kolejnych znaków pomyślnie są zgodne.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest <see cref="T:System.StringComparison" /> wartość.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do porównania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter podczas porównywania; w przeciwnym razie <see langword="false" />.</param>
        <param name="culture">Kultury informacje, które określa, jak te parametry i <c>wartość</c> są porównywane. Jeśli <c>kultury</c> jest <see langword="null" />, bieżącej kultury jest używany.</param>
        <summary>Określa, czy na początku tego wystąpienia ciągu zgodny określonego ciągu w porównaniu z użyciem kultury określonej.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametru dopasowuje początek tego ciągu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje `value` parametr podciąg na początku tego ciągu, która jest równa długości `value`i zwraca wartość wskazującą, czy są one takie same. Aby być równe `value` musi być ciągiem pustym (<xref:System.String.Empty?displayProperty=nameWithType>), musi być odwołaniem do tego samego wystąpienia lub musi odpowiadać na początku tego wystąpienia.  
  
 Ta metoda wykonuje porównanie przy użyciu określonego wielkości liter i kultury.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ciąg występuje na początku innego ciągu. <xref:System.String.StartsWith%2A> Metoda jest wywoływana kilka razy przy użyciu uwzględniana wielkość liter, liter i innych kultur wpływające na wyniki wyszukiwania.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera podciąg z tego wystąpienia.  Ten element członkowski jest przeciążony. Aby uzyskać pełne informacje dotyczące tego elementu członkowskiego, w tym informacje o jego składni i zastosowaniu oraz odpowiednie przykłady, kliknij nazwę na liście przeciążeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera znak pozycję początkową podciągu w tym wystąpieniu.</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg rozpoczyna się od określonego znaku na pozycji i kontynuuje końca ciągu.</summary>
        <returns>Ciąg, który jest odpowiednikiem podciągu, który rozpoczyna się od <paramref name="startIndex" /> w tym wystąpieniu lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="startIndex" /> jest równa długości tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.String.Substring%2A> metody do wyodrębniania podciągu z ciągiem, który rozpoczyna się od pozycji określony znak i kończy się na końcu ciągu. Pozycja początkowa znak jest liczony od zera; innymi słowy pierwszy znak w ciągu znajduje się pod indeksem 0, indeks 1. Aby wyodrębnić podciąg, rozpoczyna się od pozycji określony znak, który kończy się przed na końcu ciągu, należy wywołać <xref:System.String.Substring%2A> metody.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg, który rozpoczyna się od `startIndex` pozycji w ciągu bieżącej.  
  
 Aby wyodrębnić podciągu, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołanie metody takie jak <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> można pobrać wartości `startIndex`. Drugi przykład ilustruje wyodrębnia jego wartości klucza, który rozpoczyna się jednego znaku na pozycji po znaku "=".  
  
 Jeśli `startIndex` jest równa zero, zwraca metody oryginalnego ciągu bez zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, uzyskiwanie podciąg z ciągu.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz wartość, które są rozdzielane equals znak ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metody jest używany do pobierania pozycji znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, który rozpoczyna się od pierwszego znaku w ciągu i zwiększa liczbę znaków zwrócony przez wywołanie <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metody kolei wyodrębnia wartości przypisane do klucza. Rozpoczyna się od jednego znaku na pozycji poza znak równości, a rozszerzenie do końca ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera znak pozycję początkową podciągu w tym wystąpieniu.</param>
        <param name="length">Liczba znaków w podciąg.</param>
        <summary>Pobiera podciąg z tego wystąpienia. Podciąg rozpoczyna się od określonego znaku na pozycji i o określonej długości.</summary>
        <returns>Ciąg, który jest odpowiednikiem podciąg długość <paramref name="length" /> który zaczyna się od <paramref name="startIndex" /> w tym wystąpieniu lub <see cref="F:System.String.Empty" /> Jeśli <paramref name="startIndex" /> jest równa długości tego wystąpienia i <paramref name="length" /> wynosi zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody do wyodrębniania podciągu z ciągiem, który rozpoczyna się od pozycji określony znak i kończy się przed końcem ciągu. Pozycja początkowa znak jest liczony od zera; innymi słowy pierwszy znak w ciągu znajduje się pod indeksem 0, indeks 1. Aby wyodrębnić podciąg, rozpoczyna się od pozycji określony znak, który będzie nadal występować na końcu ciągu, należy wywołać <xref:System.String.Substring%28System.Int32%29> metody.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg z `length` znaków, poczynając od `startIndex` pozycji w ciągu bieżącej.  
  
 `length` Parametr reprezentuje całkowita liczba znaków do wyodrębniania z bieżącego wystąpienia ciągu. Obejmuje to początkowy znak w indeksie znaleziono `startIndex`.  Innymi słowy <xref:System.String.Substring%2A> metoda próbuje Wyodrębnij znaki z indeksu `startIndex` do indeksu `startIndex`  +  `length` - 1.  
  
 Aby wyodrębnić podciągu, który rozpoczyna się od określonego znaku lub sekwencji znaków, wywołanie metody takie jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> można pobrać wartości `startIndex`.  
  
 Jeśli podciąg rozciąga się od `startIndex` określony znak sekwencji, należy wywołać metodę takich jak <xref:System.String.IndexOf%2A> lub <xref:System.String.LastIndexOf%2A> uzyskać indeks znak końcowy lub sekwencja znaków.  Następnie można przekonwertować tę wartość na pozycji indeksu w ciągu w następujący sposób:  
  
-   Jeśli wyszukaniu pojedynczy znak, który jest w celu oznaczenia zakończenia podciąg, `length` parametr ma wartość `endIndex`  -  `startIndex` + 1, gdzie `endIndex` jest zwracana wartość <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> Metoda. Poniższy przykład wyodrębnia ciągłego bloku "b" znaków z ciągu.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Jeśli po przeszukaniu dla wielu znaków, które mają oznaczenia zakończenia podciąg, `length` parametr ma wartość `endIndex`  +  `endMatchLength`  -  `startIndex`, gdzie `endIndex` jest zwracana wartość <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> metody. i `endMatchLength` długość sekwencji znaków, która oznacza koniec podciąg. Poniższy przykład wyodrębnia bloku tekstu, który zawiera kod XML `<definition>` elementu.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Jeśli znak lub sekwencja znaków, nie jest uwzględniony w końcu podciąg, `length` parametr ma wartość `endIndex`  -  `startIndex`, gdzie `endIndex` jest zwracana wartość <xref:System.String.IndexOf%2A> lub <xref:System.String.IndexOf%2A> Metoda.  
  
 Jeśli `startIndex` jest równa zero i jest równa długości ciągu bieżącego, metoda zwraca ciąg oryginalnego bez zmian.  
  
   
  
## Examples  
 Poniższy przykład przedstawia proste wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodę, która wyodrębnia dwóch znaków z ciągu, zaczynając od pozycji znaku szóstego (to znaczy w indeksu pięć).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody w następujących trzech przypadkach do izolowania podciągów ciągu. W obu przypadkach podciągów są używane w porównań, a w przypadku trzeciej jest zwracany wyjątek, ponieważ określono nieprawidłowe parametry.  
  
-   Wyodrębnia pojedynczy znak, a trzeci pozycji w ciągu (pod indeksem 2), a porównuje go na "c". To porównanie zwraca `true`.  
  
-   Wyodrębnia zero znaków, zaczynając od pozycji czwarty w ciągu (w indeksie 3) i przekazuje go do <xref:System.String.IsNullOrEmpty%2A> metody. To zwraca wartość PRAWDA, ponieważ wywołanie <xref:System.String.Substring%2A> metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Próbuje Wyodrębnij jeden znak, zaczynając od pozycji czwarty w ciągu. Ponieważ w tym miejscu nie bez znaku, wywołanie metody zgłasza <xref:System.ArgumentOutOfRangeException> wyjątku.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.String.Substring%2A> metodę, aby oddzielić pary klucz wartość, które są rozdzielane equals znak ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> Metody jest używany do pobierania pozycji znaku równości w ciągu. Wywołanie <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metody wyodrębnia nazwę klucza, który rozpoczyna się od pierwszego znaku w ciągu i zwiększa liczbę znaków zwrócony przez wywołanie <xref:System.String.IndexOf%2A> metody. Wywołanie <xref:System.String.Substring%28System.Int32%29> metody kolei wyodrębnia wartości przypisane do klucza. Rozpoczyna się od jednego znaku na pozycji poza znak równości, a rozszerzenie do końca ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> wskazuje pozycję nie, w ramach tego wystąpienia.  - lub - <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Jednoznacznie moduł wyliczający służący do iterowania po bieżącej <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.Collections.Generic.IEnumerable%601> obiektu interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po bieżącej <see cref="T:System.String" /> obiektu.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu. Aby uzyskać więcej informacji, zobacz <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość aktualnie ciągu jest <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> , jeśli wartość aktualnie ciągu jest <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżących parametrów nie jest <see cref="F:System.Boolean.TrueString" /> lub <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą od <see cref="F:System.Byte.MaxValue" /> lub mniej niż <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Znak pod indeksem 0 w bieżącym <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniej niż <see cref="F:System.Decimal.MinValue" /> lub niż <see cref="F:System.Decimal.MaxValue" /> większa.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiektu jest liczbą mniej niż <see cref="F:System.Double.MinValue" /> lub większa niż <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą od <see cref="F:System.Int16.MaxValue" /> lub mniej niż <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą od <see cref="F:System.SByte.MaxValue" /> lub mniej niż <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Typ zwracany obiekt.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ChangeType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie można przekonwertować na typ określony przez <paramref name="type" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą od <see cref="F:System.UInt16.MaxValue" /> lub mniej niż <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość bieżącego <see cref="T:System.String" /> obiektu nie może zostać przeanalizowany.</exception>
        <exception cref="T:System.OverflowException">Wartość bieżącego <see cref="T:System.String" /> obiekt jest liczbą większą <see cref="F:System.UInt32.MaxValue" /> lub mniejsza niż <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Wartość przekonwertowanego bieżącego <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.String> wystąpienia jest rzutowane na <xref:System.IConvertible> interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje znaki w tym wystąpieniu do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, której elementy są znaki tego wystąpienia. Jeśli to wystąpienie jest pustym ciągiem, zwracana tablica jest pusta i o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia skopiowanie każdego znaku (to znaczy każdy <xref:System.Char> obiektu) w ciągu do tablicy znaków. Pierwszy znak skopiowane znajduje się pod indeksem zero tablicy znaków zwrócony; ostatni znak skopiowane znajduje się pod indeksem <xref:System.Array.Length%2A?displayProperty=nameWithType> -1.  
  
 Aby utworzyć ciąg znaków w tablicy znaków, należy wywołać <xref:System.String.%23ctor%28System.Char%5B%5D%29> konstruktora.  
  
 Aby utworzyć tablicę bajtów zawierającą zakodowanego znaków w ciągu, Utwórz wystąpienie odpowiedniej <xref:System.Text.Encoding> obiekt i wywołanie jego <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> metody. Niektóre kodowań standardowych dostępnych w programie .NET Framework są następujące:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.String.ToCharArray%2A> metody zostać wyodrębnione znaki w ciągu do tablicy znaków. Następnie wyświetla oryginalnego ciągu i elementów w tablicy.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 W poniższym przykładzie zdefiniowano ciąg zawierający znaki, które mają służyć jako ograniczników w ciągu rozdzielone. Następnie wywołuje <xref:System.String.ToCharArray%2A> metodę w celu utworzenia tablicy znaków, które mogą zostać przekazane do <xref:System.String.Split%28System.Char%5B%5D%29> metody, aby podzielić ciąg rozdzielany na jego poszczególnych podciągów.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Położenie początkowe podciągu w tym wystąpieniu.</param>
        <param name="length">Długość substring w tym wystąpieniu.</param>
        <summary>Kopiuje wskazany podciąg, w tym wystąpieniu znaki do tablicy znaków Unicode.</summary>
        <returns>Tablica znaków Unicode, której elementy są <paramref name="length" /> liczbę znaków w tym wystąpieniu, zaczynając od pozycji znaku <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje znaki część ciągu do tablicy znaków. Aby utworzyć ciąg z zakresu znaków w tablicy znaków, należy wywołać <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> konstruktora.  
  
 `startIndex` Parametr jest liczony od zera. Oznacza to, że indeks pierwszego znaku w ciągu wystąpienia wynosi zero.  
  
 Jeśli `length` wynosi zero, zwracana tablica jest pusta i o zerowej długości. Jeśli to wystąpienie jest `null` lub ciąg pusty (""), zwracana tablica jest pusta i o zerowej długości.  
  
 Do utworzenia tablicy bajtowej zawiera znaki zakodowane w część ciągu, Utwórz wystąpienie odpowiedniej <xref:System.Text.Encoding> obiekt i wywołanie jego <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> metody. Niektóre kodowań standardowych dostępnych w programie .NET Framework są następujące:  
  
|Kodowanie|Obiekt|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Aby uzyskać więcej informacji, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład konwertuje podciąg ciągu do tablicy znaków, a następnie wylicza i wyświetla elementy tablicy.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> plus <paramref name="length" /> jest większa niż długość tego wystąpienia.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię tego ciągu przekształcone na małe litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego ciągu przekształcone na małe litery.</summary>
        <returns>Ciąg pisane małymi literami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda uwzględnia reguły wielkość liter w bieżącej kultury.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Operacja wielkości liter, będącą wynikiem wywołania <xref:System.String.ToLower> metoda uwzględnia konwencje wielkość liter w bieżącej kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. Spowoduje utworzenie takiego samego wyniku w każdym kultury (w przeciwieństwie do <xref:System.String.ToLower> metody) i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Poniższy przykład konwertuje kilka mieszanych ciągów wielkość na małe litery.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość liter w ciągu, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby dokonać konwersji znaków na małe litery przy użyciu konwencji wielkość liter w bieżącej kultury, należy wywołać <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> przeciążenie metody o wartości <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię tego ciągu przekształcone na małe litery, przy użyciu reguł wielkość liter w określonej kultury.</summary>
        <returns>Małe litery odpowiednik bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguły wielkości liter kultury określonej przez `culture` parametru ustalić sposób wielkość liter w ciągu zostanie zmieniona.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> metody <xref:System.Globalization.CultureInfo> obiekt inny niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja wielkości liter uwzględni zasady specyficzne dla kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To spowoduje utworzenie takiego samego wyniku w każdym kultury i wykonuje wydajniej.  
  
   
  
## Examples  
 Poniższy przykład konwertuje dwa ciągi wielkich liter na małe litery, przy użyciu kultury Polski i Turecki Turcja, a następnie porównuje ciągi małe litery. Wielkie litery ciągi są identyczne z tą różnicą, że dla każdego wystąpienia Unicode LATIN litera i w jednym ciągu inny ciąg zawiera LATIN litera I z KROPKĄ powyżej.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowane na małe litery przy użyciu reguł wielkości liter Niezmienna kultura.</summary>
        <returns>Małe litery odpowiednik bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest on skojarzony z języka angielskiego, ale nie z określonego kraju lub regionu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli aplikacja jest zależna od przypadku zmienianie w sposób przewidywalny dotknięta bieżącej kultury, użyj ciągu <xref:System.String.ToLowerInvariant%2A> metody. <xref:System.String.ToLowerInvariant%2A> Metoda jest odpowiednikiem `ToLower(CultureInfo.InvariantCulture)`. Metoda jest zalecane, gdy kolekcja ciągów musi występować w przewidywalnej kolejności w formancie interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na małe litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicy ciągów, która zawiera pojedynczego wyrazu w wielu językach. <xref:System.String.ToLowerInvariant%2A> Metoda jest używana do wypełniania elementy tablica równoległa z wersją bez uwzględniania wielkości liter każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tabeli z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy małe, aby upewnić się, że elementy będą widoczne w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ ta metoda po prostu zwraca ciąg bieżącego bez zmian, nie jest niepotrzebna wywołują go bezpośrednio. Jest zwykle wywoływany niejawnie złożone formatowanie operacji, jak to pokazano w przykładzie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.String.ToString%2A> metody. Należy pamiętać, że przykładzie jawnie nie wywołuje <xref:System.String.ToString%2A> metody. Zamiast tego metodę wywoływaną niejawnie przez [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md) funkcji.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Zwraca to wystąpienie <see cref="T:System.String" />; nie jest wykonywana.</summary>
        <returns>Bieżący ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` jest zarezerwowany i aktualnie nie uczestniczy w tej operacji.  
  
 Ponieważ ta metoda po prostu zwraca ciąg bieżącego bez zmian, nie jest niepotrzebna wywołują go bezpośrednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery.</summary>
        <returns>Wielkie litery odpowiednik bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa reguł wielkość liter w bieżącej kultury, można przekonwertować każdego znaku w bieżącym wystąpieniu na jej odpowiednik wielkie litery. Jeśli znak nie ma odpowiednika wielkie litery, jest uwzględniony bez zmian w zwracany ciąg.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
 <xref:System.String.ToUpper%2A> Metoda jest często używana do przekonwertowania ciągu na wielkie litery, dzięki czemu mogą być używane porównania bez uwzględniania wielkości liter. Lepsze metody do wykonania porównania bez uwzględniania wielkości liter ma wywoływać metodę porównywania ciągów, które ma <xref:System.StringComparison> którego zostanie ustawiona na wartość parametru <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> porównanie zależne od kultury, bez uwzględniania wielkości liter.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Operacja wielkości liter, będącą wynikiem wywołania <xref:System.String.ToUpper> metoda uwzględnia konwencje wielkość liter w bieżącej kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. Spowoduje utworzenie takiego samego wyniku w każdym kultury (w przeciwieństwie do <xref:System.String.ToUpper> metody) i wykonuje bardziej efektywnie.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.String.ToUpper%2A> metodę, aby przekonwertować szereg ciągi znaków jednego, które zawierają każdego znaku w zestawach znaków rozszerzony-A Łaciński podstawowy dodatku Latin-1 i Latin. Wyświetla każdy ciąg, którego wielką literę różni się od jego małą literę.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Zgodnie z objaśnieniem w [najlepsze rozwiązania dotyczące przy użyciu Strings](~/docs/standard/base-types/best-practices-strings.md), zaleca się unikać wywoływania metod wielkość liter w ciągu, które zastępuje wartości domyślne, a zamiast tego wywołać metody, które wymagają parametry będą jawnie określony. Aby przekonwertować ciąg na wielkie litery przy użyciu konwencji wielkość liter w bieżącej kultury, należy wywołać <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> przeciążenie metody o wartości <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> dla jego <paramref name="culture" /> parametru.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię ten ciąg przekonwertowany na wielkie litery, przy użyciu reguł wielkość liter w określonej kultury.</summary>
        <returns>Wielkie litery odpowiednik bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguły wielkości liter kultury określonej przez `culture` parametru ustalić sposób wielkość liter w ciągu zostanie zmieniona.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 W przypadku przekazania <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> metody <xref:System.Globalization.CultureInfo> obiekt inny niż <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, operacja wielkości liter uwzględni zasady specyficzne dla kultury. Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody. To spowoduje utworzenie takiego samego wyniku w każdym kultury i wykonuje wydajniej.  
  
   
  
## Examples  
 Poniższy przykład dwa ciągi znaków przy użyciu kultury Polski i Turecki Turcja konwertuje ciąg z małych liter, a następnie porównuje ciągi wielkie litery. Wielkie litery ciągi są identyczne z tą różnicą, że dla każdego wystąpienia Unicode LATIN litera i w jednym ciągu inny ciąg zawiera LATIN litera I z KROPKĄ powyżej.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kopię tego <see cref="T:System.String" /> obiektu przekonwertowane na wielkie litery przy użyciu reguł wielkości liter Niezmienna kultura.</summary>
        <returns>Wielkie litery odpowiednik bieżących parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezmienna kultura reprezentuje kulturę, w której nie uwzględnia się ustawień kulturowych. Jest on skojarzony z języka angielskiego, ale nie z określonego kraju lub regionu. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli aplikacja jest zależna od przypadku zmienianie w sposób przewidywalny dotknięta bieżącej kultury, użyj ciągu <xref:System.String.ToUpperInvariant%2A> metody. <xref:System.String.ToUpperInvariant%2A> Metoda jest odpowiednikiem `ToUpper(CultureInfo.InvariantCulture)`. Metoda jest zalecane, gdy kolekcja ciągów musi występować w przewidywalnej kolejności w formancie interfejsu użytkownika.  
  
> [!NOTE]
>  Metoda ta nie modyfikuje wartości bieżącego wystąpienia. W zamian zwraca nowy ciąg, w którym wszystkie znaki w bieżącym wystąpieniu są konwertowane na wielkie litery.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Jeśli potrzebujesz wersji małe lub wielkie identyfikatora systemu operacyjnego, takie jak nazwa pliku o nazwie potoku lub klucz rejestru, użyj <xref:System.String.ToLowerInvariant%2A> lub <xref:System.String.ToUpperInvariant%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicy ciągów, która zawiera pojedynczego wyrazu w wielu językach. <xref:System.String.ToUpperInvariant%2A> Metoda jest używana do wypełniania elementy tablica równoległa z wersją bez uwzględniania wielkości liter każdego wyrazu. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Metoda jest używana do sortowania tabeli z uwzględnieniem wielkości liter na podstawie kolejności elementów w tablicy wielkie litery, aby upewnić się, że elementy będą widoczne w tej samej kolejności, niezależnie od języka.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nowy ciąg, w którym wszystkie wystąpienia wiodące i końcowe zestaw określonych znaków z bieżącego <see cref="T:System.String" /> obiektu zostaną usunięte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie znaki odstępu wiodące i końcowe z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie białe znaki są usuwane z początek i koniec bieżących parametrów. Jeśli żadne znaki nie mogą być usuwane z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Metoda usuwa z bieżących parametrów wszystkie wiodące i końcowe białe znaki. Każda operacja przycinania wiodące i końcowe zatrzymuje po napotkaniu z systemem innym niż biały znak. Na przykład, jeśli bieżący ciąg "abc xyz" <xref:System.String.Trim%2A> metoda zwraca wartość "abc xyz". Aby usunąć odstępy między wyrazami w ciągu, użyj [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Jeśli <xref:System.String.Trim%2A> metoda usuwa znaków z bieżącego wystąpienia, ta metoda nie modyfikuje wartość bieżącego wystąpienia. W zamian zwraca nowy ciąg, w której zostały usunięte wszystkie wiodące i końcowe znaki odstępu w bieżącego wystąpienia.  
  
 Jeśli bieżący ciąg równa <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składają się ze znaków odstępu, metoda zwraca <xref:System.String.Empty>.  
  
 Białe znaki są zdefiniowane w standardzie Unicode. <xref:System.String.Trim> Metoda usuwa wiodące i końcowe znaki, które powodują powstanie zwracana wartość `true` gdy są przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Trim?displayProperty=nameWithType> metodę, aby usunąć wszelkie dodatkowe wolne miejsce z wprowadzonych przez użytkownika przed ich łączenie ciągów.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach Obsługa wewnętrzną listę białe znaki, które przycina tej metody. Począwszy od [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] metoda usuwa wszystkie białe znaki Unicode (czyli znaki tego produktu <see langword="true" /> wartość zwracana, gdy są one przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Z powodu tej zmiany <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF), który <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i nowszych wersjach nie powoduje usunięcia. Ponadto <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach nie przycinany trzy białe znaki Unicode: MONGOLSKI SEPARATORA SAMOGŁOSKI (U + 180E), WĄSKIE nie-BREAK (U + 202F) i średniej MATEMATYCZNE miejsca (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące i końcowe znaki określone w tablicy z bieżącego zestawu <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z początek i koniec bieżących parametrów. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, białe znaki są usuwane w zamian. Jeśli żadne znaki nie mogą być usuwane z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> Metoda usuwa z bieżących parametrów wszystkie znaki wiodące i końcowe, które znajdują się w `trimChars` parametru. Każdy początkowe i końcowe trim zatrzymuje operację, gdy znak, który nie znajduje się w `trimChars` napotkano. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.Trim%2A> metoda zwraca wartość "abc456xyz".  
  
> [!NOTE]
>  Jeśli <xref:System.String.Trim%2A> metoda usuwa znaków z bieżącego wystąpienia, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg wszystkie początkowe i końcowe `trimChars` znaki w bieżącym wystąpieniu są usuwane.  
  
 Jeśli bieżący ciąg równa <xref:System.String.Empty> lub wszystkie znaki w bieżącym wystąpieniu składać się ze znaków w `trimChars` tablicy, metoda zwraca <xref:System.String.Empty>.  
  
 Jeśli `trimChars` jest `null` lub pusta tablica, ta metoda usuwa wiodących lub końcowych znaków, które powodują zwracanie — metoda `true` gdy są przekazywane do <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metody  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metodę, aby usunąć miejsca, gwiazdki (*) i apostrof (') znaków z ciągu.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach obsługuje wewnętrzną listę białe znaki, które przycina tej metody, jeśli <paramref name="trimChars" /> jest <see langword="null" /> albo być pustą tablicą. Począwszy od [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda usuwa wszystkie białe znaki Unicode (to znaczy znaki tego produktu <see langword="true" /> wartość zwracana, gdy są one przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Z powodu tej zmiany <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF), który <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i nowszych wersjach nie powoduje usunięcia. Ponadto <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach nie przycinany trzy białe znaki Unicode: MONGOLSKI SEPARATORA SAMOGŁOSKI (U + 180E), WĄSKIE nie-BREAK (U + 202F) i średniej MATEMATYCZNE miejsca (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia końcowe zestaw znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z końca bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, Unicode-białe znaki są usuwane zamiast tego. Jeśli żadne znaki nie mogą być usuwane z bieżącego wystąpienia, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A> Metoda usuwa z bieżących parametrów wszystkie znaki końcowe, które znajdują się w `trimChars` parametru. Zatrzymuje operację przycinania podczas pierwszego znaku który nie znajduje się w `trimChars` napotkano na końcu ciągu. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimEnd%2A> metoda zwraca wartość "123abc456xyz".  
  
> [!NOTE]
>  Jeśli <xref:System.String.TrimEnd%2A> metoda usuwa znaków z bieżącego wystąpienia, ta metoda nie modyfikuje wartość bieżącego wystąpienia. Zamiast tego zwraca nowy ciąg w końcu wszystkie znaki w `trimChars` są usuwane z bieżących parametrów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używasz <xref:System.String.TrimEnd%28System.Char%5B%5D%29> metodę, aby przyciąć spacje lub znaki interpunkcyjne od końca ciągu.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach obsługuje wewnętrzną listę białe znaki, które przycina tej metody, jeśli <paramref name="trimChars" /> jest <see langword="null" /> albo być pustą tablicą. Począwszy od [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda usuwa wszystkie białe znaki Unicode (to znaczy znaki tego produktu <see langword="true" /> wartość zwracana, gdy są one przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Z powodu tej zmiany <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF), który <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i nowszych wersjach nie powoduje usunięcia. Ponadto <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach nie przycinany trzy białe znaki Unicode: MONGOLSKI SEPARATORA SAMOGŁOSKI (U + 180E), WĄSKIE nie-BREAK (U + 202F) i średniej MATEMATYCZNE miejsca (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tablica znaków Unicode, aby usunąć, lub <see langword="null" />.</param>
        <summary>Usuwa wszystkie wystąpienia wiodące zestaw znaków określone w tablicy z bieżącego <see cref="T:System.String" /> obiektu.</summary>
        <returns>Ciąg, który pozostaje po wszystkie wystąpienia znaków w <paramref name="trimChars" /> parametru są usuwane z początku bieżącego ciągu. Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, białe znaki są usuwane w zamian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A> Metoda usuwa z bieżących parametrów wszystkie znaki wiodące, które znajdują się w `trimChars` parametru. Zatrzymuje operację przycinania, gdy znak, który nie znajduje się w `trimChars` napotkano. Na przykład, jeśli bieżący ciąg "123abc456xyz789" i `trimChars` zawiera cyfry od "1" do "9" <xref:System.String.TrimStart%2A> metoda zwraca wartość "abc456xyz789".  
  
> [!NOTE]
>  Jeśli <xref:System.String.TrimStart%2A> metoda usuwa znaków z bieżącego wystąpienia, ta metoda nie modyfikuje wartość bieżącego wystąpienia. W zamian zwraca nowy ciąg, w której zostały usunięte wszystkie wiodące znaki odstępu w bieżącym wystąpieniu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.String.TrimStart%2A> metodę, aby przyciąć biały znak i znaki komentarza z wierszy kodu źródłowego. `StripComments` Metoda opakowuje wywołanie <xref:System.String.TrimStart%2A> i przekazuje go, tablicy znaków, który zawiera spację i znak komentarz, który jest apostrof (') w Visual Basic i ukośnika (/) w języku C#. <xref:System.String.TrimStart%2A> Wywoływana jest metoda również usunąć Spacja wiodąca podczas oceniania, czy ciąg jest komentarz.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 Poniższy przykład przedstawia następnie wywołania `StripComments` metody.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach obsługuje wewnętrzną listę białe znaki, które przycina tej metody, jeśli <paramref name="trimChars" /> jest <see langword="null" /> albo być pustą tablicą. Począwszy od [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] Jeśli <paramref name="trimChars" /> jest <see langword="null" /> lub pusta tablica, metoda usuwa wszystkie białe znaki Unicode (to znaczy znaki tego produktu <see langword="true" /> wartość zwracana, gdy są one przekazywane do <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> metody). Z powodu tej zmiany <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach usuwa dwa znaki zerowej szerokości (U + 200B) i ZERO SZEROKOŚĆ bez podziału miejsca (U + FEFF), który <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i nowszych wersjach nie powoduje usunięcia. Ponadto <see cref="M:System.String.Trim" /> metody [! INCLUDE[net_v35SP1_short](~/includes/NET-v35sp1-Short-MD.MD)] i wcześniejszych wersjach nie przycinany trzy białe znaki Unicode: MONGOLSKI SEPARATORA SAMOGŁOSKI (U + 180E), WĄSKIE nie-BREAK (U + 202F) i średniej MATEMATYCZNE miejsca (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
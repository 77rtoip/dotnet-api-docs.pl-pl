<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfdf20f498b9446fa1ef100b01c36257161f0c6c" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875076" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1a109-101">Obsługuje wszystkie klasy w hierarchii klas .NET Framework i zapewnia niskopoziomowe usługi dla klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="1a109-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="1a109-102">Jest to klasa bazowa ultimate wszystkie klasy w .NET Framework; jest głównym hierarchii typów.</span><span class="sxs-lookup"><span data-stu-id="1a109-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-103">Języki zazwyczaj nie wymagają do deklarowania dziedziczenie z klasy <xref:System.Object> ponieważ dziedziczenia jest niejawne.</span><span class="sxs-lookup"><span data-stu-id="1a109-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="1a109-104">Ponieważ wszystkie klasy w .NET Framework są uzyskiwane z <xref:System.Object>, każdej metody zdefiniowane w <xref:System.Object> klasy jest dostępny w wszystkich obiektów w systemie.</span><span class="sxs-lookup"><span data-stu-id="1a109-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="1a109-105">Pochodne klasy może i zastąpić niektóre z tych metod, w tym:</span><span class="sxs-lookup"><span data-stu-id="1a109-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="1a109-106"><xref:System.Object.Equals%2A> — Obsługuje porównania między obiektami.</span><span class="sxs-lookup"><span data-stu-id="1a109-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="1a109-107"><xref:System.Object.Finalize%2A> -Wykonuje operacje oczyszczania, zanim obiekt jest automatycznie odzyskiwane.</span><span class="sxs-lookup"><span data-stu-id="1a109-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="1a109-108"><xref:System.Object.GetHashCode%2A> — Generuje numer odpowiadający wartości obiektu, aby obsługiwały korzystanie tabelę mieszania.</span><span class="sxs-lookup"><span data-stu-id="1a109-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="1a109-109"><xref:System.Object.ToString%2A> -Produkuje ciąg czytelny dla człowieka tekst, który opisuje wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="1a109-110">Zagadnienia dotyczące wydajności</span><span class="sxs-lookup"><span data-stu-id="1a109-110">Performance Considerations</span></span>  
 <span data-ttu-id="1a109-111">W przypadku projektowania klasy, takie jak pamięci, który musi obsługiwać obiekty dowolnego typu, możesz utworzyć składowych klasy, które akceptują wystąpień <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="1a109-112">Jednak proces pakowania i rozpakowywania typu niesie ze sobą spadek wydajności.</span><span class="sxs-lookup"><span data-stu-id="1a109-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="1a109-113">Jeśli wiesz, że nowej klasie często będzie obsługiwać niektórych typów wartości, można użyć jednej z dwóch taktyka zmniejszyć koszty pakowania.</span><span class="sxs-lookup"><span data-stu-id="1a109-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="1a109-114">Metoda ogólna, która akceptuje tworzenie <xref:System.Object> typ i zestaw przeciążenia metody specyficzne dla typu, które akceptują każdego typu wartości oczekujesz, że klasa często obsługi.</span><span class="sxs-lookup"><span data-stu-id="1a109-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="1a109-115">Jeśli metoda specyficznych dla typu istnieje akceptującego wywoływania typ parametru, opakowywanie nie występuje i wywoływana jest metoda specyficznych dla typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="1a109-116">Jeśli nie ma żadnego argumentu metody wywołania typu parametru, parametr jest spakowany i ogólne metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="1a109-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="1a109-117">Zaprojektuj danego typu i jej elementów członkowskich, używaj typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="1a109-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="1a109-118">Środowisko uruchomieniowe języka wspólnego tworzy zamknięty typ ogólny, podczas tworzenia wystąpienia klasy i określić argument typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="1a109-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="1a109-119">Usuwa metodę rodzajową jest specyficzny dla typu i może być wywołana bez konwersja boxing parametru wywoływania.</span><span class="sxs-lookup"><span data-stu-id="1a109-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="1a109-120">Chociaż czasami jest to niezbędne do tworzenia klasy ogólnego przeznaczenia, które akceptują i zwracają <xref:System.Object> typów, może poprawić wydajność, jednocześnie zapewniając specyficznych dla typu klasy do obsługi często używanych typów.</span><span class="sxs-lookup"><span data-stu-id="1a109-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="1a109-121">Na przykład zapewniając klasy, które są specyficzne dla ustawiania i pobierania wartości logicznych eliminuje koszt pakowania, jak i rozpakowania wartościami logicznymi.</span><span class="sxs-lookup"><span data-stu-id="1a109-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-122">W poniższym przykładzie zdefiniowano typ punktu pochodzący od <xref:System.Object> klasy i zastępuje wiele metod wirtualnych <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="1a109-123">Ponadto w przykładzie pokazano sposób wywoływania wiele statycznych lub wystąpienie metody <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="1a109-124">Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków.</span><span class="sxs-lookup"><span data-stu-id="1a109-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="1a109-125">Elementy członkowskie wystąpień nie musi być metodą o bezpiecznych wątkach.</span><span class="sxs-lookup"><span data-stu-id="1a109-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-126">Inicjuje nowe wystąpienie klasy <see cref="T:System.Object" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-127">Ten konstruktor jest wywoływany przez konstruktory w klasach pochodnych, ale może również służyć do bezpośrednio utworzyć wystąpienia <xref:System.Object> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1a109-128">Określa, czy dwa wystąpienia obiektu są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="1a109-128">Determines whether two object instances are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="1a109-129">Obiekt do porównania z bieżącym obiektem.</span><span class="sxs-lookup"><span data-stu-id="1a109-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="1a109-130">Określa, czy określony obiekt jest równy bieżącemu obiektowi.</span><span class="sxs-lookup"><span data-stu-id="1a109-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="1a109-131"><see langword="true" /> Jeśli określony obiekt jest taki sam, jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-132">Typ porównania między bieżącym wystąpieniu i `obj` parametru zależy od tego, czy bieżące wystąpienie jest typem referencyjnym lub typem wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="1a109-133">Jeśli bieżące wystąpienie jest typem referencyjnym <xref:System.Object.Equals%28System.Object%29> metody testów dla równości odwołań i wywołania <xref:System.Object.Equals%28System.Object%29> metoda jest równoważna do wywołania <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1a109-134">Równość odniesienia oznacza, że zmienne obiektów, które są porównywane odnoszą się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="1a109-135">Poniższy przykład ilustruje wynik takie porównania.</span><span class="sxs-lookup"><span data-stu-id="1a109-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="1a109-136">Definiuje `Person` klasy, która jest typem referencyjnym, i wywołuje `Person` konstruktora klasy utworzyć dwie nowe `Person` obiektów `person1a` i `person2`, które mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="1a109-137">Również przypisuje `person1a` do innej zmiennej obiektu, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="1a109-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="1a109-138">Jak wynika z w przykładzie pokazano `person1a` i `person1b` są takie same, ponieważ mogą odwoływać się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="1a109-139">Jednak `person1a` i `person2` nie są takie same, ale mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="1a109-140">Jeśli bieżące wystąpienie jest typem wartości <xref:System.Object.Equals%28System.Object%29> metoda testy na równoważność wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="1a109-141">Równość wartości oznacza, że następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="1a109-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="1a109-142">Dwa obiekty są tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-142">The two objects are of the same type.</span></span> <span data-ttu-id="1a109-143">Jak pokazano na poniższym przykładzie, <xref:System.Byte> obiekt, który ma wartość 12 nie jest równa <xref:System.Int32> obiekt, który zawiera wartość 12, ponieważ oba obiekty mają różne typy środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="1a109-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="1a109-144">Wartości pól publiczne i prywatne dwa obiekty są równe.</span><span class="sxs-lookup"><span data-stu-id="1a109-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="1a109-145">Następujący przykład sprawdza pod kątem równości wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-145">The following example tests for value equality.</span></span> <span data-ttu-id="1a109-146">Definiuje `Person` struktury, która jest typem wartości, i wywołuje `Person` konstruktora klasy utworzyć dwie nowe `Person` obiektów `person1` i `person2`, które mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="1a109-147">Dane wyjściowe z przykładu pokazują, mimo że zmienne dwóch obiektów odnoszą się do różnych obiektów, `person1` i `person2` są takie same, ponieważ mają tę samą wartość dla prywatnego `personName` pola.</span><span class="sxs-lookup"><span data-stu-id="1a109-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="1a109-148">Ponieważ <xref:System.Object> klasy jest klasą bazową dla wszystkich typów w .NET Framework <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda zawiera porównanie równości domyślnego dla wszystkich innych typów.</span><span class="sxs-lookup"><span data-stu-id="1a109-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="1a109-149">Jednak często zastępują typy <xref:System.Object.Equals%2A> metody do zaimplementowania równość wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="1a109-150">Aby uzyskać więcej informacji, zobacz uwagi dla wywołań i uwagi dotyczące obiektów dziedziczących sekcji.</span><span class="sxs-lookup"><span data-stu-id="1a109-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="1a109-151">Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1a109-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="1a109-152">Gdy wywołujesz <xref:System.Object.Equals%28System.Object%29> przeciążenie metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="1a109-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="1a109-153">Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="1a109-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="1a109-154">Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a aktualnie nie implementują <xref:System.Object.Equals%28System.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="1a109-155">Jednak wydają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.</span><span class="sxs-lookup"><span data-stu-id="1a109-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="1a109-156">klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.Equals%28System.Object%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="1a109-157">Uwagi dotyczące wywoływania</span><span class="sxs-lookup"><span data-stu-id="1a109-157">Notes for Callers</span></span>  
 <span data-ttu-id="1a109-158">Klasy pochodne często zastąpić <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do zaimplementowania równość wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="1a109-159">Ponadto typy zapewniają również często dodatkowe przeładowania silnie typizowaną `Equals` metody, zwykle przez zaimplementowanie <xref:System.IEquatable%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1a109-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="1a109-160">Gdy wywołujesz `Equals` metody do testowania pod kątem równości, należy sprawdzić, czy bieżące wystąpienie zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType> i zrozumieć, w jaki sposób wywołania określonej `Equals` metody nie zostanie rozwiązany.</span><span class="sxs-lookup"><span data-stu-id="1a109-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="1a109-161">W przeciwnym razie możesz pod kątem równości, która różni się od zamierzonym wykonywania testu, a metoda może zwrócić nieoczekiwaną wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="1a109-162">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="1a109-162">The following example provides an illustration.</span></span> <span data-ttu-id="1a109-163">Metoda tworzy trzy <xref:System.Text.StringBuilder> obiekty z identycznych ciągów, a następnie udostępnia cztery wywołania `Equals` metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="1a109-164">Pierwsza metoda wywołania zwraca `true`oraz pozostałych trzech powrotu `false`.</span><span class="sxs-lookup"><span data-stu-id="1a109-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="1a109-165">W pierwszym przypadku silnie typizowaną <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> przeciążenia metody, które testy na równoważność wartości, jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="1a109-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="1a109-166">Ponieważ ciągi przypisana do dwóch <xref:System.Text.StringBuilder> obiekty są równe, metoda zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="1a109-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="1a109-167">Jednak <xref:System.Text.StringBuilder> nie zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a109-168">W związku z tym gdy <xref:System.Text.StringBuilder> obiekt jest rzutowany <xref:System.Object>, gdy <xref:System.Text.StringBuilder> wystąpienia jest przypisywany do zmiennej typu <xref:System.Object>i kiedy <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metoda przechodzi przez dwa <xref:System.Text.StringBuilder> obiektów, domyślne <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="1a109-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="1a109-169">Ponieważ <xref:System.Text.StringBuilder> jest typem odwołania, jest to równoważne do przekazywania dwóch <xref:System.Text.StringBuilder> obiekty do <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1a109-170">Mimo że wszystkie trzy <xref:System.Text.StringBuilder> obiekty zawierają identyczne ciągi, odnoszą się do trzech różnych obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="1a109-171">W wyniku tych trzech metoda wywołuje zwracany `false`.</span><span class="sxs-lookup"><span data-stu-id="1a109-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="1a109-172">Możesz porównać bieżącego obiektu do innego obiektu równości odwołań, wywołując <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1a109-173">W języku Visual Basic umożliwia także `is` — słowo kluczowe (na przykład `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="1a109-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="1a109-174">Uwagi dotyczące obiektów dziedziczących</span><span class="sxs-lookup"><span data-stu-id="1a109-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="1a109-175">Podczas definiowania swój własny typ tego typu dziedziczy funkcje zdefiniowane przez `Equals` metoda jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="1a109-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="1a109-176">W poniższej tabeli wymieniono domyślna Implementacja klasy `Equals` metodę dla głównych kategorii typów w .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1a109-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="1a109-177">Kategoria typów</span><span class="sxs-lookup"><span data-stu-id="1a109-177">Type category</span></span>|<span data-ttu-id="1a109-178">Równość zdefiniowane przez</span><span class="sxs-lookup"><span data-stu-id="1a109-178">Equality defined by</span></span>|<span data-ttu-id="1a109-179">Komentarze</span><span class="sxs-lookup"><span data-stu-id="1a109-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="1a109-180">Klasa pochodzi bezpośrednio z <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="1a109-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="1a109-181">Równość odniesienia; równoważne z wywoływaniem <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="1a109-182">Struktura</span><span class="sxs-lookup"><span data-stu-id="1a109-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="1a109-183">Równość wartości; bezpośrednie porównanie bajt po bajcie lub pola przez porównanie przy użyciu odbicia.</span><span class="sxs-lookup"><span data-stu-id="1a109-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="1a109-184">Wyliczenie</span><span class="sxs-lookup"><span data-stu-id="1a109-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="1a109-185">Wartości muszą mieć ten sam typ wyliczeniowy i tej samej podstawowej wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="1a109-186">Delegate</span><span class="sxs-lookup"><span data-stu-id="1a109-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="1a109-187">Delegaty musi mieć tego samego typu przy użyciu list identyczne wywołania.</span><span class="sxs-lookup"><span data-stu-id="1a109-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="1a109-188">Interface</span><span class="sxs-lookup"><span data-stu-id="1a109-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="1a109-189">Równość odniesienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="1a109-190">Dla typu wartości powinny zawsze zastępuje <xref:System.Object.Equals%2A>, ponieważ testuje pod kątem równości, które działają na podstawie odbicia oferują pogorszenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="1a109-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="1a109-191">Możesz również zastąpić domyślną implementację elementu <xref:System.Object.Equals%2A> dla typów odwołań do testowania pod kątem równości wartości, a nie równości odwołań i zdefiniuj znaczenie równości wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="1a109-192">Takie implementacje <xref:System.Object.Equals%2A> zwracają `true` Jeśli dwa obiekty mają taką samą wartość, nawet jeśli nie są tego samego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="1a109-193">Typ implementujący decyduje, co stanowi wartość obiektu, ale zazwyczaj jest niektóre lub wszystkie dane przechowywane w zmiennych wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="1a109-194">Na przykład, wartość <xref:System.String> obiektu opiera się na znaki ciągu; <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> zastąpienia metody <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, aby zwrócić `true` dla każdego ciągu dwa wystąpienia, które zawierają te same znaki w tej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="1a109-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="1a109-195">Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do testowania pod kątem równości wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="1a109-196">Zastępuje ona <xref:System.Object.Equals%2A> metodę `Person` klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="1a109-197">Jeśli `Person` zaakceptowane implementację jej klasy bazowej równości, dwa `Person` obiekty są takie same, tylko wtedy, gdy ich odwołanie do pojedynczego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="1a109-198">Jednak w tym przypadku dwa `Person` obiekty są takie same, jeśli mają taką samą wartość `Person.Id` właściwości.</span><span class="sxs-lookup"><span data-stu-id="1a109-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="1a109-199">Oprócz zastępowania <xref:System.Object.Equals%2A>, można zaimplementować <xref:System.IEquatable%601> interfejsu zapewnienie silnie typizowaną test pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="1a109-200">Poniższe instrukcje muszą być prawdziwe dla wszystkich implementacjach <xref:System.Object.Equals%28System.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="1a109-201">Na liście `x`, `y`, i `z` reprezentują odwołania do obiektów, które nie są **null**.</span><span class="sxs-lookup"><span data-stu-id="1a109-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="1a109-202">`x.Equals(x)` Zwraca `true`, z wyjątkiem przypadków obejmujących typów zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="1a109-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="1a109-203">Zobacz [60559:2011 ISO/IEC/IEEE, arytmetyki zmiennoprzecinkowej technologii — procesor systemów — informacji](https://www.iso.org/standard/57469.html).</span><span class="sxs-lookup"><span data-stu-id="1a109-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="1a109-204">`x.Equals(y)` zwraca taką samą wartość jak `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="1a109-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="1a109-205">`x.Equals(y)` Zwraca `true` Jeśli oba `x` i `y` są `NaN`.</span><span class="sxs-lookup"><span data-stu-id="1a109-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="1a109-206">Jeśli `(x.Equals(y) && y.Equals(z))` zwraca `true`, następnie `x.Equals(z)` zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="1a109-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="1a109-207">Kolejne wywołania `x.Equals(y)` zwracają taką samą wartość, tak długo, jak odwołuje się do niego obiekty `x` i `y` nie są modyfikowane.</span><span class="sxs-lookup"><span data-stu-id="1a109-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="1a109-208">`x.Equals(null)` Zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="1a109-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="1a109-209">Implementacje <xref:System.Object.Equals%2A> nie może zgłaszać wyjątków, należy zawsze zwracają wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="1a109-210">Na przykład jeśli `obj` jest `null`, <xref:System.Object.Equals%2A> metoda powinna zwrócić `false` zamiast zgłaszać <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="1a109-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="1a109-211">Przestrzegać następujących wytycznych podczas zastępowania <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="1a109-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="1a109-212">Typami, które implementują <xref:System.IComparable> przesłonięcie <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="1a109-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="1a109-213">Typy zastąpienie <xref:System.Object.Equals%28System.Object%29> jest również przesłonięcie <xref:System.Object.GetHashCode%2A>; w przeciwnym razie tabele skrótów mogą nie działać poprawnie.</span><span class="sxs-lookup"><span data-stu-id="1a109-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="1a109-214">Należy rozważyć wdrożenie <xref:System.IEquatable%601> interfejsu do obsługi silnie typizowane testuje pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="1a109-215">Twoje <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementacji powinna zwrócić wyniki, które są zgodne z <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="1a109-216">Jeśli język programowania obsługuje przeciążania operatorów i przeciążaj operator równości dla danego typu, konieczne jest również przesłonięcie <xref:System.Object.Equals%28System.Object%29> metodę, aby zwracać ten sam wynik jako operatora równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="1a109-217">Pozwala to zagwarantować, że kod biblioteki klasy, który używa <xref:System.Object.Equals%2A> (takie jak <xref:System.Collections.ArrayList> i <xref:System.Collections.Hashtable>) zachowuje się w taki sposób, który jest spójny ze sposobem operatora równości jest używany przez kod aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1a109-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="1a109-218">Wytyczne dla typów odwołania</span><span class="sxs-lookup"><span data-stu-id="1a109-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="1a109-219">Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu odwołania:</span><span class="sxs-lookup"><span data-stu-id="1a109-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="1a109-220">Należy wziąć pod uwagę zastępowanie <xref:System.Object.Equals%2A> w przypadku semantykę typu opiera się na fakcie, że typ reprezentuje niektóre wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="1a109-221">Większość typów referencyjnych musi przeciążaj operator równości, nawet wtedy, gdy zastępują one <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="1a109-222">Jednak przed zaimplementowaniem typ odwołania, który jest przeznaczona do ma semantyki wartości, takie jak typ liczby zespolonej, konieczne jest przesłonięcie operatora równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="1a109-223">Nie należy zastąpić <xref:System.Object.Equals%2A> na modyfikowalnego typu referencyjnego.</span><span class="sxs-lookup"><span data-stu-id="1a109-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="1a109-224">Jest to spowodowane zastępowanie <xref:System.Object.Equals%2A> wymaga, że możesz także Przesłoń <xref:System.Object.GetHashCode%2A> metodę, zgodnie z opisem w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="1a109-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="1a109-225">Oznacza to, że skrótu wystąpienia typu referencji zmiennej można zmienić jego okres istnienia, co może powodować obiekt do utracone w tabeli wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="1a109-226">Wytyczne dla typów wartości</span><span class="sxs-lookup"><span data-stu-id="1a109-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="1a109-227">Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu wartości:</span><span class="sxs-lookup"><span data-stu-id="1a109-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="1a109-228">Jeśli określasz typ wartości, która zawiera co najmniej jedno pole, których wartości są typami odwołań, należy zastąpić <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="1a109-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="1a109-229"><xref:System.Object.Equals%28System.Object%29> Wdrażania udostępniane przez <xref:System.ValueType> wykonuje porównanie bajt po bajcie, dla typów wartości, których pola są wszystkie typy wartości, ale używa odbicia porównania przez pole z typów wartości, których pola zawierają typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="1a109-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="1a109-230">Jeśli zastąpisz <xref:System.Object.Equals%2A> i języka programowania obsługuje przeładowania operatora, muszą przeciążać operatora równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="1a109-231">Należy zaimplementować <xref:System.IEquatable%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1a109-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="1a109-232">Wywoływanie silnie typizowaną <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metoda pozwala uniknąć pakowania `obj` argumentu.</span><span class="sxs-lookup"><span data-stu-id="1a109-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-233">W poniższym przykładzie przedstawiono `Point` klasę, która zastępuje <xref:System.Object.Equals%2A> metody w celu zapewnienia równość wartości i `Point3D` klasy, która jest pochodną `Point`.</span><span class="sxs-lookup"><span data-stu-id="1a109-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="1a109-234">Ponieważ `Point` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do testowania pod kątem równości wartość <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> nie jest wywoływana metoda.</span><span class="sxs-lookup"><span data-stu-id="1a109-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="1a109-235">Jednak `Point3D.Equals` wywołania `Point.Equals` ponieważ `Point` implementuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> w taki sposób, który zapewnia równość wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="1a109-236">`Point.Equals` Metoda sprawdza, upewnij się, że `obj` argument nie jest **null** oraz że odwołuje się do wystąpienia tego samego typu jak ten obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="1a109-237">Jeśli sprawdzenie zakończy się niepowodzeniem, metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="1a109-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="1a109-238">`Point.Equals` Wywołania metody <xref:System.Object.GetType%2A> metodę pozwala ustalić, czy typów w czasie wykonywania dwa obiekty są jednakowe.</span><span class="sxs-lookup"><span data-stu-id="1a109-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="1a109-239">Jeśli metoda wyboru w formularzu `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic zwróci wyboru `true` w przypadkach, gdzie `obj` to wystąpienie klasy pochodnej `Point`, nawet jeśli `obj` i bieżący wystąpienia nie mają tego samego typu run-time.</span><span class="sxs-lookup"><span data-stu-id="1a109-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="1a109-240">Po zweryfikowaniu, że oba obiekty są tego samego typu rzutowania metoda `obj` na typ `Point` i zwraca wynik porównania pól wystąpienia dwóch obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="1a109-241">W `Point3D.Equals`, dziedziczonego `Point.Equals` metody, która zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, jest wywoływany przed odbywa się inaczej.</span><span class="sxs-lookup"><span data-stu-id="1a109-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="1a109-242">Ponieważ `Point3D` jest Klasa zapieczętowana (`NotInheritable` w języku Visual Basic), wyboru w formularzu `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic jest odpowiednia do upewnij się, że `obj` jest `Point3D` obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="1a109-243">Jeśli jest `Point3D` obiektu jest rzutowany na `Point` obiektu i przekazywane do implementacji klasy podstawowej <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="1a109-244">Tylko wtedy, gdy dziedziczonego `Point.Equals` metoda zwraca `true` jest porównanie metody `z` wystąpienia pól wprowadzonych w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="1a109-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="1a109-245">W poniższym przykładzie zdefiniowano `Rectangle` klasę implementującą wewnętrznie prostokąta jako dwa `Point` obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="1a109-246">`Rectangle` Również klasy zastąpienia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> zapewnienie na równoważność wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="1a109-247">Niektóre języki, takich jak C# i Visual Basic obsługują przeciążanie operatora.</span><span class="sxs-lookup"><span data-stu-id="1a109-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="1a109-248">Gdy typem przeciążenia operatora równości, również należy zastąpić <xref:System.Object.Equals%28System.Object%29> metody, aby udostępnić taką samą funkcjonalność.</span><span class="sxs-lookup"><span data-stu-id="1a109-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="1a109-249">Zazwyczaj jest to osiągane przez napisanie <xref:System.Object.Equals%28System.Object%29> metoda pod względem operatora równości przeciążona, jak w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="1a109-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="1a109-250">Ponieważ `Complex` jest typem wartości nie mogą pochodzić z.</span><span class="sxs-lookup"><span data-stu-id="1a109-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="1a109-251">W związku z tym, zastąpienie tak, aby <xref:System.Object.Equals%28System.Object%29> metody nie muszą wywoływać <xref:System.Object.GetType%2A> ustalenie dokładne czasu wykonywania typ każdego obiektu, ale możesz zamiast tego użyj `is` operatora w języku C# lub `TypeOf` operatora w języku Visual Basic, aby sprawdzić typ `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="1a109-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="1a109-252">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="1a109-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="1a109-253">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="1a109-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="1a109-254">Określa, czy wystąpienia określonego obiektu są uważane za równe.</span><span class="sxs-lookup"><span data-stu-id="1a109-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="1a109-255"><see langword="true" /> Jeśli obiekty są traktowane jako równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1a109-256">Jeśli oba <paramref name="objA" /> i <paramref name="objB" /> są **null**, metoda zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-257">Statyczne <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metoda wskazuje, czy dwa obiekty, `objA` i `objB`, są takie same.</span><span class="sxs-lookup"><span data-stu-id="1a109-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="1a109-258">Można również do testowania obiekty, których wartość jest **null** pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="1a109-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="1a109-259">Porównuje `objA` i `objB` pod kątem równości w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="1a109-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="1a109-260">Określa, czy dwa obiekty reprezentują ten sam odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="1a109-261">Jeśli tak, metoda zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="1a109-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="1a109-262">Ten test jest równoważne z wywoływaniem <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1a109-263">Ponadto, jeśli obie `objA` i `objB` są **null**, metoda zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="1a109-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="1a109-264">Określa, czy albo `objA` lub `objB` jest **null**.</span><span class="sxs-lookup"><span data-stu-id="1a109-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="1a109-265">Jeśli tak, zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="1a109-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="1a109-266">Jeśli dwa obiekty nie reprezentują tego samego odwołanie do obiektu i nie będzie **null**, wywoływanych przez nią `objA`.`Equals` (`objB`) i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="1a109-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="1a109-267">Oznacza to, że jeśli `objA` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, to zastąpienie.</span><span class="sxs-lookup"><span data-stu-id="1a109-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-268">W poniższym przykładzie pokazano <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metody i porównuje ją z <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-269">Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-270"><xref:System.Object.Finalize%2A> Metoda jest używana do wykonywania operacji oczyszczania niezarządzanych zasobów przechowywanych przez bieżący obiekt, zanim obiekt zostanie zniszczony.</span><span class="sxs-lookup"><span data-stu-id="1a109-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="1a109-271">Metoda jest chroniony i w związku z tym jest dostępny tylko za pomocą tej klasy lub klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="1a109-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="1a109-272">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="1a109-272">In this section:</span></span>  
  
-   [<span data-ttu-id="1a109-273">Jak działa finalizacji jest zakończona</span><span class="sxs-lookup"><span data-stu-id="1a109-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="1a109-274">Uwagi dotyczące implementacji</span><span class="sxs-lookup"><span data-stu-id="1a109-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="1a109-275">Alternatywa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="1a109-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="1a109-276">Jak działa finalizacji jest zakończona</span><span class="sxs-lookup"><span data-stu-id="1a109-276">How finalization works</span></span>  
 <span data-ttu-id="1a109-277"><xref:System.Object> Klasa udostępnia implementacji <xref:System.Object.Finalize%2A> metoda i moduł odśmiecania pamięci nie są oznaczane typów pochodnych typu <xref:System.Object> do finalizacji, chyba że zastępują one <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="1a109-278">Jeśli zastąpisz typu <xref:System.Object.Finalize%2A> metoda, moduł zbierający elementy bezużyteczne dodaje wpis dla każdego wystąpienia typu wewnętrznej struktury o nazwie Kolejka finalizacji jest zakończona.</span><span class="sxs-lookup"><span data-stu-id="1a109-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="1a109-279">Kolejka finalizacji zawiera wpisy dla wszystkich obiektów w zarządzanym stosie, którego kod finalizacji, należy uruchomić przed moduł zbierający elementy bezużyteczne mógł odzyskać pamięć.</span><span class="sxs-lookup"><span data-stu-id="1a109-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="1a109-280">Moduł zbierający elementy bezużyteczne wywołuje <xref:System.Object.Finalize%2A> metoda automatycznie w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="1a109-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="1a109-281">Po moduł zbierający elementy bezużyteczne wykrył, że obiekt jest niedostępne, chyba że obiekt została zwolniona z finalizacja przez wywołanie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="1a109-282">**W programie .NET Framework**, podczas zamykania domeny aplikacji, chyba że obiekt jest wykluczony z finalizacji jest zakończona.</span><span class="sxs-lookup"><span data-stu-id="1a109-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="1a109-283">Podczas zamykania systemu sfinalizowaniu nawet obiekty, które są nadal dostępne.</span><span class="sxs-lookup"><span data-stu-id="1a109-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="1a109-284"><xref:System.Object.Finalize%2A> zostanie automatycznie wywołana tylko raz dla danego wystąpienia, chyba że obiekt jest ponownie zarejestrowane przy użyciu mechanizmu, takiego jak <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> i <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nie została następnie wywołana metoda.</span><span class="sxs-lookup"><span data-stu-id="1a109-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="1a109-285"><xref:System.Object.Finalize%2A> operacje mają następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="1a109-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="1a109-286">Dokładny czas, kiedy uruchamia finalizatora jest niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="1a109-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="1a109-287">Aby zapewnić deterministycznego zwalniania zasobów dla wdrożenia wystąpienia klasy, `Close` metody lub podaj <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.</span><span class="sxs-lookup"><span data-stu-id="1a109-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="1a109-288">Finalizatory dwa obiekty nie ma gwarancji, uruchom w dowolnej kolejności, nawet wtedy, gdy jeden obiekt, który odwołuje się do drugiego.</span><span class="sxs-lookup"><span data-stu-id="1a109-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="1a109-289">Oznacza to jeśli obiekt A odwołuje się do obiektu B, mają finalizatory obiekt B może mieć już sfinalizowany po uruchomieniu finalizatora obiektu, A.</span><span class="sxs-lookup"><span data-stu-id="1a109-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="1a109-290">Wątek, w którym uruchamiany jest finalizator jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="1a109-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="1a109-291"><xref:System.Object.Finalize%2A> Metody może nie działać do zakończenia lub może nie działać w ogóle w następujących sytuacjach wyjątkowych:</span><span class="sxs-lookup"><span data-stu-id="1a109-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="1a109-292">Jeśli inny finalizator blokuje przez czas nieokreślony (przechodzi w pętli nieskończonej, próbuje uzyskać blokadę go może nigdy nie uzyskać i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="1a109-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="1a109-293">Ponieważ środowisko uruchomieniowe podejmie próbę uruchomienia finalizatory aż do ukończenia, inne finalizatory może nie należy wywoływać Jeśli bloki finalizator przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="1a109-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="1a109-294">Jeśli proces zakończy się bez podawania szansę, aby wyczyścić w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="1a109-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="1a109-295">W takim przypadku w środowisku uruchomieniowym pierwszego powiadomienia o zakończenie procesu jest powiadomienie komunikat DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="1a109-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="1a109-296">Środowisko wykonawcze w dalszym ciągu finalize obiektów podczas zamykania, tylko wtedy, gdy liczba obiektów, które można sfinalizować w dalszym ciągu zmniejszyć.</span><span class="sxs-lookup"><span data-stu-id="1a109-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="1a109-297">Jeśli <xref:System.Object.Finalize%2A> lub zastąpieniu obiektu <xref:System.Object.Finalize%2A> zgłasza wyjątek, który i środowisko uruchomieniowe nie jest hostowana przez aplikację, która zastępuje domyślną zasadę, środowisko uruchomieniowe kończy proces i nie aktywne `try` / `finally` bloków lub finalizatory są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="1a109-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="1a109-298">Takie zachowanie gwarantuje integralność procesu, jeśli finalizator nie bezpłatne lub niszczy zasoby.</span><span class="sxs-lookup"><span data-stu-id="1a109-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="1a109-299">Zastąpienie metody Finalize</span><span class="sxs-lookup"><span data-stu-id="1a109-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="1a109-300">Należy zastąpić <xref:System.Object.Finalize%2A> dla klasy, który używa niezarządzanych zasobów, takich jak dojścia do plików lub połączenia z bazą danych, które muszą zostać zwolnione, gdy zarządzany obiekt, który korzysta z nich jest pomijany podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="1a109-301">Nie należy implementować <xref:System.Object.Finalize%2A> metodę dla obiektów zarządzanych, ponieważ moduł odśmiecania pamięci automatycznie zwalnia zasoby zarządzane.</span><span class="sxs-lookup"><span data-stu-id="1a109-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1a109-302">Jeśli <xref:System.Runtime.InteropServices.SafeHandle> obiekt jest dostępny która umieszcza niezarządzany zasób, zalecaną alternatywą jest implementować wzorzec dispose przy użyciu bezpiecznego dojścia, a nie zastępuje <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="1a109-303">Aby uzyskać więcej informacji, zobacz [alternatywa SafeHandle](#SafeHandle) sekcji.</span><span class="sxs-lookup"><span data-stu-id="1a109-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="1a109-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> Metody nie robi nic, domyślnie, ale należy zastąpić <xref:System.Object.Finalize%2A> tylko wtedy, gdy to konieczne tylko wtedy, aby zwolnić niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="1a109-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="1a109-305">Odzyskiwanie pamięci zwykle trwać dłużej w taki sposób, jeśli operacja finalizacji jest uruchomiony, ponieważ wymaga co najmniej dwóch wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="1a109-306">Ponadto należy zastąpić <xref:System.Object.Finalize%2A> tylko typy metody dla odwołania.</span><span class="sxs-lookup"><span data-stu-id="1a109-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="1a109-307">Środowisko uruchomieniowe języka wspólnego tylko Kończenie znajdujących się w typach odwołań.</span><span class="sxs-lookup"><span data-stu-id="1a109-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="1a109-308">Ignoruje finalizatory dla typów wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="1a109-309">Zakres <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodą jest `protected`.</span><span class="sxs-lookup"><span data-stu-id="1a109-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="1a109-310">Należy zachować ten ograniczony zakres podczas zastąpienia metody w klasie.</span><span class="sxs-lookup"><span data-stu-id="1a109-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="1a109-311">Przechowując <xref:System.Object.Finalize%2A> metody chronione, można uniemożliwić użytkownikom aplikacji wywołanie obiektu <xref:System.Object.Finalize%2A> bezpośrednio metodę.</span><span class="sxs-lookup"><span data-stu-id="1a109-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="1a109-312">Każdego wykonania <xref:System.Object.Finalize%2A> w typie pochodnym, należy wywołać implementację jego typ podstawowy <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="1a109-313">Dotyczy to tylko w aplikacji, które można wywoływać kod <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="1a109-314">Obiekt <xref:System.Object.Finalize%2A> — metoda nie należy wywoływać metody obiektów innych niż jej klasa bazowa obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="1a109-315">Jest tak, ponieważ inne wywołania obiektów mogą być kolekcjonowane w tym samym czasie, co obiekt wywołujący, tak jak w przypadku zamknięcia środowiska uruchomieniowego języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="1a109-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="1a109-316">Kompilator języka C# nie zezwala na zastąpienie <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="1a109-317">Zamiast tego należy dostarczyć finalizator implementując [destruktor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) dla swojej klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="1a109-318">C# destruktor automatycznie wywołuje destruktor klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="1a109-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="1a109-319">Visual C++ również ma własną składnię implementowania <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="1a109-320">Aby uzyskać więcej informacji, zobacz sekcję "Destruktory i finalizatory" [jak: Definiowanie oraz stosowanie klas i struktur (C++sposób niezamierzony)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="1a109-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="1a109-321">Wyrzucanie elementów bezużytecznych jest deterministyczna, nie wiadomo dokładnie, gdy moduł zbierający elementy bezużyteczne wykonuje finalizacji.</span><span class="sxs-lookup"><span data-stu-id="1a109-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="1a109-322">Aby zwolnić zasoby natychmiast, możesz również wdrożyć [](~/docs/standard/garbage-collection/implementing-dispose.md) wzorzec dispose i <xref:System.IDisposable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1a109-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose .md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="1a109-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementacja może być wywoływany przez konsumentów klasy do zwalniania niezarządzanych zasobów, a następnie można użyć <xref:System.Object.Finalize%2A> metody do zwalniania niezarządzanych zasobów w przypadku gdy <xref:System.IDisposable.Dispose%2A> nie jest wywoływana metoda.</span><span class="sxs-lookup"><span data-stu-id="1a109-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="1a109-324"><xref:System.Object.Finalize%2A> może potrwać niemal wszystkich akcji, w tym resurrecting obiektu (który jest dzięki czemu obiekt dostępne ponownie), po jego został oczyszczony podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="1a109-325">Jednak obiekt można tylko można aktywowanych raz; <xref:System.Object.Finalize%2A> nie można wywołać aktywowanych obiektów podczas wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="1a109-326">Istnieje jedna akcja, implementacja <xref:System.Object.Finalize%2A> nigdy nie powinna przyjmować: nie należy nigdy nie zgłaszają wyjątek.</span><span class="sxs-lookup"><span data-stu-id="1a109-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="1a109-327">Jeśli wyjątki zgłaszane przez metody wywoływane z <xref:System.Object.Finalize%2A> metody jest nieobsługiwany przez <xref:System.Object.Finalize%2A> metody, środowisko uruchomieniowe zakłada się, że <xref:System.Object.Finalize%2A> metoda zwracane i wywoływanie w dalszym ciągu <xref:System.Object.Finalize%2A> metod innych obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="1a109-328">Alternatywa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="1a109-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="1a109-329">Często jest trudne, tworzenia niezawodnych finalizatory, ponieważ nie może wprowadzać założenia dotyczące stanu aplikacji i nieobsługiwane wyjątki systemowe, takie jak <xref:System.OutOfMemoryException> i <xref:System.StackOverflowException> zakończyć finalizatora.</span><span class="sxs-lookup"><span data-stu-id="1a109-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="1a109-330">A nie Implementowanie finalizatorów dla swojej klasy, aby zwolnić zasoby niezarządzane, można użyć obiektu, który jest tworzony na podstawie <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> klasy do opakowania niezarządzanych zasobów, a następnie implementować wzorzec dispose bez finalizatorów.</span><span class="sxs-lookup"><span data-stu-id="1a109-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="1a109-331">Program .NET Framework zawiera następujące klasy w <xref:Microsoft.Win32?displayProperty=nameWithType> przestrzeni nazw, które są uzyskiwane z <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="1a109-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="1a109-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> jest to klasa otoki dla dojścia do pliku.</span><span class="sxs-lookup"><span data-stu-id="1a109-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="1a109-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> jest to klasa otoki dla dojścia do plików mapowanych na pamięć.</span><span class="sxs-lookup"><span data-stu-id="1a109-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="1a109-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> jest to klasa otoki dla wskaźnika do bloku niezarządzanej pamięci.</span><span class="sxs-lookup"><span data-stu-id="1a109-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="1a109-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> są klas otoki uchwyty kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="1a109-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="1a109-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> jest to klasa otoki dla potoku dojść.</span><span class="sxs-lookup"><span data-stu-id="1a109-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="1a109-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> jest to klasa otoki dla dojścia do klucza rejestru.</span><span class="sxs-lookup"><span data-stu-id="1a109-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="1a109-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> jest to klasa otoki dla dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="1a109-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="1a109-339">W poniższym przykładzie użyto [wzorca usuwania](~/docs/standard/garbage-collection/implementing-dispose.md) przy użyciu bezpiecznego dojścia, zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-339">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="1a109-340">Definiuje `FileAssociation` klasę, która otacza rejestru informacji o aplikacji, która obsługuje pliki z rozszerzeniem określonego pliku.</span><span class="sxs-lookup"><span data-stu-id="1a109-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="1a109-341">Obsługuje dwa rejestru zwracane jako `out` parametry Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) wywołania funkcji są przekazywane do <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="1a109-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="1a109-342">Typ użytkownika chronionych `Dispose` następnie wywołuje metodę `SafeRegistryHandle.Dispose` bezpłatne uchwyty te dwie metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="1a109-343">Poniższy przykład sprawdza, czy <xref:System.Object.Finalize%2A> metoda jest wywoływana, gdy obiekt, który zastępuje <xref:System.Object.Finalize%2A> zostanie zniszczony.</span><span class="sxs-lookup"><span data-stu-id="1a109-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="1a109-344">Należy zauważyć, że w przypadku aplikacji produkcyjnej <xref:System.Object.Finalize%2A> metoda może zostać zastąpiona w celu zwolnić niezarządzane zasoby utrzymywane przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="1a109-345">Należy również zauważyć, że przykład C# zawiera destruktor zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="1a109-346">Na przykład dodatkowych, która zastępuje <xref:System.Object.Finalize%2A> metody, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-347">Służy jako domyślnej funkcji skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-347">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="1a109-348">Kod skrótu bieżącego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-348">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-349">Wartość skrótu jest wartością liczbową, który służy do wstawiania i zidentyfikować obiektu w kolekcji bazujących na skrótach, takich jak <xref:System.Collections.Generic.Dictionary%602> klasy <xref:System.Collections.Hashtable> klasy lub typ pochodzący od <xref:System.Collections.DictionaryBase> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="1a109-350"><xref:System.Object.GetHashCode%2A> Metoda udostępnia ten kod skrótu dla algorytmów, wymagających szybkiej kontroli równość obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a109-351">Aby uzyskać informacje o używaniu kody skrótów w tabelach wyznaczania wartości skrótu i niektóre dodatkowe kod skrótu, zobacz [funkcji skrótu](https://en.wikipedia.org/wiki/Hash_function) wpisu w witrynie Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="1a109-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="1a109-352">Dwa obiekty, które są równe zwracany skrótu, które są równe.</span><span class="sxs-lookup"><span data-stu-id="1a109-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="1a109-353">Jednakże, odwrotna sytuacja nie jest wartość true: kody skrótów równy oznacza równość obiektu, ponieważ różnych obiektów (nierówne) mogą mieć identycznych skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="1a109-354">Ponadto, .NET Framework nie gwarantuje domyślna Implementacja klasy <xref:System.Object.GetHashCode%2A> metody i wartości, Metoda ta zwraca może różnić się od wersji programu .NET Framework i platformach, takich jak platformy 32-bitowych i 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="1a109-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="1a109-355">Z tego względu nie należy używać Domyślna implementacja tej metody jako identyfikator obiektu unikatowe potrzeby wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="1a109-356">Dwie konsekwencje postępuj zgodnie z tym:</span><span class="sxs-lookup"><span data-stu-id="1a109-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="1a109-357">Nie należy zakładać, że kody mieszania równy implikują równość obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="1a109-358">Nigdy nie należy utrwalić lub użyć skrótu spoza domeny aplikacji, w której został utworzony, ponieważ ten sam obiekt może wyznaczania wartości skrótu w domenach aplikacji, procesy i platform.</span><span class="sxs-lookup"><span data-stu-id="1a109-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="1a109-359">Wartość skrótu jest przeznaczona dla wydajne wstawiania i lookup w kolekcji, które są oparte na tabelę mieszania.</span><span class="sxs-lookup"><span data-stu-id="1a109-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="1a109-360">Wartość skrótu nie jest stałe wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="1a109-361">Z tego powodu:</span><span class="sxs-lookup"><span data-stu-id="1a109-361">For this reason:</span></span>  
>   
> -   <span data-ttu-id="1a109-362">Nie serializacji wartości Kod skrótu lub przechowywać je w bazach danych.</span><span class="sxs-lookup"><span data-stu-id="1a109-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="1a109-363">Nie należy używać skrótu jako klucza można pobrać obiektu z kluczem kolekcji.</span><span class="sxs-lookup"><span data-stu-id="1a109-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="1a109-364">Nie wysyłaj kody skrótów między domenami aplikacji lub procesów.</span><span class="sxs-lookup"><span data-stu-id="1a109-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="1a109-365">W niektórych przypadkach kody skrótów mogą być obliczone na podstawie domeny na proces lub poszczególnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="1a109-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="1a109-366">Nie należy używać skrótu zamiast wartości zwracane przez kryptograficznych funkcji skrótu, jeśli potrzebujesz silną kryptograficznie wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="1a109-367">Klasy pochodzącej od użytku skróty kryptograficzne <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="1a109-368">Nie należy testować pod kątem równości kodów wartości skrótu, aby ustalić, czy dwa obiekty są takie same.</span><span class="sxs-lookup"><span data-stu-id="1a109-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="1a109-369">(Nierówne obiekty mogą mieć identycznych skrótu). Aby przetestować pod kątem równości, należy wywołać <xref:System.Object.ReferenceEquals%2A> lub <xref:System.Object.Equals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="1a109-370"><xref:System.Object.GetHashCode%2A> Metoda może być zastąpiona przez typ pochodny.</span><span class="sxs-lookup"><span data-stu-id="1a109-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="1a109-371">Jeśli <xref:System.Object.GetHashCode%2A> jest nie ich nadpisano, kody skrótów dla typów referencyjnych są obliczane przez wywołanie metody <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metoda klasy bazowej, które oblicza wartość skrótu oparta na odwołanie do obiektu; Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a109-372">Innymi słowy, dwóch obiektów, dla których <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` mają identyczne skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="1a109-373">W przypadku typów wartości nie zastępują <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metody klasy bazowej używa odbicia, aby obliczyć wartość skrótu na podstawie wartości pól typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="1a109-374">Innymi słowy typy wartości, których pola mają równe wartości mają równe skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="1a109-375">Aby uzyskać więcej informacji o zastępowanie <xref:System.Object.GetHashCode%2A>, zobacz sekcję "Uwagi dotyczące dziedziczenia".</span><span class="sxs-lookup"><span data-stu-id="1a109-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="1a109-376">Jeśli zastąpisz <xref:System.Object.GetHashCode%2A> metody, należy również zastąpić <xref:System.Object.Equals%2A>i na odwrót.</span><span class="sxs-lookup"><span data-stu-id="1a109-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="1a109-377">Jeśli Twoje zastąpione <xref:System.Object.Equals%2A> metoda zwraca `true` po dwa obiekty są sprawdzane pod kątem równości, Twoje zastąpione <xref:System.Object.GetHashCode%2A> metoda musi zwracać taką samą wartość dla dwóch obiektów.</span><span class="sxs-lookup"><span data-stu-id="1a109-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="1a109-378">Jeśli obiekt, który jest używany jako klucz w tabeli wyznaczania wartości skrótu nie udostępnia przydatne implementacji <xref:System.Object.GetHashCode%2A>, można określić dostawcy kodu wyznaczania wartości skrótu, podając <xref:System.Collections.IEqualityComparer> implementacji do jednego z przeciążeń <xref:System.Collections.Hashtable> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="1a109-379">Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1a109-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="1a109-380">Gdy wywołujesz <xref:System.Object.GetHashCode%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="1a109-381">Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="1a109-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="1a109-382">Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a aktualnie nie implementują <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="1a109-383">Jednak wydają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.</span><span class="sxs-lookup"><span data-stu-id="1a109-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="1a109-384">klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.GetHashCode%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-384">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-385">Jedną z najprostszych sposobów obliczyć wartość skrótu dla wartość liczbowa, która ma taką samą lub mniejszym zakresie niż <xref:System.Int32> typu jest po prostu zwraca tę wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="1a109-386">W poniższym przykładzie pokazano implementację dla `Number` struktury.</span><span class="sxs-lookup"><span data-stu-id="1a109-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="1a109-387">Często typ ma wiele pól danych, które mogą należeć do generowania kodu wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="1a109-388">Jednym ze sposobów, aby wygenerować wartość skrótu jest połączyć te pola w programie `XOR (eXclusive OR)` operacji, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="1a109-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="1a109-389">Poprzedni przykład zwraca tę samą wartość skrótu dla (n1, n2) i (n2 n1), a więc może generować kolizji więcej niż jest to pożądane.</span><span class="sxs-lookup"><span data-stu-id="1a109-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="1a109-390">Dostępnych jest kilka rozwiązań, tak, aby kody skrótów w takiej sytuacji nie są identyczne.</span><span class="sxs-lookup"><span data-stu-id="1a109-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="1a109-391">Jeden jest przywrócenie skrótu `Tuple` obiekt, który odzwierciedla kolejność każdego pola.</span><span class="sxs-lookup"><span data-stu-id="1a109-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="1a109-392">W poniższym przykładzie pokazano możliwą implementację, która używa <xref:System.Tuple%602> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="1a109-393">Pamiętaj jednak, obciążenie związane z wystąpienia `Tuple` obiektu znacznie może mieć wpływ na ogólną wydajność aplikacji, która przechowuje dużą liczbę obiektów w tabelach wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="1a109-394">Drugie rozwiązanie alternatywne obejmuje wagi kody skrótów poszczególnych przez po lewej stronie przesunięcie kody skrótów kolejnych pól za pomocą liczby bitów dwóch lub więcej.</span><span class="sxs-lookup"><span data-stu-id="1a109-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="1a109-395">Optymalnie zamiast zostanie odrzucony, bity przesunięte poza bit 31 zawijania wokół zamiast odrzucone.</span><span class="sxs-lookup"><span data-stu-id="1a109-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="1a109-396">Ponieważ bity są odrzucane przez operatorów przesunięcia w lewo w językach C# i Visual Basic, wymaga to tworzenia po lewej stronie metoda shift i zawijania podobne do następującego:</span><span class="sxs-lookup"><span data-stu-id="1a109-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="1a109-397">W poniższym przykładzie użyto następnie ta metoda shift i zawijania do obliczenia kodu wartości skrótu `Point` struktury używanych w poprzednich przykładach.</span><span class="sxs-lookup"><span data-stu-id="1a109-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1a109-398">Funkcję mieszania umożliwia szybkie generowanie numer (skrótu), która odpowiada wartości obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-398">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="1a109-399">Funkcje wyznaczania wartości skrótu są zazwyczaj specyficzne dla każdego typu i aby zapewnić unikatowość, należy użyć co najmniej jedno z pól wystąpienia jako dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="1a109-399">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="1a109-400">Kody skrótów nie powinien można obliczyć przy użyciu wartości pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="1a109-400">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="1a109-401">Dla klasy pochodne <see cref="T:System.Object" />, <see langword="GetHashCode" /> delegować metody do klasy bazowej <see cref="M:System.Object.GetHashCode" /> implementację tylko wtedy, gdy klasa pochodna definiuje równości jako równości odwołań.</span><span class="sxs-lookup"><span data-stu-id="1a109-401">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="1a109-402">Domyślna implementacja klasy <see cref="M:System.Object.GetHashCode" /> dla odwołania do typów zwraca wartość skrótu, który jest odpowiednikiem ten, który został zwrócony przez <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-402">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="1a109-403">Można zastąpić <see cref="M:System.Object.GetHashCode" /> dla typów odwołań niezmienne.</span><span class="sxs-lookup"><span data-stu-id="1a109-403">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="1a109-404">Ogólnie rzecz biorąc, aby uzyskać modyfikowalnych typów referencyjnych, należy zastąpić <see cref="M:System.Object.GetHashCode" /> tylko wtedy, gdy:</span><span class="sxs-lookup"><span data-stu-id="1a109-404">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="1a109-405">— Można obliczyć skrótu z pól, które nie są modyfikowalną; lub</span><span class="sxs-lookup"><span data-stu-id="1a109-405">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="1a109-406">— Można zagwarantować, że wartość skrótu dla obiektu modyfikowalnego nie zmienia się, gdy obiekt jest zawarty w kolekcji, która zależy od jego kod skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-406">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="1a109-407">W przeciwnym razie może się wydawać, że w tabeli wyznaczania wartości skrótu są tracone obiektu modyfikowalnego.</span><span class="sxs-lookup"><span data-stu-id="1a109-407">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="1a109-408">Jeśli chcesz przesłonić <see cref="M:System.Object.GetHashCode" /> dla modyfikowalnego typu referencyjnego, z dokumentacją powinien ułatwiają Wyczyść, że użytkownicy tego typu nie należy modyfikować wartości obiektu, gdy obiekt jest przechowywany w tabeli wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-408">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="1a109-409">Dla typów wartości <see cref="M:System.ValueType.GetHashCode" /> udostępnia domyślną implementację kodu wyznaczania wartości skrótu, który używa odbicia.</span><span class="sxs-lookup"><span data-stu-id="1a109-409">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="1a109-410">Należy rozważyć przesłanianie go w celu zapewnienia lepszej wydajności.</span><span class="sxs-lookup"><span data-stu-id="1a109-410">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="1a109-411">Aby uzyskać więcej informacji i przykładów, które może obliczyć kodów skrótu w na różne sposoby zobacz sekcję przykłady.</span><span class="sxs-lookup"><span data-stu-id="1a109-411">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="1a109-412">Funkcja wyznaczania wartości skrótu musi mieć następujące właściwości:</span><span class="sxs-lookup"><span data-stu-id="1a109-412">A hash function must have the following properties:</span></span> 
<span data-ttu-id="1a109-413">— Jeśli dwa obiekty porównać jako równe, <see cref="M:System.Object.GetHashCode" /> metoda dla każdego obiektu musi zwrócić tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-413">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="1a109-414">Jednakże, jeśli dwa obiekty nie porównują jako równe, <see cref="M:System.Object.GetHashCode" /> metody dwa obiekty nie muszą zwracać różne wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-414">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="1a109-415"><see cref="M:System.Object.GetHashCode" /> Metodę obiektu spójnie musi zwracać taki sam skrótu tak długo, jak nie ma żadnych modyfikacji stanu obiektu, który określa wartość zwracaną obiektu [element System.Object.Equals](xref:System.Object.Equals*) metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-415">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="1a109-416">Należy pamiętać, że ta zasada obowiązuje tylko w przypadku wykonywania bieżącej aplikacji i że różnych skrótu mogą zostać zwrócone, jeśli aplikacja jest uruchamiana ponownie.</span><span class="sxs-lookup"><span data-stu-id="1a109-416">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="1a109-417">-Aby uzyskać najlepszą wydajność funkcja wyznaczania wartości skrótu powinien wygenerować równomiernego rozłożenia dla wszystkich danych wejściowych, włącznie z danych wejściowych, który jest w dużym stopniu klastrze.</span><span class="sxs-lookup"><span data-stu-id="1a109-417">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="1a109-418">Użycie tego możliwa jest niewielkie modyfikacje do stanu obiektu powinno spowodować duże modyfikacje wynikowy skrótu, aby uzyskać najlepszą wydajność tabeli wyznaczania wartości skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-418">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="1a109-419">— Funkcje skrótu powinny być tanie do obliczenia.</span><span class="sxs-lookup"><span data-stu-id="1a109-419">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="1a109-420"><see cref="M:System.Object.GetHashCode" /> Metoda nie powinna zgłaszać wyjątków.</span><span class="sxs-lookup"><span data-stu-id="1a109-420">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="1a109-421">Na przykład implementacji <see cref="M:System.String.GetHashCode" /> metody dostarczone przez <see cref="T:System.String" /> Klasa zwraca kody skrótów identyczne dla identyczne ciągi.</span><span class="sxs-lookup"><span data-stu-id="1a109-421">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="1a109-422">W związku z tym, dwa <see cref="T:System.String" /> obiektów zwraca tę samą wartość skrótu, jeśli stanowią one taką samą wartość ciągu.</span><span class="sxs-lookup"><span data-stu-id="1a109-422">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="1a109-423">Ponadto metoda używa wszystkich znaków w ciągu do generowania rozsądnie losowo rozproszonych danych wyjściowych, nawet wtedy, gdy dane wejściowe działa w klastrze w określonych zakresach (na przykład wielu użytkowników może być ciągi, które zawierają tylko niższe 128 znaków ASCII, nawet jeśli ciąg może zawierać znaków Unicode 65 535).</span><span class="sxs-lookup"><span data-stu-id="1a109-423">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="1a109-424">Zapewnianie funkcji skrótu dobre dla klasy, można znacznie wpłynąć na wydajność dodanie tych obiektów do tabeli mieszania.</span><span class="sxs-lookup"><span data-stu-id="1a109-424">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="1a109-425">W tabeli skrótów przy użyciu kluczy, które zapewniają dobrą implementację funkcji skrótu Wyszukiwanie elementu czasochłonne stałych (na przykład jest operacją O(1)).</span><span class="sxs-lookup"><span data-stu-id="1a109-425">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="1a109-426">W tabeli wyznaczania wartości skrótu z niską implementację funkcji mieszania, wydajność wyszukiwania zależy od liczby elementów w tablicy skrótów (na przykład O (`n`) operacji, gdzie `n` jest liczba elementów w tablicy skrótów).</span><span class="sxs-lookup"><span data-stu-id="1a109-426">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="1a109-427">Złośliwy użytkownik może wpisać danych, która zwiększa liczbę konfliktów, które mogłoby znacznie pogorszyć wydajność aplikacji, które są zależne od tabel skrótów, w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="1a109-427">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="1a109-428">— W przypadku funkcji mieszania powodować częste kolizji.</span><span class="sxs-lookup"><span data-stu-id="1a109-428">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="1a109-429">— W przypadku duża część obiektów w tablicy skrótów generuje kody skrótów, które są równe lub około równa się ze sobą.</span><span class="sxs-lookup"><span data-stu-id="1a109-429">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="1a109-430">— W przypadku użytkowników wprowadzania danych, z którego jest obliczana wartość skrótu.</span><span class="sxs-lookup"><span data-stu-id="1a109-430">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="1a109-431">Pochodne klasy, które zastępują <see cref="M:System.Object.GetHashCode" /> jest również przesłonięcie <see cref="M:System.Object.Equals(System.Object)" /> celu zagwarantowania, że dwa obiekty uważane za równe mają tę samą wartość skrótu; w przeciwnym razie <see cref="T:System.Collections.Hashtable" /> typu mogą nie działać poprawnie.</span><span class="sxs-lookup"><span data-stu-id="1a109-431">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-432">Pobiera <see cref="T:System.Type" /> bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-432">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="1a109-433">Typ środowiska uruchomieniowego dokładnie bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-433">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-434">Ponieważ <xref:System.Object?displayProperty=nameWithType> jest klasą bazową dla wszystkich typów w systemie typów środowiska .NET Framework, <xref:System.Object.GetType%2A> metoda może służyć do zwrócenia <xref:System.Type> obiekty reprezentujące wszystkie typy .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1a109-434">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="1a109-435">.NET Framework rozpoznaje następujących pięć kategorii typów:</span><span class="sxs-lookup"><span data-stu-id="1a109-435">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="1a109-436">Klasy, które są uzyskiwane z <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="1a109-436">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="1a109-437">Typy, które są uzyskiwane z wartości <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-437">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="1a109-438">Interfejsy, które są uzyskiwane z <xref:System.Object?displayProperty=nameWithType> począwszy od programu .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="1a109-438">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="1a109-439">Wyliczenia, które są uzyskiwane z <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-439">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="1a109-440">Delegatów, które są uzyskiwane z <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-440">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1a109-441">Dla dwóch obiektów `x` i `y` mają identyczne środowisko uruchomieniowe typów, `Object.ReferenceEquals(x.GetType(),y.GetType())` zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="1a109-441">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="1a109-442">W poniższym przykładzie użyto <xref:System.Object.GetType%2A> metody z <xref:System.Object.ReferenceEquals%2A> metodę, aby określić, czy jedną wartość liczbową, jest taki sam jak dwóch wartości liczbowych.</span><span class="sxs-lookup"><span data-stu-id="1a109-442">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="1a109-443">Aby ustalić, czy obiekt jest określonego typu, można użyć słowa kluczowego porównanie typ danego języka lub konstruowania.</span><span class="sxs-lookup"><span data-stu-id="1a109-443">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="1a109-444">Na przykład, można użyć `TypeOf…Is` konstruowania w języku Visual Basic lub `is` — słowo kluczowe w języku C#.</span><span class="sxs-lookup"><span data-stu-id="1a109-444">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="1a109-445"><xref:System.Object.GetType%2A> Metoda jest dziedziczona przez wszystkie typy, które wynikają z <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1a109-445">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="1a109-446">Oznacza to, że oprócz przy użyciu własnego języka porównania — słowo kluczowe, można użyć <xref:System.Object.GetType%2A> metodę pozwala ustalić typ określonego obiektu, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="1a109-446">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="1a109-447"><xref:System.Type> Obiekt udostępnia metadane skojarzone z klasą bieżącego <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1a109-447">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-448">Poniższy przykład kodu pokazuje, że <xref:System.Object.GetType%2A> zwraca typ środowiska uruchomieniowego bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-448">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-449">Tworzy płytką kopię bieżącego <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-449">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="1a109-450">Płytką kopię bieżącego <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-450">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-451"><xref:System.Object.MemberwiseClone%2A> Metoda tworzy płytką kopię przez utworzenie nowego obiektu, a następnie skopiować niestatycznego pola bieżącego obiektu do nowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-451">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="1a109-452">Jeśli pole jest typem wartości, bit przez bitowy kopię pole jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="1a109-452">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="1a109-453">Jeśli pole jest typem referencyjnym, odwołanie jest kopiowane, ale przywoływanego obiektu jest; w związku z tym oryginalny obiekt i jego klon odwołują się do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-453">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="1a109-454">Rozważmy na przykład obiekt o nazwie X, który odwołuje się do obiektów, A i B. obiekt B, z kolei odwołania do obiektu C. Kopia pobieżna X tworzy nowy obiekt X2, który odwołuje się obiektów, A i B. Z kolei kopię głęboką X tworzy nowy obiekt X2, który odwołuje się do nowych obiektów A2 i B2, które są kopiami A i B. B2, z kolei odwołuje się do nowego obiektu C2, który jest kopią C. W przykładzie pokazano różnicę między produkowanymi i operacji głębokiego kopiowania.</span><span class="sxs-lookup"><span data-stu-id="1a109-454">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="1a109-455">Istnieje wiele sposobów implementowania operacji głębokiego kopiowania, jeśli operacja płytka kopia wykonana przez <xref:System.Object.MemberwiseClone%2A> metody nie spełnia Twoich potrzeb.</span><span class="sxs-lookup"><span data-stu-id="1a109-455">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="1a109-456">Należą do nich między innymi:</span><span class="sxs-lookup"><span data-stu-id="1a109-456">These include the following:</span></span>  
  
-   <span data-ttu-id="1a109-457">Wywołanie konstruktora klasy obiektu do skopiowania, aby utworzyć drugi obiekt z wartości właściwości pobrane z pierwszego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-457">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="1a109-458">Przy założeniu, że wartości obiektu są całkowicie zdefiniowane przez jej konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-458">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="1a109-459">Wywołaj <xref:System.Object.MemberwiseClone%2A> metody do tworzenia płytkiej kopi obiektu, a następnie przypisz nowe obiekty, których wartości są takie same jak oryginalnego obiektu właściwości lub pól, których wartości są typami odwołań.</span><span class="sxs-lookup"><span data-stu-id="1a109-459">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="1a109-460">`DeepCopy` To podejście pokazano metody w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="1a109-460">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="1a109-461">Serializacji obiektu jako głębokie, skopiować, a następnie przywróć dane serializowane, zmiennej innego obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-461">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="1a109-462">Za pomocą odbicia rekursji do wykonania tej operacji głęboka kopia.</span><span class="sxs-lookup"><span data-stu-id="1a109-462">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-463">W poniższym przykładzie pokazano <xref:System.Object.MemberwiseClone%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-463">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="1a109-464">Definiuje on `ShallowCopy` metodę, która wywołuje <xref:System.Object.MemberwiseClone%2A> metody, które można wykonać operacji płytka kopia na `Person` obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-464">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="1a109-465">Umożliwia on również definiowanie `DeepCopy` metody, która wykonuje operację głęboka kopia `Person` obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-465">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="1a109-466">W tym przykładzie `Person.IdInfo` właściwość zwraca `IdInfo` obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-466">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="1a109-467">Jako dane wyjściowe w przykładzie pokazano gdy `Person` obiekt został sklonowany, wywołując <xref:System.Object.MemberwiseClone%2A> metody, sklonowany `Person` obiekt jest niezależne kopię oryginalnego obiektu, z tą różnicą, że mogą współużytkować ten sam `Person.IdInfo` odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-467">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="1a109-468">W rezultacie, modyfikując klonu `Person.IdInfo` właściwość zmienia oryginalnego obiektu `Person.IdInfo` właściwości.</span><span class="sxs-lookup"><span data-stu-id="1a109-468">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="1a109-469">Z drugiej strony, gdy operacja głęboka kopia jest wykonywana, sklonowany `Person` obiektu, łącznie z jego `Person.IdInfo` właściwość, może być modyfikowana bez wywierania wpływu na oryginalny obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-469">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="1a109-470">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="1a109-470">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="1a109-471">Drugi obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="1a109-471">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="1a109-472">Określa, czy określony <see cref="T:System.Object" /> wystąpienia są tego samego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-472">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="1a109-473"><see langword="true" /> Jeśli <paramref name="objA" /> jest tego samego wystąpienia co <paramref name="objB" /> lub jeśli obie są **null**; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a109-473"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-474">W odróżnieniu od <xref:System.Object.Equals%2A> metody i operator równości <xref:System.Object.ReferenceEquals%2A> metoda nie może zostać zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="1a109-474">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="1a109-475">W związku z tym, jeśli chcesz przetestować dwa obiektu odwołania pod kątem równości i wiesz o implementacji `Equals` metodę można wywołać <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-475">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="1a109-476">Jednakże wartość zwracana przez <xref:System.Object.ReferenceEquals%2A> metoda może być wyświetlana nietypowe w przypadku tych dwóch scenariuszy:</span><span class="sxs-lookup"><span data-stu-id="1a109-476">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="1a109-477">Podczas porównywania typów wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-477">When comparing value types.</span></span> <span data-ttu-id="1a109-478">Jeśli `objA` i `objB` są typami wartości muszą być zapakowany przed przekazaniem ich do <xref:System.Object.ReferenceEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-478">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1a109-479">Oznacza to, że jeśli oba `objA` i `objB` reprezentują tego samego wystąpienia typu wartości <xref:System.Object.ReferenceEquals%2A> metoda niemniej zwraca `false`, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="1a109-479">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="1a109-480">Instrukcje dotyczące konwersji boxing typów wartości, zobacz [opakowywanie i rozpakowywanie](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="1a109-480">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="1a109-481">Podczas porównywania ciągów.</span><span class="sxs-lookup"><span data-stu-id="1a109-481">When comparing strings.</span></span> <span data-ttu-id="1a109-482">Jeśli `objA` i `objB` są ciągami, <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` Jeśli ciąg jest interned.</span><span class="sxs-lookup"><span data-stu-id="1a109-482">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="1a109-483">Nie wykonuje test pod kątem równości wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-483">It does not perform a test for value equality.</span></span>  <span data-ttu-id="1a109-484">W poniższym przykładzie `s1` i `s2` są takie same, ponieważ są one dwa wystąpienia jednego ciągu interned.</span><span class="sxs-lookup"><span data-stu-id="1a109-484">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="1a109-485">Jednak `s3` i `s4` nie są takie same, ponieważ mimo że mają identyczne ciągi, ten ciąg nie jest interned.</span><span class="sxs-lookup"><span data-stu-id="1a109-485">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="1a109-486">Aby uzyskać więcej informacji na temat wewnętrzne przygotowanie ciągu zobacz <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-486">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a109-487">W poniższym przykładzie użyto <xref:System.Object.ReferenceEquals%2A> można sprawdzić, czy dwa obiekty są tego samego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-487">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a109-488">Zwraca ciąg, który reprezentuje bieżący obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-488">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="1a109-489">Ciąg, który reprezentuje bieżący obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-489">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a109-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> Trwa głównej formatowanie metody .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1a109-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="1a109-491">Konwertuje obiekt na jego reprezentację ciągu tak, że nadaje się do wyświetlania.</span><span class="sxs-lookup"><span data-stu-id="1a109-491">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="1a109-492">(Aby uzyskać informacji na temat formatowania pomocy technicznej w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).) Domyślne implementacje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca w pełni kwalifikowaną nazwę typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-492">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1a109-493">Osiągnięto tę stronę, klikając łącze z listy członków innego typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-493">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="1a109-494">Wynika to z tego typu nie zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-494">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a109-495">Zamiast tego dziedziczy funkcje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-495">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1a109-496">Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w celu zapewnienia bardziej odpowiednie reprezentację ciągu określonego typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-496">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="1a109-497">Typy również często przeciążenia <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w celu zapewnienia obsługi ciągów formatu lub formatowania kultury.</span><span class="sxs-lookup"><span data-stu-id="1a109-497">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="1a109-498">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="1a109-498">In this section:</span></span>  
  
 <span data-ttu-id="1a109-499">[Domyślną metodą Object.ToString()](#Default) </span><span class="sxs-lookup"><span data-stu-id="1a109-499">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="1a109-500">[Zastępowanie metody Object.ToString()](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="1a109-500">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="1a109-501">[Przeciążenie metody ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="1a109-501">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="1a109-502">[Rozszerzanie metoda Object.ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="1a109-502">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="1a109-503">Uwagi dotyczące środowiska uruchomieniowego Windows</span><span class="sxs-lookup"><span data-stu-id="1a109-503">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="1a109-504">Domyślną metodą Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="1a109-504">The default Object.ToString() method</span></span>  
 <span data-ttu-id="1a109-505">Domyślna implementacja klasy <xref:System.Object.ToString%2A> metoda zwraca w pełni kwalifikowaną nazwę typu <xref:System.Object>, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="1a109-505">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="1a109-506">Ponieważ <xref:System.Object> jest klasą bazową dla wszystkich typów odniesienia w .NET Framework to zachowanie jest dziedziczone przez typy odwołań, które nie zastępują <xref:System.Object.ToString%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-506">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="1a109-507">Ilustruje to poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="1a109-507">The following example illustrates this.</span></span> <span data-ttu-id="1a109-508">Definiuje klasę o nazwie `Object1` akceptujący Domyślna implementacja wszystkich <xref:System.Object> elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="1a109-508">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="1a109-509">Jego <xref:System.Object.ToString%2A> metoda zwraca obiekt w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-509">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="1a109-510">Zastępowanie metody Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="1a109-510">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="1a109-511">Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg, który reprezentuje wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-511">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="1a109-512">Na przykład podstawowa typy takie jak <xref:System.Char>, <xref:System.Int32>, i <xref:System.String> zapewniają <xref:System.Object.ToString%2A> implementacji, które zwracają postaci ciągu, wartości, który reprezentuje obiekt.</span><span class="sxs-lookup"><span data-stu-id="1a109-512">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="1a109-513">W poniższym przykładzie zdefiniowano klasę, `Object2`, która zastępuje <xref:System.Object.ToString%2A> metodę, aby zwrócić nazwę typu, wraz z jego wartość.</span><span class="sxs-lookup"><span data-stu-id="1a109-513">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="1a109-514">Poniższa tabela zawiera listę kategorii typów w programie .NET Framework i wskazuje, czy nie zastępują one <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-514">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="1a109-515">Kategoria typów</span><span class="sxs-lookup"><span data-stu-id="1a109-515">Type category</span></span>|<span data-ttu-id="1a109-516">Zastępuje Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="1a109-516">Overrides Object.ToString()</span></span>|<span data-ttu-id="1a109-517">Zachowanie</span><span class="sxs-lookup"><span data-stu-id="1a109-517">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="1a109-518">Class</span><span class="sxs-lookup"><span data-stu-id="1a109-518">Class</span></span>|<span data-ttu-id="1a109-519">n/d</span><span class="sxs-lookup"><span data-stu-id="1a109-519">n/a</span></span>|<span data-ttu-id="1a109-520">n/d</span><span class="sxs-lookup"><span data-stu-id="1a109-520">n/a</span></span>|  
|<span data-ttu-id="1a109-521">Struktura</span><span class="sxs-lookup"><span data-stu-id="1a109-521">Structure</span></span>|<span data-ttu-id="1a109-522">Tak (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="1a109-522">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="1a109-523">Takie same jak Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="1a109-523">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="1a109-524">Wyliczenie</span><span class="sxs-lookup"><span data-stu-id="1a109-524">Enumeration</span></span>|<span data-ttu-id="1a109-525">Tak (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="1a109-525">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="1a109-526">Nazwa elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="1a109-526">The member name</span></span>|  
|<span data-ttu-id="1a109-527">Interface</span><span class="sxs-lookup"><span data-stu-id="1a109-527">Interface</span></span>|<span data-ttu-id="1a109-528">Nie</span><span class="sxs-lookup"><span data-stu-id="1a109-528">No</span></span>|<span data-ttu-id="1a109-529">n/d</span><span class="sxs-lookup"><span data-stu-id="1a109-529">n/a</span></span>|  
|<span data-ttu-id="1a109-530">Delegate</span><span class="sxs-lookup"><span data-stu-id="1a109-530">Delegate</span></span>|<span data-ttu-id="1a109-531">Nie</span><span class="sxs-lookup"><span data-stu-id="1a109-531">No</span></span>|<span data-ttu-id="1a109-532">n/d</span><span class="sxs-lookup"><span data-stu-id="1a109-532">n/a</span></span>|  
  
 <span data-ttu-id="1a109-533">Zobacz uwagi dotyczące obiektów dziedziczących sekcji, aby uzyskać dodatkowe informacje w przypadku przesłaniania <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-533">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="1a109-534">Przeciążenie metody ToString</span><span class="sxs-lookup"><span data-stu-id="1a109-534">Overloading the ToString method</span></span>  
 <span data-ttu-id="1a109-535">Oprócz zastępowania bez parametrów <xref:System.Object.ToString?displayProperty=nameWithType> przeciążenia wiele typów metody `ToString` metodę w celu udostępnienia wersji metody, które akceptuje parametrów.</span><span class="sxs-lookup"><span data-stu-id="1a109-535">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="1a109-536">Najczęściej jest to realizowane aby zapewnić obsługę formatowania kultury i formatowanie zmiennych.</span><span class="sxs-lookup"><span data-stu-id="1a109-536">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="1a109-537">Poniższy przykład przeciążenia `ToString` metoda zwraca ciąg wynikowy, który zawiera wartość różnymi polami `Automobile` klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-537">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="1a109-538">Definiuje cztery ciągi formatu: G, która zwraca nazwę modelu i rok; D, która zwraca nazwę modelu, rok i liczba drzwi; C, która zwraca nazwę modelu, rok i liczba cylindrów; i A, który zwraca ciąg zawierający wszystkie cztery pola wartości.</span><span class="sxs-lookup"><span data-stu-id="1a109-538">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="1a109-539">Poniższy przykład wywołuje przeciążone <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę w celu wyświetlenia wrażliwość na ustawienia kulturowe formatowania wartości waluty.</span><span class="sxs-lookup"><span data-stu-id="1a109-539">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="1a109-540">Aby uzyskać więcej informacji na temat ciągów formatu i formatowania kultury, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="1a109-540">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="1a109-541">Dla ciągów formatów obsługiwanych przez wartości liczbowych, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="1a109-541">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="1a109-542">Dla ciągów formatów obsługiwanych przez wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="1a109-542">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="1a109-543">Rozszerzanie metoda Object.ToString</span><span class="sxs-lookup"><span data-stu-id="1a109-543">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="1a109-544">Ponieważ typ dziedziczy domyślnie <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, można znaleźć jego zachowanie niepożądanych i chcesz je zmienić.</span><span class="sxs-lookup"><span data-stu-id="1a109-544">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="1a109-545">Jest to szczególnie istotne, tablic i klas kolekcji.</span><span class="sxs-lookup"><span data-stu-id="1a109-545">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="1a109-546">Chociaż może oczekiwać `ToString` Metoda tablicy lub kolekcji klasy do wyświetlania wartości jego członków, zamiast tego Wyświetla typ pełni kwalifikowaną nazwę typu, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="1a109-546">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="1a109-547">Istnieje kilka opcji, aby ciąg wynikowy, który chcesz utworzyć.</span><span class="sxs-lookup"><span data-stu-id="1a109-547">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="1a109-548">Jeśli typ jest tablicą, obiekt kolekcji lub obiekt, który implementuje <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601> interfejsów, można wyliczyć jego elementy przy użyciu `foreach` instrukcji w języku C# lub `For Each...Next` konstruowania w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1a109-548">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="1a109-549">Jeśli klasa nie jest `sealed` (w języku C#) lub `NotInheritable` (w języku Visual Basic), możesz tworzyć klasy otoki, która dziedziczy z klasy bazowej, którego <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, który chcesz dostosować.</span><span class="sxs-lookup"><span data-stu-id="1a109-549">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="1a109-550">Co najmniej wymaga to, że wykonano następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="1a109-550">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="1a109-551">Zaimplementuj wszystkie niezbędne konstruktory.</span><span class="sxs-lookup"><span data-stu-id="1a109-551">Implement any necessary constructors.</span></span> <span data-ttu-id="1a109-552">Klasy pochodne nie dziedziczą ich Konstruktory klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="1a109-552">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="1a109-553">Zastąp <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg wynikowy, który chcesz.</span><span class="sxs-lookup"><span data-stu-id="1a109-553">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="1a109-554">W poniższym przykładzie zdefiniowano klasę otoki dla <xref:System.Collections.Generic.List%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-554">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="1a109-555">Zastępuje ona <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby wyświetlić wartość każdej metody kolekcji, a nie w pełni kwalifikowana nazwa typu.</span><span class="sxs-lookup"><span data-stu-id="1a109-555">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="1a109-556">Twórz [— metoda rozszerzenia](~/docs/standard/design-guidelines/extension-methods.md) zwracającego ciąg wynikowy, który chcesz.</span><span class="sxs-lookup"><span data-stu-id="1a109-556">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="1a109-557">Należy pamiętać, że nie można zastąpić domyślne <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w ten sposób (oznacza to, że rozszerzenie klasy (w języku C#) lub modułów (w języku Visual Basic) nie może mieć metody bez parametrów o nazwie `ToString` o nazwie zamiast oryginalnego typu `ToString` — metoda .</span><span class="sxs-lookup"><span data-stu-id="1a109-557">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="1a109-558">Musisz podać kilka innych nazwę użytkownika bez parametrów `ToString` zastępczy.</span><span class="sxs-lookup"><span data-stu-id="1a109-558">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="1a109-559">W poniższym przykładzie zdefiniowano dwie metody, które rozszerzają <xref:System.Collections.Generic.List%601> klasy: bez parametrów `ToString2` metody i `ToString` metody z <xref:System.String> parametr, który reprezentuje ciąg formatu.</span><span class="sxs-lookup"><span data-stu-id="1a109-559">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="1a109-560">Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1a109-560">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="1a109-561">Gdy wywołujesz <xref:System.Object.ToString%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-561">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="1a109-562">Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="1a109-562">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="1a109-563">Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a nie zawsze wdrożenia <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a109-563">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="1a109-564">Jednak zawsze pojawiają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.</span><span class="sxs-lookup"><span data-stu-id="1a109-564">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="1a109-565">Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], środowisko uruchomieniowe języka wspólnego będzie używać [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) na [!INCLUDE[wrt](~/includes/wrt-md.md)] obiektu przed powrotem do domyślna Implementacja klasy <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-565">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="1a109-566">klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.ToString%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="1a109-566">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="1a109-567">[!INCLUDE[wrt](~/includes/wrt-md.md)] i interfejs IStringable</span><span class="sxs-lookup"><span data-stu-id="1a109-567">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="1a109-568">Począwszy od [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] obejmuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejs którego pojedynczej metody [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), zapewnia podstawową obsługę formatowania porównywalne dostarczone przez <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a109-568">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1a109-569">Aby uniknąć niejednoznaczności, nie należy implementować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) na typach zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="1a109-569">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="1a109-570">Kiedy zarządzane obiekty są wywoływane przez kod natywny lub kod napisany w językach takich jak JavaScript lub C++/CX, pojawiają się do zaimplementowania [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="1a109-570">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="1a109-571">Środowisko uruchomieniowe języka wspólnego będzie automatycznie kierować wywołania z [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) do <xref:System.Object.ToString%2A?displayProperty=nameWithType> w zdarzeniu [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie został zaimplementowany dla obiektu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="1a109-571">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="1a109-572">Ponieważ środowisko uruchomieniowe języka wspólnego automatycznie — implementuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) wszystkie zarządzane typy w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji, firma Microsoft zaleca, aby nie zapewnić własne [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacji.</span><span class="sxs-lookup"><span data-stu-id="1a109-572">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="1a109-573">Implementowanie [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) może spowodować niezamierzone zachowanie podczas wywoływania `ToString` z [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX lub JavaScript.</span><span class="sxs-lookup"><span data-stu-id="1a109-573">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="1a109-574">Jeśli wybierzesz do zaimplementowania [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w publicznych typ zarządzany, który jest eksportowana w [!INCLUDE[wrt](~/includes/wrt-md.md)] składnika, występują następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="1a109-574">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="1a109-575">Można zdefiniować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejsu tylko w relacji "klasy implementuje", takich jak</span><span class="sxs-lookup"><span data-stu-id="1a109-575">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="1a109-576">w języku C# lub</span><span class="sxs-lookup"><span data-stu-id="1a109-576">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="1a109-577">w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1a109-577">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="1a109-578">Nie można zaimplementować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w interfejsie.</span><span class="sxs-lookup"><span data-stu-id="1a109-578">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="1a109-579">Nie można zadeklarować parametr będzie typu [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="1a109-579">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="1a109-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie może być zwracany typ metody, właściwości lub pola.</span><span class="sxs-lookup"><span data-stu-id="1a109-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="1a109-581">Nie można ukryć swoje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacja z klasy podstawowej za pomocą definicji metody, takie jak następujące:</span><span class="sxs-lookup"><span data-stu-id="1a109-581">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="1a109-582">Zamiast tego [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) musi zawsze zastąpić implementacji klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="1a109-582">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="1a109-583">Można ukryć `ToString` implementacji, wywołując je tylko w rozmiarze wystąpienia silnie typizowanej klasy.</span><span class="sxs-lookup"><span data-stu-id="1a109-583">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="1a109-584">Należy zauważyć, że w różnych warunkach, wywołań z kodu natywnego do zarządzanego typu, który implementuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) lub ukrywa jego [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementacji może spowodować nieoczekiwane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="1a109-584">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1a109-585">Podczas implementowania własnych typów, należy zastąpić <see cref="M:System.Object.ToString" /> metodę, aby zwracać wartości, które mają znaczenie dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="1a109-585">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="1a109-586">Pochodne klasy, które wymagają większa kontrola nad formatowaniem niż <see cref="M:System.Object.ToString" /> zapewnia można zaimplementować <see cref="T:System.IFormattable" /> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1a109-586">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="1a109-587">Jego <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> metoda umożliwia definiowanie ciągów formatu, które kontrolują formatowanie i użyj <see cref="T:System.IFormatProvider" /> obiekt, który może spowodować uzyskanie formatowanie specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="1a109-587">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="1a109-588">Zastępuje z <see cref="M:System.Object.ToString" /> metody należy przestrzegać następujących wytycznych:</span><span class="sxs-lookup"><span data-stu-id="1a109-588">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="1a109-589">-Zwracanego ciągu musi być, przyjazne i odczytany przez ludzi.</span><span class="sxs-lookup"><span data-stu-id="1a109-589">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="1a109-590">-Zwracanego ciągu musi jednoznacznie wskazywać na wartości wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-590">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="1a109-591">-Zwracanego ciągu powinien był jak najkrótszy, dlatego, że nadaje się do wyświetlania przez debuger.</span><span class="sxs-lookup"><span data-stu-id="1a109-591">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="1a109-592">- <see cref="M:System.Object.ToString" /> Zastąpienie nie powinny zwracać <see cref="F:System.String.Empty" /> lub pusty ciąg.</span><span class="sxs-lookup"><span data-stu-id="1a109-592">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="1a109-593">- <see cref="M:System.Object.ToString" /> Zastąpienie nie powinien zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="1a109-593">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="1a109-594">— Jeśli ciąg reprezentujący wystąpienie jest uwzględniana kultura, mogą być sformatowane na różne sposoby zaimplementowania <see cref="T:System.IFormattable" /> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="1a109-594">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="1a109-595">— Jeśli zwracanego ciągu zawiera poufne informacje, należy najpierw zażądać odpowiednie uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="1a109-595">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="1a109-596">Jeśli żądanie zakończy się powodzeniem, można zwrócić informacji poufnych; w przeciwnym razie powinien zwrócić ciąg, który nie obejmuje informacji poufnych.</span><span class="sxs-lookup"><span data-stu-id="1a109-596">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="1a109-597">- <see cref="M:System.Object.ToString" /> Zastąpienie powinien mieć nie widocznych efekty uboczne, aby uniknąć komplikacji podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="1a109-597">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="1a109-598">Na przykład, wywołanie <see cref="M:System.Object.ToString" /> metoda nie powinna zmieniać wartość pola wystąpień.</span><span class="sxs-lookup"><span data-stu-id="1a109-598">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="1a109-599">— Jeśli Twój typ implementuje metodę analizowania (lub <see langword="Parse" /> lub <see langword="TryParse" /> metoda, Konstruktor lub niektóre statyczna metoda, która tworzy wystąpienie tego typu z ciągu), należy upewnić się, że ciąg zwracany przez <see cref="M:System.Object.ToString" /> metoda może być przekonwertowane na wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="1a109-599">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="1a109-600">Typy formatowania na platformie .NET</span><span class="sxs-lookup"><span data-stu-id="1a109-600">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee401431516e6e306ca24894699063c7e527b563" />
    <Meta Name="ms.sourcegitcommit" Value="d3cf721118797166546daadbf87d91d5c256d489" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/28/2018" />
    <Meta Name="ms.locfileid" Value="37077182" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Obsługuje wszystkie klasy w hierarchii klas .NET Framework i udostępnia usługi niskiego poziomu dla klasy pochodnej. Jest to klasa podstawowa ultimate wszystkie klasy w programie .NET Framework; jest elementem głównym hierarchii typów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Języki zazwyczaj nie wymagają zadeklarować dziedziczenia z klasy <xref:System.Object> ponieważ dziedziczenia jest niejawnie.  
  
 Ponieważ wszystkie klasy w programie .NET Framework są uzyskiwane z <xref:System.Object>, każdej metody zdefiniowane w <xref:System.Object> klasa jest dostępna we wszystkich obiektach w systemie. Może klas pochodnych i zastępowania niektórych z tych metod, w tym:  
  
-   <xref:System.Object.Equals%2A> — Obsługuje porównań między obiektami.  
  
-   <xref:System.Object.Finalize%2A> -Wykonuje operacje oczyszczania, przed obiektu jest automatycznie odzyskać.  
  
-   <xref:System.Object.GetHashCode%2A> -Generuje numer odpowiadający wartość obiektu do obsługi tablicy skrótów.  
  
-   <xref:System.Object.ToString%2A> -Wytwarza ciąg tekstowy zrozumiałą dla użytkownika, który opisuje wystąpienie klasy.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 W przypadku projektowania klasy, takie jak pamięci, który musi obsługiwać obiekty dowolnego typu, możesz utworzyć elementów członkowskich klasy, które akceptują wystąpienia <xref:System.Object> klasy. Jednak proces konwersji boxing i konwersja unboxing typu niesie spadek wydajności. Jeśli wiesz, że nowej klasie często będzie obsługiwać niektórych typów wartości umożliwia jeden z dwóch taktyk minimalizuje to koszt boxing.  
  
-   Tworzenie ogólnych metody, która akceptuje <xref:System.Object> typ i zestaw przeciążenia metody określonego typu, które akceptują każdego typu wartości oczekiwać klasy do obsługi często. Jeśli metoda określonego typu istnieje akceptującego typ parametru wywołania, opakowywanie nie występuje i wywoływana jest metoda określonego typu. Jeśli nie ma żaden argument metody odpowiadający typowi parametru wywoływania, parametr jest opakowany oraz ogólne metoda jest wywoływana.  
  
-   Projektowanie danego typu i jej elementów członkowskich, aby użyć typów ogólnych. Środowisko uruchomieniowe języka wspólnego tworzy zamkniętego typu ogólnego, podczas tworzenia wystąpienia klasy i określ argumentu typu ogólnego. Metoda rodzajowa jest określonego typu i może być wywoływany bez konwersja boxing parametru wywoływania.  
  
 Mimo że czasami jest niezbędne do tworzenia klas ogólnego przeznaczenia, które zaakceptować i zwracać <xref:System.Object> typów, może poprawić wydajność podając również często używanych typów klasy określonego typu. Na przykład udostępnia klasę, która jest specyficzna dla ustawiania i pobierania wartości logiczne eliminuje koszty konwersja boxing i rozpakowywanie wartościami logicznymi.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano typ punktu tworzony na podstawie <xref:System.Object> klasy i zastępuje wiele metod wirtualnych <xref:System.Object> klasy. Ponadto w przykładzie przedstawiono sposób wywoływania wiele statycznych i wystąpienie metody <xref:System.Object> klasy.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Elementów członkowskich wystąpień nie ma gwarancji za bezpieczne wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Object" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez konstruktorów w klasach pochodnych, ale może również służyć do bezpośrednio utworzyć wystąpienia <xref:System.Object> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa wystąpienia obiektu są sobie równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony obiekt jest równy bieżącemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli określony obiekt jest taki sam jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ porównania dla bieżącego wystąpienia i `obj` parametru zależy od tego, czy bieżące wystąpienie jest typem referencyjnym lub typem wartości.  
  
-   Jeśli bieżące wystąpienie jest typem referencyjnym <xref:System.Object.Equals%28System.Object%29> testy metoda równości odwołań i wywołanie <xref:System.Object.Equals%28System.Object%29> jest odpowiednikiem wywołania metody <xref:System.Object.ReferenceEquals%2A> metody. Równość odwołania oznacza, że zmienne obiektów, które są porównywane odwołują się do tego samego obiektu. Poniższy przykład przedstawia wynik takie porównanie. Definiuje `Person` klasy, która jest typem referencyjnym, i wywołania `Person` konstruktora klasy można utworzyć dwa nowe `Person` obiektów, `person1a` i `person2`, które mają taką samą wartość. Przypisuje także `person1a` innej zmiennej obiektu, `person1b`. Jako dane wyjściowe w przykładzie pokazano `person1a` i `person1b` są takie same, ponieważ odwołujących się do tego samego obiektu. Jednak `person1a` i `person2` nie są takie same, mimo że mają one taką samą wartość.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Jeśli bieżące wystąpienie jest typem wartości <xref:System.Object.Equals%28System.Object%29> testy metoda równości wartości. Równość wartości oznacza, że następujące czynności:  
  
    -   Dwa obiekty są tego samego typu. Jak pokazano na poniższym przykładzie, <xref:System.Byte> obiekt, który ma wartość 12 nie jest równa <xref:System.Int32> obiekt, który ma wartość 12, ponieważ te dwa obiekty mają różne typy środowiska wykonawczego.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Wartości pola publiczne i prywatne dwa obiekty są równe. Poniższy przykład badań równości wartości. Definiuje `Person` struktury, która jest typem wartości, i wywołania `Person` konstruktora klasy można utworzyć dwa nowe `Person` obiektów, `person1` i `person2`, które mają taką samą wartość. Jak dane wyjściowe w przykładzie pokazano, mimo że zmienne dwóch obiektów odwoływać się do różnych obiektów, `person1` i `person2` są takie same, ponieważ mają one taką samą wartość dla prywatnego `personName` pola.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Ponieważ <xref:System.Object> klasa jest klasą bazową dla wszystkich typów w programie .NET Framework <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda zapewnia domyślne porównania równości dla wszystkich innych typów. Jednak typy często przesłaniać <xref:System.Object.Equals%2A> metody do zaimplementowania równości wartości. Aby uzyskać więcej informacji zobacz uwagi dla wywołań i uwagi dotyczące dziedziczenia sekcji.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Podczas wywoływania <xref:System.Object.Equals%28System.Object%29> przeciążenie metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastępują <xref:System.Object.Equals%28System.Object%29>. To jest częścią programu .NET Framework zapewnia obsługę [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje dla aplikacji ze Sklepu Windows i środowiska wykonawczego systemu Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczy <xref:System.Object>, a obecnie nie implementują <xref:System.Object.Equals%28System.Object%29> metody. Jednak pojawią się one mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy ich używać w kodzie C# lub Visual Basic i .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które są napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.Equals%28System.Object%29> przeciążenie metody.  
  
## <a name="notes-for-callers"></a>Uwagi dotyczące wywoływania  
 Klasy pochodne często zastąpienie <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do zaimplementowania równości wartości. Ponadto typy również często udostępniają dodatkowe przeładowania jednoznacznie `Equals` metody zwykle zaimplementowanie <xref:System.IEquatable%601> interfejsu. Podczas wywoływania `Equals` metody do testowania pod kątem równości, należy sprawdzić, czy bieżące wystąpienie zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType> i zrozumieć, w jaki sposób wywołania określonej `Equals` metody został rozwiązany. W przeciwnym razie należy pod kątem równości, który różni się od zgodny z zamierzonym wykonywania testu, a metoda może zwracać nieoczekiwaną wartość.  
  
 Poniższy przykład stanowi ilustrację. Tworzy wystąpienie, trzy <xref:System.Text.StringBuilder> obiekty o identycznych ciągów, a następnie tworzy cztery wywołania `Equals` metody. Pierwsza metoda wywołania zwraca `true`i pozostałe trzy zwrot `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 W pierwszym przypadku silnie typizowaną <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> przeciążenie metody, które testy w celu porównania wartości, jest wywoływana. Ponieważ ciągi są przypisywane dwa <xref:System.Text.StringBuilder> obiekty są takie same, metoda zwraca `true`. Jednak <xref:System.Text.StringBuilder> nie przesłania <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. W związku z tym podczas <xref:System.Text.StringBuilder> obiekt jest rzutowany <xref:System.Object>, gdy <xref:System.Text.StringBuilder> wystąpienia jest przypisany do zmiennej typu <xref:System.Object>i kiedy <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metody jest przekazywany dwa <xref:System.Text.StringBuilder> obiektów, domyślny <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>metoda jest wywoływana. Ponieważ <xref:System.Text.StringBuilder> jest typem referencyjnym, co jest równoważne przekazywanie dwa <xref:System.Text.StringBuilder> obiekty do <xref:System.Object.ReferenceEquals%2A> metody. Mimo że wszystkie trzy <xref:System.Text.StringBuilder> obiekty zawierają identycznych ciągów, odnoszą się do trzech oddzielnych obiektów. W związku z tym te trzy metoda wywołuje zwracany `false`.  
  
 Możesz porównać bieżący obiekt do innego obiektu równości odwołań, wywołując <xref:System.Object.ReferenceEquals%2A> metody. W języku Visual Basic, można również użyć `is` — słowo kluczowe (na przykład `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Uwagi dotyczące obiektów dziedziczących  
 Podczas definiowania własnych typu ten typ dziedziczy funkcje zdefiniowane przez `Equals` metoda jego typ podstawowy. W poniższej tabeli wymieniono Domyślna implementacja `Equals` metodę główne kategorie typów w programie .NET Framework.  
  
|Typ kategorii|Zdefiniowane przez równości|Komentarze|  
|-------------------|-------------------------|--------------|  
|Klasa pochodzi bezpośrednio z <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Równości odwołań; odpowiednikiem wywołania <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struktura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Równość wartości; bezpośrednie porównanie po bicie lub porównanie przez pole przy użyciu odbicia.|  
|Wyliczenie|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Wartości muszą mieć ten sam typ wyliczeniowy i tej samej wartości podstawowej.|  
|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Obiekty delegowane musi mieć ten sam typ z listami identyczne wywołania.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Równość odwołania.|  
  
 Dla typu wartości powinny zawsze zastępować <xref:System.Object.Equals%2A>, ponieważ testy pod kątem równości, które działają na podstawie odbicia oferuje pogorszenie wydajności. Można również zmienić domyślną implementację elementu <xref:System.Object.Equals%2A> dla typów odwołań do testowania pod kątem równości wartości zamiast równości odwołań i definiowanie równości wartości znaczenie. Takie implementacje <xref:System.Object.Equals%2A> zwracać `true` Jeśli dwa obiekty mają taką samą wartość, nawet jeśli nie są tego samego wystąpienia. Typ implementujący decyduje o tym, co stanowi wartość obiektu, ale jest zwykle niektórych lub wszystkich danych przechowywanych w zmiennych wystąpienia obiektu. Na przykład, wartość <xref:System.String> obiektu jest oparta na znaki ciągu; <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> zamienników metod <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, aby zwrócić `true` dla dowolnego ciągu dwa wystąpienia, które zawierają te same znaki w tej samej kolejności.  
  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do testowania pod kątem równości wartości. Zastępuje on <xref:System.Object.Equals%2A> metodę `Person` klasy. Jeśli `Person` zaakceptowane implementację jej klasy podstawowej równości, dwa `Person` obiekty są takie same, tylko wtedy, gdy ich odwołuje się do pojedynczego obiektu. Jednak w takim przypadku dwa `Person` obiekty są takie same, jeśli mają taką samą wartość `Person.Id` właściwości.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Oprócz zastępowania <xref:System.Object.Equals%2A>, można zaimplementować <xref:System.IEquatable%601> interfejsu zapewnienie jednoznacznie testu równości.  
  
 Poniższe instrukcje musi mieć wartość true dla wszystkich wdrożeń <xref:System.Object.Equals%28System.Object%29> metody. Na liście `x`, `y`, i `z` reprezentowania odwołań do obiektów, które nie są **null**.  
  
-   `x.Equals(x)` Zwraca `true`, z wyjątkiem przypadków obejmujących typów zmiennoprzecinkowych. Zobacz IEEE-ISO/IEC 60559:2011, technologii informatycznych — mikroprocesora systemów — zmiennoprzecinkowe arytmetyczne.  
  
-   `x.Equals(y)` zwraca taką samą wartość jak `y.Equals(x)`.  
  
-   `x.Equals(y)` Zwraca `true` Jeśli obie `x` i `y` są `NaN`.  
  
-   Jeśli `(x.Equals(y) && y.Equals(z))` zwraca `true`, następnie `x.Equals(z)` zwraca `true`.  
  
-   Kolejne wywołania `x.Equals(y)` zwraca tę samą wartość jak odwołują się obiekty `x` i `y` nie są modyfikowane.  
  
-   `x.Equals(null)` Zwraca `false`.  
  
 Implementacje <xref:System.Object.Equals%2A> nie może zostać zwrócone wyjątków; należy zawsze zwracają wartość. Na przykład jeśli `obj` jest `null`, <xref:System.Object.Equals%2A> metoda powinna zwrócić `false` zamiast zgłaszanie <xref:System.ArgumentNullException>.  
  
 Skorzystaj z następujących wskazówek podczas zastępowania <xref:System.Object.Equals%28System.Object%29>:  
  
-   Typy, które implementują <xref:System.IComparable> przesłonięcie <xref:System.Object.Equals%28System.Object%29>.  
  
-   Typy zastąpienie tego <xref:System.Object.Equals%28System.Object%29> musi także zastępować metodę <xref:System.Object.GetHashCode%2A>; w przeciwnym razie wartość skrótu tabele mogą nie działać poprawnie.  
  
-   Należy rozważyć wdrożenie <xref:System.IEquatable%601> interfejs do obsługi silnie wpisane testy pod kątem równości. Twoje <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementacji powinien zwrócić wyników, które są zgodne z <xref:System.Object.Equals%2A>.  
  
-   Jeśli język programowania obsługuje przeładowania operatora i przeciążenia operatora równości dla danego typu, musi także zastępować <xref:System.Object.Equals%28System.Object%29> metodę, aby zwrócić takiego samego wyniku jako operator równości. Pomaga to zapewnić, że kod biblioteki klasy, który używa <xref:System.Object.Equals%2A> (takich jak <xref:System.Collections.ArrayList> i <xref:System.Collections.Hashtable>) działa w sposób zgodny z sposób operator równości jest używany przez kod aplikacji.  
  
### <a name="guidelines-for-reference-types"></a>Wytyczne dla typów odwołania  
 Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu odwołania:  
  
-   Należy wziąć pod uwagę zastępowanie <xref:System.Object.Equals%2A> przypadku opiera się na fakt, że niektóre wartości reprezentuje typ semantykę typu.  
  
-   Większość typów referencyjnych nie muszą przeciążać operatora równości, nawet jeśli zastępują one <xref:System.Object.Equals%2A>. Jednak w przypadku wdrażania typu odwołania, która powinna mieć semantyki wartości, takie jak typ liczby złożonej, konieczne jest przesłonięcie operatora równości.  
  
-   Nie należy zastąpić <xref:System.Object.Equals%2A> na modyfikowalnego typu referencyjnego. Jest to spowodowane zastępowanie <xref:System.Object.Equals%2A> wymaga się, że możesz też przesłonić <xref:System.Object.GetHashCode%2A> metody, zgodnie z opisem w poprzedniej sekcji. Oznacza to, że wartość skrótu wystąpienia modyfikowalnego typu referencyjnego może zmieniać się przez jego okres istnienia, co może powodować obiektu utracone w tablicy skrótów.  
  
### <a name="guidelines-for-value-types"></a>Wytyczne dla typów wartości  
 Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu wartości:  
  
-   Jeśli definiujesz typu wartości, która zawiera co najmniej jedno pole których wartości są typy odwołań, powinny zastępować <xref:System.Object.Equals%28System.Object%29>. <xref:System.Object.Equals%28System.Object%29> Implementacji podał <xref:System.ValueType> przeprowadza porównanie po bicie dla typów wartości, których pola są wszystkie typy wartości, ale używa odbicia do wykonania porównania pola przez typy wartości, których pola obejmują typy referencyjne.  
  
-   Jeśli można zastąpić <xref:System.Object.Equals%2A> i przeciążania operatorów obsługuje język programowania, muszą przeciążać operatora równości.  
  
-   Należy zaimplementować <xref:System.IEquatable%601> interfejsu. Wywoływanie silnie typizowaną <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metoda pozwala uniknąć pakującej `obj` argumentu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `Point` klasy, która zastępuje <xref:System.Object.Equals%2A> metodę w celu zapewnienia równości wartości i `Point3D` klasy, która jest pochodną `Point`. Ponieważ `Point` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do testowania równości wartości <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> nie jest wywoływana metoda. Jednak `Point3D.Equals` wywołania `Point.Equals` ponieważ `Point` implementuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> w taki sposób, który udostępnia wartość porównania.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals` Metoda sprawdza, upewnij się, że `obj` argument nie jest **null** i czy odwołuje się wystąpienia tego samego typu co ten obiekt. Jeśli zaznacz kończy się niepowodzeniem, metoda zwraca `false`.  
  
 `Point.Equals` Wywołania metody <xref:System.Object.GetType%2A> metodę, aby określić, czy typy środowiska wykonawczego dwa obiekty są identyczne. Jeśli metodę wyboru w postaci `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic zwróci sprawdzania `true` w przypadkach, gdzie `obj` jest wystąpieniem klasy pochodnej z `Point`, mimo że `obj` i obecnie wystąpienie nie są tego samego typu czasu wykonywania. Po zweryfikowaniu, że oba obiekty są tego samego typu rzutowania metody `obj` na typ `Point` i zwraca wynik porównania pól wystąpień dwóch obiektów.  
  
 W `Point3D.Equals`, dziedziczonego `Point.Equals` metodę, która zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, jest wywoływana przed odbywa się inaczej. Ponieważ `Point3D` jest klasy zapieczętowanej (`NotInheritable` w języku Visual Basic), wyboru w formularzu `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic jest odpowiednia do upewnij się, że `obj` jest `Point3D` obiektu. Jeśli jest `Point3D` obiektu, jest rzutowane na `Point` obiektu i przekazane do implementacji klasy podstawowej <xref:System.Object.Equals%2A>. Tylko wtedy, gdy dziedziczonego `Point.Equals` metoda zwraca `true` jest compare — metoda `z` wystąpienia pól wprowadzone w klasie pochodnej.  
  
 W poniższym przykładzie zdefiniowano `Rectangle` klasy, która implementuje wewnętrznie prostokąt jako dwa `Point` obiektów. `Rectangle` Klasy również zastąpienia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do zapewnienia równości wartości.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Niektóre języki, takich jak C# i Visual Basic obsługują przeładowania operatora. Gdy typem overloads operator równości, musi także zastępować <xref:System.Object.Equals%28System.Object%29> metodę, aby dostarczyć te same funkcje. Zazwyczaj jest to realizowane za pomocą <xref:System.Object.Equals%28System.Object%29> metody pod względem operator równości przeciążone, jak w poniższym przykładzie.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Ponieważ `Complex` jest to typ wartości nie może pochodzić z.  W związku z tym zastąpienie mające na celu <xref:System.Object.Equals%28System.Object%29> — metoda nie należy wywoływać <xref:System.Object.GetType%2A> ustalenie dokładne czasu wykonywania typu każdego obiektu, ale może zamiast tego użyj `is` operatora w języku C# lub `TypeOf` operatora w języku Visual Basic, aby sprawdzić typ `obj` parametru.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="objB">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy wystąpienia określonego obiektu są traktowane jako równe.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekty są traktowane jako równe; w przeciwnym razie <see langword="false" />. Jeśli oba <paramref name="objA" /> i <paramref name="objB" /> są ** null **, metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statycznych <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metoda wskazuje, czy dwa obiekty, `objA` i `objB`, są takie same. Można również do testowania obiektów, którego wartość jest **null** pod kątem równości. Porównuje `objA` i `objB` równości w następujący sposób:  
  
-   Określa, czy dwa obiekty reprezentuje odwołanie do tego samego obiektu. Jeśli nie, metoda zwraca `true`. Ten test jest odpowiednikiem wywołania <xref:System.Object.ReferenceEquals%2A> metody. Ponadto, jeśli obie `objA` i `objB` są **null**, metoda zwraca `true`.  
  
-   Określa czy albo `objA` lub `objB` jest **null**. Jeśli tak, zwraca `false`.  
  
-   Jeśli dwa obiekty nie reprezentują tego samego odwołania do obiektu i nie będzie **null**, wywołuje `objA`.`Equals` (`objB`) i zwraca wynik. Oznacza to, że jeśli `objA` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, to zastąpienie.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> — metoda i porównuje ją z <xref:System.Object.ReferenceEquals%2A> metody.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu, próby zwolnienia zasobów i wykonywać inne operacje oczyszczania, przed jego jest odzyskana przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> Metoda jest używana do wykonywania operacji oczyszczania na niezarządzane zasoby zajmowane przez bieżący obiekt, zanim obiekt zostanie zniszczony. Metoda jest chroniona i w związku z tym jest dostępny tylko za pomocą tej klasy lub z klasy pochodnej.  
  
 W tej sekcji:  
  
-   [Jak działa finalizacji](#How)  
  
-   [Informacje o implementacji](#Notes)  
  
-   [Element SafeHandle alternatywnej](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Jak działa finalizacji  
 <xref:System.Object> Klasa dostarcza implementacji <xref:System.Object.Finalize%2A> — metoda i moduł zbierający elementy bezużyteczne nie znaku typów pochodnych <xref:System.Object> dla finalizacji chyba, że zastępują one <xref:System.Object.Finalize%2A> — metoda.  
  
 Jeśli typem zastąpienie <xref:System.Object.Finalize%2A> metoda, moduł zbierający elementy bezużyteczne dodaje wpis dla każdego wystąpienia typu o nazwie Kolejka finalizacji wewnętrznej struktury. Kolejka finalizacji zawiera wpisy dla wszystkich obiektów w stercie zarządzanej, którego kod finalizacji należy uruchomić przed modułu zbierającego elementy bezużyteczne mógł odzyskać ich pamięci. Wywołuje moduł garbage collector <xref:System.Object.Finalize%2A> metody automatycznie w następujących warunkach:  
  
-   Po moduł garbage collector wykrył, że obiekt jest niedostępny, chyba że obiekt została zwolniona z finalizacji przez wywołanie do <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
-   Podczas zamykania domeny aplikacji chyba że obiekt jest wykluczony z finalizacji. Podczas zamykania sfinalizowaniu nawet obiektów, które są nadal dostępne.  
  
 <xref:System.Object.Finalize%2A> jest automatycznie wywołana tylko raz w danym wystąpieniu, chyba że obiekt jest ponownie zarejestrowane przy użyciu mechanizmu, takich jak <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> i <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nie została następnie wywołana metoda.  
  
 <xref:System.Object.Finalize%2A> operacje mają następujące ograniczenia:  
  
-   Dokładny czas, kiedy wykonuje finalizatora jest niezdefiniowana. Zapewnienie deterministyczne zwolnienia zasobów dla wystąpień klasy, wdrożenie `Close` metody lub podaj <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.  
  
-   Finalizatory dwóch obiektów nie ma gwarancji do uruchamiania w dowolnej kolejności, nawet jeśli jeden obiekt odwołuje się do innych. Oznacza to mają finalizatory obiektu A zawiera odwołanie do obiektu B, obiekt B może mieć już sfinalizowany podczas uruchamiania finalizatora obiektu, A.  
  
-   Wątek, na którym jest uruchomiony finalizatora jest nieokreślony.  
  
 <xref:System.Object.Finalize%2A> Metody mogą nie działać do zakończenia lub może nie działać w ogóle następujących wyjątkowych okolicznościach:  
  
-   Jeśli inny finalizator blokuje nieskończoność (przechodzi w nieskończonej pętli, próbuje uzyskać blokady go może nigdy nie uzyskać i tak dalej). Ponieważ środowisko wykonawcze próbuje uruchomić finalizatory w celu ukończenia, innych finalizatory może nie można wywołać Jeśli bloki finalizator przez nieograniczony czas.  
  
-   Jeśli proces zakończy się bez nadawania środowiska uruchomieniowego możliwość wyczyścić. W takim przypadku środowiska uruchomieniowego pierwszego powiadomienia o wygaśnięciu procesu jest powiadomienie komunikat DLL_PROCESS_DETACH.  
  
 Środowisko uruchomieniowe w dalszym ciągu finalize obiekty podczas zamykania tylko wtedy, gdy liczba obiektów finalizable nadal zmniejszyć.  
  
 Jeśli <xref:System.Object.Finalize%2A> lub zastępująca <xref:System.Object.Finalize%2A> zgłasza wyjątek, który występuje i środowiska uruchomieniowego nie jest obsługiwany przez aplikację, która zastępuje domyślną zasadę, środowisko uruchomieniowe kończy proces i nie ma aktywnych `try` / `finally` bloków lub finalizatory są wykonywane. Takie zachowanie gwarantuje integralności procesu, jeśli finalizator nie może zwolnić lub zniszczenie zasobów.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Zastępowanie metody Finalize 
 Należy zastąpić <xref:System.Object.Finalize%2A> dla klasy, która używa niezarządzane zasoby, takie jak dojścia do plików lub połączenia z bazą danych, które muszą zostać zwolnione, gdy obiekt zarządzany, który używa tych zostaną odrzucone podczas wyrzucania elementów bezużytecznych. Nie należy implementować <xref:System.Object.Finalize%2A> metodę zarządzane obiekty, ponieważ moduł garbage collector zwalnia zasoby zarządzane automatycznie.  
  
> [!IMPORTANT]
>  Jeśli <xref:System.Runtime.InteropServices.SafeHandle> obiekt jest dostępny który opakowuje niezarządzanego zasobu, zalecaną alternatywą jest implementować wzorzec dispose z bezpieczne dojście do przesłania <xref:System.Object.Finalize%2A>. Aby uzyskać więcej informacji, zobacz [zamiast SafeHandle](#SafeHandle) sekcji.  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> — Metoda nie działa domyślnie, ale powinny zastępować <xref:System.Object.Finalize%2A> tylko wtedy, gdy konieczne, a jedynie, aby zwolnić zasoby niezarządzane. Odzyskiwanie pamięci zwykle trwać znacznie dłużej, jeśli operacja finalizacji działa, ponieważ wymaga co najmniej dwóch wyrzucania. Ponadto należy zastąpić <xref:System.Object.Finalize%2A> metody dla odwołania tylko typy. Środowisko uruchomieniowe języka wspólnego tylko Kończenie znajdujących się w typach odwołań. Ignoruje finalizatory w typach wartości.  

Zakres <xref:System.Object.Finalize%2A?displayProperty=nameWithType> jest metoda `protected`. Należy zachować ten ograniczony zakres podczas zastąpienia metody w klasie. Dzięki przechowywaniu <xref:System.Object.Finalize%2A> metody chronione, należy uniemożliwić użytkownikom aplikacji z wywoływania obiektu <xref:System.Object.Finalize%2A> metody bezpośrednio.
  
 Każdy implementacja <xref:System.Object.Finalize%2A> typu pochodnego musi wywołać wykonania jego typ podstawowy <xref:System.Object.Finalize%2A>. Dotyczy to tylko w aplikacji, które może wywoływać kod <xref:System.Object.Finalize%2A>. Obiekt <xref:System.Object.Finalize%2A> — metoda nie należy wywołać metodę na wszelkie obiekty inną niż swojej klasy podstawowej. Jest tak, ponieważ inne wywołania obiektów mogą być kolekcjonowane w tym samym czasie, co obiekt wywołujący, tak jak w przypadku zamknięcia środowiska uruchomieniowego języka wspólnego. 
  
> [!NOTE]
>  Kompilator języka C# nie pozwala na zastąpienie <xref:System.Object.Finalize%2A> metody. Zamiast tego Podaj finalizator zaimplementowanie [destruktora](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) dla klasy. C# destruktora automatycznie wywołuje destruktor klasy podstawowej.  
>   
>  Visual C++ udostępnia również własną składni wykonywania <xref:System.Object.Finalize%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję "Destruktory i finalizatory" [porady: definiowanie i korzystać z klas i struktur (C + +/ CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Wyrzucanie elementów bezużytecznych jest deterministyczna, nie wiadomo, mówiąc, gdy moduł garbage collector wykonuje finalizacji. Aby zwolnić zasoby natychmiast, również można zaimplementować [wzorzec dispose](~/docs/standard/design-guidelines/dispose-pattern.md) i <xref:System.IDisposable> interfejsu. <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementacja może być wywoływany przez konsumentów klasy do zwalniania niezarządzanych zasobów i służy <xref:System.Object.Finalize%2A> metody do zwalniania niezarządzanych zasobów w przypadku gdy <xref:System.IDisposable.Dispose%2A> nie jest wywoływana metoda.  
  
 <xref:System.Object.Finalize%2A> może zająć prawie każdego działania, w tym resurrecting obiektu (tj. udostępnienie obiektu ponownie), po jego został oczyszczony podczas wyrzucania elementów bezużytecznych. Jednak obiekt można tylko być aktywowanych raz; <xref:System.Object.Finalize%2A> nie można wywołać w obiektach aktywowanych podczas wyrzucania elementów bezużytecznych. Brak jednej akcji który implementacji <xref:System.Object.Finalize%2A> nigdy nie powinna przyjmować: go nigdy nie powinien zgłosić wyjątek. Jeśli wszelkie wyjątki zgłaszane przez metody wywoływane z <xref:System.Object.Finalize%2A> metody jest nieobsługiwany przez <xref:System.Object.Finalize%2A> — metoda, środowisko uruchomieniowe przy założeniu, że <xref:System.Object.Finalize%2A> — metoda zwróciła i kontynuuje wywoływanie <xref:System.Object.Finalize%2A> metody innych obiektów. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Element SafeHandle alternatywnej  
 Często jest trudne, tworzenie niezawodnej finalizatory, ponieważ nie można wprowadzić założenia dotyczące stanu aplikacji i nieobsługiwane wyjątki systemu, takich jak <xref:System.OutOfMemoryException> i <xref:System.StackOverflowException> przerwanie finalizatora. Zamiast implementacja finalizatora dla klasy, aby zwolnić zasoby niezarządzane, możesz użyć obiektu, który jest pochodną <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> klasy opakowywać niezarządzane zasoby, a następnie implementować wzorzec dispose bez finalizator. Platforma .NET Framework zapewnia następujące klasy w <xref:Microsoft.Win32?displayProperty=nameWithType> przestrzeni nazw, które są pochodnymi <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to klasa otoki dla dojście do pliku.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> to klasa otoki dla dojścia do plików mapowanych na pamięć.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> to klasa otoki dla wskaźnika do bloku pamięci niezarządzanej.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> są klasy otoki dojść do usług kryptograficznych.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> to klasa otoki dla dojścia potoku.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> to klasa otoki na dojście do klucza rejestru.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> to klasa otoki dla dojście oczekiwania.  
  
 W poniższym przykładzie użyto [wzorzec dispose](~/docs/standard/design-guidelines/dispose-pattern.md) z uchwytami bezpieczne zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody. Definiuje `FileAssociation` klasy, która opakowuje rejestru informacji o aplikacji, która obsługuje pliki z rozszerzeniem określonego pliku. Uchwyty dwóch rejestru zwracane jako `out` parametry przez system Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) wywołania funkcji są przekazywane do <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> konstruktora. Typ obiektu chronione `Dispose` metoda wywołuje `SafeRegistryHandle.Dispose` metody zwolnienia tych dwóch uchwytów.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy <xref:System.Object.Finalize%2A> metoda jest wywoływana, gdy obiekt, który zastępuje <xref:System.Object.Finalize%2A> zostanie zniszczony. Należy zauważyć, że w aplikacji produkcyjnej <xref:System.Object.Finalize%2A> metody może zostać zastąpiona w celu Zwolnij niezarządzane zasoby zajmowane przez obiekt. Należy również zauważyć, że w C# przykładzie przedstawiono destruktora zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Przykład dodatkowe zastępujący <xref:System.Object.Finalize%2A> metody, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Służy jako domyślnej funkcji skrótu.</summary>
        <returns>Kod skrótu bieżącego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość skrótu jest wartością numeryczną, który służy do wstawiania i zidentyfikować obiektu w kolekcji na podstawie wyznaczania wartości skrótu, takich jak <xref:System.Collections.Generic.Dictionary%602> klasy <xref:System.Collections.Hashtable> klasy lub typ pochodny typu <xref:System.Collections.DictionaryBase> klasy. <xref:System.Object.GetHashCode%2A> Metoda zapewnia tego skrótu algorytmy, które wymagają szybkiej kontroli równość obiektu.  
  
> [!NOTE]
>  Informacje o jak skrótu są używane w tabelach skrótów oraz algorytmów kodu niektóre dodatkowe wyznaczania wartości skrótu, zobacz [funkcji skrótu](https://en.wikipedia.org/wiki/Hash_function) wpis w Wikipedia.  
  
 Dwa obiekty, które są kody taki sam zwracany wyznaczania wartości skrótu, które są takie same. Jednak odwrotnej nie jest prawdziwe: równy skrótu nie zakłada równość obiektu, ponieważ inne obiekty (nierówne) może mieć identyczne skrótu. Ponadto, .NET Framework nie gwarantuje Domyślna implementacja <xref:System.Object.GetHashCode%2A> — metoda i wartość ta metoda zwraca może różnić się od wersji systemu .NET Framework i platformy, na przykład 32-bitowe i 64-bitowych platform. Z tego względu nie należy używać Domyślna implementacja tej metody jako identyfikator obiektu unikatowe potrzeby wyznaczania wartości skrótu. Dwie konsekwencje i postępuj zgodnie z to:  
  
-   Nie należy zakładać, że takie same skrótu implikują równość obiektu.  
  
-   Nigdy nie należy utrwalić lub użyj skrótu spoza domeny aplikacji, w której został utworzony, ponieważ ten sam obiekt może skrótów w domenach aplikacji, procesów i platform.  
  
> [!WARNING]
>  Wartość skrótu jest przeznaczony do wstawienia wydajne i wyszukiwania w kolekcji, które są oparte na tablicy skrótów. Wartość skrótu nie jest wartością trwałych. Z tego powodu:  
>   
> -   Nie serializacji wartości skrótu kodu lub przechowywać je w bazach danych.  
> -   Nie używaj skrótu klucza można pobrać obiektu z kluczem kolekcji.  
> -   Nie wysyłaj skrótu między domenami aplikacji lub procesów. W niektórych przypadkach skrótu może być obliczonych na podstawie domeny na proces lub określonych aplikacji.  
> -   Nie należy używać skrótu zamiast wartości zwróconej przez kryptograficznych funkcji skrótu, jeśli potrzebujesz silną kryptograficznie wyznaczania wartości skrótu. Skróty kryptograficzne, można użyć klasy pochodzącej od <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> klasy.  
> -   Nie należy przeprowadzać testów równości skrótu, aby określić, czy dwa obiekty są takie same. (Nierówne obiekty mogą mieć identycznych skrótu). Aby przetestować pod kątem równości, należy wywołać <xref:System.Object.ReferenceEquals%2A> lub <xref:System.Object.Equals%2A> metody.  
  
 <xref:System.Object.GetHashCode%2A> Metody może zostać przesłonięta przez typu pochodnego. Jeśli <xref:System.Object.GetHashCode%2A> jest nie została zastąpiona, skrótu dla typów odwołań są obliczane przez wywołanie metody <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> na podstawie metody klasy podstawowej, który oblicza wartość skrótu dla odwołania do obiektu; Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Innymi słowy, dwóch obiektów, dla których <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` mają identyczne skrótu. W przypadku typów wartości nie zastępują <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metody klasy podstawowej używa odbicia można obliczyć skrótu na podstawie wartości pola typu. Innymi słowy typy wartości, których pola mają takie same wartości mają takie same skrótu. Aby uzyskać więcej informacji na temat zastępowania <xref:System.Object.GetHashCode%2A>, zobacz sekcję "Uwagi dotyczące dziedziczenia".  
  
> [!WARNING]
>  Jeśli można zastąpić <xref:System.Object.GetHashCode%2A> metody, należy również przesłonięcia <xref:System.Object.Equals%2A>i na odwrót. Jeśli Twoje przesłoniętych <xref:System.Object.Equals%2A> metoda zwraca `true` Jeśli dwa obiekty są sprawdzane pod kątem równości, Twoje zastąpiona <xref:System.Object.GetHashCode%2A> metoda musi zwracać taką samą wartość dla dwóch obiektów.  
  
 Jeśli obiekt, który jest używany jako klucz w tablicy skrótów nie zapewnia implementacji przydatne <xref:System.Object.GetHashCode%2A>, można określić dostawcy kodu wyznaczania wartości skrótu, podając <xref:System.Collections.IEqualityComparer> implementacji do jednego z przeciążeń <xref:System.Collections.Hashtable> konstruktora klasy.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Podczas wywoływania <xref:System.Object.GetHashCode%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastępują <xref:System.Object.GetHashCode%2A>. To jest częścią programu .NET Framework zapewnia obsługę [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje dla aplikacji ze Sklepu Windows i środowiska wykonawczego systemu Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a obecnie nie implementują <xref:System.Object.GetHashCode%2A>. Jednak pojawią się one mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy ich używać w kodzie C# lub Visual Basic i .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które są napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.GetHashCode%2A> metody.  
  
   
  
## Examples  
 Jedną z najprostszych sposobów obliczyć wartość skrótu dla wartości liczbowej ma taką samą lub mniejszym zakresie niż <xref:System.Int32> typu jest po prostu zwraca tę wartość. Poniższy przykład przedstawia implementację dla `Number` struktury.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Często typu ma wiele pól danych, które mogą należeć do generowania skrótu. Jednym ze sposobów generowania skrótu jest połączenie tych pól przy użyciu `XOR (eXclusive OR)` operacji, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Poprzedni przykład zwraca taki sam skrót dla (n1, n2) i (n2 n1), a więc może generować kolizji więcej niż pożądane. Dostępnych jest kilka rozwiązań, umożliwiając skrótu w takich przypadkach nie są identyczne. Co ma zwrócić skrótu `Tuple` obiektu, które odzwierciedla kolejność każdego pola. W poniższym przykładzie przedstawiono możliwe implementację, która używa <xref:System.Tuple%602> klasy. Należy pamiętać, że obciążenie związane z tworzenia wystąpienia `Tuple` obiekt może mieć znaczący wpływ na ogólną wydajność aplikacji, która przechowuje dużą liczbą obiektów w tabelach skrótów.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Drugi rozwiązań alternatywnych obejmuje wagi poszczególnych skrótu przesuwając od lewej-skrótu kolejnych pól za pomocą liczby bitów dwóch lub więcej. Optymalnie zamiast zostanie odrzucony, bitów przesunięty poza bit 31 powinna być zawijana wokół zamiast odrzucone. Ponieważ usługa bits są odrzucane przez operatory przesunięcia w lewo w języku C# i Visual Basic, to wymaga utworzenia po lewej stronie metody shift-wrap podobne do poniższych:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 W poniższym przykładzie użyto następnie ta metoda shift-wrap można obliczyć skrótu `Point` struktury używane w poprzednich przykładach.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Funkcja wyznaczania wartości skrótu służy do szybkiego generowania liczby (skrótu), która odpowiada wartości obiektu. Funkcje skrótu są zazwyczaj specyficzne dla poszczególnych typów i unikatowość, należy użyć co najmniej jednego pola wystąpienia jako dane wejściowe. Kody skrótów powinien nie można obliczyć przy użyciu wartości pól statycznych.  Dla klas pochodnych <see cref="T:System.Object" />, <see langword="GetHashCode" /> delegować metody do klasy podstawowej <see cref="M:System.Object.GetHashCode" /> implementacji tylko wtedy, gdy klasa pochodna definiuje równości być równości odwołań. Domyślna implementacja <see cref="M:System.Object.GetHashCode" /> dla odwołania do typów zwraca wartość skrótu odpowiada jednej zwrócony przez <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> metody. Można zastąpić <see cref="M:System.Object.GetHashCode" /> dla typów odwołań niezmienialny. Ogólnie rzecz biorąc, dla typów referencyjnych powinny zastępować <see cref="M:System.Object.GetHashCode" /> tylko wtedy, gdy: — można obliczyć skrótu z pól, które nie są modyfikowalną; lub - zapewnia wartość skrótu obiektu modyfikowalnego nie ulega zmianie podczas, gdy obiekt jest zawarty w collecti na tym polega na jego wartość skrótu.  W przeciwnym razie podejrzenie, że obiektu modyfikowalnego zostaną utracone w tablicy skrótów. Jeśli chcesz przesłonić <see cref="M:System.Object.GetHashCode" /> dla modyfikowalnego typu referencyjnego, z dokumentacją powinien stał się że użytkownicy tego typu nie należy modyfikować wartości obiektu, gdy obiekt jest przechowywany w tablicy skrótów.  Dla typów wartości <see cref="M:System.ValueType.GetHashCode" /> udostępnia domyślną implementację kodu skrótu używa odbicia. Należy rozważyć przesłanianie go w celu zapewnienia lepszej wydajności.  <block subset="none" type="note"><para> Aby uzyskać dodatkowe informacje i przykłady, które służą do obliczania skrótu na różne sposoby zobacz sekcję przykłady.  </para></block>  Funkcja wyznaczania wartości skrótu musi mieć następujące właściwości: — Jeśli dwa obiekty porównania jako równe, <see cref="M:System.Object.GetHashCode" /> metody dla każdego obiektu musi zwracać taką samą wartość. Jednakże, jeśli dwa obiekty porównuje jako równe, <see cref="M:System.Object.GetHashCode" /> metody dwa obiekty nie należy zwracać różne wartości.  - <see cref="M:System.Object.GetHashCode" /> Metodę dla obiekt spójnie musi zwracać taki sam skrótu tak długo, jak nie istnieje żadne modyfikacji stanu obiektu, który określa wartość zwracaną obiektu [Metoda System.Object.Equals](xref:System.Object.Equals*). Należy pamiętać, że jest to wartość true tylko w przypadku wykonywania bieżącej aplikacji i że różnych skrótu może być zwracany, jeśli aplikacja jest uruchamiana ponownie.  — Aby uzyskać najlepszą wydajność funkcji skrótu powinna generować nawet dystrybucji dla wszystkich danych wejściowych, w tym danych wejściowych silnie jest klastrowany. Możliwa jest mała zmiany stanu obiektu powinno spowodować duże modyfikacje wynikowy skrótu najlepszą wydajność tabeli skrótów.  — Funkcje skrótu powinny być tanie do obliczenia.  - <see cref="M:System.Object.GetHashCode" /> — Metoda nie powinny zgłaszać wyjątków.  Na przykład stosowania <see cref="M:System.String.GetHashCode" /> metody dostarczone przez <see cref="T:System.String" /> Klasa zwraca kodów skrótów identyczne wartości identycznych ciągów. W związku z tym dwóch <see cref="T:System.String" /> obiektów zwracać taki sam skrót, jeśli reprezentują one taką samą wartość ciągu. Ponadto metoda używa do wszystkich znaków w ciągu Generowanie rozsądnych losowo rozproszonej dane wyjściowe, nawet wtedy, gdy dane wejściowe jest klastrowany w określonych zakresach (na przykład w przypadku wielu użytkowników może być ciągi, które zawierają tylko niższe 128 znaków ASCII, mimo że ciąg może zawierać znaków Unicode 65 535).  Zapewnianie funkcji skrótu dobrej klasy mogą znacznie wpłynąć na wydajność dodanie tych obiektów do tablicy skrótów. W tablicy skrótów z kluczami, które zapewniają dobrą stosowania funkcji skrótu Wyszukiwanie elementu czas stałych (na przykład operacji O(1)). W tablicy skrótów niską implementacji funkcji skrótu, wydajność wyszukiwania zależy od liczby elementów w tablicy skrótów (na przykład operacji O('n'), gdzie "n" to liczba elementów w tablicy skrótów). Złośliwy użytkownik może wprowadzić dane, które zwiększa liczbę konfliktów, które mogłoby znacznie pogorszyć wydajność aplikacji, które są zależne od tabelach skrótów, w następujących warunkach: — funkcje skrótu utworzyć częste kolizji.  — Gdy duża część obiektów w tablicy skrótów utworzyć skrótu, które są takie same lub równy około ze sobą.  — Użytkownicy wprowadzania danych, z którego jest obliczana wartość skrótu.  Klasy, które zastępują pochodne <see cref="M:System.Object.GetHashCode" /> musi także zastępować metodę <see cref="M:System.Object.Equals(System.Object)" /> aby zagwarantować, że dwa obiekty traktowane jako równe mają taki sam skrót; w przeciwnym razie <see cref="T:System.Collections.Hashtable" /> typu może nie działać poprawnie.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> bieżącego wystąpienia.</summary>
        <returns>Typ środowiska uruchomieniowego dokładne bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Object?displayProperty=nameWithType> jest klasą bazową dla wszystkich typów w systemie typów .NET Framework, <xref:System.Object.GetType%2A> metody można użyć do zwrócenia <xref:System.Type> obiektów, które reprezentują wszystkie typy .NET Framework. .NET Framework rozpoznaje następujących kategorii pięć typów:  
  
-   Klasy, które są pochodnymi <xref:System.Object?displayProperty=nameWithType>,  
  
-   Typy, które pochodzą z wartości <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfejsy, które są pochodnymi <xref:System.Object?displayProperty=nameWithType> w programie .NET Framework 2.0.  
  
-   Wyliczenia, które są pochodnymi <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegatów, które są pochodnymi <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Dla dwóch obiektów `x` i `y` zawierających typy identyczne środowisko uruchomieniowe `Object.ReferenceEquals(x.GetType(),y.GetType())` zwraca `true`. W poniższym przykładzie użyto <xref:System.Object.GetType%2A> metody z <xref:System.Object.ReferenceEquals%2A> metodę, aby określić, czy jedną wartość liczbowa jest taki sam typ jak dwóch wartości liczbowych.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Aby ustalić, czy obiekt jest określonego typu, można użyć słowa kluczowego porównania typu swój język lub utworzenia. Na przykład można użyć `TypeOf…Is` utworzyć w języku Visual Basic lub `is` — słowo kluczowe języka C#.  
  
 <xref:System.Object.GetType%2A> Metody jest dziedziczona przez wszystkie typy, które pochodzą z <xref:System.Object>. Oznacza to, że oprócz za pomocą słowa kluczowego porównania własnym języku, możesz użyć <xref:System.Object.GetType%2A> metodę, aby określić typ określonego obiektu, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type> Obiekt udostępnia metadane skojarzone z klasą bieżącego <xref:System.Object>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Object.GetType%2A> zwraca typ środowiska uruchomieniowego bieżącego wystąpienia.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną bieżącego <see cref="T:System.Object" />.</summary>
        <returns>Skrócona kopię bieżącego <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> Metoda tworzy kopię pobieżną przez utworzenie nowego obiektu, a następnie skopiować niestatycznego pola z bieżącego obiektu do nowego obiektu. Jeśli pole jest typu wartości, jest wykonywane kopii bitowej przez bitowej pola. Jeśli pole jest typem referencyjnym, odwołanie jest kopiowana, ale określony obiekt jest; w związku z tym oryginalny obiekt i jego klon odwoływać się do tego samego obiektu.  
  
 Rozważmy na przykład obiekt o nazwie X, który z kolei odwołuje się obiekty A i B. obiektu B, obiekt odwołania C. Kopia pobieżna wartości X tworzy nowy obiekt X2 również odwołujących się do obiektów, A i B. Z kolei głęboką kopię X tworzy nowy obiekt X2, który odwołuje się do nowych obiektów A2 i B2, które są kopiami A i B. B2, z kolei odwołuje się do nowego obiektu C2, który jest kopią C. Różnica między małym i operacji kopiowania głębokie pokazano w przykładzie.  
  
 Istnieje wiele sposobów implementuje operacji kopiowania głębokie, jeśli operacja kopiowania skrócona wykonywane przez <xref:System.Object.MemberwiseClone%2A> metody odpowiada Twoim potrzebom. Należą do nich między innymi:  
  
-   Wywołanie konstruktora klasy obiektu, który ma zostać skopiowany na utworzyć drugi obiekt z wartościami właściwości pobierane z pierwszego obiektu. Przy założeniu, że wartości obiektu są całkowicie zdefiniowane przez jego konstruktora klasy.  
  
-   Wywołanie <xref:System.Object.MemberwiseClone%2A> metodę, aby utworzyć kopię pobieżną obiektu, a następnie przypisz nowe obiekty, których wartości są takie same jak oryginalne obiektu właściwości lub pól, których wartości są typy referencyjne. `DeepCopy` Metody w tym przykładzie przedstawiono tej metody.  
  
-   Serializacji obiektu za głębokie skopiowane, a następnie przywróć dane serializowane zmiennej innego obiektu.  
  
-   Za pomocą odbicia rekursji do wykonania tej operacji kopiowania bezpośrednich.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Object.MemberwiseClone%2A> metody. Definiuje `ShallowCopy` — metoda, która wywołuje <xref:System.Object.MemberwiseClone%2A> metody podczas operacji kopiowania skrócona `Person` obiektu. Definiuje również `DeepCopy` metodę, która wykonuje operację kopiowania głębokie na `Person` obiektu.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 W tym przykładzie `Person.IdInfo` zwraca właściwość `IdInfo` obiektu. Jako dane wyjściowe w przykładzie pokazano gdy `Person` obiekt został sklonowany, wywołując <xref:System.Object.MemberwiseClone%2A> metoda, sklonowany `Person` obiekt jest niezależna kopia oryginalnego obiektu, z wyjątkiem tego, aby miały taki sam `Person.IdInfo` obiektu odwołania. W związku z tym modyfikowanie klonu `Person.IdInfo` zmiany właściwości obiektu oryginalnego `Person.IdInfo` właściwości. Z drugiej strony, podczas operacji kopiowania głębokie jest wykonywana, sklonowany `Person` obiektu, łącznie z jej `Person.IdInfo` właściwość, może być modyfikowana bez wpływu na oryginalny obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="objB">Drugi obiekt do porównania.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> wystąpienia są tego samego wystąpienia.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="objA" /> jest tym samym wystąpieniu jako <paramref name="objB" /> lub obu ** null **; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Object.Equals%2A> — metoda i operator równości <xref:System.Object.ReferenceEquals%2A> metoda nie może zostać zastąpiona. W związku z tym, jeśli chcesz przetestować dwa obiektu odwołania równości i nie wiesz o implementacji `Equals` metody należy wywołać <xref:System.Object.ReferenceEquals%2A> metody.  
  
 Jednak wartość zwracaną <xref:System.Object.ReferenceEquals%2A> metoda może być wyświetlana nietypowych w tych dwóch scenariuszy:  
  
-   Podczas porównywania typów wartości. Jeśli `objA` i `objB` są typy wartości, są one opakowany przed ich do <xref:System.Object.ReferenceEquals%2A> metody. Oznacza to, że jeśli obie `objA` i `objB` reprezentują tego samego wystąpienia typu wartości <xref:System.Object.ReferenceEquals%2A> metoda niemniej zwraca `false`, jak pokazano na poniższym przykładzie.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Informacje o typach wartości pakującej, zobacz [opakowywanie i rozpakowywanie](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Podczas porównywania ciągów. Jeśli `objA` i `objB` są ciągami, <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` Jeśli ciąg jest interned. Nie wykonuje testu równości wartości.  W poniższym przykładzie `s1` i `s2` są takie same, ponieważ są one dwa wystąpienia jednego ciągu interned. Jednak `s3` i `s4` nie są takie same, ponieważ mimo że mają identyczne ciągami, ten ciąg jest nie interned.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Aby uzyskać więcej informacji o ciągu interning, zobacz <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Object.ReferenceEquals%2A> do ustalenia, czy dwa obiekty są tego samego wystąpienia.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje bieżący obiekt.</summary>
        <returns>Ciąg, który reprezentuje bieżący obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> głównych formatuje metody w programie .NET Framework. Konwertuje obiekt do reprezentacji ciągu tak, aby odpowiednie do wyświetlenia. (Informacje na temat formatowania pomocy technicznej w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).) Domyślne implementacje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca w pełni kwalifikowana nazwa typu obiektu.  
  
> [!IMPORTANT]
>  Osiągnięto tej strony, klikając łącze z listy elementów członkowskich innego typu. Wynika to z tego typu nie przesłania <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Zamiast tego dziedziczy funkcjonalność <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.  
  
 Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę w celu zapewnienia bardziej odpowiednie reprezentację ciągu określonego typu. Typy również często przeciążenia <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby zapewnić obsługę dla ciągi formatów lub formatowania zależne od kultury.  
  
 W tej sekcji:  
  
 [Domyślną metodą Object.ToString()](#Default)   
 [Zastąpienie metody Object.ToString()](#Overriding)   
 [Przeładowanie metody ToString](#Overloading)   
 [Rozszerzanie Object.ToString — metoda](#Extending)   
 [Uwagi dla środowiska uruchomieniowego systemu Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Domyślną metodą Object.ToString()  
 Domyślna implementacja <xref:System.Object.ToString%2A> metoda zwraca w pełni kwalifikowana nazwa typu <xref:System.Object>, jak pokazano na poniższym przykładzie.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Ponieważ <xref:System.Object> jest klasą bazową dla wszystkich typów odwołań w programie .NET Framework to zachowanie jest dziedziczone przez typy odwołań, które nie zastępują <xref:System.Object.ToString%2A> metody. Ilustruje to poniższy przykład. Definiuje klasę o nazwie `Object1` która akceptuje domyślną implementację wszystkich <xref:System.Object> elementów członkowskich. Jego <xref:System.Object.ToString%2A> metoda zwraca obiekt, w pełni kwalifikowaną nazwę typu.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Zastąpienie metody Object.ToString()  
 Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg reprezentujący wystąpienie obiektu. Na przykład, takich jak podstawowym typy <xref:System.Char>, <xref:System.Int32>, i <xref:System.String> podaj <xref:System.Object.ToString%2A> implementacji, które zwracają wartość, która reprezentuje obiekt formę ciągu. W poniższym przykładzie zdefiniowano klasę, `Object2`, która zastępuje <xref:System.Object.ToString%2A> metodę, aby zwrócić nazwę typu wraz z jego wartość.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 W poniższej tabeli wymieniono kategorie typów w programie .NET Framework i wskazuje, czy zastępują one <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.  
  
|Typ kategorii|Zastępuje Object.ToString()|Zachowanie|  
|-------------------|-----------------------------------|--------------|  
|Class|n/d|n/d|  
|Struktura|Tak (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identyczny Object.ToString()|  
|Wyliczenie|Tak (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Nazwa elementu członkowskiego|  
|Interface|Nie|n/d|  
|Delegate|Nie|n/d|  
  
 Zobacz uwagi dotyczące obiektów dziedziczących sekcji, aby uzyskać dodatkowe informacje na zastępowanie <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Przeładowanie metody ToString  
 Oprócz zastępowania bez parametrów <xref:System.Object.ToString?displayProperty=nameWithType> przeciążyć wiele typów metody `ToString` metodę w celu zapewnienia wersji metody, które akceptują parametrów. Najczęściej jest to realizowane zapewnienie wsparcia dla zmiennej formatowania i formatowania zależne od kultury.  
  
 Następujący przykład przeciążeń `ToString` metoda zwraca ciąg wynik, która zawiera wartości różnych pól `Automobile` klasy. Definiuje cztery ciągi formatu: G, która zwraca nazwę modelu i roku; D, który zwraca nazwę modelu, rok i liczba drzwi; C, która zwraca nazwę modelu, rok i liczba cylindrów; i A, która zwraca ciąg zawierający wszystkie cztery pola wartości.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Poniższy przykład wywołuje przeciążone <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę, aby wyświetlić zależne od kultury formatowania wartości waluty.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Aby uzyskać więcej informacji na ciągi formatów i formatowanie zależne od kultury, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md). Ciągi formatu, obsługiwane przez wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu, obsługiwane przez wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Rozszerzanie Object.ToString — metoda  
 Ponieważ typ dziedziczy domyślnie <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, można znaleźć jego zachowanie niepożądanych i chcesz je zmienić. Jest to szczególnie istotne, tablic i klasy kolekcji. Gdy może oczekiwać `ToString` metody tablicą lub kolekcją klasy do wyświetlenia wartości jego elementów członkowskich, zamiast tego Wyświetla typu w pełni kwalifikowana nazwa typu, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Masz kilka opcji ciąg wynik, który chcesz utworzyć.  
  
-   Jeśli typ jest tablicą, obiekt kolekcji lub obiekt, który implementuje <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601> interfejsów, jego elementy można wyliczać za pomocą `foreach` instrukcji w języku C# lub `For Each...Next` utworzyć w języku Visual Basic.  
  
-   Jeśli klasa nie jest `sealed` (w języku C#) lub `NotInheritable` (w języku Visual Basic), można utworzyć klasy otoki, która dziedziczy po klasie podstawowej, którego <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, które chcesz dostosować. Co najmniej wymaga, należy wykonać następujące czynności:  
  
    1.  Implementuje wszelkie niezbędne konstruktorów. Klasy pochodne nie dziedziczą ich konstruktorów klasy podstawowej.  
  
    2.  Zastąpienie <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg wyniku, który ma.  
  
     W poniższym przykładzie zdefiniowano klasę otoki dla <xref:System.Collections.Generic.List%601> klasy. Zastępuje on <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby wyświetlić wartość każdej metody kolekcji, a nie w pełni kwalifikowaną nazwę typu.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Tworzenie [— metoda rozszerzenia](~/docs/standard/design-guidelines/extension-methods.md) zwracającą ciąg wyniku, który ma. Należy pamiętać, że nie można zastąpić domyślną <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w ten sposób (oznacza to, z rozszerzenia klasy (w języku C#) lub modułu (w języku Visual Basic) nie może mieć bez parametrów metodę o nazwie `ToString` jest to zamiast oryginalnego typu `ToString` — metoda . Musisz podać inną nazwę dla użytkownika bez parametrów `ToString` zastąpienia.  
  
     W poniższym przykładzie zdefiniowano dwie metody, które rozszerzają <xref:System.Collections.Generic.List%601> klasy: bez parametrów `ToString2` metody, a `ToString` metody z <xref:System.String> parametr, który reprezentuje ciąg formatu.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Podczas wywoływania <xref:System.Object.ToString%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastępują <xref:System.Object.ToString%2A>. To jest częścią programu .NET Framework zapewnia obsługę [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje dla aplikacji ze Sklepu Windows i środowiska wykonawczego systemu Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>i nie zawsze implementują <xref:System.Object.ToString%2A>. Jednak zawsze były wyświetlane mają <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy ich używać w kodzie C# lub Visual Basic i .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], będzie używana przez środowisko uruchomieniowe języka wspólnego [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) na [!INCLUDE[wrt](~/includes/wrt-md.md)] obiektu przed powrotem do domyślną implementację elementu <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które są napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.ToString%2A> metody.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] i interfejsu IStringable  
 Począwszy od [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] obejmuje [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejs którego pojedynczej metody [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), zapewnia podstawową obsługę formatowania porównywalna do dostarczone przez <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Aby uniknąć niejednoznaczności, nie powinny implementować [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) na typy zarządzane.  
  
 Kiedy obiekty zarządzane są wywoływane przez kod natywny lub kod napisany w językach takich jak JavaScript lub C + +/ CX, pojawią się one do zaimplementowania [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Środowisko uruchomieniowe języka wspólnego automatycznie będzie przekierowywać wywołania z [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) do <xref:System.Object.ToString%2A?displayProperty=nameWithType> zdarzeń [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie został zaimplementowany dla obiekt zarządzany.  
  
> [!WARNING]
>  Ponieważ środowisko uruchomieniowe języka wspólnego auto implementuje [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) wszystkie typy w zarządzane [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji, firma Microsoft zaleca, że nie podano własne [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacji. Implementowanie [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) może spowodować niezamierzone zachowanie podczas wywoływania metody `ToString` z [!INCLUDE[wrt](~/includes/wrt-md.md)], C + +/ CX lub JavaScript.  
  
 Jeśli chcesz wdrożyć [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w publicznych typu zarządzanego wyeksportowany w [!INCLUDE[wrt](~/includes/wrt-md.md)] składnika, obowiązują następujące ograniczenia:  
  
-   Można zdefiniować [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejsu tylko w relacji "implementuje klasy", takie jak  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     w języku C# lub  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     w języku Visual Basic.  
  
-   Nie można zaimplementować [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w interfejsie.  
  
-   Nie można zadeklarować parametr będzie typu [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie może być zwracany typ metody, właściwości lub pola.  
  
-   Nie można ukryć Twojej [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacja klas podstawowych za pomocą definicji metody, takie jak następujące:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Zamiast tego [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) zawsze musi zastąpić implementacji klasy podstawowej. Można ukryć `ToString` implementacji tylko przy wywoływaniu wystąpienie silnie typizowanej klasy.  
  
 Należy pamiętać, że w różnych warunkach, wywołuje z kodu natywnego do zarządzanego typu, który implementuje [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) lub ukrywa jego [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementacja może spowodować nieoczekiwane zachowanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Po zaimplementowaniu własnych typów powinny zastępować <see cref="M:System.Object.ToString" /> metody, aby zwrócić wartości, które są przydatne w przypadku tych typów. Pochodzi z klasy, które wymagają większą kontrolę nad formatowanie niż <see cref="M:System.Object.ToString" /> zapewnia można zaimplementować <see cref="T:System.IFormattable" /> interfejsu. Jego <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> — metoda umożliwia definiowanie ciągi formatów, które kontrolują, formatowanie i użyj <see cref="T:System.IFormatProvider" /> obiekt, który może dostarczyć do formatowania specyficzne dla kultury.  Zastępuje z <see cref="M:System.Object.ToString" /> metody należy przestrzegać następujących wytycznych:-zwracany ciąg powinny być przyjazne i czytelna dla człowieka.  -Zwracany ciąg musi jednoznacznie wskazywać wartość wystąpienia obiektu.  -Zwracany ciąg powinna być możliwie krótki, aby była ona odpowiednią do wyświetlania przez debuger.  - <see cref="M:System.Object.ToString" /> Zastąpienie nie może zwracać <see cref="F:System.String.Empty" /> lub pusty ciąg.  - <see cref="M:System.Object.ToString" /> Zastąpienie nie powinien zgłosić wyjątek.  -Reprezentację ciągu wystąpienia jest zależne od kultury lub być sformatowane na różne sposoby, należy wdrożyć <see cref="T:System.IFormattable" /> interfejsu.  — Jeśli zwracany ciąg zawiera poufne informacje, należy najpierw wymaga odpowiednich uprawnień. Jeśli żądanie zakończy się powodzeniem, można powrócić poufne informacje; w przeciwnym razie powinien zwrócić ciąg, który nie obejmuje informacji poufnych.  - <see cref="M:System.Object.ToString" /> Zastąpienie powinien mieć żadnych efektów ubocznych zauważalne, aby uniknąć komplikacji w debugowaniu. Na przykład wywołanie <see cref="M:System.Object.ToString" /> — metoda nie należy zmieniać wartości pól wystąpień.  — Jeśli Twoje typ implementuje metodę analizowania (lub <see langword="Parse" /> lub <see langword="TryParse" /> metody, konstruktora lub niektóre statyczną metodę, która tworzy wystąpienie tego typu z ciągu), należy upewnić się, że długość ciągu zwróconego przez <see cref="M:System.Object.ToString" /> może być — metoda przekonwertować na wystąpienie obiektu.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
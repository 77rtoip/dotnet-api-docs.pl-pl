<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="3575d47a0ba065e8986f03d99279f478811907b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="05/20/2019" /><Meta Name="ms.locfileid" Value="65922726" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Obsługuje wszystkie klasy w hierarchię klas .NET i zapewnia niskopoziomowe usługi dla klas pochodnych. Jest to ultimate klasę bazową dla wszystkich klas .NET; jest głównym hierarchii typów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Języki zazwyczaj nie wymagają do deklarowania dziedziczenie z klasy <xref:System.Object> ponieważ dziedziczenia jest niejawne.  
  
 Ponieważ wszystkie klasy w środowisku .NET pochodzą od <xref:System.Object>, każdej metody zdefiniowane w <xref:System.Object> klasy jest dostępny w wszystkich obiektów w systemie. Pochodne klasy może i zastąpić niektóre z tych metod, w tym:  
  
-   <xref:System.Object.Equals%2A> — Obsługuje porównania między obiektami.  
  
-   <xref:System.Object.Finalize%2A> -Wykonuje operacje oczyszczania, zanim obiekt jest automatycznie odzyskiwane.  
  
-   <xref:System.Object.GetHashCode%2A> — Generuje numer odpowiadający wartości obiektu, aby obsługiwały korzystanie tabelę mieszania.  
  
-   <xref:System.Object.ToString%2A> -Produkuje ciąg czytelny dla człowieka tekst, który opisuje wystąpienia klasy.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 W przypadku projektowania klasy, takie jak pamięci, który musi obsługiwać obiekty dowolnego typu, możesz utworzyć składowych klasy, które akceptują wystąpień <xref:System.Object> klasy. Jednak proces pakowania i rozpakowywania typu niesie ze sobą spadek wydajności. Jeśli wiesz, że nowej klasie często będzie obsługiwać niektórych typów wartości, można użyć jednej z dwóch taktyka zmniejszyć koszty pakowania.  
  
-   Metoda ogólna, która akceptuje tworzenie <xref:System.Object> typ i zestaw przeciążenia metody specyficzne dla typu, które akceptują każdego typu wartości oczekujesz, że klasa często obsługi. Jeśli metoda specyficznych dla typu istnieje akceptującego wywoływania typ parametru, opakowywanie nie występuje i wywoływana jest metoda specyficznych dla typu. Jeśli nie ma żadnego argumentu metody wywołania typu parametru, parametr jest spakowany i ogólne metoda jest wywoływana.  
  
-   Zaprojektuj danego typu i jej elementów członkowskich, używaj typów ogólnych. Środowisko uruchomieniowe języka wspólnego tworzy zamknięty typ ogólny, podczas tworzenia wystąpienia klasy i określić argument typu ogólnego. Usuwa metodę rodzajową jest specyficzny dla typu i może być wywołana bez konwersja boxing parametru wywoływania.  
  
 Chociaż czasami jest to niezbędne do tworzenia klasy ogólnego przeznaczenia, które akceptują i zwracają <xref:System.Object> typów, może poprawić wydajność, jednocześnie zapewniając specyficznych dla typu klasy do obsługi często używanych typów. Na przykład zapewniając klasy, które są specyficzne dla ustawiania i pobierania wartości logicznych eliminuje koszt pakowania, jak i rozpakowania wartościami logicznymi.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano typ punktu pochodzący od <xref:System.Object> klasy i zastępuje wiele metod wirtualnych <xref:System.Object> klasy. Ponadto w przykładzie pokazano sposób wywoływania wiele statycznych lub wystąpienie metody <xref:System.Object> klasy.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Elementy członkowskie wystąpień nie musi być metodą o bezpiecznych wątkach.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Object" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez konstruktory w klasach pochodnych, ale może również służyć do bezpośrednio utworzyć wystąpienia <xref:System.Object> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa wystąpienia obiektu są sobie równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony obiekt jest równy bieżącemu obiektowi.</summary>
        <returns><see langword="true" /> Jeśli określony obiekt jest taki sam, jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ porównania między bieżącym wystąpieniu i `obj` parametru zależy od tego, czy bieżące wystąpienie jest typem referencyjnym lub typem wartości.  
  
-   Jeśli bieżące wystąpienie jest typem referencyjnym <xref:System.Object.Equals%28System.Object%29> metody testów dla równości odwołań i wywołania <xref:System.Object.Equals%28System.Object%29> metoda jest równoważna do wywołania <xref:System.Object.ReferenceEquals%2A> metody. Równość odniesienia oznacza, że zmienne obiektów, które są porównywane odnoszą się do tego samego obiektu. Poniższy przykład ilustruje wynik takie porównania. Definiuje `Person` klasy, która jest typem referencyjnym, i wywołuje `Person` konstruktora klasy utworzyć dwie nowe `Person` obiektów `person1a` i `person2`, które mają taką samą wartość. Również przypisuje `person1a` do innej zmiennej obiektu, `person1b`. Jak wynika z w przykładzie pokazano `person1a` i `person1b` są takie same, ponieważ mogą odwoływać się do tego samego obiektu. Jednak `person1a` i `person2` nie są takie same, ale mają taką samą wartość.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Jeśli bieżące wystąpienie jest typem wartości <xref:System.Object.Equals%28System.Object%29> metoda testy na równoważność wartości. Równość wartości oznacza, że następujące czynności:  
  
    -   Dwa obiekty są tego samego typu. Jak pokazano na poniższym przykładzie, <xref:System.Byte> obiekt, który ma wartość 12 nie jest równa <xref:System.Int32> obiekt, który zawiera wartość 12, ponieważ oba obiekty mają różne typy środowiska wykonawczego.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Wartości pól publiczne i prywatne dwa obiekty są równe. Następujący przykład sprawdza pod kątem równości wartości. Definiuje `Person` struktury, która jest typem wartości, i wywołuje `Person` konstruktora klasy utworzyć dwie nowe `Person` obiektów `person1` i `person2`, które mają taką samą wartość. Dane wyjściowe z przykładu pokazują, mimo że zmienne dwóch obiektów odnoszą się do różnych obiektów, `person1` i `person2` są takie same, ponieważ mają tę samą wartość dla prywatnego `personName` pola.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Ponieważ <xref:System.Object> klasy jest klasą bazową dla wszystkich typów w .NET Framework <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metoda zawiera porównanie równości domyślnego dla wszystkich innych typów. Jednak często zastępują typy <xref:System.Object.Equals%2A> metody do zaimplementowania równość wartości. Aby uzyskać więcej informacji, zobacz uwagi dla wywołań i uwagi dotyczące obiektów dziedziczących sekcji.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Gdy wywołujesz <xref:System.Object.Equals%28System.Object%29> przeciążenie metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.Equals%28System.Object%29>. Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a aktualnie nie implementują <xref:System.Object.Equals%28System.Object%29> metody. Jednak wydają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.Equals%28System.Object%29> przeciążenie metody.  
  
## <a name="notes-for-callers"></a>Uwagi dotyczące wywoływania  
 Klasy pochodne często zastąpić <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do zaimplementowania równość wartości. Ponadto typy zapewniają również często dodatkowe przeładowania silnie typizowaną `Equals` metody, zwykle przez zaimplementowanie <xref:System.IEquatable%601> interfejsu. Gdy wywołujesz `Equals` metody do testowania pod kątem równości, należy sprawdzić, czy bieżące wystąpienie zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType> i zrozumieć, w jaki sposób wywołania określonej `Equals` metody nie zostanie rozwiązany. W przeciwnym razie możesz pod kątem równości, która różni się od zamierzonym wykonywania testu, a metoda może zwrócić nieoczekiwaną wartość.  
  
 Poniższy przykład stanowi ilustrację. Metoda tworzy trzy <xref:System.Text.StringBuilder> obiekty z identycznych ciągów, a następnie udostępnia cztery wywołania `Equals` metody. Pierwsza metoda wywołania zwraca `true`oraz pozostałych trzech powrotu `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 W pierwszym przypadku silnie typizowaną <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> przeciążenia metody, które testy na równoważność wartości, jest wywoływana. Ponieważ ciągi przypisana do dwóch <xref:System.Text.StringBuilder> obiekty są równe, metoda zwraca `true`. Jednak <xref:System.Text.StringBuilder> nie zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. W związku z tym gdy <xref:System.Text.StringBuilder> obiekt jest rzutowany <xref:System.Object>, gdy <xref:System.Text.StringBuilder> wystąpienia jest przypisywany do zmiennej typu <xref:System.Object>i kiedy <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metoda przechodzi przez dwa <xref:System.Text.StringBuilder> obiektów, domyślne <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>metoda jest wywoływana. Ponieważ <xref:System.Text.StringBuilder> jest typem odwołania, jest to równoważne do przekazywania dwóch <xref:System.Text.StringBuilder> obiekty do <xref:System.Object.ReferenceEquals%2A> metody. Mimo że wszystkie trzy <xref:System.Text.StringBuilder> obiekty zawierają identyczne ciągi, odnoszą się do trzech różnych obiektów. W wyniku tych trzech metoda wywołuje zwracany `false`.  
  
 Możesz porównać bieżącego obiektu do innego obiektu równości odwołań, wywołując <xref:System.Object.ReferenceEquals%2A> metody. W języku Visual Basic umożliwia także `is` — słowo kluczowe (na przykład `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Uwagi dotyczące obiektów dziedziczących  
 Podczas definiowania swój własny typ tego typu dziedziczy funkcje zdefiniowane przez `Equals` metoda jego typ podstawowy. W poniższej tabeli wymieniono domyślna Implementacja klasy `Equals` metodę dla głównych kategorii typów w .NET Framework.  
  
|Kategoria typów|Równość zdefiniowane przez|Komentarze|  
|-------------------|-------------------------|--------------|  
|Klasa pochodzi bezpośrednio z <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Równość odniesienia; równoważne z wywoływaniem <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struktura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Równość wartości; bezpośrednie porównanie bajt po bajcie lub pola przez porównanie przy użyciu odbicia.|  
|Wyliczenie|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Wartości muszą mieć ten sam typ wyliczeniowy i tej samej podstawowej wartości.|  
|Delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegaty musi mieć tego samego typu przy użyciu list identyczne wywołania.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Równość odniesienia.|  
  
 Dla typu wartości powinny zawsze zastępuje <xref:System.Object.Equals%2A>, ponieważ testuje pod kątem równości, które działają na podstawie odbicia oferują pogorszenia wydajności. Możesz również zastąpić domyślną implementację elementu <xref:System.Object.Equals%2A> dla typów odwołań do testowania pod kątem równości wartości, a nie równości odwołań i zdefiniuj znaczenie równości wartość. Takie implementacje <xref:System.Object.Equals%2A> zwracają `true` Jeśli dwa obiekty mają taką samą wartość, nawet jeśli nie są tego samego wystąpienia. Typ implementujący decyduje, co stanowi wartość obiektu, ale zazwyczaj jest niektóre lub wszystkie dane przechowywane w zmiennych wystąpienia obiektu. Na przykład, wartość <xref:System.String> obiektu opiera się na znaki ciągu; <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> zastąpienia metody <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, aby zwrócić `true` dla każdego ciągu dwa wystąpienia, które zawierają te same znaki w tej samej kolejności.  
  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody do testowania pod kątem równości wartości. Zastępuje ona <xref:System.Object.Equals%2A> metodę `Person` klasy. Jeśli `Person` zaakceptowane implementację jej klasy bazowej równości, dwa `Person` obiekty są takie same, tylko wtedy, gdy ich odwołanie do pojedynczego obiektu. Jednak w tym przypadku dwa `Person` obiekty są takie same, jeśli mają taką samą wartość `Person.Id` właściwości.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Oprócz zastępowania <xref:System.Object.Equals%2A>, można zaimplementować <xref:System.IEquatable%601> interfejsu zapewnienie silnie typizowaną test pod kątem równości.  
  
 Poniższe instrukcje muszą być prawdziwe dla wszystkich implementacjach <xref:System.Object.Equals%28System.Object%29> metody. Na liście `x`, `y`, i `z` reprezentują odwołania do obiektów, które nie są **null**.  
  
-   `x.Equals(x)` Zwraca `true`, z wyjątkiem przypadków obejmujących typów zmiennoprzecinkowych. Zobacz [60559:2011 ISO/IEC/IEEE, arytmetyki zmiennoprzecinkowej technologii — procesor systemów — informacji](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` zwraca taką samą wartość jak `y.Equals(x)`.  
  
-   `x.Equals(y)` Zwraca `true` Jeśli oba `x` i `y` są `NaN`.  
  
-   Jeśli `(x.Equals(y) && y.Equals(z))` zwraca `true`, następnie `x.Equals(z)` zwraca `true`.  
  
-   Kolejne wywołania `x.Equals(y)` zwracają taką samą wartość, tak długo, jak odwołuje się do niego obiekty `x` i `y` nie są modyfikowane.  
  
-   `x.Equals(null)` Zwraca `false`.  
  
 Implementacje <xref:System.Object.Equals%2A> nie może zgłaszać wyjątków, należy zawsze zwracają wartość. Na przykład jeśli `obj` jest `null`, <xref:System.Object.Equals%2A> metoda powinna zwrócić `false` zamiast zgłaszać <xref:System.ArgumentNullException>.  
  
 Przestrzegać następujących wytycznych podczas zastępowania <xref:System.Object.Equals%28System.Object%29>:  
  
-   Typami, które implementują <xref:System.IComparable> przesłonięcie <xref:System.Object.Equals%28System.Object%29>.  
  
-   Typy zastąpienie <xref:System.Object.Equals%28System.Object%29> jest również przesłonięcie <xref:System.Object.GetHashCode%2A>; w przeciwnym razie tabele skrótów mogą nie działać poprawnie.  
  
-   Należy rozważyć wdrożenie <xref:System.IEquatable%601> interfejsu do obsługi silnie typizowane testuje pod kątem równości. Twoje <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementacji powinna zwrócić wyniki, które są zgodne z <xref:System.Object.Equals%2A>.  
  
-   Jeśli język programowania obsługuje przeciążania operatorów i przeciążaj operator równości dla danego typu, konieczne jest również przesłonięcie <xref:System.Object.Equals%28System.Object%29> metodę, aby zwracać ten sam wynik jako operatora równości. Pozwala to zagwarantować, że kod biblioteki klasy, który używa <xref:System.Object.Equals%2A> (takie jak <xref:System.Collections.ArrayList> i <xref:System.Collections.Hashtable>) zachowuje się w taki sposób, który jest spójny ze sposobem operatora równości jest używany przez kod aplikacji.  
  
### <a name="guidelines-for-reference-types"></a>Wytyczne dla typów odwołania  
 Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu odwołania:  
  
-   Należy wziąć pod uwagę zastępowanie <xref:System.Object.Equals%2A> w przypadku semantykę typu opiera się na fakcie, że typ reprezentuje niektóre wartości.  
  
-   Większość typów referencyjnych musi przeciążaj operator równości, nawet wtedy, gdy zastępują one <xref:System.Object.Equals%2A>. Jednak przed zaimplementowaniem typ odwołania, który jest przeznaczona do ma semantyki wartości, takie jak typ liczby zespolonej, konieczne jest przesłonięcie operatora równości.  
  
-   Nie należy zastąpić <xref:System.Object.Equals%2A> na modyfikowalnego typu referencyjnego. Jest to spowodowane zastępowanie <xref:System.Object.Equals%2A> wymaga, że możesz także Przesłoń <xref:System.Object.GetHashCode%2A> metodę, zgodnie z opisem w poprzedniej sekcji. Oznacza to, że skrótu wystąpienia typu referencji zmiennej można zmienić jego okres istnienia, co może powodować obiekt do utracone w tabeli wyznaczania wartości skrótu.  
  
### <a name="guidelines-for-value-types"></a>Wytyczne dla typów wartości  
 Poniższe wskazówki dotyczą zastępowanie <xref:System.Object.Equals%28System.Object%29> dla typu wartości:  
  
-   Jeśli określasz typ wartości, która zawiera co najmniej jedno pole, których wartości są typami odwołań, należy zastąpić <xref:System.Object.Equals%28System.Object%29>. <xref:System.Object.Equals%28System.Object%29> Wdrażania udostępniane przez <xref:System.ValueType> wykonuje porównanie bajt po bajcie, dla typów wartości, których pola są wszystkie typy wartości, ale używa odbicia porównania przez pole z typów wartości, których pola zawierają typy odwołań.  
  
-   Jeśli zastąpisz <xref:System.Object.Equals%2A> i języka programowania obsługuje przeładowania operatora, muszą przeciążać operatora równości.  
  
-   Należy zaimplementować <xref:System.IEquatable%601> interfejsu. Wywoływanie silnie typizowaną <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metoda pozwala uniknąć pakowania `obj` argumentu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `Point` klasę, która zastępuje <xref:System.Object.Equals%2A> metody w celu zapewnienia równość wartości i `Point3D` klasy, która jest pochodną `Point`. Ponieważ `Point` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> do testowania pod kątem równości wartość <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> nie jest wywoływana metoda. Jednak `Point3D.Equals` wywołania `Point.Equals` ponieważ `Point` implementuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> w taki sposób, który zapewnia równość wartości.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals` Metoda sprawdza, upewnij się, że `obj` argument nie jest **null** oraz że odwołuje się do wystąpienia tego samego typu jak ten obiekt. Jeśli sprawdzenie zakończy się niepowodzeniem, metoda zwraca `false`.  
  
 `Point.Equals` Wywołania metody <xref:System.Object.GetType%2A> metodę pozwala ustalić, czy typów w czasie wykonywania dwa obiekty są jednakowe. Jeśli metoda wyboru w formularzu `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic zwróci wyboru `true` w przypadkach, gdzie `obj` to wystąpienie klasy pochodnej `Point`, nawet jeśli `obj` i bieżący wystąpienia nie mają tego samego typu run-time. Po zweryfikowaniu, że oba obiekty są tego samego typu rzutowania metoda `obj` na typ `Point` i zwraca wynik porównania pól wystąpienia dwóch obiektów.  
  
 W `Point3D.Equals`, dziedziczonego `Point.Equals` metody, która zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, jest wywoływany przed odbywa się inaczej. Ponieważ `Point3D` jest Klasa zapieczętowana (`NotInheritable` w języku Visual Basic), wyboru w formularzu `obj is Point` w języku C# lub `TryCast(obj, Point)` w języku Visual Basic jest odpowiednia do upewnij się, że `obj` jest `Point3D` obiektu. Jeśli jest `Point3D` obiektu jest rzutowany na `Point` obiektu i przekazywane do implementacji klasy podstawowej <xref:System.Object.Equals%2A>. Tylko wtedy, gdy dziedziczonego `Point.Equals` metoda zwraca `true` jest porównanie metody `z` wystąpienia pól wprowadzonych w klasie pochodnej.  
  
 W poniższym przykładzie zdefiniowano `Rectangle` klasę implementującą wewnętrznie prostokąta jako dwa `Point` obiektów. `Rectangle` Również klasy zastąpienia <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> zapewnienie na równoważność wartości.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Niektóre języki, takich jak C# i Visual Basic obsługują przeciążanie operatora. Gdy typem przeciążenia operatora równości, również należy zastąpić <xref:System.Object.Equals%28System.Object%29> metody, aby udostępnić taką samą funkcjonalność. Zazwyczaj jest to osiągane przez napisanie <xref:System.Object.Equals%28System.Object%29> metoda pod względem operatora równości przeciążona, jak w poniższym przykładzie.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Ponieważ `Complex` jest typem wartości nie mogą pochodzić z.  W związku z tym, zastąpienie tak, aby <xref:System.Object.Equals%28System.Object%29> metody nie muszą wywoływać <xref:System.Object.GetType%2A> ustalenie dokładne czasu wykonywania typ każdego obiektu, ale możesz zamiast tego użyj `is` operatora w języku C# lub `TypeOf` operatora w języku Visual Basic, aby sprawdzić typ `obj` parametru.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="objB">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy wystąpienia określonego obiektu są uważane za równe.</summary>
        <returns><see langword="true" /> Jeśli obiekty są traktowane jako równe; w przeciwnym razie <see langword="false" />. Jeśli oba <paramref name="objA" /> i <paramref name="objB" /> są **null**, metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metoda wskazuje, czy dwa obiekty, `objA` i `objB`, są takie same. Można również do testowania obiekty, których wartość jest **null** pod kątem równości. Porównuje `objA` i `objB` pod kątem równości w następujący sposób:  
  
-   Określa, czy dwa obiekty reprezentują ten sam odwołanie do obiektu. Jeśli tak, metoda zwraca `true`. Ten test jest równoważne z wywoływaniem <xref:System.Object.ReferenceEquals%2A> metody. Ponadto, jeśli obie `objA` i `objB` są **null**, metoda zwraca `true`.  
  
-   Określa, czy albo `objA` lub `objB` jest **null**. Jeśli tak, zwraca `false`.  
  
-   Jeśli dwa obiekty nie reprezentują tego samego odwołanie do obiektu i nie będzie **null**, wywoływanych przez nią `objA`.`Equals` (`objB`) i zwraca wynik. Oznacza to, że jeśli `objA` zastępuje <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, to zastąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metody i porównuje ją z <xref:System.Object.ReferenceEquals%2A> metody.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> Metoda jest używana do wykonywania operacji oczyszczania niezarządzanych zasobów przechowywanych przez bieżący obiekt, zanim obiekt zostanie zniszczony. Metoda jest chroniony i w związku z tym jest dostępny tylko za pomocą tej klasy lub klasy pochodnej.  
  
 W tej sekcji:  
  
-   [Jak działa finalizacji jest zakończona](#How)  
  
-   [Uwagi dotyczące implementacji](#Notes)  
  
-   [Alternatywa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Jak działa finalizacji jest zakończona  
 <xref:System.Object> Klasa udostępnia implementacji <xref:System.Object.Finalize%2A> metoda i moduł odśmiecania pamięci nie są oznaczane typów pochodnych typu <xref:System.Object> do finalizacji, chyba że zastępują one <xref:System.Object.Finalize%2A> metody.  
  
 Jeśli zastąpisz typu <xref:System.Object.Finalize%2A> metoda, moduł zbierający elementy bezużyteczne dodaje wpis dla każdego wystąpienia typu wewnętrznej struktury o nazwie Kolejka finalizacji jest zakończona. Kolejka finalizacji zawiera wpisy dla wszystkich obiektów w zarządzanym stosie, którego kod finalizacji, należy uruchomić przed moduł zbierający elementy bezużyteczne mógł odzyskać pamięć. Moduł zbierający elementy bezużyteczne wywołuje <xref:System.Object.Finalize%2A> metoda automatycznie w następujących warunkach:  
  
-   Po moduł zbierający elementy bezużyteczne wykrył, że obiekt jest niedostępne, chyba że obiekt została zwolniona z finalizacja przez wywołanie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
-   **W programie .NET Framework**, podczas zamykania domeny aplikacji, chyba że obiekt jest wykluczony z finalizacji jest zakończona. Podczas zamykania systemu sfinalizowaniu nawet obiekty, które są nadal dostępne.  
  
 <xref:System.Object.Finalize%2A> zostanie automatycznie wywołana tylko raz dla danego wystąpienia, chyba że obiekt jest ponownie zarejestrowane przy użyciu mechanizmu, takiego jak <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> i <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> nie została następnie wywołana metoda.  
  
 <xref:System.Object.Finalize%2A> operacje mają następujące ograniczenia:  
  
-   Dokładny czas, kiedy uruchamia finalizatora jest niezdefiniowane. Aby zapewnić deterministycznego zwalniania zasobów dla wdrożenia wystąpienia klasy, `Close` metody lub podaj <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji.  
  
-   Finalizatory dwa obiekty nie ma gwarancji, uruchom w dowolnej kolejności, nawet wtedy, gdy jeden obiekt, który odwołuje się do drugiego. Oznacza to jeśli obiekt A odwołuje się do obiektu B, mają finalizatory obiekt B może mieć już sfinalizowany po uruchomieniu finalizatora obiektu, A.  
  
-   Wątek, w którym uruchamiany jest finalizator jest nieokreślona.  
  
 <xref:System.Object.Finalize%2A> Metody może nie działać do zakończenia lub może nie działać w ogóle w następujących sytuacjach wyjątkowych:  
  
-   Jeśli inny finalizator blokuje przez czas nieokreślony (przechodzi w pętli nieskończonej, próbuje uzyskać blokadę go może nigdy nie uzyskać i tak dalej). Ponieważ środowisko uruchomieniowe podejmie próbę uruchomienia finalizatory aż do ukończenia, inne finalizatory może nie należy wywoływać Jeśli bloki finalizator przez czas nieokreślony.  
  
-   Jeśli proces zakończy się bez podawania szansę, aby wyczyścić w czasie wykonywania. W takim przypadku w środowisku uruchomieniowym pierwszego powiadomienia o zakończenie procesu jest powiadomienie komunikat DLL_PROCESS_DETACH.  
  
 Środowisko wykonawcze w dalszym ciągu finalize obiektów podczas zamykania, tylko wtedy, gdy liczba obiektów, które można sfinalizować w dalszym ciągu zmniejszyć.  
  
 Jeśli <xref:System.Object.Finalize%2A> lub zastąpieniu obiektu <xref:System.Object.Finalize%2A> zgłasza wyjątek, który i środowisko uruchomieniowe nie jest hostowana przez aplikację, która zastępuje domyślną zasadę, środowisko uruchomieniowe kończy proces i nie aktywne `try` / `finally` bloków lub finalizatory są wykonywane. Takie zachowanie gwarantuje integralność procesu, jeśli finalizator nie bezpłatne lub niszczy zasoby.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Zastąpienie metody Finalize 
 Należy zastąpić <xref:System.Object.Finalize%2A> dla klasy, który używa niezarządzanych zasobów, takich jak dojścia do plików lub połączenia z bazą danych, które muszą zostać zwolnione, gdy zarządzany obiekt, który korzysta z nich jest pomijany podczas wyrzucania elementów bezużytecznych. Nie należy implementować <xref:System.Object.Finalize%2A> metodę dla obiektów zarządzanych, ponieważ moduł odśmiecania pamięci automatycznie zwalnia zasoby zarządzane.  
  
> [!IMPORTANT]
>  Jeśli <xref:System.Runtime.InteropServices.SafeHandle> obiekt jest dostępny która umieszcza niezarządzany zasób, zalecaną alternatywą jest implementować wzorzec dispose przy użyciu bezpiecznego dojścia, a nie zastępuje <xref:System.Object.Finalize%2A>. Aby uzyskać więcej informacji, zobacz [alternatywa SafeHandle](#SafeHandle) sekcji.  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Metody nie robi nic, domyślnie, ale należy zastąpić <xref:System.Object.Finalize%2A> tylko wtedy, gdy to konieczne tylko wtedy, aby zwolnić niezarządzane zasoby. Odzyskiwanie pamięci zwykle trwać dłużej w taki sposób, jeśli operacja finalizacji jest uruchomiony, ponieważ wymaga co najmniej dwóch wyrzucania elementów bezużytecznych. Ponadto należy zastąpić <xref:System.Object.Finalize%2A> tylko typy metody dla odwołania. Środowisko uruchomieniowe języka wspólnego tylko Kończenie znajdujących się w typach odwołań. Ignoruje finalizatory dla typów wartości.  

Zakres <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodą jest `protected`. Należy zachować ten ograniczony zakres podczas zastąpienia metody w klasie. Przechowując <xref:System.Object.Finalize%2A> metody chronione, można uniemożliwić użytkownikom aplikacji wywołanie obiektu <xref:System.Object.Finalize%2A> bezpośrednio metodę.
  
 Każdego wykonania <xref:System.Object.Finalize%2A> w typie pochodnym, należy wywołać implementację jego typ podstawowy <xref:System.Object.Finalize%2A>. Dotyczy to tylko w aplikacji, które można wywoływać kod <xref:System.Object.Finalize%2A>. Obiekt <xref:System.Object.Finalize%2A> — metoda nie należy wywoływać metody obiektów innych niż jej klasa bazowa obiektów. Jest tak, ponieważ inne wywołania obiektów mogą być kolekcjonowane w tym samym czasie, co obiekt wywołujący, tak jak w przypadku zamknięcia środowiska uruchomieniowego języka wspólnego. 
  
> [!NOTE]
>  Kompilator języka C# nie zezwala na zastąpienie <xref:System.Object.Finalize%2A> metody. Zamiast tego należy dostarczyć finalizator implementując [destruktor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) dla swojej klasy. C# destruktor automatycznie wywołuje destruktor klasy podstawowej.  
>   
>  Visual C++ również ma własną składnię implementowania <xref:System.Object.Finalize%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję "Destruktory i finalizatory" [jak: Definiowanie oraz stosowanie klas i struktur (C++sposób niezamierzony)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Wyrzucanie elementów bezużytecznych jest deterministyczna, nie wiadomo dokładnie, gdy moduł zbierający elementy bezużyteczne wykonuje finalizacji. Aby zwolnić zasoby natychmiast, możesz również wdrożyć [wzorca usuwania](~/docs/standard/garbage-collection/implementing-dispose.md) i <xref:System.IDisposable> interfejsu. <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementacja może być wywoływany przez konsumentów klasy do zwalniania niezarządzanych zasobów, a następnie można użyć <xref:System.Object.Finalize%2A> metody do zwalniania niezarządzanych zasobów w przypadku gdy <xref:System.IDisposable.Dispose%2A> nie jest wywoływana metoda.  
  
 <xref:System.Object.Finalize%2A> może potrwać niemal wszystkich akcji, w tym resurrecting obiektu (który jest dzięki czemu obiekt dostępne ponownie), po jego został oczyszczony podczas wyrzucania elementów bezużytecznych. Jednak obiekt można tylko można aktywowanych raz; <xref:System.Object.Finalize%2A> nie można wywołać aktywowanych obiektów podczas wyrzucania elementów bezużytecznych.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Alternatywa SafeHandle  
 Często jest trudne, tworzenia niezawodnych finalizatory, ponieważ nie może wprowadzać założenia dotyczące stanu aplikacji i nieobsługiwane wyjątki systemowe, takie jak <xref:System.OutOfMemoryException> i <xref:System.StackOverflowException> zakończyć finalizatora. A nie Implementowanie finalizatorów dla swojej klasy, aby zwolnić zasoby niezarządzane, można użyć obiektu, który jest tworzony na podstawie <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> klasy do opakowania niezarządzanych zasobów, a następnie implementować wzorzec dispose bez finalizatorów. Program .NET Framework zawiera następujące klasy w <xref:Microsoft.Win32?displayProperty=nameWithType> przestrzeni nazw, które są uzyskiwane z <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> jest to klasa otoki dla dojścia do pliku.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> jest to klasa otoki dla dojścia do plików mapowanych na pamięć.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> jest to klasa otoki dla wskaźnika do bloku niezarządzanej pamięci.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> są klas otoki uchwyty kryptograficznych.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> jest to klasa otoki dla potoku dojść.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> jest to klasa otoki dla dojścia do klucza rejestru.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> jest to klasa otoki dla dojście oczekiwania.  
  
 W poniższym przykładzie użyto [wzorca usuwania](~/docs/standard/garbage-collection/implementing-dispose.md) przy użyciu bezpiecznego dojścia, zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody. Definiuje `FileAssociation` klasę, która otacza rejestru informacji o aplikacji, która obsługuje pliki z rozszerzeniem określonego pliku. Obsługuje dwa rejestru zwracane jako `out` parametry Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) wywołania funkcji są przekazywane do <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> konstruktora. Typ użytkownika chronionych `Dispose` następnie wywołuje metodę `SafeRegistryHandle.Dispose` bezpłatne uchwyty te dwie metody.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy <xref:System.Object.Finalize%2A> metoda jest wywoływana, gdy obiekt, który zastępuje <xref:System.Object.Finalize%2A> zostanie zniszczony. Należy zauważyć, że w przypadku aplikacji produkcyjnej <xref:System.Object.Finalize%2A> metoda może zostać zastąpiona w celu zwolnić niezarządzane zasoby utrzymywane przez obiekt. Należy również zauważyć, że przykład C# zawiera destruktor zamiast przesłaniać metodę <xref:System.Object.Finalize%2A> metody.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Na przykład dodatkowych, która zastępuje <xref:System.Object.Finalize%2A> metody, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Służy jako domyślnej funkcji skrótu.</summary>
        <returns>Kod skrótu bieżącego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość skrótu jest wartością liczbową, który służy do wstawiania i zidentyfikować obiektu w kolekcji bazujących na skrótach, takich jak <xref:System.Collections.Generic.Dictionary%602> klasy <xref:System.Collections.Hashtable> klasy lub typ pochodzący od <xref:System.Collections.DictionaryBase> klasy. <xref:System.Object.GetHashCode%2A> Metoda udostępnia ten kod skrótu dla algorytmów, wymagających szybkiej kontroli równość obiektu.  
  
> [!NOTE]
>  Aby uzyskać informacje o używaniu kody skrótów w tabelach wyznaczania wartości skrótu i niektóre dodatkowe kod skrótu, zobacz [funkcji skrótu](https://en.wikipedia.org/wiki/Hash_function) wpisu w witrynie Wikipedia.  
  
 Dwa obiekty, które są równe zwracany skrótu, które są równe. Jednakże, odwrotna sytuacja nie jest wartość true: kody skrótów równy oznacza równość obiektu, ponieważ różnych obiektów (nierówne) mogą mieć identycznych skrótu. Ponadto .NET nie gwarantuje domyślna Implementacja klasy <xref:System.Object.GetHashCode%2A> metody i wartości, Metoda ta zwraca mogą się różnić od implementacji .NET, takich jak różne wersje programu .NET Framework i .NET Core i platformach, takich jak 32-bitowe i 64-bitowych platform. Z tego względu nie należy używać Domyślna implementacja tej metody jako identyfikator obiektu unikatowe potrzeby wyznaczania wartości skrótu. Dwie konsekwencje postępuj zgodnie z tym:  
  
-   Nie należy zakładać, że kody mieszania równy implikują równość obiektu.  
  
-   Nigdy nie należy utrwalić lub użyć skrótu spoza domeny aplikacji, w której został utworzony, ponieważ ten sam obiekt może wyznaczania wartości skrótu w domenach aplikacji, procesy i platform.  
  
> [!WARNING]
>  Wartość skrótu jest przeznaczona dla wydajne wstawiania i lookup w kolekcji, które są oparte na tabelę mieszania. Wartość skrótu nie jest stałe wartości. Z tego powodu:  
>   
> -   Nie serializacji wartości Kod skrótu lub przechowywać je w bazach danych.  
> -   Nie należy używać skrótu jako klucza można pobrać obiektu z kluczem kolekcji.  
> -   Nie wysyłaj kody skrótów między domenami aplikacji lub procesów. W niektórych przypadkach kody skrótów mogą być obliczone na podstawie domeny na proces lub poszczególnych aplikacji.  
> -   Nie należy używać skrótu zamiast wartości zwracane przez kryptograficznych funkcji skrótu, jeśli potrzebujesz silną kryptograficznie wyznaczania wartości skrótu. Klasy pochodzącej od użytku skróty kryptograficzne <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> klasy.  
> -   Nie należy testować pod kątem równości kodów wartości skrótu, aby ustalić, czy dwa obiekty są takie same. (Nierówne obiekty mogą mieć identycznych skrótu). Aby przetestować pod kątem równości, należy wywołać <xref:System.Object.ReferenceEquals%2A> lub <xref:System.Object.Equals%2A> metody.  
  
 <xref:System.Object.GetHashCode%2A> Metoda może być zastąpiona przez typ pochodny. Jeśli <xref:System.Object.GetHashCode%2A> jest nie ich nadpisano, kody skrótów dla typów referencyjnych są obliczane przez wywołanie metody <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metoda klasy bazowej, które oblicza wartość skrótu oparta na odwołanie do obiektu; Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Innymi słowy, dwóch obiektów, dla których <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` mają identyczne skrótu. W przypadku typów wartości nie zastępują <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metody klasy bazowej używa odbicia, aby obliczyć wartość skrótu na podstawie wartości pól typu. Innymi słowy typy wartości, których pola mają równe wartości mają równe skrótu. Aby uzyskać więcej informacji o zastępowanie <xref:System.Object.GetHashCode%2A>, zobacz sekcję "Uwagi dotyczące dziedziczenia".  
  
> [!WARNING]
>  Jeśli zastąpisz <xref:System.Object.GetHashCode%2A> metody, należy również zastąpić <xref:System.Object.Equals%2A>i na odwrót. Jeśli Twoje zastąpione <xref:System.Object.Equals%2A> metoda zwraca `true` po dwa obiekty są sprawdzane pod kątem równości, Twoje zastąpione <xref:System.Object.GetHashCode%2A> metoda musi zwracać taką samą wartość dla dwóch obiektów.  
  
 Jeśli obiekt, który jest używany jako klucz w tabeli wyznaczania wartości skrótu nie udostępnia przydatne implementacji <xref:System.Object.GetHashCode%2A>, można określić dostawcy kodu wyznaczania wartości skrótu, podając <xref:System.Collections.IEqualityComparer> implementacji do jednego z przeciążeń <xref:System.Collections.Hashtable> konstruktora klasy.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Gdy wywołujesz <xref:System.Object.GetHashCode%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.GetHashCode%2A>. Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a aktualnie nie implementują <xref:System.Object.GetHashCode%2A>. Jednak wydają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.GetHashCode%2A> metody.  
  
   
  
## Examples  
 Jedną z najprostszych sposobów obliczyć wartość skrótu dla wartość liczbowa, która ma taką samą lub mniejszym zakresie niż <xref:System.Int32> typu jest po prostu zwraca tę wartość. W poniższym przykładzie pokazano implementację dla `Number` struktury.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Często typ ma wiele pól danych, które mogą należeć do generowania kodu wyznaczania wartości skrótu. Jednym ze sposobów, aby wygenerować wartość skrótu jest połączyć te pola w programie `XOR (eXclusive OR)` operacji, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Poprzedni przykład zwraca tę samą wartość skrótu dla (n1, n2) i (n2 n1), a więc może generować kolizji więcej niż jest to pożądane. Dostępnych jest kilka rozwiązań, tak, aby kody skrótów w takiej sytuacji nie są identyczne. Jeden jest przywrócenie skrótu `Tuple` obiekt, który odzwierciedla kolejność każdego pola. W poniższym przykładzie pokazano możliwą implementację, która używa <xref:System.Tuple%602> klasy. Pamiętaj jednak, obciążenie związane z wystąpienia `Tuple` obiektu znacznie może mieć wpływ na ogólną wydajność aplikacji, która przechowuje dużą liczbę obiektów w tabelach wyznaczania wartości skrótu.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Drugie rozwiązanie alternatywne obejmuje wagi kody skrótów poszczególnych przez po lewej stronie przesunięcie kody skrótów kolejnych pól za pomocą liczby bitów dwóch lub więcej. Optymalnie zamiast zostanie odrzucony, bity przesunięte poza bit 31 zawijania wokół zamiast odrzucone. Ponieważ bity są odrzucane przez operatorów przesunięcia w lewo w językach C# i Visual Basic, wymaga to tworzenia po lewej stronie metoda shift i zawijania podobne do następującego:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 W poniższym przykładzie użyto następnie ta metoda shift i zawijania do obliczenia kodu wartości skrótu `Point` struktury używanych w poprzednich przykładach.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Funkcję mieszania umożliwia szybkie generowanie numer (skrótu), która odpowiada wartości obiektu. Funkcje wyznaczania wartości skrótu są zazwyczaj specyficzne dla każdego typu i aby zapewnić unikatowość, należy użyć co najmniej jedno z pól wystąpienia jako dane wejściowe. Kody skrótów nie powinien można obliczyć przy użyciu wartości pola statyczne.  
  
Dla klasy pochodne <see cref="T:System.Object" />, <see langword="GetHashCode" /> delegować metody do klasy bazowej <see cref="M:System.Object.GetHashCode" /> implementację tylko wtedy, gdy klasa pochodna definiuje równości jako równości odwołań. Domyślna implementacja klasy <see cref="M:System.Object.GetHashCode" /> dla odwołania do typów zwraca wartość skrótu, który jest odpowiednikiem ten, który został zwrócony przez <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> metody. Można zastąpić <see cref="M:System.Object.GetHashCode" /> dla typów odwołań niezmienne. Ogólnie rzecz biorąc, aby uzyskać modyfikowalnych typów referencyjnych, należy zastąpić <see cref="M:System.Object.GetHashCode" /> tylko wtedy, gdy: 
— Można obliczyć skrótu z pól, które nie są modyfikowalną; lub 
— Można zagwarantować, że wartość skrótu dla obiektu modyfikowalnego nie zmienia się, gdy obiekt jest zawarty w kolekcji, która zależy od jego kod skrótu.  
  
W przeciwnym razie może się wydawać, że w tabeli wyznaczania wartości skrótu są tracone obiektu modyfikowalnego. Jeśli chcesz przesłonić <see cref="M:System.Object.GetHashCode" /> dla modyfikowalnego typu referencyjnego, z dokumentacją powinien ułatwiają Wyczyść, że użytkownicy tego typu nie należy modyfikować wartości obiektu, gdy obiekt jest przechowywany w tabeli wyznaczania wartości skrótu.  
  
Dla typów wartości <see cref="M:System.ValueType.GetHashCode" /> udostępnia domyślną implementację kodu wyznaczania wartości skrótu, który używa odbicia. Należy rozważyć przesłanianie go w celu zapewnienia lepszej wydajności.  
  
 <block subset="none" type="note"><para>  
 Aby uzyskać więcej informacji i przykładów, które może obliczyć kodów skrótu w na różne sposoby zobacz sekcję przykłady.  
  
</para></block>  
  
 Funkcja wyznaczania wartości skrótu musi mieć następujące właściwości: 
— Jeśli dwa obiekty porównać jako równe, <see cref="M:System.Object.GetHashCode" /> metoda dla każdego obiektu musi zwrócić tę samą wartość. Jednakże, jeśli dwa obiekty nie porównują jako równe, <see cref="M:System.Object.GetHashCode" /> metody dwa obiekty nie muszą zwracać różne wartości.  
  
<see cref="M:System.Object.GetHashCode" /> Metodę obiektu spójnie musi zwracać taki sam skrótu tak długo, jak nie ma żadnych modyfikacji stanu obiektu, który określa wartość zwracaną obiektu [element System.Object.Equals](xref:System.Object.Equals*) metody. Należy pamiętać, że ta zasada obowiązuje tylko w przypadku wykonywania bieżącej aplikacji i że różnych skrótu mogą zostać zwrócone, jeśli aplikacja jest uruchamiana ponownie.  
  
-Aby uzyskać najlepszą wydajność funkcja wyznaczania wartości skrótu powinien wygenerować równomiernego rozłożenia dla wszystkich danych wejściowych, włącznie z danych wejściowych, który jest w dużym stopniu klastrze. Użycie tego możliwa jest niewielkie modyfikacje do stanu obiektu powinno spowodować duże modyfikacje wynikowy skrótu, aby uzyskać najlepszą wydajność tabeli wyznaczania wartości skrótu.  
  
— Funkcje skrótu powinny być tanie do obliczenia.  
  
<see cref="M:System.Object.GetHashCode" /> Metoda nie powinna zgłaszać wyjątków.  
  
Na przykład implementacji <see cref="M:System.String.GetHashCode" /> metody dostarczone przez <see cref="T:System.String" /> Klasa zwraca kody skrótów identyczne dla identyczne ciągi. W związku z tym, dwa <see cref="T:System.String" /> obiektów zwraca tę samą wartość skrótu, jeśli stanowią one taką samą wartość ciągu. Ponadto metoda używa wszystkich znaków w ciągu do generowania rozsądnie losowo rozproszonych danych wyjściowych, nawet wtedy, gdy dane wejściowe działa w klastrze w określonych zakresach (na przykład wielu użytkowników może być ciągi, które zawierają tylko niższe 128 znaków ASCII, nawet jeśli ciąg może zawierać znaków Unicode 65 535).  
  
Zapewnianie funkcji skrótu dobre dla klasy, można znacznie wpłynąć na wydajność dodanie tych obiektów do tabeli mieszania. W tabeli skrótów przy użyciu kluczy, które zapewniają dobrą implementację funkcji skrótu Wyszukiwanie elementu czasochłonne stałych (na przykład jest operacją O(1)). W tabeli wyznaczania wartości skrótu z niską implementację funkcji mieszania, wydajność wyszukiwania zależy od liczby elementów w tablicy skrótów (na przykład O (`n`) operacji, gdzie `n` jest liczba elementów w tablicy skrótów). Złośliwy użytkownik może wpisać danych, która zwiększa liczbę konfliktów, które mogłoby znacznie pogorszyć wydajność aplikacji, które są zależne od tabel skrótów, w następujących warunkach: 
— W przypadku funkcji mieszania powodować częste kolizji.  
  
— W przypadku duża część obiektów w tablicy skrótów generuje kody skrótów, które są równe lub około równa się ze sobą.  
  
— W przypadku użytkowników wprowadzania danych, z którego jest obliczana wartość skrótu.  
  
Pochodne klasy, które zastępują <see cref="M:System.Object.GetHashCode" /> jest również przesłonięcie <see cref="M:System.Object.Equals(System.Object)" /> celu zagwarantowania, że dwa obiekty uważane za równe mają tę samą wartość skrótu; w przeciwnym razie <see cref="T:System.Collections.Hashtable" /> typu mogą nie działać poprawnie.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> bieżącego wystąpienia.</summary>
        <returns>Typ środowiska uruchomieniowego dokładnie bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Object?displayProperty=nameWithType> jest klasą bazową dla wszystkich typów w .NET typu systemu, <xref:System.Object.GetType%2A> metoda może służyć do zwrócenia <xref:System.Type> obiekty reprezentujące wszystkie typy .NET. .NET rozpoznaje następujących pięć kategorii typów:  
  
-   Klasy, które są uzyskiwane z <xref:System.Object?displayProperty=nameWithType>,  
  
-   Typy, które są uzyskiwane z wartości <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfejsy, które są uzyskiwane z <xref:System.Object?displayProperty=nameWithType> począwszy od programu .NET Framework 2.0.  
  
-   Wyliczenia, które są uzyskiwane z <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegatów, które są uzyskiwane z <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Dla dwóch obiektów `x` i `y` mają identyczne środowisko uruchomieniowe typów, `Object.ReferenceEquals(x.GetType(),y.GetType())` zwraca `true`. W poniższym przykładzie użyto <xref:System.Object.GetType%2A> metody z <xref:System.Object.ReferenceEquals%2A> metodę, aby określić, czy jedną wartość liczbową, jest taki sam jak dwóch wartości liczbowych.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Aby ustalić, czy obiekt jest określonego typu, można użyć słowa kluczowego porównanie typ danego języka lub konstruowania. Na przykład, można użyć `TypeOf…Is` konstruowania w języku Visual Basic lub `is` — słowo kluczowe w języku C#.  
  
 <xref:System.Object.GetType%2A> Metoda jest dziedziczona przez wszystkie typy, które wynikają z <xref:System.Object>. Oznacza to, że oprócz przy użyciu własnego języka porównania — słowo kluczowe, można użyć <xref:System.Object.GetType%2A> metodę pozwala ustalić typ określonego obiektu, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type> Obiekt udostępnia metadane skojarzone z klasą bieżącego <xref:System.Object>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Object.GetType%2A> zwraca typ środowiska uruchomieniowego bieżącego wystąpienia.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy płytką kopię bieżącego <see cref="T:System.Object" />.</summary>
        <returns>Płytką kopię bieżącego <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> Metoda tworzy płytką kopię przez utworzenie nowego obiektu, a następnie skopiować niestatycznego pola bieżącego obiektu do nowego obiektu. Jeśli pole jest typem wartości, bit przez bitowy kopię pole jest wykonywane. Jeśli pole jest typem referencyjnym, odwołanie jest kopiowane, ale przywoływanego obiektu jest; w związku z tym oryginalny obiekt i jego klon odwołują się do tego samego obiektu.  
  
 Rozważmy na przykład obiekt o nazwie X, który odwołuje się do obiektów, A i B. obiekt B, z kolei odwołania do obiektu C. Kopia pobieżna X tworzy nowy obiekt X2, który odwołuje się obiektów, A i B. Z kolei kopię głęboką X tworzy nowy obiekt X2, który odwołuje się do nowych obiektów A2 i B2, które są kopiami A i B. B2, z kolei odwołuje się do nowego obiektu C2, który jest kopią C. W przykładzie pokazano różnicę między produkowanymi i operacji głębokiego kopiowania.  
  
 Istnieje wiele sposobów implementowania operacji głębokiego kopiowania, jeśli operacja płytka kopia wykonana przez <xref:System.Object.MemberwiseClone%2A> metody nie spełnia Twoich potrzeb. Należą do nich między innymi:  
  
-   Wywołanie konstruktora klasy obiektu do skopiowania, aby utworzyć drugi obiekt z wartości właściwości pobrane z pierwszego obiektu. Przy założeniu, że wartości obiektu są całkowicie zdefiniowane przez jej konstruktora klasy.  
  
-   Wywołaj <xref:System.Object.MemberwiseClone%2A> metody do tworzenia płytkiej kopi obiektu, a następnie przypisz nowe obiekty, których wartości są takie same jak oryginalnego obiektu właściwości lub pól, których wartości są typami odwołań. `DeepCopy` To podejście pokazano metody w przykładzie.  
  
-   Serializacji obiektu jako głębokie, skopiować, a następnie przywróć dane serializowane, zmiennej innego obiektu.  
  
-   Za pomocą odbicia rekursji do wykonania tej operacji głęboka kopia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Object.MemberwiseClone%2A> metody. Definiuje on `ShallowCopy` metodę, która wywołuje <xref:System.Object.MemberwiseClone%2A> metody, które można wykonać operacji płytka kopia na `Person` obiektu. Umożliwia on również definiowanie `DeepCopy` metody, która wykonuje operację głęboka kopia `Person` obiektu.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 W tym przykładzie `Person.IdInfo` właściwość zwraca `IdInfo` obiektu. Jako dane wyjściowe w przykładzie pokazano gdy `Person` obiekt został sklonowany, wywołując <xref:System.Object.MemberwiseClone%2A> metody, sklonowany `Person` obiekt jest niezależne kopię oryginalnego obiektu, z tą różnicą, że mogą współużytkować ten sam `Person.IdInfo` odwołanie do obiektu. W rezultacie, modyfikując klonu `Person.IdInfo` właściwość zmienia oryginalnego obiektu `Person.IdInfo` właściwości. Z drugiej strony, gdy operacja głęboka kopia jest wykonywana, sklonowany `Person` obiektu, łącznie z jego `Person.IdInfo` właściwość, może być modyfikowana bez wywierania wpływu na oryginalny obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="objB">Drugi obiekt do porównania.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> wystąpienia są tego samego wystąpienia.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="objA" /> jest tego samego wystąpienia co <paramref name="objB" /> lub jeśli obie są **null**; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Object.Equals%2A> metody i operator równości <xref:System.Object.ReferenceEquals%2A> metoda nie może zostać zastąpiona. W związku z tym, jeśli chcesz przetestować dwa obiektu odwołania pod kątem równości i wiesz o implementacji `Equals` metodę można wywołać <xref:System.Object.ReferenceEquals%2A> metody.  
  
 Jednakże wartość zwracana przez <xref:System.Object.ReferenceEquals%2A> metoda może być wyświetlana nietypowe w przypadku tych dwóch scenariuszy:  
  
-   Podczas porównywania typów wartości. Jeśli `objA` i `objB` są typami wartości muszą być zapakowany przed przekazaniem ich do <xref:System.Object.ReferenceEquals%2A> metody. Oznacza to, że jeśli oba `objA` i `objB` reprezentują tego samego wystąpienia typu wartości <xref:System.Object.ReferenceEquals%2A> metoda niemniej zwraca `false`, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Instrukcje dotyczące konwersji boxing typów wartości, zobacz [opakowywanie i rozpakowywanie](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Podczas porównywania ciągów. Jeśli `objA` i `objB` są ciągami, <xref:System.Object.ReferenceEquals%2A> metoda zwraca `true` Jeśli ciąg jest interned. Nie wykonuje test pod kątem równości wartości.  W poniższym przykładzie `s1` i `s2` są takie same, ponieważ są one dwa wystąpienia jednego ciągu interned. Jednak `s3` i `s4` nie są takie same, ponieważ mimo że mają identyczne ciągi, ten ciąg nie jest interned.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Aby uzyskać więcej informacji na temat wewnętrzne przygotowanie ciągu zobacz <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Object.ReferenceEquals%2A> można sprawdzić, czy dwa obiekty są tego samego wystąpienia.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje bieżący obiekt.</summary>
        <returns>Ciąg, który reprezentuje bieżący obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> Trwa głównej formatowanie metody .NET Framework. Konwertuje obiekt na jego reprezentację ciągu tak, że nadaje się do wyświetlania. (Aby uzyskać informacji na temat formatowania pomocy technicznej w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).) Domyślne implementacje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca w pełni kwalifikowaną nazwę typu obiektu.  
  
> [!IMPORTANT]
>  Osiągnięto tę stronę, klikając łącze z listy członków innego typu. Wynika to z tego typu nie zastępuje <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Zamiast tego dziedziczy funkcje <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.  
  
 Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w celu zapewnienia bardziej odpowiednie reprezentację ciągu określonego typu. Typy również często przeciążenia <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w celu zapewnienia obsługi ciągów formatu lub formatowania kultury.  
  
 W tej sekcji:  
  
 [Domyślną metodą Object.ToString()](#Default)   
 [Zastępowanie metody Object.ToString()](#Overriding)   
 [Przeciążenie metody ToString](#Overloading)   
 [Rozszerzanie metoda Object.ToString](#Extending)   
 [Uwagi dotyczące środowiska uruchomieniowego Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Domyślną metodą Object.ToString()  
 Domyślna implementacja klasy <xref:System.Object.ToString%2A> metoda zwraca w pełni kwalifikowaną nazwę typu <xref:System.Object>, jak pokazano w poniższym przykładzie.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Ponieważ <xref:System.Object> jest klasą bazową dla wszystkich typów odniesienia w .NET Framework to zachowanie jest dziedziczone przez typy odwołań, które nie zastępują <xref:System.Object.ToString%2A> metody. Ilustruje to poniższy przykład. Definiuje klasę o nazwie `Object1` akceptujący Domyślna implementacja wszystkich <xref:System.Object> elementów członkowskich. Jego <xref:System.Object.ToString%2A> metoda zwraca obiekt w pełni kwalifikowaną nazwę typu.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Zastępowanie metody Object.ToString()  
 Typy często przesłaniać <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg, który reprezentuje wystąpienie obiektu. Na przykład podstawowa typy takie jak <xref:System.Char>, <xref:System.Int32>, i <xref:System.String> zapewniają <xref:System.Object.ToString%2A> implementacji, które zwracają postaci ciągu, wartości, który reprezentuje obiekt. W poniższym przykładzie zdefiniowano klasę, `Object2`, która zastępuje <xref:System.Object.ToString%2A> metodę, aby zwrócić nazwę typu, wraz z jego wartość.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Poniższa tabela zawiera listę kategorii typów w programie .NET i wskazuje, czy nie zastępują one <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody.  
  
|Kategoria typów|Zastępuje Object.ToString()|Zachowanie|  
|-------------------|-----------------------------------|--------------|  
|Class|n/d|n/d|  
|Struktura|Tak (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Takie same jak `Object.ToString()`|  
|Wyliczenie|Tak (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Nazwa elementu członkowskiego|  
|Interface|Nie|n/d|  
|Delegate|Nie|n/d|  
  
 Zobacz uwagi dotyczące obiektów dziedziczących sekcji, aby uzyskać dodatkowe informacje w przypadku przesłaniania <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Przeciążenie metody ToString  
 Oprócz zastępowania bez parametrów <xref:System.Object.ToString?displayProperty=nameWithType> przeciążenia wiele typów metody `ToString` metodę w celu udostępnienia wersji metody, które akceptuje parametrów. Najczęściej jest to realizowane aby zapewnić obsługę formatowania kultury i formatowanie zmiennych.  
  
 Poniższy przykład przeciążenia `ToString` metoda zwraca ciąg wynikowy, który zawiera wartość różnymi polami `Automobile` klasy. Definiuje cztery ciągi formatu: G, która zwraca nazwę modelu i rok; D, która zwraca nazwę modelu, rok i liczba drzwi; C, która zwraca nazwę modelu, rok i liczba cylindrów; i A, który zwraca ciąg zawierający wszystkie cztery pola wartości.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Poniższy przykład wywołuje przeciążone <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę w celu wyświetlenia wrażliwość na ustawienia kulturowe formatowania wartości waluty.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Aby uzyskać więcej informacji na temat ciągów formatu i formatowania kultury, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md). Dla ciągów formatów obsługiwanych przez wartości liczbowych, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Dla ciągów formatów obsługiwanych przez wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Rozszerzanie metoda Object.ToString  
 Ponieważ typ dziedziczy domyślnie <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, można znaleźć jego zachowanie niepożądanych i chcesz je zmienić. Jest to szczególnie istotne, tablic i klas kolekcji. Chociaż może oczekiwać `ToString` Metoda tablicy lub kolekcji klasy do wyświetlania wartości jego członków, zamiast tego Wyświetla typ pełni kwalifikowaną nazwę typu, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Istnieje kilka opcji, aby ciąg wynikowy, który chcesz utworzyć.  
  
-   Jeśli typ jest tablicą, obiekt kolekcji lub obiekt, który implementuje <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601> interfejsów, można wyliczyć jego elementy przy użyciu `foreach` instrukcji w języku C# lub `For Each...Next` konstruowania w języku Visual Basic.  
  
-   Jeśli klasa nie jest `sealed` (w języku C#) lub `NotInheritable` (w języku Visual Basic), możesz tworzyć klasy otoki, która dziedziczy z klasy bazowej, którego <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, który chcesz dostosować. Co najmniej wymaga to, że wykonano następujące czynności:  
  
    1.  Zaimplementuj wszystkie niezbędne konstruktory. Klasy pochodne nie dziedziczą ich Konstruktory klasy bazowej.  
  
    2.  Zastąp <xref:System.Object.ToString%2A?displayProperty=nameWithType> metoda zwraca ciąg wynikowy, który chcesz.  
  
     W poniższym przykładzie zdefiniowano klasę otoki dla <xref:System.Collections.Generic.List%601> klasy. Zastępuje ona <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby wyświetlić wartość każdej metody kolekcji, a nie w pełni kwalifikowana nazwa typu.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Twórz [— metoda rozszerzenia](~/docs/standard/design-guidelines/extension-methods.md) zwracającego ciąg wynikowy, który chcesz. Należy pamiętać, że nie można zastąpić domyślne <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w ten sposób (oznacza to, że rozszerzenie klasy (w języku C#) lub modułów (w języku Visual Basic) nie może mieć metody bez parametrów o nazwie `ToString` o nazwie zamiast oryginalnego typu `ToString` — metoda . Musisz podać kilka innych nazwę użytkownika bez parametrów `ToString` zastępczy.  
  
     W poniższym przykładzie zdefiniowano dwie metody, które rozszerzają <xref:System.Collections.Generic.List%601> klasy: bez parametrów `ToString2` metody i `ToString` metody z <xref:System.String> parametr, który reprezentuje ciąg formatu.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Uwagi dla [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Gdy wywołujesz <xref:System.Object.ToString%2A> metody w klasie w [!INCLUDE[wrt](~/includes/wrt-md.md)], zapewnia domyślne zachowanie dla klas, które nie zastąpisz <xref:System.Object.ToString%2A>. Jest to część obsługi, która oferuje funkcje programu .NET Framework [!INCLUDE[wrt](~/includes/wrt-md.md)] (zobacz [.NET Framework obsługuje for Windows Store Apps i środowiska wykonawczego Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klasy w [!INCLUDE[wrt](~/includes/wrt-md.md)] nie dziedziczą <xref:System.Object>, a nie zawsze wdrożenia <xref:System.Object.ToString%2A>. Jednak zawsze pojawiają się mieć <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, i <xref:System.Object.GetHashCode%2A> metody, gdy będziesz ich używać w kodzie języka C# lub Visual Basic a .NET Framework zapewnia domyślne zachowanie dla tych metod.  
  
 Począwszy od [!INCLUDE[net_v451](~/includes/net-v451-md.md)], środowisko uruchomieniowe języka wspólnego będzie używać [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) na [!INCLUDE[wrt](~/includes/wrt-md.md)] obiektu przed powrotem do domyślna Implementacja klasy <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] klasy, które zostały napisane w języku C# lub Visual Basic można zastąpić <xref:System.Object.ToString%2A> metody.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] i interfejs IStringable  
 Począwszy od [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] obejmuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejs którego pojedynczej metody [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), zapewnia podstawową obsługę formatowania porównywalne dostarczone przez <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Aby uniknąć niejednoznaczności, nie należy implementować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) na typach zarządzanych.  
  
 Kiedy zarządzane obiekty są wywoływane przez kod natywny lub kod napisany w językach takich jak JavaScript lub C++/CX, pojawiają się do zaimplementowania [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Środowisko uruchomieniowe języka wspólnego będzie automatycznie kierować wywołania z [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) do <xref:System.Object.ToString%2A?displayProperty=nameWithType> w zdarzeniu [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie został zaimplementowany dla obiektu zarządzanego.  
  
> [!WARNING]
>  Ponieważ środowisko uruchomieniowe języka wspólnego automatycznie — implementuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) wszystkie zarządzane typy w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji, firma Microsoft zaleca, aby nie zapewnić własne [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacji. Implementowanie [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) może spowodować niezamierzone zachowanie podczas wywoływania `ToString` z [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX lub JavaScript.  
  
 Jeśli wybierzesz do zaimplementowania [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w publicznych typ zarządzany, który jest eksportowana w [!INCLUDE[wrt](~/includes/wrt-md.md)] składnika, występują następujące ograniczenia:  
  
-   Można zdefiniować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfejsu tylko w relacji "klasy implementuje", takich jak  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     w języku C# lub  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     w języku Visual Basic.  
  
-   Nie można zaimplementować [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) w interfejsie.  
  
-   Nie można zadeklarować parametr będzie typu [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nie może być zwracany typ metody, właściwości lub pola.  
  
-   Nie można ukryć swoje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementacja z klasy podstawowej za pomocą definicji metody, takie jak następujące:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Zamiast tego [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) musi zawsze zastąpić implementacji klasy podstawowej. Można ukryć `ToString` implementacji, wywołując je tylko w rozmiarze wystąpienia silnie typizowanej klasy.  
  
 Należy zauważyć, że w różnych warunkach, wywołań z kodu natywnego do zarządzanego typu, który implementuje [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) lub ukrywa jego [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementacji może spowodować nieoczekiwane zachowanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas implementowania własnych typów, należy zastąpić <see cref="M:System.Object.ToString" /> metodę, aby zwracać wartości, które mają znaczenie dla tych typów. Pochodne klasy, które wymagają większa kontrola nad formatowaniem niż <see cref="M:System.Object.ToString" /> zapewnia można zaimplementować <see cref="T:System.IFormattable" /> interfejsu. Jego <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> metoda umożliwia definiowanie ciągów formatu, które kontrolują formatowanie i użyj <see cref="T:System.IFormatProvider" /> obiekt, który może spowodować uzyskanie formatowanie specyficzne dla kultury.  
  
Zastępuje z <see cref="M:System.Object.ToString" /> metody należy przestrzegać następujących wytycznych: 
-Zwracanego ciągu musi być, przyjazne i odczytany przez ludzi.  
  
-Zwracanego ciągu musi jednoznacznie wskazywać na wartości wystąpienia obiektu.  
  
-Zwracanego ciągu powinien był jak najkrótszy, dlatego, że nadaje się do wyświetlania przez debuger.  
  
- <see cref="M:System.Object.ToString" /> Zastąpienie nie powinny zwracać <see cref="F:System.String.Empty" /> lub pusty ciąg.  
  
- <see cref="M:System.Object.ToString" /> Zastąpienie nie powinien zgłosić wyjątek.  
  
— Jeśli ciąg reprezentujący wystąpienie jest uwzględniana kultura, mogą być sformatowane na różne sposoby zaimplementowania <see cref="T:System.IFormattable" /> interfejsu.  
  
— Jeśli zwracanego ciągu zawiera poufne informacje, należy najpierw zażądać odpowiednie uprawnienia. Jeśli żądanie zakończy się powodzeniem, można zwrócić informacji poufnych; w przeciwnym razie powinien zwrócić ciąg, który nie obejmuje informacji poufnych.  
  
- <see cref="M:System.Object.ToString" /> Zastąpienie powinien mieć nie widocznych efekty uboczne, aby uniknąć komplikacji podczas debugowania. Na przykład, wywołanie <see cref="M:System.Object.ToString" /> metoda nie powinna zmieniać wartość pola wystąpień.  
  
— Jeśli Twój typ implementuje metodę analizowania (lub <see langword="Parse" /> lub <see langword="TryParse" /> metoda, Konstruktor lub niektóre statyczna metoda, która tworzy wystąpienie tego typu z ciągu), należy upewnić się, że ciąg zwracany przez <see cref="M:System.Object.ToString" /> metoda może być przekonwertowane na wystąpienie obiektu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>

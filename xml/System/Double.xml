<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc8fb0c3b1b5aea8602fbae3aa9505aa4fa7aea6" /><Meta Name="ms.sourcegitcommit" Value="24f564114ee2fa9c63dbac1b25b82826cc4e320f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/25/2019" /><Meta Name="ms.locfileid" Value="68488605" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje liczbę zmiennoprzecinkową o podwójnej precyzji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości reprezentuje liczbę 64-bitową o podwójnej precyzji z wartościami w zakresie od ujemną 1.79769313486232 e308 do pozytywnego 1.79769313486232 e308, a także dodatnią lub ujemną <xref:System.Double.PositiveInfinity>zero <xref:System.Double.NegativeInfinity>,, i nie liczbą ( <xref:System.Double> <xref:System.Double.NaN>). Jest to przeznaczone do reprezentowania wartości, które są niezwykle duże (takie jak odległości między planety lub galaxies) lub skrajnie bardzo małe (masa cząsteczkowa substancji w kilogramach) i często są nieprecyzyjne (takie jak odległość od ziemi do innego systemu słonecznego), <xref:System.Double> typ jest zgodny ze standardem IEC 60559:1989 (IEEE 754) dla binarnej arytmetycznej liczby zmiennoprzecinkowej.  
  
 Ten temat zawiera następujące sekcje:  
  
-   [Reprezentacja liczb zmiennoprzecinkowych i precyzja](#Precision)  
  
-   [Testowanie pod kątem równości](#Equality)  
  
-   [Wartości zmiennoprzecinkowe i wyjątki](#Exceptions)  
  
-   [Konwersje typów i podwójne struktury](#Conversions)  
  
-   [Funkcje zmiennoprzecinkowe](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Reprezentacja liczb zmiennoprzecinkowych i precyzja  
 Typ <xref:System.Double> danych przechowuje wartości zmiennoprzecinkowe o podwójnej precyzji w formacie binarnym 64-bitowym, jak pokazano w poniższej tabeli:  
  
|Części|Bity|  
|----------|----------|  
|Mantysę lub mantysy|0-51|  
|Zapis|52-62|  
|Sign (0 = pozytywna, 1 = ujemna)|63|  
  
 Podobnie jak ułamki dziesiętne nie mogą precyzyjnie reprezentować niektórych wartości ułamkowych (takich <xref:System.Math.PI?displayProperty=nameWithType>jak 1/3 lub), ułamki binarne nie mogą reprezentować niektórych wartości ułamkowych. Na przykład 1/10, który jest reprezentowany dokładnie przez ułamek w postaci ułamka dziesiętnego, jest reprezentowane przez. 001100110011 jako ułamek binarny ze wzorcem "0011" powtarzanym względem nieskończoności. W takim przypadku wartość zmiennoprzecinkowa zapewnia nieprecyzyjną reprezentację liczby reprezentowanej przez nią. Wykonywanie dodatkowych operacji matematycznych w pierwotnej wartości zmiennoprzecinkowej często zwiększa swój brak dokładności. Na przykład, Jeśli porównamy wynik mnożenia dziesiątki o 10 i dodając liczbę do. 1 9 razy, zobaczymy ten dodatek, ponieważ zawiera osiem więcej operacji, wygenerował mniej dokładny wynik. Należy zauważyć, że te różnice są widoczne tylko wtedy, gdy <xref:System.Double> są wyświetlane dwie wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md)"R", który w razie potrzeby wyświetla wszystkie 17 cyfr <xref:System.Double> dokładności obsługiwanej przez typ.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Ponieważ niektóre liczby nie mogą być reprezentowane dokładnie jako wartości binarne ułamkowe, liczby zmiennoprzecinkowe mogą jedynie przybliżyć rzeczywiste liczby.  
  
 Wszystkie liczby zmiennoprzecinkowe zawierają również ograniczoną liczbę cyfr znaczących, które również określają, jak dokładnie wartość zmiennoprzecinkowa przybliża liczbę rzeczywistą.   <xref:System.Double> Wartość może mieć maksymalnie 15 cyfr dziesiętnych, mimo że maksymalnie 17 cyfr jest przechowywanych wewnętrznie. Oznacza to, że niektóre operacje zmiennoprzecinkowe mogą nie mieć dokładności, aby zmienić wartość zmiennoprzecinkową. Poniższy przykład stanowi ilustrację. Definiuje bardzo dużą wartość zmiennoprzecinkową, a następnie dodaje do niej produkt <xref:System.Double.Epsilon?displayProperty=nameWithType> i jeden quadrillion. Produkt jest jednak zbyt mały, aby można było zmodyfikować oryginalną wartość zmiennoprzecinkową. Jego najmniej znacząca cyfra to stutysięcznych, a najbardziej znacząca cyfra w produkcie to 10<sup>-309</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Ograniczona precyzja liczby zmiennoprzecinkowej ma kilka konsekwencji:  
  
-   Dwie liczby zmiennoprzecinkowe, które są wyświetlane jako równe określonej precyzji, mogą nie być porównane, ponieważ ich najmniej znaczące cyfry są różne. W poniższym przykładzie seria numerów jest dodawana razem, a ich łączna suma jest porównywana z ich oczekiwaną sumą. Chociaż dwie wartości są takie same, wywołanie `Equals` metody wskazuje, że nie są.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Jeśli <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> zmienisz elementy formatu w instrukcji z `{0}` i `{1}` na `{0:R}` i, `{1:R}` aby wyświetlić wszystkie znaczące cyfry dwóch <xref:System.Double> wartości, jest jasne, że dwie wartości nie są równe, ponieważ utratę dokładności podczas operacji dodawania. W takim przypadku problem można rozwiązać, wywołując <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby <xref:System.Double> zaokrąglić wartości do odpowiedniej dokładności przed przeprowadzeniem porównania.  
  
-   Operacja matematyczna lub porównawcza korzystająca z liczby zmiennoprzecinkowej może nie dać tego samego wyniku, jeśli użyto liczby dziesiętnej, ponieważ liczba zmiennoprzecinkowa binarna może nie być równa liczbie dziesiętnej. W poprzednim przykładzie zilustrowano to poprzez wyświetlenie wyniku mnożenia dziesiątki przez 10 i dodanie. 1 razy.  
  
     Gdy dokładność w operacjach liczbowych z wartościami ułamkowymi jest ważna, można użyć <xref:System.Decimal> zamiast tego <xref:System.Double> typu. Gdy dokładność w operacjach liczbowych o wartościach całkowitych poza <xref:System.Int64> zakresem lub <xref:System.UInt64> <xref:System.Numerics.BigInteger> jest istotna, należy użyć typu.  
  
-   Wartość nie może być przezaokrąglana, jeśli jest używana liczba zmiennoprzecinkowa. Wartość jest określana na potrzeby rundy, jeśli operacja konwertuje oryginalną liczbę zmiennoprzecinkową na inny formularz, operacja odwrotna przekształca przekonwertowanego formularza z powrotem do liczby zmiennoprzecinkowej, a końcowa liczba zmiennoprzecinkowa nie jest równa pierwotnemu liczba zmiennoprzecinkowa. Runda może się nie powieść, ponieważ co najmniej jedna znacząca cyfra zostanie utracona lub zmieniona w konwersji. W poniższym przykładzie trzy <xref:System.Double> wartości są konwertowane na ciągi i zapisywane w pliku. Gdy dane wyjściowe są widoczne, jednak mimo że wartości wyglądają tak samo, przywrócone wartości nie są równe oryginalnym wartościom.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     W takim przypadku wartości można pomyślnie zaokrąglić, używając [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "G17", aby zachować pełną precyzję <xref:System.Double> wartości, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  W przypadku użycia z <xref:System.Double> wartością specyfikator formatu "R" w niektórych przypadkach nie może pomyślnie wykonać rundy pierwotnej wartości. Aby upewnić <xref:System.Double> się, że wartości zostały pomyślnie rundy, użyj specyfikatora formatu "G17".

-   <xref:System.Single>wartości mają mniejszą precyzję <xref:System.Double> niż wartości. Wartość, która jest konwertowana na pozornie równoważne <xref:System.Double> , <xref:System.Double> często nie jest równa wartości ze względu na różnice dokładności. <xref:System.Single> W poniższym przykładzie wynik identycznych operacji dzielenia jest przypisywany do <xref:System.Double> <xref:System.Single> wartości i. Gdy wartość jest rzutowana <xref:System.Double>na, porównanie dwóch wartości pokazuje, że są one nierówne. <xref:System.Single>  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Aby uniknąć tego problemu, użyj <xref:System.Double> zamiast <xref:System.Single> tego <xref:System.Math.Round%2A> typu danych lub użyj metody, aby obie wartości miały taką samą precyzję.  
  
 Ponadto wynik operacji arytmetycznych i przypisywania z <xref:System.Double> wartościami może się nieco różnić przez platformę ze względu na utratę precyzji <xref:System.Double> typu. Na przykład wynik przypisywania wartości literału <xref:System.Double> może się różnić w 32-bitowych i 64-bitowych wersjach .NET Framework. Poniższy przykład ilustruje tę różnicę, gdy wartość Literal-4.42330604244772 e-305 i zmienna, której wartość to-4.42330604244772 e-305 są przypisane do <xref:System.Double> zmiennej. Należy zauważyć, że wynik <xref:System.Double.Parse%28System.String%29> metody w tym przypadku nie cierpi na utratę precyzji.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testowanie pod kątem równości  
 Aby można je było traktować jako <xref:System.Double> równe, dwie wartości muszą reprezentować identyczne wartości. Jednak ze względu na różnice między wartościami lub ze względu na utratę dokładności przez jedną lub obie wartości, wartości zmiennoprzecinkowe, które powinny być identyczne, często nie są równe z powodu różnic w ich najmniej znaczących cyfrach. W rezultacie wywołania <xref:System.Double.Equals%2A> metody, aby określić, czy dwie wartości są równe lub wywołania <xref:System.Double.CompareTo%2A> metody w celu określenia relacji między dwiema <xref:System.Double> wartościami, często dają nieoczekiwane wyniki. Jest to oczywiste w poniższym przykładzie, gdzie dwie pozornie równe <xref:System.Double> wartości są nierówne, ponieważ pierwsza z nich ma 15 cyfr, a druga ma 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Obliczone wartości, które są zgodne z różnymi ścieżkami kodu i które są manipulowane na różne sposoby, są często nierówne. W poniższym przykładzie jedna <xref:System.Double> wartość jest kwadratowa, a następnie zostanie obliczony pierwiastek kwadratowy, aby przywrócić oryginalną wartość. Sekunda <xref:System.Double> jest mnożona przez 3,51 i kwadratowa przed pierwiastek kwadratowy wyniku podzieloną przez 3,51, aby przywrócić oryginalną wartość. Chociaż dwie wartości wyglądają tak samo, wywołanie <xref:System.Double.Equals%28System.Double%29> metody wskazuje, że nie są równe. Użycie ciągu formatu standardowego "R" do zwrócenia ciągu wynikowego, który wyświetla wszystkie znaczące cyfry każdej podwójnej wartości, pokazuje, że druga wartość jest .0000000000001 mniejsza od pierwszej.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 W przypadkach, gdy utrata dokładności będzie prawdopodobnie miała wpływ na wynik porównania, można zastosować dowolne z następujących alternatyw, aby wywołać <xref:System.Double.Equals%2A> metodę lub: <xref:System.Double.CompareTo%2A>  
  
-   Wywołaj <xref:System.Math.Round%2A?displayProperty=nameWithType> metodę, aby upewnić się, że obie wartości mają taką samą precyzję. Poniższy przykład modyfikuje poprzedni przykład, aby użyć tego podejścia, tak aby dwie wartości ułamkowe były równoważne.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Należy zauważyć, że problem z dokładnością nadal stosuje się do zaokrąglania wartości punktu środkowego. Aby uzyskać więcej informacji, zobacz <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> metodę.  
  
-   Przetestuj, aby uzyskać przybliżoną równość, a nie równość. Wymaga to zdefiniowania bezwzględnej ilości, przez którą dwie wartości mogą się różnić, ale nadal są równe lub że definiujesz względną liczbę, o której mniejsza wartość może się rozbieżny od większej wartości.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType>jest czasami używany jako miara bezwzględna odległości między dwiema <xref:System.Double> wartościami przy testowaniu pod kątem równości.  Jednak mierzy najmniejszą możliwą wartość, którą można dodać do lub odjąć od <xref:System.Double> , której wartość jest równa zero. <xref:System.Double.Epsilon?displayProperty=nameWithType> Dla większości wartości dodatnich <xref:System.Double> i ujemnych <xref:System.Double.Epsilon?displayProperty=nameWithType> wartość jest zbyt mała do wykrycia. Z tego względu, z wyjątkiem wartości, które są równe zero, nie zalecamy użycia w testach pod kątem równości.  
  
     Poniższy przykład używa tego ostatniego podejścia do zdefiniowania `IsApproximatelyEqual` metody, która testuje względną różnicę między dwiema wartościami. Różni się również wynik wywołań `IsApproximatelyEqual` metody <xref:System.Double.Equals%28System.Double%29> i metody.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Wartości zmiennoprzecinkowe i wyjątki  
 W przeciwieństwie do operacji z typami całkowitymi, które generują wyjątki w przypadku przepełnienia lub niedozwolonych operacji, takich jak dzielenie przez zero, operacje z wartościami zmiennoprzecinkowymi nie generują wyjątków. Zamiast tego w wyjątkowych sytuacjach wynik operacji zmiennoprzecinkowej wynosi zero, nieskończoność dodatnia, nieskończoność ujemna lub nie jest liczbą (NaN):  
  
-   Jeśli wynik operacji zmiennoprzecinkowej jest za mały dla formatu docelowego, wynik wynosi zero. Taka sytuacja może wystąpić, gdy są mnożone dwie bardzo małe liczby, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Jeśli wartość wyniku operacji zmiennoprzecinkowej przekroczy zakres formatu docelowego, wynik operacji jest <xref:System.Double.PositiveInfinity> lub <xref:System.Double.NegativeInfinity>, zgodnie z potrzebami, w odniesieniu do znaku wyniku. Wynikiem operacji przepełnienia <xref:System.Double.MaxValue?displayProperty=nameWithType> jest <xref:System.Double.PositiveInfinity>, a wynikiem <xref:System.Double.MinValue?displayProperty=nameWithType> operacji przepełnienia jest <xref:System.Double.NegativeInfinity>, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity>wyniki od dzielenia przez zero z dodatnią dzielną i <xref:System.Double.NegativeInfinity> wyniki dzielenia przez zero z ujemną dzielną.  
  
-   Jeśli operacja zmiennoprzecinkowa jest nieprawidłowa, wynik operacji to <xref:System.Double.NaN>. Na przykład <xref:System.Double.NaN> wyniki z następujących operacji:  
  
    -   Dzielenie przez zero z dzielną równą zero. Zwróć uwagę, że inne przypadki dzielenia przez zero powodują jedno <xref:System.Double.PositiveInfinity> lub <xref:System.Double.NegativeInfinity>.  
  
-   Wszystkie operacje zmiennoprzecinkowe z nieprawidłowymi danymi wejściowymi. Na przykład wywołanie <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metody z ujemną wartością zwraca <xref:System.Double.NaN>wartość <xref:System.Math.Acos%2A?displayProperty=nameWithType> , tak jak wywołanie metody z wartością, która jest większa niż jedna lub mniejsza od zera.  
  
-   Każda operacja z argumentem, którego wartość <xref:System.Double.NaN?displayProperty=nameWithType>to.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Konwersje typów i podwójne struktury  
 <xref:System.Double> Struktura nie definiuje żadnych jawnych lub niejawnych operatorów konwersji; zamiast tego konwersje są implementowane przez kompilator.  
  
 Konwersja wartości dowolnego pierwotnego typu liczbowego na a <xref:System.Double> jest konwersją rozszerzającą i w związku z tym nie wymaga jawnego operatora rzutowania ani wywołania metody konwersji, chyba że kompilator jawnie go wymaga. Na przykład C# kompilator wymaga operatora rzutowania dla konwersji z <xref:System.Decimal> do <xref:System.Double>, natomiast kompilator Visual Basic nie. Poniższy przykład konwertuje minimalną lub maksymalną wartość innych pierwotnych typów liczbowych na <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 <xref:System.Single> Dodatkowo wartości ,,i<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>przekonwertować do, ,<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>i,odpowiednio. <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> <xref:System.Single.NaN?displayProperty=nameWithType> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>  
  
 Należy zauważyć, że konwersja wartości niektórych typów liczbowych na <xref:System.Double> wartość może wiązać się z utratą precyzji. Jak pokazano na przykładzie, podczas konwersji <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, i <xref:System.UInt64> wartości na <xref:System.Double> wartości jest możliwe zmniejszenie dokładności.  
  
 Konwersja <xref:System.Double> wartości na wartość dowolnego innego typu danych liczb pierwotnych to zawężana konwersja i wymaga operatora rzutowania (w C#), metody konwersji (w Visual Basic) lub wywołania <xref:System.Convert> metody. Wartości, które znajdują się poza zakresem docelowego typu danych, które są definiowane przez typ `MinValue` docelowy i `MaxValue` właściwości, zachowują się jak pokazano w poniższej tabeli.  
  
|Typ docelowy|Wynik|  
|-----------------|------------|  
|Dowolny typ całkowity|<xref:System.OverflowException> Wyjątek, jeśli konwersja występuje w kontekście zaewidencjonowanych.<br /><br /> Jeśli konwersja występuje w kontekście niesprawdzonym (wartość domyślna w C#), operacja konwersji zakończy się powodzeniem, ale wartość jest przepełniania.|  
|<xref:System.Decimal>|<xref:System.OverflowException> Wyjątek.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>dla wartości ujemnych.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>dla wartości dodatnich.|  
  
 Ponadto <xref:System.Double.NaN?displayProperty=nameWithType> ,,i<xref:System.Double.NegativeInfinity?displayProperty=nameWithType> throw<xref:System.OverflowException> dla konwersji do liczb całkowitych w zaznaczonym kontekście, ale te wartości są przepełnione w przypadku przekonwertowania na liczby całkowite w niesprawdzonym kontekście. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> W przypadku konwersji <xref:System.Decimal>do, zawsze <xref:System.OverflowException>generują. W przypadku konwersji <xref:System.Single>na, są one <xref:System.Single.NaN?displayProperty=nameWithType>konwertowane <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>na, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, i, odpowiednio.  
  
 Należy zauważyć, że utrata dokładności może wynikać z konwersji <xref:System.Double> wartości na inny typ liczbowy. W przypadku konwertowania wartości niecałkowitych <xref:System.Double> , jak dane wyjściowe z przykładu pokazują, składnik Ułamkowy zostanie utracony, <xref:System.Double> gdy wartość zostanie zaokrąglona (w Visual Basic) lub obcięta (jako C#). W przypadku konwersji <xref:System.Decimal> do <xref:System.Single> i wartości, <xref:System.Double> wartość może nie mieć precyzyjnej reprezentacji w docelowym typie danych.  
  
 Poniższy przykład konwertuje <xref:System.Double> kilka wartości na kilka innych typów liczbowych. Konwersje są wykonywane w kontekście zaewidencjonowanych w Visual Basic (wartość domyślna) i w C# (z powodu słowa kluczowego [Checked](~/docs/csharp/language-reference/keywords/checked.md) ). Dane wyjściowe z przykładu przedstawiają wynik konwersji zarówno w niesprawdzonym kontekście. Można wykonać konwersje w niesprawdzonym kontekście w Visual Basic przez skompilowanie z `/removeintchecks+` przełącznikiem kompilatora i w C# wyniku dodawania komentarza do `checked` instrukcji.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Aby uzyskać więcej informacji na temat konwersji typów liczbowych, zobacz [Konwersja typu w tabelach .NET Framework](~/docs/standard/base-types/type-conversion.md) i [konwersji typów](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funkcje zmiennoprzecinkowe  
 <xref:System.Double> Struktura i powiązane typy zapewniają metody wykonywania operacji w następujących obszarach:  
  
-   **Porównanie wartości**. Możesz wywołać <xref:System.Double.Equals%2A> metodę, aby określić, czy dwie <xref:System.Double> wartości <xref:System.Double.CompareTo%2A> są równe, lub metodę, aby określić relację między dwiema wartościami.  
  
     <xref:System.Double> Struktura obsługuje również kompletny zestaw operatorów porównania. Na przykład można testować pod kątem równości lub nierówności lub określić, czy jedna wartość jest większa lub równa innej. Jeśli jeden z operandów jest typu liczbowego innego niż a <xref:System.Double>, jest konwertowany na a <xref:System.Double> przed przeprowadzeniem porównania.  
  
    > [!WARNING]
    >  Ze względu na różnice w precyzji, dwie <xref:System.Double> wartości, które powinny być równe, mogą być nierówne, co ma wpływ na wynik porównania. Zobacz sekcję [testowanie pod kątem równości](#Equality) , aby uzyskać więcej informacji na <xref:System.Double> temat porównywania dwóch wartości.  
  
     Możesz również wywołać <xref:System.Double.IsNaN%2A>metody,, <xref:System.Double.IsInfinity%2A> <xref:System.Double.IsPositiveInfinity%2A>, i <xref:System.Double.IsNegativeInfinity%2A> , aby przetestować dla tych specjalnych wartości.  
  
-   **Operacje matematyczne**. Typowe operacje arytmetyczne, takie jak dodawanie, odejmowanie, mnożenie i dzielenie, są implementowane przez kompilatory języka i instrukcje wspólnego języka pośredniego (CIL), a nie <xref:System.Double> za pomocą metod. Jeśli jeden z argumentów operacji matematycznych jest typem liczbowym innym niż a <xref:System.Double>, jest konwertowany na a <xref:System.Double> przed wykonaniem operacji. Wynik operacji jest również <xref:System.Double> wartością.  
  
     Inne operacje matematyczne mogą być wykonywane przez `static` wywoływanie metod (`Shared` w <xref:System.Math?displayProperty=nameWithType> Visual Basic) w klasie. Obejmuje ona dodatkowe metody, które są powszechnie używane do arytmetycznych (takich <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>jak <xref:System.Math.Abs%2A?displayProperty=nameWithType> <xref:System.Math.Sign%2A?displayProperty=nameWithType>,, i), <xref:System.Math.Cos%2A?displayProperty=nameWithType> geometrii <xref:System.Math.Sin%2A?displayProperty=nameWithType>(takie jak i), i <xref:System.Math.Log%2A?displayProperty=nameWithType>calculus (na przykład).  
  
     Można również manipulować pojedynczymi bitami w <xref:System.Double> wartości. Metoda zachowuje wzorzec bitu wartości w 64-bitowej liczbie całkowitej. <xref:System.Double> <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> Metoda zwraca swój wzór bitowy w tablicy bajtów.  
  
-   **Zaokrąglenie**. Zaokrąglanie jest często stosowane jako technika zmniejszenia wpływu różnic między wartościami spowodowanymi problemami z reprezentacją zmiennoprzecinkową i dokładnością. Możesz zaokrąglić <xref:System.Double> wartość, <xref:System.Math.Round%2A?displayProperty=nameWithType> wywołując metodę.  
  
-   **Formatowanie**. Można przekonwertować <xref:System.Double> wartość na reprezentację ciągu, <xref:System.Double.ToString%2A> wywołując metodę lub korzystając z funkcji formatowania złożonego. Aby uzyskać informacje na temat sposobu, w jaki ciągi formatu kontrolują reprezentację wartości zmiennoprzecinkowych, zobacz [Standardowe ciągi formatu liczb](~/docs/standard/base-types/standard-numeric-format-strings.md) i niestandardowe [ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md) .  
  
-   **Analizowanie ciągów**. Można przekonwertować ciąg reprezentujący wartość zmiennoprzecinkową na <xref:System.Double> wartość przez wywołanie <xref:System.Double.Parse%2A> metody lub <xref:System.Double.TryParse%2A> . Jeśli operacja analizy zakończy się niepowodzeniem, <xref:System.Double.Parse%2A> Metoda zgłasza wyjątek, <xref:System.Double.TryParse%2A> podczas gdy metoda `false`zwraca.  
  
-   **Konwersja typu**. Struktura zapewnia jawną implementację <xref:System.IConvertible> interfejsu, która obsługuje konwersję między dowolnymi dwoma standardowymi typami danych .NET Framework. <xref:System.Double> Kompilatory języka obsługują również niejawną konwersję wartości wszystkich innych standardowych typów liczbowych <xref:System.Double> na wartości. Konwersja wartości dowolnego standardowego typu liczbowego na a <xref:System.Double> jest konwersją rozszerzającą i nie wymaga użytkownika operatora rzutowania ani metody konwersji.  
  
     Jednak konwersja <xref:System.Int64> i <xref:System.Single> wartości może spowodować utratę precyzji. W poniższej tabeli przedstawiono różnice dokładności dla każdego z tych typów:  
  
    |Typ|Precyzja maksymalna|Dokładność wewnętrzna|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 cyfr dziesiętnych|19 cyfr dziesiętnych|  
    |<xref:System.Single>|7 cyfr dziesiętnych|9 cyfr dziesiętnych|  
  
     Problem z dokładnością najczęściej wpływa <xref:System.Single> na wartości, które są konwertowane na <xref:System.Double> wartości. W poniższym przykładzie dwie wartości generowane przez identyczne operacje dzielenia są nierówne, ponieważ jedna z wartości jest wartością zmiennoprzecinkową o pojedynczej precyzji przekonwertowanej na <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: Narzędzie do formatowania .NET Framework 4</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje to wystąpienie do określonego obiektu lub <see cref="T:System.Double" /> obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu lub <see cref="T:System.Double" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zmiennoprzecinkowa podwójnej precyzji do porównania.</param>
        <summary>Porównuje to wystąpienie z określoną liczbą zmiennoprzecinkową o podwójnej precyzji i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonej liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba ze znakiem wskazująca wartości względne tego wystąpienia <paramref name="value" />i.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie jest mniejsze niż <paramref name="value" />.  
  
—lub— 
To wystąpienie nie jest liczbą (<see cref="F:System.Double.NaN" />) i <paramref name="value" /> jest liczbą.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
—lub— 
Oba te wystąpienia i <paramref name="value" /> nie są liczbami (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" />lub <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest większe niż <paramref name="value" />.  
  
—lub— 
To wystąpienie jest liczbą i <paramref name="value" /> nie jest liczbą (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości muszą być identyczne, aby były uważane za równe. Szczególnie gdy wartości zmiennoprzecinkowe są zależne od wielu operacji matematycznych, często są dla nich tracone precyzje i ich wartości są niemal identyczne, z wyjątkiem ich najmniej znaczących cyfr. Z tego powodu wartość <xref:System.Double.CompareTo%2A> zwracana metody w godzinach może wydawać się zaskakujące. Na przykład, mnożenie według określonej wartości, po której następuje dzielenie przez tę samą wartość, powinno generować pierwotną wartość. W poniższym przykładzie, obliczona wartość jest większa niż oryginalna wartość. Wyświetlanie wszystkich znaczących cyfr dwóch wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" wskazuje, że obliczona wartość różni się od oryginalnej wartości w najmniej znaczących cyfrach. Aby uzyskać informacje na temat obsługi takich porównań, zobacz sekcję <xref:System.Double.Equals%28System.Double%29> uwagi metody.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepszą niż metoda, <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> ponieważ nie musi konwertować `value` parametru do obiektu.  
  
 Należy zauważyć, że chociaż obiekt, którego wartość <xref:System.Double.NaN> nie jest uważany za równy innemu obiektowi, <xref:System.Double.NaN> którego wartość jest ( <xref:System.IComparable%601> nawet sama), interfejs `A.CompareTo(A)` wymaga, aby zwracał zero.  
  
## <a name="widening-conversions"></a>Poszerzenie konwersji  
 W zależności od języka programowania może być możliwe kod <xref:System.Double.CompareTo%2A> metody, w której typ parametru ma mniejszą liczbę bitów (jest węższy) niż typ wystąpienia. To jest możliwe, ponieważ w niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która powoduje reprezentowanie parametru jako typu z taką samą liczbą bitów jak liczba bitów wystąpienia.  
  
 Załóżmy na przykład, że typ wystąpienia to <xref:System.Double> i typ parametru to. <xref:System.Int32> Kompilator firmy C# Microsoft generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Double> obiektu <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> , a następnie generuje metodę, która porównuje wartości wystąpienia i poszerzonną reprezentację parametru.  
  
 Sprawdź dokumentację języka programowania, aby określić, czy jego kompilator wykonuje niejawne poszerzenia konwersji dla typów liczbowych. Aby uzyskać więcej informacji, zobacz temat [tabele konwersji typów](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ogólne i nieogólne wersje <xref:System.Double.CompareTo%2A> metody dla kilku typów wartości i elementów referencyjnych.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie do określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Liczba ze znakiem wskazująca wartości względne tego wystąpienia <paramref name="value" />i.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Ujemna liczba całkowita 
 </term><description> To wystąpienie jest mniejsze niż <paramref name="value" />.  
  
—lub— 
To wystąpienie nie jest liczbą (<see cref="F:System.Double.NaN" />) i <paramref name="value" /> jest liczbą.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
—lub— 
To wystąpienie i <paramref name="value" /> obie <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />lub<see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Dodatnia liczba całkowita 
 </term><description> To wystąpienie jest większe niż <paramref name="value" />.  
  
—lub— 
To wystąpienie jest liczbą i <paramref name="value" /> nie jest liczbą (<see cref="F:System.Double.NaN" />).  
  
—lub— 
 <paramref name="value" />jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być `null` lub wystąpieniem `Double`; w przeciwnym razie jest zgłaszany wyjątek. `value` Każde wystąpienie <xref:System.Double>, niezależnie od jego wartości, jest traktowane jako większe niż `null`.  
  
 Wartości muszą być identyczne, aby były uważane za równe. Szczególnie gdy wartości zmiennoprzecinkowe są zależne od wielu operacji matematycznych, często są dla nich tracone precyzje i ich wartości są niemal identyczne, z wyjątkiem ich najmniej znaczących cyfr. Z tego powodu wartość <xref:System.Double.CompareTo%2A> zwracana metody w godzinach może wydawać się zaskakujące. Na przykład, mnożenie według określonej wartości, po której następuje dzielenie przez tę samą wartość, powinno generować pierwotną wartość. W poniższym przykładzie, obliczona wartość jest większa niż oryginalna wartość. Wyświetlanie wszystkich znaczących cyfr dwóch wartości przy użyciu [standardowego ciągu formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" wskazuje, że obliczona wartość różni się od oryginalnej wartości w najmniej znaczących cyfrach. Aby uzyskać informacje na temat obsługi takich porównań, zobacz sekcję <xref:System.Double.Equals%28System.Double%29> uwagi metody.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Ta metoda jest implementowana do obsługi <xref:System.IComparable> interfejsu. Należy zauważyć, że mimo <xref:System.Double.NaN> że nie jest uważany za równy innemu <xref:System.Double.NaN> ( <xref:System.IComparable> nawet jeden), interfejs wymaga, aby `A.CompareTo(A)` zwracał zero.  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `CompareTo` w `Double`kontekście.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie <see cref="T:System.Double" />jest.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Reprezentuje najmniejszą wartość <see cref="T:System.Double" /> dodatnią, która jest większa od zera. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Double.Epsilon> właściwości odzwierciedla najmniejszy dodatnią <xref:System.Double> wartość, która jest istotna w operacjach liczbowych lub porównaniach, <xref:System.Double> gdy wartość wystąpienia jest równa zero. Na przykład poniższy kod pokazuje, że zero i <xref:System.Double.Epsilon> są uważane za wartości nierówne, natomiast zero i połowa <xref:System.Double.Epsilon> wartości są uważane za równe.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Dokładniej, format zmiennoprzecinkowy składa się z znaku, 52-bitowy mantysy lub mantysę i 11-bitowego wykładnika. Jak pokazano na poniższym przykładzie, zero ma wykładnik-1022 i mantysy 0. <xref:System.Double.Epsilon>ma wykładnik wartości-1022 i mantysy 1. Oznacza to, <xref:System.Double.Epsilon> że jest to najmniejsza wartość dodatnia <xref:System.Double> większa od zera i reprezentuje najmniejszą możliwą wartość oraz najmniejszy możliwy <xref:System.Double> przyrost dla elementu, którego wykładnik to-1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Jednakże właściwość nie jest ogólną miarą precyzji <xref:System.Double> typu <xref:System.Double> ; dotyczy tylko wystąpień, które mają wartość zero lub wykładnik wartości-1022. <xref:System.Double.Epsilon>  
  
> [!NOTE]
>  Wartość <xref:System.Double.Epsilon> właściwości nie jest równoznaczna z liczbą komputerów Epsilon, która reprezentuje górną granicę względnego błędu z powodu zaokrąglenia w arytmetycznej liczbie zmiennoprzecinkowej.  
  
 Wartość tej stałej to 4.94065645841247 e-324.  
  
 Dwie prawdopodobnie równoważne liczby zmiennoprzecinkowe mogą nie być porównywane z powodu różnic w ich najmniej znaczących cyfrach. Na przykład C# wyrażenie `(double)1/3 == (double)0.33333`nie jest porównywane, ponieważ operacja dzielenia po lewej stronie ma maksymalną precyzję, podczas gdy stała po prawej stronie jest precyzyjna tylko do określonych cyfr. W przypadku utworzenia niestandardowego algorytmu, który określa, czy dwie liczby zmiennoprzecinkowe mogą być uważane za równe, nie zaleca się, aby na podstawie wartości <xref:System.Double.Epsilon> stałej określić akceptowalny, bezwzględny margines różnicy dla dwie wartości, które mają być traktowane jako równe.  (Zazwyczaj ten margines różnicy jest wiele razy większy niż <xref:System.Double.Epsilon>). Aby uzyskać informacje na temat porównywania dwóch wartości zmiennoprzecinkowych o podwójnej <xref:System.Double> precyzji, zobacz i <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Uwagi dotyczące platformy  
 W systemach ARM wartość <xref:System.Double.Epsilon> stałej jest zbyt mała, aby mogła zostać wykryta, więc jest równa zero. Zamiast tego można zdefiniować alternatywną wartość Epsilon równą 2.2250738585072014 E-308.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia <see cref="T:System.Double" /> reprezentują tę samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Double" /> Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie i określony <see cref="T:System.Double" /> obiekt reprezentują tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> jest równe temu wystąpieniu; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepsze niż <xref:System.Double.Equals%2A> , ponieważ nie musi skonwertować `obj` parametru do obiektu.  
  
## <a name="widening-conversions"></a>Poszerzenie konwersji  
 W zależności od języka programowania może być możliwe kod <xref:System.Double.Equals%2A> metody, w której typ parametru ma mniejszą liczbę bitów (jest węższy) niż typ wystąpienia. To jest możliwe, ponieważ w niektórych językach programowania jest wykonywana niejawna konwersja poszerzająca, która powoduje reprezentowanie parametru jako typu z taką samą liczbą bitów jak liczba bitów wystąpienia.  
  
 Załóżmy na przykład, że typ wystąpienia to <xref:System.Double> i typ parametru to. <xref:System.Int32> Kompilator firmy C# Microsoft generuje instrukcje do reprezentowania wartości parametru jako <xref:System.Double> obiektu <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> , a następnie generuje metodę, która porównuje wartości wystąpienia i poszerzonną reprezentację parametru.  
  
 Sprawdź dokumentację języka programowania, aby określić, czy jego kompilator wykonuje niejawne poszerzenia konwersji dla typów liczbowych. Aby uzyskać więcej informacji, zobacz temat [tabele konwersji typów](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Precyzja w porównaniach  
 <xref:System.Double.Equals%2A> Metoda powinna być stosowana z zachowaniem ostrożności, ponieważ dwie równoważne wartości mogą być nierówne z powodu różnej dokładności dwóch wartości. Poniższy przykład zgłasza, że <xref:System.Double> wartość. 333333 <xref:System.Double> i wartość zwracana przez dzielenie 1 przez 3 nie są równe.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Zamiast porównywania pod kątem równości, jedna technika obejmuje definiowanie akceptowalnego względnego marginesu różnicy między dwiema wartościami (na przykład .001% jednej z wartości). Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza niż lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicami i dlatego wartości mogą być równe. W poniższym przykładzie zastosowano tę technikę do porównania. 33333 i 1/3, <xref:System.Double> dwie wartości, które nie zostały odnalezione przez poprzedni przykład kodu. W takim przypadku wartości są równe.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Ponieważ <xref:System.Double.Epsilon> definiuje minimalne wyrażenie wartości dodatniej, której zakres jest bliski zero, margines różnicy między dwoma podobnymi wartościami musi być większy niż <xref:System.Double.Epsilon>. Zwykle jest to wiele razy większe niż <xref:System.Double.Epsilon>. Z tego powodu zaleca się, aby nie używać <xref:System.Double.Epsilon> podczas porównywania <xref:System.Double> wartości równości.  
  
 Druga Technika polega na porównaniu różnicy między dwoma liczbami zmiennoprzecinkowymi A pewną wartością bezwzględną. Jeśli różnica jest mniejsza lub równa tej wartości bezwzględnej, liczby są równe. Jeśli jest większa, liczby nie są równe. Alternatywnie można arbitralnie wybrać wartość bezwzględną. Jest to przyczyną problemów, jednak ponieważ akceptowalny margines różnic zależy od wielkości <xref:System.Double> wartości. Druga alternatywa wykorzystuje funkcję projektowania formatu zmiennoprzecinkowego: Różnica między liczbą całkowitą dwóch wartości zmiennoprzecinkowych wskazuje liczbę możliwych wartości zmiennoprzecinkowych oddzielających je. Na przykład różnica między 0,0 i <xref:System.Double.Epsilon> wynosi 1, ponieważ <xref:System.Double.Epsilon> jest najmniejszą reprezentacją wartości podczas pracy z, <xref:System.Double> której wartość jest równa zero. W poniższym przykładzie zastosowano tę technikę do porównania. 33333 i 1/3, czyli dwie <xref:System.Double> wartości, których poprzedni przykład kodu <xref:System.Double.Equals%28System.Double%29> z metodą nie jest równy. Należy zauważyć, że w przykładzie <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> zastosowano metodę, aby przekonwertować wartość zmiennoprzecinkową podwójnej precyzji na reprezentację liczb całkowitych.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
 Jeśli dwie <xref:System.Double.NaN?displayProperty=nameWithType> wartości są badane pod kątem równości przez <xref:System.Double.Equals%2A> wywołanie metody, metoda zwraca `true`. Jeśli jednak dwie <xref:System.Double.NaN> wartości są badane pod kątem równości przy użyciu operatora równości, operator zwraca `false`. Aby określić, czy wartość <xref:System.Double> nie jest liczbą (NaN), alternatywą jest <xref:System.Double.IsNaN%2A> wywołanie metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Rozwiązanie do przeciążenia kompilatora może uwzględniać pozorną różnicę w zachowaniu dwóch <see cref="M:System.Double.Equals(System.Object)" /> przeciążeń metod. Jeśli niejawna konwersja między <paramref name="obj" /> <see cref="T:System.Double" /> argumentem a jest zdefiniowana, a argument nie <see cref="T:System.Object" />jest typem jako, kompilatory <see cref="M:System.Double.Equals(System.Double)" /> mogą wykonać niejawną konwersję i wywołać metodę. W <see cref="M:System.Double.Equals(System.Object)" /> przeciwnym razie wywołuje metodę, która zawsze zwraca <see langword="false" /> wartość, jeśli <paramref name="obj" /> <see cref="T:System.Double" /> jej argument nie jest wartością. Poniższy przykład ilustruje różnice w zachowaniu między dwoma przeciążeniami metod. W przypadku wszystkich pierwotnych typów liczbowych, z <see cref="T:System.Decimal" /> wyjątkiem i C#w, pierwsze porównanie zwraca <see langword="true" /> , ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołuje <see cref="M:System.Double.Equals(System.Double)" /> metodę, podczas gdy drugi Porównanie zwraca <see langword="false" /> , <see cref="M:System.Double.Equals(System.Object)" /> ponieważ kompilator wywołuje metodę.  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> jest <see langword="false" />wystąpieniem i jest równa wartości tego wystąpienia; w przeciwnym razie,. <see cref="T:System.Double" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A> Metoda powinna być stosowana z zachowaniem ostrożności, ponieważ dwie równoważne wartości mogą być nierówne z powodu różnej dokładności dwóch wartości. Poniższy przykład zgłasza, że <xref:System.Double> wartość. 3333 <xref:System.Double> i zwrócone przez podział 1 przez 3 są różne.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Aby poznać alternatywy wywołania <xref:System.Double.Equals%2A> metody, zapoznaj się z dokumentacją <xref:System.Double.Equals%28System.Double%29> przeciążenia.  
  
> [!NOTE]
>  Ponieważ <xref:System.Double.Epsilon> definiuje minimalne wyrażenie wartości dodatniej, której zakres jest bliski zero, margines różnicy między dwoma podobnymi wartościami musi być większy niż <xref:System.Double.Epsilon>. Zwykle jest to wiele razy większe niż <xref:System.Double.Epsilon>.  
  
 Dokładność liczb zmiennoprzecinkowych poza udokumentowaną dokładnością jest określona dla implementacji oraz wersji systemu .NET Framework. W związku z tym porównanie dwóch określonych liczb może ulec zmianie między wersji systemu .NET Framework, ponieważ precyzja przedstawienia numeracji wewnętrznej może ulec zmianie.  
  
 Jeśli dwie <xref:System.Double.NaN?displayProperty=nameWithType> wartości są badane pod kątem równości przez <xref:System.Double.Equals%2A> wywołanie metody, metoda zwraca `true`. Jeśli jednak dwie <xref:System.Double.NaN> wartości są badane pod kątem równości przy użyciu operatora równości, operator zwraca `false`. Aby określić, czy wartość <xref:System.Double> nie jest liczbą (NaN), alternatywą jest <xref:System.Double.IsNaN%2A> wywołanie metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Rozwiązanie do przeciążenia kompilatora może uwzględniać pozorną różnicę w zachowaniu dwóch <see cref="M:System.Double.Equals(System.Object)" /> przeciążeń metod. Jeśli niejawna konwersja między <paramref name="obj" /> <see cref="T:System.Double" /> argumentem a jest zdefiniowana, a argument nie <see cref="T:System.Object" />jest typem jako, kompilatory <see cref="M:System.Double.Equals(System.Double)" /> mogą wykonać niejawną konwersję i wywołać metodę. W <see cref="M:System.Double.Equals(System.Object)" /> przeciwnym razie wywołuje metodę, która zawsze zwraca <see langword="false" /> wartość, jeśli <paramref name="obj" /> <see cref="T:System.Double" /> jej argument nie jest wartością. Poniższy przykład ilustruje różnice w zachowaniu między dwoma przeciążeniami metod. W przypadku wszystkich pierwotnych typów liczbowych, z <see cref="T:System.Decimal" /> wyjątkiem i C#w, pierwsze porównanie zwraca <see langword="true" /> , ponieważ kompilator automatycznie wykonuje konwersję rozszerzającą i wywołuje <see cref="M:System.Double.Equals(System.Double)" /> metodę, podczas gdy drugi Porównanie zwraca <see langword="false" /> , <see cref="M:System.Double.Equals(System.Object)" /> ponieważ kompilator wywołuje metodę.  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość typu <see cref="T:System.Double" />. <see cref="T:System.TypeCode" /></summary>
        <returns>Stała <see cref="F:System.TypeCode.Double" />Wyliczenie.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Określa, czy określona wartość jest skończona (zero, subnormal lub Normal).</summary>
        <returns><see langword="true" />Jeśli wartość jest skończona (zero, subnormal lub Normal); <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona liczba daje w wyniku ujemną czy dodatnią.</summary>
        <returns><see langword="true" />Jeśli <paramref name="d" /> jest wynikiem obliczenia <see cref="F:System.Double.PositiveInfinity" /> lub <see cref="F:System.Double.NegativeInfinity" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Double.PositiveInfinity> lub <xref:System.Double.NegativeInfinity> sygnalizujący warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona wartość nie jest liczbą (<see cref="F:System.Double.NaN" />).</summary>
        <returns><see langword="true" />w <paramref name="d" /> przypadku wartości zwraca <see cref="F:System.Double.NaN" />wartość; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Double.NaN> do sygnału, że wynik operacji jest niezdefiniowany. Na przykład dzielenie 0,0 przez 0,0 skutkuje wynikiem <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A>zwraca `false` czy<xref:System.Double> wartość jest <xref:System.Double.PositiveInfinity> albo<xref:System.Double.NegativeInfinity>. Aby przetestować te wartości, użyj <xref:System.Double.IsInfinity%2A>metod, <xref:System.Double.IsPositiveInfinity%2A>i <xref:System.Double.IsNegativeInfinity%2A> .  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Określa, czy określona wartość jest ujemna.</summary>
        <returns><see langword="true" />Jeśli wartość jest ujemna; <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca wartość wskazującą, czy określona liczba ma być ujemna nieskończoność.</summary>
        <returns><see langword="true" />w <paramref name="d" /> przypadku wartości zwraca <see cref="F:System.Double.NegativeInfinity" />wartość; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Double.NegativeInfinity> do sygnału warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Określa, czy określona wartość jest normalna.</summary>
        <returns><see langword="true" />Jeśli wartość jest normalna; <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca wartość wskazującą czy określona liczba daje w wyniku dodatnią nieskończoność.</summary>
        <returns><see langword="true" />w <paramref name="d" /> przypadku wartości zwraca <see cref="F:System.Double.PositiveInfinity" />wartość; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacje zmiennoprzecinkowe zwracają <xref:System.Double.PositiveInfinity> do sygnału warunek przepełnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Określa, czy określona wartość jest w trybie normalnym.</summary>
        <returns><see langword="true" />Jeśli wartość jest normalna; <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Reprezentuje największą możliwą wartość <see cref="T:System.Double" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej to dodatnia 1.7976931348623157 E + 308.  
  
 Wynik operacji, która przekracza wartość <xref:System.Double.MaxValue?displayProperty=nameWithType> równą. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> W poniższym przykładzie <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> wynikiem są operacje dodawania, mnożenia i potęgowania, gdy wynik przekroczy <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Reprezentuje najmniejszą możliwą wartość <see cref="T:System.Double" />. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest ujemna 1.7976931348623157 E + 308.  
  
 Wynik operacji, która jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> W poniższym przykładzie wynikiem są <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> operacje odejmowania i mnożenia, gdy wynik jest mniejszy niż. <xref:System.Double.MinValue?displayProperty=nameWithType>  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Reprezentuje wartość, która nie jest liczbą (<see langword="NaN" />). To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda lub operator zwraca <xref:System.Double.NaN> , gdy wynik operacji jest niezdefiniowany. Na przykład wynik dzielenia zera przez zero to <xref:System.Double.NaN>, jak pokazano w poniższym przykładzie. (Ale należy zauważyć, że dzielenie liczby niezerowej przez zero zwraca albo <xref:System.Double.PositiveInfinity> lub <xref:System.Double.NegativeInfinity>, w zależności od znaku dzielnika).  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Ponadto wywołanie metody z <xref:System.Double.NaN> wartością lub operacją <xref:System.Double.NaN> w zwracanej <xref:System.Double.NaN>wartości, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Użyj metody <xref:System.Double.IsNaN%2A> , aby określić, czy wartość nie jest liczbą. Operator traktuje dwie <xref:System.Double.NaN> wartości, aby były nierówne. <xref:System.Double.op_Equality%2A> <xref:System.Double> Ogólnie rzecz biorąc operatory nie mogą być używane do <xref:System.Double.NaN?displayProperty=nameWithType> porównywania <xref:System.Double> z innymi wartościami, chociaż metody porównania ( <xref:System.Double.Equals%2A> takie <xref:System.Double.CompareTo%2A>jak i) mogą. Poniższy przykład ilustruje różnice w zachowaniu między <xref:System.Double> operatorami i metodami porównania.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Double.NaN>:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Reprezentuje nieskończoność ujemną. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest wynikiem dzielenia ujemnej liczby przez zero.  
  
 Ta stała jest zwracana, gdy wynik operacji jest mniejszy niż <xref:System.Double.MinValue>.  
  
 Użyj <xref:System.Double.IsNegativeInfinity%2A> , aby określić, czy wartość ma być ujemna nieskończoność.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie określone <see cref="T:System.Double" /> wartości są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> sąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operator równości dla <xref:System.Double> wartości. <xref:System.Double.op_Equality%2A>  
  
 Jeśli dwie <xref:System.Double.NaN?displayProperty=nameWithType> wartości są badane pod kątem równości przy użyciu operatora równości, wynik to `false`; dwie <xref:System.Double.NaN?displayProperty=nameWithType> wartości nie są uważane za równe. Jeśli są one badane pod kątem równości przez wywołanie <xref:System.Double.Equals%2A> metody, wynik jest. `true`  Aby określić, czy wartość <xref:System.Double> nie jest liczbą (NaN), alternatywą jest <xref:System.Double.IsNaN%2A> wywołanie metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Double" /> wartość jest większa niż inna określona <see cref="T:System.Double" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego od dla <xref:System.Double> wartości. <xref:System.Double.op_GreaterThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Double" /> wartość jest większa lub równa innej określonej <see cref="T:System.Double" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większe lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora wyższego niż lub równego dla <xref:System.Double> wartości. <xref:System.Double.op_GreaterThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie określone <see cref="T:System.Double" /> wartości nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operator nierówności dla <xref:System.Double> wartości. <xref:System.Double.op_Inequality%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Double" /> wartość jest mniejsza od innej określonej <see cref="T:System.Double" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszościowego dla <xref:System.Double> wartości. <xref:System.Double.op_LessThan%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określona <see cref="T:System.Double" /> wartość jest mniejsza lub równa innej określonej <see cref="T:System.Double" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego niż lub równego dla <xref:System.Double> wartości. <xref:System.Double.op_LessThanOrEqual%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową podwójnej precyzji.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową podwójnej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa podwójnej precyzji, która jest równoważna z wartością numeryczną lub symbolem <paramref name="s" />określonym w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr może zawierać bieżącą <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>kulturę, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>lub ciąg w postaci: `s`  
  
 [*WS*] [*Sign*] [*cyfry całkowite*[*,*]] *cyfry całkowite* [*.* [*cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+). Można użyć tylko znaku wiodącego.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Uruchomienia *cyfr całkowitych* mogą być partycjonowane przez symbol separatora grupy. Na przykład w niektórych kulturach przecinek (,) oddziela grupy wartości tysięcznych. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|,|Symbol separatora tysięcy specyficzny dla kultury.|  
|.|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Oznacza to, że znaki odstępu i separatory tysięcy są dozwolone, na przykład, gdy symbole waluty nie są. Aby uzyskać dokładniejszą kontrolę nad tym, które elementy `s` stylów są dozwolone w celu pomyślnego wykonania <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> operacji analizy <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> , wywołaj metodę lub.  
  
 Parametr jest interpretowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest inicjowany dla bieżącej kultury wątku. `s` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Aby przeanalizować ciąg przy użyciu informacji o formatowaniu innej kultury, <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Wywołaj <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę lub.  
  
 Zwykle w przypadku przekazania <xref:System.Double.Parse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Double.Parse%28System.String%29> sposób używania metody.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje liczby w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Double.MinValue" /> lub <see cref="F:System.Double.MaxValue" />równa.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="s" />. Typową wartością do określenia jest kombinacja <see cref="F:System.Globalization.NumberStyles.Float" /> połączone z. <see cref="F:System.Globalization.NumberStyles.AllowThousands" /></param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu do jej równoważnej liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa podwójnej precyzji, która jest równoważna z wartością numeryczną lub symbolem <paramref name="s" />określonym w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, separatory tysięcy i symbole waluty), które są dozwolone `s` w parametrze dla operacji analizy. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Parametr może zawierać bieżącą <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>kulturę, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>lub <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. `s` W zależności od wartości `style`, może również mieć postać:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry całkowite*[*,*]]*cyfry całkowite*[*.* [*cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `s` if `style` zawiera flagę.|  
|$|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> bieżącej kultury. Symbol waluty bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+). Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|,|Separator grupy specyficzny dla kultury. Symbol separatora grupy bieżącej kultury może pojawić się `s` w `style` przypadku, <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> gdy zawiera flagę|  
|.|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `s`|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie formantu, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Elementy dozwolone jako `s` uzupełnienie cyfr|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (*.*) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. Ta flaga sama obsługuje wartości w postaci *cyfr*E*cyfr*; dodatkowe flagi są konieczne do pomyślnego przeanalizowania ciągów z takimi elementami jak znaki dodatnie lub ujemne oraz symbole separatora dziesiętnego.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora tysięcznego (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na końcu `s`, ** `s`znak na początku i symbol separatora dziesiętnego (.). `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (,) i separator dziesiętny (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej.|  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `s` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Zwykle w przypadku przekazania <xref:System.Double.Parse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> , aby przeanalizować ciąg <xref:System.Double> reprezentujący wartości przy użyciu kultury en-us.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje liczby w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Double.MinValue" /> lub <see cref="F:System.Double.MaxValue" />równa.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> zawiera wartość.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="s" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym formacie specyficznym dla kultury do jej równoważnej liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa podwójnej precyzji, która jest równoważna z wartością numeryczną lub symbolem <paramref name="s" />określonym w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> metody jest zwykle używane do konwersji tekstu, który można sformatować na różne sposoby <xref:System.Double> . Na przykład można go użyć do przekonwertowania tekstu wprowadzonego przez użytkownika w polu tekstowym HTML na wartość liczbową.  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, lub<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> dla kultury określonej przez lub może zawierać ciąg w postaci: `s`  
  
 [*WS*] [*Sign*] *cyfry całkowite* [*.* [*cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy, które zawierają „cyfry”, składają się z serii cyfr od 0 do 9.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+).|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Uruchomienia *cyfr całkowitych* mogą być partycjonowane przez symbol separatora grupy. Na przykład w niektórych kulturach przecinek (,) oddziela grupy wartości tysięcznych. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|.|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
 Aby uzyskać więcej informacji na temat formatów liczbowych, zobacz temat [Typy formatowania](~/docs/standard/base-types/formatting-types.md) .  
  
 <xref:System.IFormatProvider.GetFormat%2A> `s`Parametr jest implementacją, której metoda zwraca obiekt,którydostarczainformacjespecyficznedlakulturyużywanewinterpretacjiformatu.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` Zwykle jest <xref:System.Globalization.NumberFormatInfo> to obiekt lub <xref:System.Globalization.CultureInfo> . Jeśli `provider` jest `null` lub<xref:System.Globalization.NumberFormatInfo> nie można uzyskać informacji o formatowaniu dla bieżącej kultury systemu.  
  
 Zwykle w przypadku przekazania <xref:System.Double.Parse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie występuje program obsługi zdarzeń kliknięcia przycisku w formularzu sieci Web. Używa tablicy zwracanej przez <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> właściwość w celu określenia ustawień regionalnych użytkownika. Następnie tworzy wystąpienie <xref:System.Globalization.CultureInfo> obiektu, który odpowiada tym ustawieniom regionalnym. Obiekt, który należy do tego <xref:System.Globalization.CultureInfo> obiektu, <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> jest następnie przenoszona do metody <xref:System.Double> w celu przekonwertowania danych wejściowych użytkownika na wartość. <xref:System.Globalization.NumberFormatInfo>  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje liczby w prawidłowym formacie.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Double.MinValue" /> lub <see cref="F:System.Double.MaxValue" />równa.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="s" />. Typowa wartość do określenia jest <see cref="F:System.Globalization.NumberStyles.Float" /> połączona <see cref="F:System.Globalization.NumberStyles.AllowThousands" />z.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="s" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury do jego równorzędnej liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa podwójnej precyzji, która jest równoważna z wartością numeryczną lub symbolem <paramref name="s" />określonym w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, separatory tysięcy i symbole waluty), które są dozwolone `s` w parametrze dla operacji analizy. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, lub<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> dla kultury określonej przez. `s` W zależności od wartości `style`, może również mieć postać:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry całkowite*],*cyfry całkowite*[. [ *cyfry ułamkowe*]] [E [*Sign*]*cyfry wykładnicze*] [*WS*]  
  
 Elementy w nawiasach kwadratowych ([i]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `s` if `style` zawiera flagę.|  
|$|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> bieżącej kultury. Symbol waluty bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Symbol znaku minus (-) lub znaku dodatniego (+). Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Element ** z cyframi całkowitymi może być nieobecny, jeśli ciąg zawiera element *Ułamkowo-cyfr* .|  
|,|Separator grupy specyficzny dla kultury. Symbol separatora grupy bieżącej kultury może pojawić się `s` w `style` przypadku, <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> gdy zawiera flagę|  
|.|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `s`|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie formantu, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Elementy dozwolone jako `s` uzupełnienie cyfr|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (*.*) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. Ta flaga sama obsługuje wartości w postaci *cyfr*E*cyfr*; dodatkowe flagi są konieczne do pomyślnego przeanalizowania ciągów z takimi elementami jak znaki dodatnie lub ujemne oraz symbole separatora dziesiętnego.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora tysięcznego (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na końcu `s`, ** `s`znak na początku i symbol separatora dziesiętnego (.). `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (,) i separator dziesiętny (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `s` Jednak nie może reprezentować liczby szesnastkowej.|  
  
 <xref:System.IFormatProvider.GetFormat%2A> `s`Parametr jest implementacją, której metoda zwraca obiekt,którydostarczainformacjespecyficznedlakulturyużywanewinterpretacjiformatu.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` Zwykle jest <xref:System.Globalization.NumberFormatInfo> to obiekt lub <xref:System.Globalization.CultureInfo> . Jeśli `provider` jest `null` lub<xref:System.Globalization.NumberFormatInfo> nie można uzyskać informacji o formatowaniu dla bieżącej kultury systemu.  
  
 Zwykle w przypadku przekazania <xref:System.Double.Parse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody do przypisywania kilku ciągów `Temperature` do wartości temperatury do obiektu.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />nie reprezentuje wartości liczbowej.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> jest wartością.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />reprezentuje liczbę, która jest mniejsza <see cref="F:System.Double.MinValue" /> lub <see cref="F:System.Double.MaxValue" />równa.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Reprezentuje nieskończoność dodatnią. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest wynikiem dzielenia liczby dodatniej przez zero.  
  
 Ta stała jest zwracana, gdy wynik operacji jest większy niż <xref:System.Double.MaxValue>.  
  
 Użyj <xref:System.Double.IsPositiveInfinity%2A> , aby określić, czy wartość jest równa nieskończoności dodatniej.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli wartość bieżącego wystąpienia nie jest równa zero; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia tej metody <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Ta konwersja nie jest obsługiwana. Próba użycia tej metody zgłasza<see cref="T:System.InvalidCastException" /></summary>
        <returns>Ta konwersja nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ, do którego ma zostać przekonwertowana ta <see cref="T:System.Double" /> wartość.</param>
        <param name="provider"><see cref="T:System.IFormatProvider" /> Implementacja, która dostarcza informacje specyficzne dla kultury o formacie zwracanej wartości.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie `static` metody (`Shared` w Visual Basic). <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ten parametr jest ignorowany.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />Zobacz.</summary>
        <returns>Wartość bieżącego wystąpienia, konwertowana na <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Double> gdy wystąpienie jest rzutowane <xref:System.IConvertible> do interfejsu. Zalecaną alternatywą jest wywołanie <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString> Metoda formatujewartośćwformaciedomyślnym("G"lubogólnym<xref:System.Double> ) bieżącej kultury. Jeśli chcesz określić inny format, precyzję lub kulturę, użyj innych przeciążeń <xref:System.Double.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Określona kultura|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Określony format lub precyzja|Domyślna kultura (bieżąca)|<xref:System.Double.ToString%28System.String%29>|  
|Określony format lub precyzja|Określona kultura|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub ciąg w postaci:  
  
 [znak]cyfry-całkowite[.[cyfry-ułamkowe]][e[znak]cyfry-wykładnicze]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy, które zawierają „cyfry”, składają się z serii cyfr od 0 do 9. Elementy wymienione w poniższej tabeli są obsługiwane.  
  
|Element|Opis|  
|-------------|-----------------|  
|*sign*|Znak ujemny lub symbol znaku dodatniego.|  
|*integral-digits*|Ciąg cyfr określający część całkowitą liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|'*.*'|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr określający część ułamkową liczby.|  
|"*e*"|Mała litera „e”, wskazująca zapis wykładniczy (naukowy).|  
|*cyfry wykładnicze*|Ciąg cyfr określające wykładnik potęgi.|  
  
 Oto kilka przykładów zwracanej wartości: „100”, „-123,456,789”, „123.45e + 6”, „500”, „3.1416”, „600”, „-0.123” i „-nieskończoność”.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano metodę <xref:System.Double.ToString?displayProperty=nameWithType> domyślną, aby wyświetlić reprezentację ciągu dla <xref:System.Double> wielu wartości.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Poniższy przykład ilustruje użycie <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanych danych formatowania specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29> Metoda formatujewartośćwformaciedomyślnym("G"lubogólnym<xref:System.Double> ) określonej kultury. Jeśli chcesz określić inny format lub kulturę, użyj innych przeciążeń <xref:System.Double.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślne (bieżące)|<xref:System.Double.ToString>|  
|Określony format lub precyzja|Domyślna kultura (bieżąca)|<xref:System.Double.ToString%28System.String%29>|  
|Określony format lub precyzja|Określona kultura|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>lub ciąg w postaci:  
  
 [znak]cyfry-całkowite[.[cyfry-ułamkowe]][e[znak]cyfry-wykładnicze]  
  
 Elementy opcjonalne są obramowane nawiasami kwadratowymi ([ i ]). Elementy, które zawierają „cyfry”, składają się z serii cyfr od 0 do 9. Elementy wymienione w poniższej tabeli są obsługiwane.  
  
|Element|Opis|  
|-------------|-----------------|  
|*sign*|Znak ujemny lub symbol znaku dodatniego.|  
|*integral-digits*|Ciąg cyfr określający część całkowitą liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|'*.*'|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Ciąg cyfr określający część ułamkową liczby.|  
|"*e*"|Mała litera „e”, wskazująca zapis wykładniczy (naukowy).|  
|*cyfry wykładnicze*|Ciąg cyfr określające wykładnik potęgi.|  
  
 Oto kilka przykładów zwracanej wartości: „100”, „-123,456,789”, „123.45e + 6”, „500”, „3.1416”, „600”, „-0.123” i „-nieskończoność”.  
  
 To wystąpienie jest sformatowana za pomocą ogólnego specyfikatora formatu liczbowego („G”).  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Parametr jest <xref:System.IFormatProvider> implementacją<xref:System.IFormatProvider.GetFormat%2A> , której metoda zwraca obiekt.<xref:System.Globalization.NumberFormatInfo> `provider` `provider` Zazwyczaj <xref:System.Globalization.NumberFormatInfo> jest obiektemlubobiektem.<xref:System.Globalization.CultureInfo> `provider` Parametr dostarcza informacje specyficzne dla kultury używane w formatowaniu. Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> wartość zwracana jest formatowana przy użyciu obiektu dla bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wyświetla ciąg reprezentujący dwie <xref:System.Double> wartości przy użyciu <xref:System.Globalization.CultureInfo> obiektów, które reprezentują kilka różnych kultur.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Poniższy przykład ilustruje użycie <xref:System.Double.ToString%2A>, <xref:System.String> pobierając parametry i <xref:System.IFormatProvider> jako.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29> Metoda formatujewartośćwokreślonymformacieprzy<xref:System.Double> użyciu Konwencji bieżącej kultury. Jeśli chcesz określić inny format lub kulturę, użyj innych przeciążeń <xref:System.Double.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślna kultura (bieżąca)|<xref:System.Double.ToString>|  
|Domyślny format ("G")|Określona kultura|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Określony format lub precyzja|Określona kultura|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, lub reprezentację liczby w postaci ciągu określonego przez `format`.  
  
 `format` Parametr może być dowolnym prawidłowym standardowym specyfikatorem formatu liczbowego z wyjątkiem D i X, a także dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli `format` jest `null` lub jest pustym ciągiem, wartość zwracana jest formatowana przy użyciu ogólnego specyfikatora formatu liczbowego ("G").  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Domyślnie wartość zwracana zawiera tylko 15 cyfr precyzji, chociaż maksymalnie 17 cyfr jest przechowywanych wewnętrznie. Jeśli wartość tego wystąpienia ma więcej niż 15 cyfr, <xref:System.Double.ToString%2A> zwraca <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> zamiast oczekiwanej liczby. Jeśli potrzebujesz większej dokładności, określ `format` wartość w formacie "G17", która zawsze zwraca 17 cyfr dokładności lub "R", która zwraca 15 cyfr, jeśli liczba może być reprezentowana z dokładnością lub 17 cyfr, jeśli liczba może być tylko reprezentowane z maksymalną dokładnością.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wartość liczbową i formatuje ją jako wartość walutową przy użyciu standardowego ciągu formatu liczbowego "C" i jako wartość liczbowa do trzech miejsc dziesiętnych przy użyciu standardowego ciągu formatu liczbowego "N". Ciągi wynikowe są formatowane przy użyciu Konwencji kultury en-US. Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 Poniższy przykład wyświetla kilka <xref:System.Double> wartości przy użyciu obsługiwanych standardowych specyfikatorów formatu liczbowego wraz z trzema niestandardowymi ciągami formatu liczb. Jeden z tych ciągów formatu niestandardowego ilustruje sposób uzupełniania <xref:System.Single> wartości zerami wiodącymi. Ponadto w przykładzie użyto specyfikatorów dokładności z każdym standardowym specyfikatorem formatu, z wyjątkiem "R". Wartości specyfikatorów dokładności mieszczą się w zakresie od 0 do 3. Aby przekonwertować wartości liczbowe na ciągi, w przykładzie stosowane są konwencje formatowania kultury en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.</exception>
        <block subset="none" type="usage"><para>W niektórych przypadkach <see cref="T:System.Double" /> wartości sformatowane przy <see langword="/platform:x64" /> użyciu standardowego ciągu formatu liczbowego "R" nie przeprowadzono pomyślnie rundy w przypadku skompilowania za pomocą <see langword="/platform:anycpu" /> przełącznika lub i uruchomienia w systemach 64-bitowych. Aby obejść ten problem, można sformatować <see cref="T:System.Double" /> wartości przy użyciu standardowego ciągu formatu liczbowego "G17". Poniższy przykład używa ciągu formatu "R" z <see cref="T:System.Double" /> wartością, która nie jest pomyślna, a także używa ciągu formatu "G17", aby pomyślnie zaokrąglić oryginalną wartość.  
  
[! code-CSharp[System. Double. ToString # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [! code — VB[System. Double. ToString # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Instrukcje: Uzupełnianie liczby zerami wiodącymi</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową tego wystąpienia na równoważną reprezentację w postaci ciągu przy użyciu podanego formatu i informacji specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość tego wystąpienia określony przez <paramref name="format" /> i. <paramref name="provider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> Metoda formatujewartośćw<xref:System.Double> określonym formacie określonej kultury. Jeśli chcesz określić inny format lub kulturę, użyj innych przeciążeń <xref:System.Double.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Domyślny format ("G")|Domyślna kultura (bieżąca)|<xref:System.Double.ToString>|  
|Domyślny format ("G")|Określona kultura|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Określony format lub precyzja|Domyślna kultura (bieżąca)|<xref:System.Double.ToString%28System.String%29>|  
  
 Wartością zwracaną może być <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, lub reprezentację liczby w postaci ciągu określonego przez `format`.  
  
 `format` Parametr może być dowolnym prawidłowym standardowym specyfikatorem formatu liczbowego z wyjątkiem D i X, a także dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli `format` jest `null` lub jest pustym ciągiem, wartość zwracana dla tego wystąpienia jest formatowana przy użyciu ogólnego specyfikatora formatu liczbowego ("G").  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Parametr jest <xref:System.IFormatProvider> implementacją<xref:System.IFormatProvider.GetFormat%2A> , której metoda zwraca obiekt.<xref:System.Globalization.NumberFormatInfo> `provider` `provider` Zazwyczaj <xref:System.Globalization.NumberFormatInfo> jest obiektemlubobiektem.<xref:System.Globalization.CultureInfo> `provider` Parametr dostarcza informacje specyficzne dla kultury używane w formatowaniu. Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> wartość zwracana jest formatowana przy użyciu obiektu dla bieżącej kultury.  
  
 Domyślnie wartość zwracana zawiera tylko 15 cyfr precyzji, chociaż maksymalnie 17 cyfr jest przechowywanych wewnętrznie. Jeśli wartość tego wystąpienia ma więcej niż 15 cyfr, <xref:System.Double.ToString%2A> zwraca <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> zamiast oczekiwanej liczby. Jeśli potrzebujesz większej dokładności, określ `format` wartość w formacie "G17", która zawsze zwraca 17 cyfr dokładności lub "R", która zwraca 15 cyfr, jeśli liczba może być reprezentowana z dokładnością lub 17 cyfr, jeśli liczba może być tylko reprezentowane z maksymalną dokładnością.  
  
   
  
## Examples  
 Poniższy przykład wyświetla <xref:System.Double> wartość przy użyciu każdego z obsługiwanych standardowych specyfikatorów formatu liczbowego dla kilku różnych kultur.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Poniższy przykład ilustruje użycie <xref:System.Double.ToString%2A>, <xref:System.String> pobierając parametry i <xref:System.IFormatProvider> jako.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>W niektórych przypadkach <see cref="T:System.Double" /> wartości sformatowane przy <see langword="/platform:x64" /> użyciu standardowego ciągu formatu liczbowego "R" nie przeprowadzono pomyślnie rundy w przypadku skompilowania za pomocą <see langword="/platform:anycpu" /> przełącznika lub i uruchomienia w systemach 64-bitowych. Aby obejść ten problem, można sformatować <see cref="T:System.Double" /> wartości przy użyciu standardowego ciągu formatu liczbowego "G17". Poniższy przykład używa ciągu formatu "R" z <see cref="T:System.Double" /> wartością, która nie jest pomyślna, a także używa ciągu formatu "G17", aby pomyślnie zaokrąglić oryginalną wartość.  
  
[!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Instrukcje: Uzupełnianie liczby zerami wiodącymi</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: Narzędzie do formatowania .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową podwójnej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera liczbę zmiennoprzecinkową o <paramref name="s" /> podwójnej precyzji, jeśli konwersja zakończyła się powodzeniem, lub zero, jeśli konwersja zakończyła się niepowodzeniem. Konwersja nie powiedzie się <paramref name="s" /> , jeśli <see langword="null" /> parametr <see cref="F:System.String.Empty" />ma wartość lub, nie jest liczbą w prawidłowym <see cref="F:System.Double.MinValue" /> formacie lub <see cref="F:System.Double.MaxValue" />reprezentuje liczbę mniejszą lub równą. Ten parametr jest przekazaniem niezainicjowanym; Każda wartość pokazana w <paramref name="result" /> programie zostanie nadpisywana.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na odpowiadającą mu liczbę zmiennoprzecinkową podwójnej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <returns><see langword="true" />Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie różni się od <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> metody przez zwrócenie wartości logicznej wskazującej, czy operacja analizy zakończyła się powodzeniem, zamiast zwracać przeanalizowanej wartości liczbowej. Eliminuje to konieczność użycia obsługi wyjątków do testowania dla <xref:System.FormatException> zdarzenia, które `s` jest nieprawidłowe i nie można go pomyślnie przeanalizować.  
  
 Parametr może zawierać bieżącą <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>kulturę, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (porównanie ciągów jest rozróżniana wielkość liter) lub ciąg w postaci: `s`  
  
 WS zapis [cyfry całkowite], cyfry całkowite [. [ cyfry ułamkowe]] [e [sign] cyfry wykładnicze] [ws]  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Ciąg znaków spacji.|  
|*sign*|Znak ujemny lub symbol znaku dodatniego.|  
|*integral-digits*|Szereg znaków numerycznych od 0 do 9, które określają integralną część liczby. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|*,*|Symbol separatora grupy specyficzny dla kultury.|  
|*.*|Symbol dziesiętny specyficzny dla kultury.|  
|*cyfry ułamkowe*|Szereg znaków numerycznych od 0 do 9, które określają część ułamkową liczby.|  
|*E*|Wielkie lub małe litery "e", które oznacza notację wykładniczą (naukową).|  
|*cyfry wykładnicze*|Seria znaków numerycznych od 0 do 9, które określają wykładnik.|  
  
 Aby uzyskać więcej informacji na temat formatów liczbowych, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Parametr jest interpretowany przy użyciu kombinacji <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> flag i <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>. `s` Oznacza to, że biały znak i separatory tysięczne są dozwolone, ale symbole walut nie. Aby jawnie zdefiniować elementy (takie jak symbole waluty, separatory tysięcy i białe znaki), które mogą być obecne w `s`, <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> Użyj przeciążenia metody.  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `s` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Aby przeanalizować ciąg przy użyciu informacji o formatowaniu innej określonej kultury, użyj <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> przeciążenia metody.  
  
 Zwykle w przypadku przekazania <xref:System.Double.TryParse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Jeśli podczas operacji analizowania napotkany `s` jest separator, a Separatory dziesiętne i grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie separatorem grupy. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> metodę, aby przekonwertować ciąg reprezentujący wartości liczbowe na <xref:System.Double> wartości. Przyjęto założenie, że pl-US jest bieżącą kulturą.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: Narzędzie do formatowania .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający liczbę, która ma zostać przekształcona.</param>
        <param name="style">Bitowa kombinacja <see cref="T:System.Globalization.NumberStyles" /> wartości, która wskazuje dozwolony <paramref name="s" />format. Typowa wartość do określenia jest <see cref="F:System.Globalization.NumberStyles.Float" /> połączona <see cref="F:System.Globalization.NumberStyles.AllowThousands" />z.</param>
        <param name="provider">Dostarcza informacje o formatowaniu specyficzne dla kultury. <paramref name="s" /> <see cref="T:System.IFormatProvider" /></param>
        <param name="result">Gdy ta metoda zwraca, zawiera liczbę zmiennoprzecinkową o podwójnej precyzji, która jest równoważna wartości liczbowej lub <paramref name="s" />symbolu zawartej w, jeśli konwersja zakończyła się powodzeniem lub zero, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się <paramref name="s" /> , jeśli <see langword="null" /> parametr <see cref="F:System.String.Empty" />ma wartość lub, nie jest w formacie <paramref name="style" /> <see cref="F:System.SByte.MinValue" /> zgodnym z, reprezentuje liczbę mniejszą lub równą <see cref="F:System.SByte.MaxValue" />lub jeśli <paramref name="style" /> wartość nie jest prawidłowa kombinacja stałych <see cref="T:System.Globalization.NumberStyles" /> wyliczeniowych. Ten parametr jest przekazaniem niezainicjowanym; Każda wartość pokazana w <paramref name="result" /> programie zostanie nadpisywana.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury do jego równorzędnej liczby zmiennoprzecinkowej podwójnej precyzji. Zwracana wartość wskazuje, czy konwersja powiodła się czy nie.</summary>
        <returns><see langword="true" />Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest taka sama <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> jak metoda, z tą różnicą, że ta metoda nie zgłasza wyjątku, jeśli konwersja nie powiedzie się. <xref:System.Double.TryParse%2A> Jeśli konwersja zakończy się pomyślnie, wartość zwracana jest `true` `result` i parametr zostanie ustawiony na wynik konwersji. Jeśli konwersja nie powiedzie się, wartość zwracana `false` jest `result` i parametr zostanie ustawiony na zero. Eliminuje to konieczność użycia obsługi wyjątków <xref:System.FormatException> w celu przetestowania zdarzenia, które `s` jest nieprawidłowe i nie można go pomyślnie przeanalizować.  
  
 Parametr definiuje dozwolony format `s` parametru, aby operacja analizy powiodła się. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Następujące <xref:System.Globalization.NumberStyles> elementy członkowskie nie są obsługiwane:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> `provider`Parametr może zawierać ,<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, lub<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> dla kultury wskazanej przez. `s` Ponadto, w zależności od wartości `style` `s` , parametr może zawierać następujące elementy:  
  
 WS [$] zapis [cyfry całkowite], cyfry całkowite [. Ułamkowo-cyfry] [e [sign] cyfry wykładnicze] [ws]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak może pojawić się na początku `s` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę. Może pojawić się na końcu `s` , jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagę.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> lub <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metodę `provider` parametru. Symbol waluty może pojawić się `s` w `style` , <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Opcjonalny znak. Znak `s` może występować na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `s` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> być wyświetlany na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `s` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*integral-digits*|Ciąg cyfr od 0 do 9, które określają jej część całkowitą. Cyfry całkowite mogą być nieobecne w przypadku cyfr ułamkowych.|  
|*,*|Symbol separatora tysięcy specyficzny dla kultury. Symbol separatora tysięcy bieżącej kultury może pojawić się `s` w `style` , <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `s` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*cyfry ułamkowe*|Ciąg cyfr od 0 do 9, które określają część ułamkową liczby. Cyfry ułamkowe mogą występować w `s` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|*e*|Znak e lub e, który wskazuje, że `s` może reprezentować liczbę przy użyciu notacji wykładniczej. Parametr może reprezentować liczbę w notacji wykładniczej, jeśli <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> styl zawiera flagę. `s`|  
|*cyfry wykładnicze*|Ciąg cyfr od 0 do 9, które określają wykładnik potęgi.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Pozostałe <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementy członkowskie kontrolki, które mogą być, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela wskazuje, w <xref:System.Globalization.NumberStyles> jaki sposób poszczególne flagi wpływają na elementy, które `s`mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w parametrze s|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *całkowitej* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Parametr może również używać notacji wykładniczej. Ta flaga sama obsługuje wartości w postaci cyfr *całkowitych*E *-* cyfrowych. dodatkowe flagi są konieczne, aby pomyślnie analizować ciągi w notacji wykładniczej z takimi elementami jak znaki dodatnie lub ujemne oraz symbole cyfr dziesiętnych.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element *,* .|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie. `s` Parametr nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na `s`końcu, ** `s`znak na początku i *.* symbol. `s` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`, separator tysięcy (*,)* i punkty dziesiętne (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie style, z `s` wyjątkiem nie mogą reprezentować liczby szesnastkowej.|  
  
 Parametr jest <xref:System.Globalization.CultureInfo> implementacją, taką jak obiekt lub.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` `provider` Parametr dostarcza informacje specyficzne dla kultury używane podczas analizowania. Jeśli `provider` jest `null` lub<xref:System.Globalization.NumberFormatInfo> nie można uzyskać obiektu, zostanie użyta informacja o formacie dla bieżącej kultury.  
  
 Konwersja nie powiedzie się `s` , jeśli `null` parametr nie jest wartością liczbową, `provider` parametr nie zwraca <xref:System.Globalization.NumberFormatInfo> obiektu lub `style` parametr nie jest kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> Licznik.  
  
 Zwykle w przypadku przekazania <xref:System.Double.TryParse%2A?displayProperty=nameWithType> metody do ciągu, który jest tworzony przez <xref:System.Double.ToString%2A?displayProperty=nameWithType> wywołanie metody, zwracana jest oryginalna <xref:System.Double> wartość. Jednak ze względu na utratę precyzji wartości mogą być różne. Ponadto próbuje przeanalizować ciąg reprezentujący <xref:System.Double.MinValue> lub <xref:System.Double.MaxValue> zgłasza <xref:System.OverflowException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Jeśli w `s` parametrze podczas operacji analizy napotkany jest separator, a odpowiednia waluta lub liczba dziesiętna i separatory grupy są takie same, operacja analizy zakłada, że separator jest separatorem dziesiętnym, a nie grupą rozdzielając. Aby uzyskać więcej informacji na temat separatorów <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>zobacz <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>,, <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>, i.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> metody do analizowania ciągu reprezentującego liczby mające określony styl i są formatowane przy użyciu konwencji określonej kultury.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" /><see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> zawiera wartość.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizowanie ciągów liczbowych w programie .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>

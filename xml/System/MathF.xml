<Type Name="MathF" FullName="System.MathF">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b72284d390ede7fa9e0265550f568899dce9d8d" /><Meta Name="ms.sourcegitcommit" Value="a9b8eb12d69b131f7c0de74d471798e44e863282" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="06/04/2019" /><Meta Name="ms.locfileid" Value="66501872" /></Metadata><TypeSignature Language="C#" Value="public static class MathF" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MathF extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MathF" />
  <TypeSignature Language="VB.NET" Value="Public Class MathF" />
  <TypeSignature Language="C++ CLI" Value="public ref class MathF abstract sealed" />
  <TypeSignature Language="F#" Value="type MathF = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia stałe i metody statyczne trygonometrycznych logarytmicznej i innych typowych funkcji matematycznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

Pola statyczne i metody `MathF` klasy odpowiadają identyfikatorom <xref:System.Math> klasy, z tą różnicą, że ich parametry są typu <xref:System.Single> zamiast <xref:System.Double>, a także zwracają <xref:System.Single> zamiast <xref:System.Double> wartości.

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float x);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.MathF.Abs x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, która jest większa lub równa <see cref="F:System.Single.MinValue" />, ale jest mniejsza lub równa <see cref="F:System.Single.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa pojedynczej precyzji, x, że x ≤ 0 ≤ <see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Single> jest wartość liczbowa, bez znaku. Na przykład, wartość bezwzględna zarówno 1.2E-03 i - 1.2e03 jest 1.2e03.  
  
 Jeśli `x` jest równa <xref:System.Single.NegativeInfinity> lub <xref:System.Single.PositiveInfinity>, zwracana jest wartość <xref:System.Single.PositiveInfinity>. Jeśli `x` jest równa <xref:System.Single.NaN>, zwracana jest wartość <xref:System.Single.NaN>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static float Acos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acos(float x);" />
      <MemberSignature Language="F#" Value="static member Acos : single -&gt; single" Usage="System.MathF.Acos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca cosinus, gdzie <paramref name="x" /> musi być większa niż lub równy-1, ale jest mniejszy niż 1.</param>
        <summary>Zwraca kąt, którego cosinus jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że 0 ≤ θ ≤ π.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> &lt; -1 lub <paramref name="x" /> &gt; 1 lub <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static float Acosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acosh(float x);" />
      <MemberSignature Language="F#" Value="static member Acosh : single -&gt; single" Usage="System.MathF.Acosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca cosinus hiperboliczny, gdzie <paramref name="x" /> musi być większa lub równa 1, ale jest mniejsza lub równa <see cref="F:System.Single.PositiveInfinity" />.</param>
        <summary>Zwraca kąt, którego cosinus hiperboliczny jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że 0 ≤ θ ≤ ∞;.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> &lt; 1 lub <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static float Asin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asin(float x);" />
      <MemberSignature Language="F#" Value="static member Asin : single -&gt; single" Usage="System.MathF.Asin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca sinusa, gdzie <paramref name="x" /> musi być większa niż lub równy-1, ale jest mniejszy niż 1.</param>
        <summary>Zwraca kąt, którego sinus jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że ≤ θ ≤ - π/2 π/2.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> &lt; -1 lub <paramref name="x" /> &gt; 1 lub <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodatnia wartość zwracana reprezentuje kątowi z osi x; ujemna wartość zwracana oznacza kąt obrotu w prawo.  
  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static float Asinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asinh(float x);" />
      <MemberSignature Language="F#" Value="static member Asinh : single -&gt; single" Usage="System.MathF.Asinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca sinus hiperboliczny, gdzie <paramref name="x" /> musi być większa lub równa <see cref="F:System.Single.NegativeInfinity" />, ale jest mniejsza lub równa <see cref="F:System.Single.PositiveInfinity" />.</param>
        <summary>Zwraca kąt, którego sinus hiperboliczny jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że ∞; - &lt; θ ≤ -1 lub 1 ≤ θ &lt; ∞;. 
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static float Atan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan(float x);" />
      <MemberSignature Language="F#" Value="static member Atan : single -&gt; single" Usage="System.MathF.Atan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca stycznej.</param>
        <summary>Zwraca kąt, którego tangens jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że ≤ θ ≤ - π/2 π/2.  
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, - π/2 jest zaokrąglana do podwójnej precyzji (-1.5707963267949) Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" />, lub π/2 jest zaokrąglana do podwójnej precyzji (1.5707963267949) Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodatnia wartość zwracana reprezentuje kątowi z osi x; ujemna wartość zwracana oznacza kąt obrotu w prawo.  
  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static float Atan2 (float y, float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan2(float32 y, float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan2(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Single, x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan2(float y, float x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : single * single -&gt; single" Usage="System.MathF.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="y">Współrzędna y punktu.</param>
        <param name="x">Współrzędna x punktu.</param>
        <summary>Zwraca kąt, którego tangens jest równy ilorazowi dwóch podanych liczb.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak, aby - π ≤ θ ≤ π i tan(θ) = <paramref name="y" />  /  <paramref name="x" />, gdzie (<paramref name="x" />, <paramref name="y" />) jest punktem na płaszczyźnie formułuje. Sprawdź następujące czynności: 
-Aby (<paramref name="x" />, <paramref name="y" />) w quadrant 1, 0 &lt; θ &lt; π/2.  
  
-Aby (<paramref name="x" />, <paramref name="y" />) w quadrant 2, π/2 &lt; θ ≤ π.  
  
-Aby (<paramref name="x" />, <paramref name="y" />) w quadrant 3, - π &lt; θ &lt; - π/2.  
  
-Aby (<paramref name="x" />, <paramref name="y" />) w quadrant 4, - π/2 &lt; θ &lt; 0.  
  
Dla punktów w granicach ćwiartkach wartość zwracana jest następująca: 
-Y wynosi 0 i x czy nie jest to ujemna θ = 0.  
  
— Jeśli y wynosi 0 i x ma wartość ujemną, θ = π.  
  
-Jeśli y jest dodatnia, a x jest równa 0, θ = π/2.  
  
— Jeśli y jest ujemna, a x jest równa 0, θ = - π/2.  
  
— Jeśli y wynosi 0, a x jest równa 0, θ = 0.  
  
Jeśli <paramref name="x" /> lub <paramref name="y" /> jest <see cref="F:System.Single.NaN" />, lub jeśli <paramref name="x" /> i <paramref name="y" /> są <see cref="F:System.Single.PositiveInfinity" /> lub <see cref="F:System.Single.NegativeInfinity" />, metoda zwraca <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana jest wartość kąta w płaszczyzną formułuje utworzoną przez osi x i wektorowej, począwszy od źródła (0,0) i przerywa w punkcie, (x, y).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static float Atanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atanh(float x);" />
      <MemberSignature Language="F#" Value="static member Atanh : single -&gt; single" Usage="System.MathF.Atanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Liczba reprezentująca tangens hiperboliczny, gdzie <paramref name="x" /> musi być większa niż lub równy-1, ale jest mniejszy niż 1.</param>
        <summary>Zwraca kąt, którego tangens hiperboliczny jest równy podanej liczbie.</summary>
        <returns>Kąt, θ, wyrażony w radianach, tak że ∞; - &lt; θ &lt;-1 lub 1 &lt; θ &lt; ∞;.  
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> &lt; -1 lub <paramref name="x" /> &gt; 1 lub <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.MathF.PI?displayProperty=nameWithType> do przekonwertowania z radianów na stopnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static float BitDecrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitDecrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitDecrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitDecrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : single -&gt; single" Usage="System.MathF.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Wartość, aby zmniejszyć.</param>
        <summary>Zwraca najmniejszą wartość dalej, która porównuje mniejsza niż <paramref name="x" />.</summary>
        <returns>Dalej najmniejszą wartość, która porównuje mniej niż <paramref name="x" />.
  
—lub— 
 <see cref="F:System.Single.NegativeInfinity" /> Jeśli <paramref name="x" /> jest równa się <see cref="F:System.Single.NegativeInfinity" />.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static float BitIncrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitIncrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitIncrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitIncrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : single -&gt; single" Usage="System.MathF.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Wartość do zwiększenia.</param>
        <summary>Zwraca następny największa wartość, która jest większa niż <paramref name="x" />.</summary>
        <returns>Dalej największa wartość, która jest większa niż <paramref name="x" />.
  
—lub— 
 <see cref="F:System.Single.PositiveInfinity" /> Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.PositiveInfinity" />.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> jest równa się <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static float Cbrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cbrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cbrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cbrt(float x);" />
      <MemberSignature Language="F#" Value="static member Cbrt : single -&gt; single" Usage="System.MathF.Cbrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Numer główny modułu, którego ma zostać znaleziona.</param>
        <summary>Zwraca katalog główny modułu określonej liczby.</summary>
        <returns>Głównym modułu <paramref name="x" />.
  
—lub— 
 <see cref="F:System.Single.NaN" /> Jeśli <paramref name="x" /> jest równa się <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static float Ceiling (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Ceiling(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Ceiling(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Ceiling(float x);" />
      <MemberSignature Language="F#" Value="static member Ceiling : single -&gt; single" Usage="System.MathF.Ceiling x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca najmniejszą wartość całkowita, która jest większa niż lub równą podanej liczbie zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Najmniejsza wartość całkowita, która jest większa lub równa <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />, jest zwracana wartość. Należy zauważyć, że ta metoda zwraca <see cref="T:System.Single" /> zamiast typu całkowitego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność. Innymi słowy Jeśli `x` jest dodatnia, obecność dowolnej przyczyny części ułamkowych `x` ma zostać zaokrąglona do liczby całkowitej najwyższy. Jeśli `x` jest ujemna, operację zaokrąglenia powoduje, że dowolny składnik ułamkowe `x` do usunięcia. Działanie tej metody różni się od <xref:System.MathF.Floor%28System.Single%29> metody, która obsługuje zaokrąglaniem kierunku minus nieskończoność.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static float CopySign (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CopySign(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.CopySign(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CopySign(float x, float y);" />
      <MemberSignature Language="F#" Value="static member CopySign : single * single -&gt; single" Usage="System.MathF.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której wartość bezwzględna jest używany w wyniku.</param>
        <param name="y">Liczba, której znak jest używany w wyniku.</param>
        <summary>Zwraca wartość o wielkości <paramref name="x" /> i znak <paramref name="y" />.</summary>
        <returns>Wartość o wielkości <paramref name="x" /> i znak <paramref name="y" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static float Cos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cos(float x);" />
      <MemberSignature Language="F#" Value="static member Cos : single -&gt; single" Usage="System.MathF.Cos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca cosinus określonego kąta.</summary>
        <returns>Cosinus <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />, Metoda ta zwraca <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static float Cosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cosh(float x);" />
      <MemberSignature Language="F#" Value="static member Cosh : single -&gt; single" Usage="System.MathF.Cosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca cosinus hiperboliczny podanemu kątowi.</summary>
        <returns>Cosinus hiperboliczny liczby <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" /> lub <see cref="F:System.Single.PositiveInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> jest zwracana. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const float E = 2.718282;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 E = (2.718282)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Single  = 2.718282" />
      <MemberSignature Language="C++ CLI" Value="public: float E = 2.718282;" />
      <MemberSignature Language="F#" Value="val mutable E : single" Usage="System.MathF.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>2.718282</MemberValue>
      <Docs>
        <summary>Reprezentuje logarytmu naturalnego, określony przez wartość stałej, <see langword="e" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Wartość tej stałej jest 2.71828175.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static float Exp (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exp(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Exp(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exp(float x);" />
      <MemberSignature Language="F#" Value="static member Exp : single -&gt; single" Usage="System.MathF.Exp x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba określająca potęgi.</param>
        <summary>Zwraca <see langword="e" /> podniesione do określonej potęgi.</summary>
        <returns>Liczba <see langword="e" /> podniesioną do potęgi <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" /> lub <see cref="F:System.Single.PositiveInfinity" />, jest zwracana wartość. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" />, zwracany jest 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` jest stałe matematyczne, którego wartością jest około 2.71828.  
  
 Użyj <xref:System.MathF.Pow%2A> metodę, aby obliczyć potęgi innych podstaw.  
  
 <xref:System.MathF.Exp%2A> jest przeciwieństwem <xref:System.MathF.Log%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
        <altmember cref="M:System.MathF.Log(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static float Floor (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Floor(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Floor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Floor(float x);" />
      <MemberSignature Language="F#" Value="static member Floor : single -&gt; single" Usage="System.MathF.Floor x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji.</param>
        <summary>Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Całkowite największą wartość mniejsze niż lub równe <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />, jest zwracana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność. Innymi słowy Jeśli `x` jest dodatnia, dowolny składnik ułamkowe zostały obcięte. Jeśli `x` jest ujemna, obecności części ułamkowych powoduje, że ma zostać zaokrąglona do mniejszej liczby całkowitej. Działanie tej metody różni się od <xref:System.MathF.Ceiling%2A> metody, która obsługuje zaokrąglaniem kierunku Plus nieskończoność.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static float FusedMultiplyAdd (float x, float y, float z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 FusedMultiplyAdd(float32 x, float32 y, float32 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.FusedMultiplyAdd(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Single, y As Single, z As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float FusedMultiplyAdd(float x, float y, float z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : single * single * single -&gt; single" Usage="System.MathF.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="z" Type="System.Single" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, należy pomnożyć z <paramref name="y" />.</param>
        <param name="y">Liczba, należy pomnożyć z <paramref name="x" />.</param>
        <param name="z">Numer, który ma zostać dodany do wyniku <paramref name="x" /> pomnożona przez <paramref name="y" />.</param>
        <summary>Zwraca (x * y) + z, zaokrąglony jako jedna operacja trójargumentowy.</summary>
        <returns>(x * y) + z, zaokrąglony jako jedna operacja trójargumentowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To oblicza `(x * y)` tak, jakby dokładnością do nieskończoności, dodaje `z` do wyniku tak, jakby dokładnością do nieskończoności, a na koniec powoduje zaokrąglenie do najbliższej wartość.
  
 To różni się od sekwencji zespolone, który będzie obliczenia `(x * y)` tak, jakby na nieskończonej preicision zaokrąglony wynik na najbliższą wartość, należy dodać "z", aby zaokrąglony wynik tak, jakby dokładnością do nieskończoności, a na koniec zaokrąglona do najbliższej stałego wartość.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static float IEEERemainder (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 IEEERemainder(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.IEEERemainder(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float IEEERemainder(float x, float y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : single * single -&gt; single" Usage="System.MathF.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Dzielna.</param>
        <param name="y">Dzielnik.</param>
        <summary>Zwraca resztę z dzielenia liczby określonej przez inny określony numer.</summary>
        <returns>Liczby równej <paramref name="x" /> -(<paramref name="y" /> funkcji pytania i odpowiedzi), w którym funkcji pytania i odpowiedzi jest równy ilorazowi <paramref name="x" />  /  <paramref name="y" /> zaokrąglona do najbliższej liczby całkowitej (Jeśli <paramref name="x" />  /  <paramref name="y" /> przypada w połowie między dwoma liczbami całkowitymi, parzystej liczby całkowitej jest zwracana).  
  
Jeśli <paramref name="x" /> -(<paramref name="y" /> funkcji pytania i odpowiedzi) wynosi zero, wartość + 0 jest zwracany, jeśli <paramref name="x" /> jest dodatni lub - 0, jeśli <paramref name="x" /> jest ujemna.  
  
Jeśli <paramref name="y" /> = 0, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja jest zgodny z zdefiniowane w sekcji 5.1 754-1985 standard ANSI/IEEE; Operacja Reminder Standard IEEE binarne arytmetyki zmiennoprzecinkowej; Instytut elektrycznych i Electronics Engineers, Inc.; 1985 roku.  
  
 <xref:System.MathF.IEEERemainder%2A> Metoda nie jest taka sama jak [operator reszty](~/docs/csharp/language-reference/operators/remainder-operator.md). Mimo że oba zwracają resztę po dzielenia, formuł, które używają różnią się. Formuła <xref:System.MathF.IEEERemainder%2A> metodą jest:  
  
```  
IEEERemainder = dividend - (divisor * MathF.Round(dividend / divisor))  
```  
  
 Z kolei dla operatora reszta jest:  
  
```  
Remainder = (MathF.Abs(dividend) - (MathF.Abs(divisor) *   
            (MathF.Floor(MathF.Abs(dividend) / MathF.Abs(divisor))))) *   
            MathF.Sign(dividend)  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ILogB(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(float x);" />
      <MemberSignature Language="F#" Value="static member ILogB : single -&gt; int" Usage="System.MathF.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm liczby całkowitej 2 określonej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="x" /> Parametr 
 </term><description> Wartość zwracana 
 </description></listheader><item><term> Domyślny 
 </term><description> Podstawowy dziennik 2 całkowitą <paramref name="x" />; czyli log2 (int) (<paramref name="x" />).  
  
 </description></item><item><term> Zero 
 </term><description> <see cref="F:System.Int32.MinValue" />
  
 </description></item><item><term> Równa <see cref="F:System.Single.NaN" /> lub <see cref="F:System.Single.PositiveInfinity" /> lub <see cref="F:System.Single.NegativeInfinity" />
  
 </term><description> <see cref="F:System.Int32.MaxValue" />
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `x` jest określony jako podstawowy numer 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x);" />
      <MemberSignature Language="F#" Value="static member Log : single -&gt; single" Usage="System.MathF.Log x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytmu określonej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="x" /> Parametr 
 </term><description> Wartość zwracana 
 </description></listheader><item><term> Dodatnie 
 </term><description> Logarytm naturalny <paramref name="x" />; oznacza to, ln <paramref name="x" />, lub dziennika e <paramref name="x" /></description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Ujemne 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `x` jest określony jako podstawowy numer 10.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Exp(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Log : single * single -&gt; single" Usage="System.MathF.Log (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której logarytm ma zostać znaleziona.</param>
        <param name="newBase">Podstawa logarytmu.</param>
        <summary>Zwraca wartość logarytmu określonej liczby, w określonej bazie.</summary>
        <returns>Jedna z wartości w tabeli poniżej. (+ Infinity oznacza <see cref="F:System.Single.PositiveInfinity" />, - nieskończoność oznacza <see cref="F:System.Single.NegativeInfinity" />, i oznacza NaN <see cref="F:System.Single.NaN" />.) 
 <list type="table"><listheader><term><paramref name="x" /></term><description><paramref name="newBase" /></description><description> Wartość zwracana 
 </description></listheader><item><term><paramref name="x" />&gt; 0 
 </term><description> (0 &lt; <paramref name="newBase" /> &lt; 1) - lub -(<paramref name="newBase" /> &gt; 1) 
 </description><description> lognewBase(a) 
 </description></item><item><term><paramref name="x" />&lt; 0 
 </term><description> (dowolna wartość) 
 </description><description> NaN 
 </description></item><item><term> (dowolna wartość) 
 </term><description><paramref name="newBase" />&lt; 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = + Infinity 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = NaN 
 </term><description> (dowolna wartość) 
 </description><description> NaN 
 </description></item><item><term> (dowolna wartość) 
 </term><description><paramref name="newBase" /> = NaN 
 </description><description> NaN 
 </description></item><item><term> (dowolna wartość) 
 </term><description><paramref name="newBase" /> = 1 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> + Infinity 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> -Nieskończoność. 
 </description></item><item><term><paramref name="x" /> = + Infinity 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> -Nieskończoność. 
 </description></item><item><term><paramref name="x" /> = + Infinity 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> + Infinity 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> 0 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = + Infinity 
 </description><description> 0 
 </description></item></list></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static float Log10 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log10(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log10(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log10(float x);" />
      <MemberSignature Language="F#" Value="static member Log10 : single -&gt; single" Usage="System.MathF.Log10 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm 10 określoną liczbę.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="x" /> Parametr 
 </term><description> Wartość zwracana 
 </description></listheader><item><term> Dodatnie 
 </term><description> Dziennik podstawowy 10 <paramref name="x" />; to, zaloguj się 10<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Ujemne 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `x` jest określony jako podstawowy numer 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static float Log2 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log2(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log2(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log2(float x);" />
      <MemberSignature Language="F#" Value="static member Log2 : single -&gt; single" Usage="System.MathF.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm 2 określoną liczbę.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="x" /> Parametr 
 </term><description> Wartość zwracana 
 </description></listheader><item><term> Dodatnie 
 </term><description> Dziennik podstawowego 2 <paramref name="x" />; to, zaloguj się 2<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Ujemne 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Równa się <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `x` jest określony jako podstawowy numer 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.MathF.Max (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Pierwsza z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="y">Drugi dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca większy z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="x" /> lub <paramref name="y" />, która kwota jest większa. Jeśli <paramref name="x" />, lub <paramref name="y" />, i / lub <paramref name="x" /> i <paramref name="y" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MaxMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : single * single -&gt; single" Usage="System.MathF.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Pierwsza z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="y">Drugi dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca wartość większych dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="x" /> lub <paramref name="y" />, zależnie od ma większe znaczenie. Jeśli <paramref name="x" />, lub <paramref name="y" />, i / lub <paramref name="x" /> i <paramref name="y" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.MathF.Min (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Pierwsza z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="y">Drugi dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca wartość mniejszą z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="x" /> lub <paramref name="y" />, która kwota jest mniejsza. Jeśli <paramref name="x" />, <paramref name="y" />, i / lub <paramref name="x" /> i <paramref name="y" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MinMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : single * single -&gt; single" Usage="System.MathF.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Pierwsza z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="y">Drugi dwóch liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca wartość mniejszą z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="x" /> lub <paramref name="y" />, zależności jest mniejsze znaczenie. Jeśli <paramref name="x" />, lub <paramref name="y" />, i / lub <paramref name="x" /> i <paramref name="y" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracana.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const float PI = 3.141593;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PI = (3.141593)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Single  = 3.141593" />
      <MemberSignature Language="C++ CLI" Value="public: float PI = 3.141593;" />
      <MemberSignature Language="F#" Value="val mutable PI : single" Usage="System.MathF.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.141593</MemberValue>
      <Docs>
        <summary>Reprezentuje jego średnicy określony przez stałą π stosunek obwód koła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Wartość tego pola jest 3.14159274.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static float Pow (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Pow(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Pow(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Pow(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Pow : single * single -&gt; single" Usage="System.MathF.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji na podniesione do potęgi.</param>
        <param name="y">Liczba zmiennoprzecinkowa pojedynczej precyzji, która określa potęgi.</param>
        <summary>Zwraca określoną liczbę podniesioną do wskazanej potęgi.</summary>
        <returns>Liczba <paramref name="x" /> podniesioną do potęgi <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższa tabela wskazuje wartość zwracana, gdy różne wartości lub wartości, które są określone dla `x` i `y` parametrów. Aby uzyskać więcej informacji, zobacz <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
|Parametry|Wartość zwracana|  
|----------------|------------------|  
|`x` lub `y`  =  `NaN`.|`NaN`|  
|`x` = Wszystkie wartości z wyjątkiem `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` jest dodatnia nieparzystej liczby całkowitej.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` jest dodatni, ale nie nieparzystej liczby całkowitej.|`PositiveInfinity`|  
|`x` < 0, ale nie `NegativeInfinity`; `y` nie jest liczbą całkowitą `NegativeInfinity`, lub `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y`  =  `NegativeInfinity` lub `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` < wartość -1 lub `x` > 1; `y` = `NegativeInfinity`.|0|  
|`x` < wartość -1 lub `x` > 1; `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` oznacza dowolną wartość z wyjątkiem `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.MathF.Sqrt(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x);" />
      <MemberSignature Language="F#" Value="static member Round : single -&gt; single" Usage="System.MathF.Round x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji ma zostać zaokrąglona.</param>
        <summary>Zaokrągla wartość zmiennoprzecinkową o pojedynczej dokładności do najbliższej wartości całkowitej, a punkt środkowy Zaokrągla do najbliższej parzystej liczby.</summary>
        <returns>Liczbę całkowitą najbliższej <paramref name="x" />. Jeśli część ułamkową <paramref name="x" /> jest w połowie między dwóch liczb całkowitych, z których jeden jest parzysta, a nieparzysta, zwracana jest liczba parzysta. Należy zauważyć, że ta metoda zwraca <see cref="T:System.Single" /> zamiast typu całkowitego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ta metoda używa domyślnej konwencji zaokrąglania <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Jeśli wartość `x` argument jest <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>. Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, odpowiednio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ze względu na utratę dokładności, który może wynikać z reprezentujących wartości dziesiętnej jako liczb zmiennoprzecinkowych lub wykonujące operacje arytmetyczne na wartości zmiennoprzecinkowe, w niektórych przypadkach <see cref="M:System.MathF.Round(System.Single)" /> metoda nie może występować zaokrąglić wartości punktu środkowego najbliższej parzystej liczby całkowitej.</para></block>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : single * int -&gt; single" Usage="System.MathF.Round (x, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji ma zostać zaokrąglona.</param>
        <param name="digits">Liczba cyfr ułamkowych w wartości zwracanej.</param>
        <summary>Zaokrągla wartość zmiennoprzecinkową o pojedynczej dokładności określonej liczby cyfr dziesiętnych, a punkt środkowy Zaokrągla do najbliższej parzystej liczby.</summary>
        <returns>Liczba najbliżej do <paramref name="x" /> zawierającą liczbę cyfr ułamkowych, jaka jest równa <paramref name="digits" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Wartość `digits` argument do zakresu od 0 do 6. Należy pamiętać, że 6 maksymalną liczbę cyfr zaokrągleń obsługiwane przez <xref:System.Single> typu.

Ta metoda używa domyślnej konwencji zaokrąglania <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. 

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Jeśli wartość `x` argument jest <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>. Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> jest mniejszy niż 0 lub większa niż 6.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji ma zostać zaokrąglona.</param>
        <param name="mode">Specyfikacja sposób zaokrąglania <paramref name="x" /> Jeśli pomiędzy dwoma inne liczby pozycjami.</param>
        <summary>Zaokrągla wartość zmiennoprzecinkową pojedynczej precyzji dla najbliższej liczby całkowitej, a następnie używa określonej konwencji zaokrąglania wartości punktu środkowego.</summary>
        <returns>Liczbę całkowitą najbliższej <paramref name="x" />. Jeśli <paramref name="x" /> jest w połowie między dwóch liczb całkowitych, z których jeden jest parzysta, a nieparzysta, następnie <paramref name="mode" /> określa dwóch zwrócony. Należy zauważyć, że ta metoda zwraca <see cref="T:System.Single" /> zamiast typu całkowitego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Jeśli wartość `x` argument jest <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>. Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * int * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji ma zostać zaokrąglona.</param>
        <param name="digits">Liczba cyfr ułamkowych w wartości zwracanej.</param>
        <param name="mode">Specyfikacja sposób zaokrąglania <paramref name="x" /> Jeśli pomiędzy dwoma inne liczby pozycjami.</param>
        <summary>Zaokrągla wartość zmiennoprzecinkową o pojedynczej dokładności określonej liczby cyfr ułamkowych, jaka i używa określonej konwencji zaokrąglania wartości punktu środkowego.</summary>
        <returns>Liczba najbliżej do <paramref name="x" /> zawierający liczbę cyfr ułamkowych, jaka jest równa <paramref name="digits" />. Jeśli <paramref name="x" /> ma mniej cyfr ułamkowych, jaka niż <paramref name="digits" />, <paramref name="x" /> jest zwracany bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Wartość `digits` argument do zakresu od 0 do 6. Należy pamiętać, że 6 maksymalną liczbę cyfr zaokrągleń obsługiwane przez <xref:System.Single> typu.


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Jeśli wartość `x` argument jest <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>. Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> jest mniejszy niż 0 lub większa niż 6.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static float ScaleB (float x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ScaleB(float32 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ScaleB(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Single, n As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ScaleB(float x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : single * int -&gt; single" Usage="System.MathF.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa pojedynczej precyzji, która określa wartości bazowej.</param>
        <param name="n">Liczba zmiennoprzecinkowa pojedynczej precyzji, która określa możliwości.</param>
        <summary>Zwraca x * 2 ^ n obliczane wydajnie.</summary>
        <returns>x * 2 ^ n obliczane wydajnie.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float x);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.MathF.Sign x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która określa znak liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Liczba, która określa znak <paramref name="x" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Znaczenie 
 </description></listheader><item><term> -1 
 </term><description><paramref name="x" /> jest mniejsza niż zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="x" /> jest równa zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="x" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks></remarks>
        <exception cref="T:System.ArithmeticException"><paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static float Sin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sin(float x);" />
      <MemberSignature Language="F#" Value="static member Sin : single -&gt; single" Usage="System.MathF.Sin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca sinus określonego kąta.</summary>
        <returns>Sinus <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />, Metoda ta zwraca <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static float Sinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sinh(float x);" />
      <MemberSignature Language="F#" Value="static member Sinh : single -&gt; single" Usage="System.MathF.Sinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca sinus hiperboliczny liczby podanemu kątowi.</summary>
        <returns>Sinus hiperboliczny liczby <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, lub <see cref="F:System.Single.NaN" />, Metoda ta zwraca <see cref="T:System.Single" /> równa <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static float Sqrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sqrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sqrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sqrt(float x);" />
      <MemberSignature Language="F#" Value="static member Sqrt : single -&gt; single" Usage="System.MathF.Sqrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba, której pierwiastek kwadratowy ma zostać znaleziona.</param>
        <summary>Zwraca pierwiastek kwadratowy z podanej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="x" /> Parametr 
 </term><description> Wartość zwracana 
 </description></listheader><item><term> Zero lub wynik dodatni 
 </term><description> Dodatnia pierwiastek kwadratowy liczby <paramref name="x" />.  
  
 </description></item><item><term> Ujemne 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> równa się <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> równa się <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static float Tan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tan(float x);" />
      <MemberSignature Language="F#" Value="static member Tan : single -&gt; single" Usage="System.MathF.Tan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca tangens określonego kąta.</summary>
        <returns>Tangens <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />, Metoda ta zwraca <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static float Tanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tanh(float x);" />
      <MemberSignature Language="F#" Value="static member Tanh : single -&gt; single" Usage="System.MathF.Tanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Kąt wyrażony w radianach.</param>
        <summary>Zwraca tangens hiperboliczny podanemu kątowi.</summary>
        <returns>Tangens hiperboliczny liczby <paramref name="x" />. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" />, ta metoda zwraca wartość -1. Jeśli wartość jest równa <see cref="F:System.Single.PositiveInfinity" />, ta metoda zwraca wartość 1. Jeśli <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />, Metoda ta zwraca <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `x`, musi być podany w radianach. Mnożenie przez <xref:System.MathF.PI?displayProperty=nameWithType>/180 Konwertuje stopnie na radiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static float Truncate (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Truncate(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Truncate(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Truncate(float x);" />
      <MemberSignature Language="F#" Value="static member Truncate : single -&gt; single" Usage="System.MathF.Truncate x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Liczba do obcięcia.</param>
        <summary>Oblicza integralną część podanej liczbie zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Integralną częścią <paramref name="x" />; oznacza to, liczba który pozostaje po wszystkie cyfry ułamkowe zostały odrzucone lub jedna z wartości wymienionych w poniższej tabeli.  
  
 <list type="table"><listheader><term><paramref name="x" /></term><description> Wartość zwracana 
 </description></listheader><item><term><see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term><see cref="F:System.Single.NegativeInfinity" /></term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term><see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.MathF.Truncate%2A> Zaokrągla `x` do najbliższej liczby całkowitej w kierunku zera.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="MathF" FullName="System.MathF">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e2e0c51ad5b1b7db6569bdce9243c970f50e5d9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69405611" /></Metadata><TypeSignature Language="C#" Value="public static class MathF" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MathF extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MathF" />
  <TypeSignature Language="VB.NET" Value="Public Class MathF" />
  <TypeSignature Language="C++ CLI" Value="public ref class MathF abstract sealed" />
  <TypeSignature Language="F#" Value="type MathF = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="0d12f-101">Zapewnia stałe i statyczne metody dla kątów, logarytmu i innych typowych funkcji matematycznych.</span><span class="sxs-lookup"><span data-stu-id="0d12f-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="0d12f-102">`MathF` Statyczne pola i metody klasy odpowiadają <xref:System.Math> klasom klasy, z tą różnicą, że ich parametry <xref:System.Double>są typu <xref:System.Single> , a <xref:System.Double> nie i zwracają <xref:System.Single> wartości.</span><span class="sxs-lookup"><span data-stu-id="0d12f-102">The static fields and methods of the `MathF` class correspond to those of the <xref:System.Math> class, except that their parameters are of type <xref:System.Single> rather than <xref:System.Double>, and they return <xref:System.Single> rather than <xref:System.Double> values.</span></span>

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float x);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.MathF.Abs x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-103">Liczba, która jest większa lub równa <see cref="F:System.Single.MinValue" />, ale mniejsza lub <see cref="F:System.Single.MaxValue" />równa.</span><span class="sxs-lookup"><span data-stu-id="0d12f-103">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="0d12f-104">Zwraca wartość bezwzględną liczby zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-104">Returns the absolute value of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-105">Liczba zmiennoprzecinkowa o pojedynczej precyzji, x, taka jak 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-105">A single-precision floating-point number, x, such that 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-106">Wartość bezwzględna elementu <xref:System.Single> jest wartością numeryczną bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0d12f-106">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="0d12f-107">Na przykład absolutna wartość obu 1,2 e-03 i-1,2 E03 to 1,2 E03.</span><span class="sxs-lookup"><span data-stu-id="0d12f-107">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="0d12f-108">Jeśli `x` jest <xref:System.Single.PositiveInfinity> <xref:System.Single.PositiveInfinity>równa lub, wartość zwracana to. <xref:System.Single.NegativeInfinity></span><span class="sxs-lookup"><span data-stu-id="0d12f-108">If `x` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="0d12f-109">Jeśli `x` jest <xref:System.Single.NaN>równa, wartość zwracana to. <xref:System.Single.NaN></span><span class="sxs-lookup"><span data-stu-id="0d12f-109">If `x` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static float Acos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acos(float x);" />
      <MemberSignature Language="F#" Value="static member Acos : single -&gt; single" Usage="System.MathF.Acos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-110">Liczba reprezentująca cosinus, gdzie <paramref name="x" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="0d12f-110">A number representing a cosine, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="0d12f-111">Zwraca kąt, którego cosinus jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-111">Returns the angle whose cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-112">Kąt θ, mierzony w radianach, taki jak 0 ≤ θ ≤ π.</span><span class="sxs-lookup"><span data-stu-id="0d12f-112">An angle, θ, measured in radians, such that 0 ≤ θ ≤ π.</span></span>
  
<span data-ttu-id="0d12f-113">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-113">-or-</span></span> 
 <span data-ttu-id="0d12f-114"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> -1<paramref name="x" /> lub 1lub<paramref name="x" /> równa się<see cref="F:System.Single.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-114"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-115">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-115">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static float Acosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acosh(float x);" />
      <MemberSignature Language="F#" Value="static member Acosh : single -&gt; single" Usage="System.MathF.Acosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-116">Liczba reprezentująca cosinus hiperboliczny, gdzie <paramref name="x" /> musi być większa lub równa 1, ale mniejsza lub <see cref="F:System.Single.PositiveInfinity" />równa.</span><span class="sxs-lookup"><span data-stu-id="0d12f-116">A number representing a hyperbolic cosine, where <paramref name="x" /> must be greater than or equal to 1, but less than or equal to <see cref="F:System.Single.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="0d12f-117">Zwraca kąt, którego cosinus hiperboliczny jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-117">Returns the angle whose hyperbolic cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-118">Kąt θ, mierzony w radianach, taki jak 0 ≤ θ ≤ ∞.</span><span class="sxs-lookup"><span data-stu-id="0d12f-118">An angle, θ, measured in radians, such that 0 ≤ θ ≤ ∞.</span></span>
  
<span data-ttu-id="0d12f-119">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-119">-or-</span></span> 
 <span data-ttu-id="0d12f-120"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> 1&lt; lub <paramref name="x" /> równa<see cref="F:System.Single.NaN" />się.</span><span class="sxs-lookup"><span data-stu-id="0d12f-120"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-121">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-121">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static float Asin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asin(float x);" />
      <MemberSignature Language="F#" Value="static member Asin : single -&gt; single" Usage="System.MathF.Asin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-122">Liczba reprezentująca sinus, gdzie <paramref name="x" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="0d12f-122">A number representing a sine, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="0d12f-123">Zwraca kąt, którego sinus jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-123">Returns the angle whose sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-124">Kąt, θ, mierzony w radianach, taki jak π/2 ≤ θ ≤ π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-124">An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.</span></span>
  
<span data-ttu-id="0d12f-125">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-125">-or-</span></span> 
 <span data-ttu-id="0d12f-126"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> -1<paramref name="x" /> lub 1lub<paramref name="x" /> równa się<see cref="F:System.Single.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-126"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-127">Dodatnia wartość zwrotna reprezentuje kąt w kierunku przeciwnym do osi x. ujemna wartość zwracana reprezentuje kąt w prawo.</span><span class="sxs-lookup"><span data-stu-id="0d12f-127">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="0d12f-128">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-128">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static float Asinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asinh(float x);" />
      <MemberSignature Language="F#" Value="static member Asinh : single -&gt; single" Usage="System.MathF.Asinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-129">Liczba reprezentująca sinus hiperboliczny, gdzie <paramref name="x" /> musi być większa lub <see cref="F:System.Single.NegativeInfinity" />równa, ale <see cref="F:System.Single.PositiveInfinity" />mniejsza lub równa.</span><span class="sxs-lookup"><span data-stu-id="0d12f-129">A number representing a hyperbolic sine, where <paramref name="x" /> must be greater than or equal to <see cref="F:System.Single.NegativeInfinity" />, but less than or equal to <see cref="F:System.Single.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="0d12f-130">Zwraca kąt, którego sinus hiperboliczny jest podaną liczbą.</span><span class="sxs-lookup"><span data-stu-id="0d12f-130">Returns the angle whose hyperbolic sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-131">Kąt θ, mierzony w radianach, taki jak ∞ &lt; θ ≤-1 lub 1 ≤ θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="0d12f-131">An angle, θ, measured in radians, such that -∞ &lt; θ ≤ -1, or 1 ≤ θ &lt; ∞.</span></span> 
  
<span data-ttu-id="0d12f-132">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-132">-or-</span></span> 
 <span data-ttu-id="0d12f-133"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="0d12f-133"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-134">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-134">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static float Atan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan(float x);" />
      <MemberSignature Language="F#" Value="static member Atan : single -&gt; single" Usage="System.MathF.Atan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-135">Liczba reprezentująca tangens.</span><span class="sxs-lookup"><span data-stu-id="0d12f-135">A number representing a tangent.</span></span></param>
        <summary><span data-ttu-id="0d12f-136">Zwraca kąt, którego tangens jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-136">Returns the angle whose tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-137">Kąt, θ, mierzony w radianach, taki jak π/2 ≤ θ ≤ π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-137">An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.</span></span>  
  
<span data-ttu-id="0d12f-138">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-138">-or-</span></span> 
 <span data-ttu-id="0d12f-139"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równe,-π/2 zaokrąglony do podwójnej precyzji ( <paramref name="x" /> - <see cref="F:System.Single.NegativeInfinity" />1.5707963267949), jeśli Equals, lub π/2 zaokrąglony do <paramref name="x" /> podwójnej precyzji (1.5707963267949), jeśli jest równa <see cref="F:System.Single.PositiveInfinity" />się.</span><span class="sxs-lookup"><span data-stu-id="0d12f-139"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="x" /> equals <see cref="F:System.Single.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="x" /> equals <see cref="F:System.Single.PositiveInfinity" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-140">Dodatnia wartość zwrotna reprezentuje kąt w kierunku przeciwnym do osi x. ujemna wartość zwracana reprezentuje kąt w prawo.</span><span class="sxs-lookup"><span data-stu-id="0d12f-140">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="0d12f-141">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-141">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static float Atan2 (float y, float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan2(float32 y, float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan2(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Single, x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan2(float y, float x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : single * single -&gt; single" Usage="System.MathF.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="y"><span data-ttu-id="0d12f-142">Współrzędna y punktu.</span><span class="sxs-lookup"><span data-stu-id="0d12f-142">The y coordinate of a point.</span></span></param>
        <param name="x"><span data-ttu-id="0d12f-143">Współrzędna x punktu.</span><span class="sxs-lookup"><span data-stu-id="0d12f-143">The x coordinate of a point.</span></span></param>
        <summary><span data-ttu-id="0d12f-144">Zwraca kąt, którego tangens jest ilorazem dwóch określonych liczb.</span><span class="sxs-lookup"><span data-stu-id="0d12f-144">Returns the angle whose tangent is the quotient of two specified numbers.</span></span></summary>
        <returns><span data-ttu-id="0d12f-145">Kąt θ, mierzony w radianach, taki jak π ≤ θ ≤ π, i Tan (θ) <paramref name="y" />=  /  <paramref name="x" />, gdzie (<paramref name="x" />, <paramref name="y" />) jest punktem w płaszczyźnie kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="0d12f-145">An angle, θ, measured in radians, such that -π ≤ θ ≤ π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span></span> <span data-ttu-id="0d12f-146">Zwróć uwagę na następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="0d12f-146">Observe the following:</span></span> 
<span data-ttu-id="0d12f-147">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 1, &lt; 0 &lt; θ π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-147">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span></span>  
  
<span data-ttu-id="0d12f-148">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 2, π/ &lt; 2 θ ≤ π.</span><span class="sxs-lookup"><span data-stu-id="0d12f-148">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ ≤ π.</span></span>  
  
<span data-ttu-id="0d12f-149">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 3,- &lt; π &lt; θ-π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-149">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span></span>  
  
<span data-ttu-id="0d12f-150">-For (<paramref name="x" />, <paramref name="y" />) w ćwiartki 4,-π/ &lt; 2 &lt; θ 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-150">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span></span>  
  
<span data-ttu-id="0d12f-151">Dla punktów na granicach ćwiartek wartość zwracana jest następująca:</span><span class="sxs-lookup"><span data-stu-id="0d12f-151">For points on the boundaries of the quadrants, the return value is the following:</span></span> 
<span data-ttu-id="0d12f-152">-Jeśli y jest 0, a x nie jest ujemna, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-152">-   If y is 0 and x is not negative, θ = 0.</span></span>  
  
<span data-ttu-id="0d12f-153">-Jeśli y jest 0, a x jest ujemna, θ = π.</span><span class="sxs-lookup"><span data-stu-id="0d12f-153">-   If y is 0 and x is negative, θ = π.</span></span>  
  
<span data-ttu-id="0d12f-154">-Jeśli y jest dodatnia, a x to 0, θ = π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-154">-   If y is positive and x is 0, θ = π/2.</span></span>  
  
<span data-ttu-id="0d12f-155">-Jeśli y jest ujemna, a x to 0, θ =-π/2.</span><span class="sxs-lookup"><span data-stu-id="0d12f-155">-   If y is negative and x is 0, θ = -π/2.</span></span>  
  
<span data-ttu-id="0d12f-156">-Jeśli y jest 0, a x to 0, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-156">-   If y is 0 and x is 0, θ = 0.</span></span>  
  
<span data-ttu-id="0d12f-157"><paramref name="x" /> Jeślilub<see cref="F:System.Single.NaN" /> <paramref name="x" /> jestlub<see cref="F:System.Single.NegativeInfinity" />, lub jeśli i<paramref name="y" /> są albo<see cref="F:System.Single.PositiveInfinity" /> lub, metoda zwraca <see cref="F:System.Single.NaN" />. <paramref name="y" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-157">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Single.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Single.PositiveInfinity" /> or <see cref="F:System.Single.NegativeInfinity" />, the method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-158">Wartość zwracana to kąt w płaszczyźnie kartezjańskiego utworzony przez oś x, a wektor rozpoczynający się od źródła (0, 0) i kończący się w punkcie (x, y).</span><span class="sxs-lookup"><span data-stu-id="0d12f-158">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static float Atanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atanh(float x);" />
      <MemberSignature Language="F#" Value="static member Atanh : single -&gt; single" Usage="System.MathF.Atanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-159">Liczba reprezentująca tangens hiperboliczny, gdzie <paramref name="x" /> musi być większa lub równa-1, ale mniejsza lub równa 1.</span><span class="sxs-lookup"><span data-stu-id="0d12f-159">A number representing a hyperbolic tangent, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="0d12f-160">Zwraca kąt, którego tangens hiperboliczny jest równy podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-160">Returns the angle whose hyperbolic tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-161">Kąt θ, mierzony &lt; w radianach, taki jak ∞ θ &lt;-1 lub 1 &lt; θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="0d12f-161">An angle, θ, measured in radians, such that -∞ &lt; θ &lt;-1, or 1 &lt; θ &lt; ∞.</span></span>  
  
<span data-ttu-id="0d12f-162">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-162">-or-</span></span> 
 <span data-ttu-id="0d12f-163"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> -1<paramref name="x" /> lub 1lub<paramref name="x" /> równa się<see cref="F:System.Single.NaN" />. &lt; &gt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-163"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-164">Pomnóż wartość zwracaną przez 180/<xref:System.MathF.PI?displayProperty=nameWithType> do konwersji z radianów na stopnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-164">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static float BitDecrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitDecrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitDecrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitDecrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : single -&gt; single" Usage="System.MathF.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-165">Wartość do zmniejszenia.</span><span class="sxs-lookup"><span data-stu-id="0d12f-165">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="0d12f-166">Zwraca następną najmniejszą wartość, która porównuje mniej niż <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-166">Returns the next smallest value that compares less than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="0d12f-167">Następna najmniejsza wartość, która porównuje <paramref name="x" />mniej niż.</span><span class="sxs-lookup"><span data-stu-id="0d12f-167">The next smallest value that compares less than <paramref name="x" />.</span></span>
  
<span data-ttu-id="0d12f-168">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-168">-or-</span></span> 
 <span data-ttu-id="0d12f-169"><see cref="F:System.Single.NegativeInfinity" />if <paramref name="x" /> jest równa <see cref="F:System.Single.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-169"><see cref="F:System.Single.NegativeInfinity" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NegativeInfinity" />.</span></span>
  
<span data-ttu-id="0d12f-170">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-170">-or-</span></span> 
 <span data-ttu-id="0d12f-171"><see cref="F:System.Single.NaN" />Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równe.</span><span class="sxs-lookup"><span data-stu-id="0d12f-171"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static float BitIncrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitIncrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitIncrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitIncrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : single -&gt; single" Usage="System.MathF.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-172">Wartość do zwiększenia.</span><span class="sxs-lookup"><span data-stu-id="0d12f-172">The value to increment.</span></span></param>
        <summary><span data-ttu-id="0d12f-173">Zwraca następną największą wartość, która jest większa <paramref name="x" />niż.</span><span class="sxs-lookup"><span data-stu-id="0d12f-173">Returns the next largest value that is greater than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="0d12f-174">Kolejną największą wartością, która jest większa niż <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-174">The next largest value that is greater than <paramref name="x" />.</span></span>
  
<span data-ttu-id="0d12f-175">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-175">-or-</span></span> 
 <span data-ttu-id="0d12f-176"><see cref="F:System.Single.PositiveInfinity" />Jeśli <paramref name="x" /> jest <see cref="F:System.Single.PositiveInfinity" />równe.</span><span class="sxs-lookup"><span data-stu-id="0d12f-176"><see cref="F:System.Single.PositiveInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Single.PositiveInfinity" />.</span></span>
  
<span data-ttu-id="0d12f-177">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-177">-or-</span></span> 
 <span data-ttu-id="0d12f-178"><see cref="F:System.Single.NaN" />if <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-178"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static float Cbrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cbrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cbrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cbrt(float x);" />
      <MemberSignature Language="F#" Value="static member Cbrt : single -&gt; single" Usage="System.MathF.Cbrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-179">Liczba, dla której ma zostać odnaleziony katalog główny modułu.</span><span class="sxs-lookup"><span data-stu-id="0d12f-179">The number whose cube root is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-180">Zwraca katalog główny modułu o podanej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-180">Returns the cube root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-181">Katalog główny <paramref name="x" />modułu.</span><span class="sxs-lookup"><span data-stu-id="0d12f-181">The cube root of <paramref name="x" />.</span></span>
  
<span data-ttu-id="0d12f-182">—lub—</span><span class="sxs-lookup"><span data-stu-id="0d12f-182">-or-</span></span> 
 <span data-ttu-id="0d12f-183"><see cref="F:System.Single.NaN" />if <paramref name="x" /> jest równa <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-183"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static float Ceiling (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Ceiling(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Ceiling(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Ceiling(float x);" />
      <MemberSignature Language="F#" Value="static member Ceiling : single -&gt; single" Usage="System.MathF.Ceiling x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-184">Liczba zmiennoprzecinkowa pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-184">A single-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="0d12f-185">Zwraca najmniejszą wartość całkowitą, która jest większa lub równa określonej liczbie zmiennoprzecinkowej pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-185">Returns the smallest integral value that is greater than or equal to the specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-186">Najmniejsza wartość całkowita, która jest większa lub równa <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-186">The smallest integral value that is greater than or equal to <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-187">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równe ,<see cref="F:System.Single.NegativeInfinity" />, lub<see cref="F:System.Single.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-187">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="0d12f-188">Należy zauważyć, że ta metoda <see cref="T:System.Single" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="0d12f-188">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-189">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="0d12f-189">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="0d12f-190">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="0d12f-190">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="0d12f-191">Innymi słowy, jeśli `x` ma wartość dodatnią, obecność dowolnego częściowego składnika powoduje `x` Zaokrąglenie do najbliższej najwyższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-191">In other words, if `x` is positive, the presence of any fractional component causes `x` to be rounded to the next highest integer.</span></span> <span data-ttu-id="0d12f-192">Jeśli `x` jest ujemna, operacja zaokrąglania powoduje odrzucenie dowolnego `x` składnika ułamka.</span><span class="sxs-lookup"><span data-stu-id="0d12f-192">If `x` is negative, the rounding operation causes any fractional component of `x` to be discarded.</span></span> <span data-ttu-id="0d12f-193">Operacja tej metody różni się od <xref:System.MathF.Floor%28System.Single%29> metody, która obsługuje zaokrąglenie w kierunku nieskończoności ujemnej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-193">The operation of this method differs from the <xref:System.MathF.Floor%28System.Single%29> method, which supports rounding toward negative infinity.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static float CopySign (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CopySign(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.CopySign(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CopySign(float x, float y);" />
      <MemberSignature Language="F#" Value="static member CopySign : single * single -&gt; single" Usage="System.MathF.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-194">Liczba, której wartość jest używana w wyniku.</span><span class="sxs-lookup"><span data-stu-id="0d12f-194">A number whose magnitude is used in the result.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-195">Liczba, której znak jest używany w wyniku.</span><span class="sxs-lookup"><span data-stu-id="0d12f-195">A number whose sign is the used in the result.</span></span></param>
        <summary><span data-ttu-id="0d12f-196">Zwraca wartość o wielkości <paramref name="x" /> i <paramref name="y" />znaku.</span><span class="sxs-lookup"><span data-stu-id="0d12f-196">Returns a value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></summary>
        <returns><span data-ttu-id="0d12f-197">Wartość z wielkością <paramref name="x" /> i <paramref name="y" />znakiem.</span><span class="sxs-lookup"><span data-stu-id="0d12f-197">A value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static float Cos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cos(float x);" />
      <MemberSignature Language="F#" Value="static member Cos : single -&gt; single" Usage="System.MathF.Cos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-198">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-198">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-199">Zwraca cosinus określonego kąta.</span><span class="sxs-lookup"><span data-stu-id="0d12f-199">Returns the cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-200">Cosinus <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-200">The cosine of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-201">Jeśli <paramref name="x" /> <see cref="F:System.Single.NegativeInfinity" />jest <see cref="F:System.Single.PositiveInfinity" />równa <see cref="F:System.Single.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-201">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-202">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-202">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-203">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-203">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static float Cosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cosh(float x);" />
      <MemberSignature Language="F#" Value="static member Cosh : single -&gt; single" Usage="System.MathF.Cosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-204">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-204">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-205">Zwraca cosinus hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-205">Returns the hyperbolic cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-206">Cosinus hiperboliczny <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-206">The hyperbolic cosine of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-207">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.PositiveInfinity" /> równa<see cref="F:System.Single.PositiveInfinity" />lub, jest zwracana. <see cref="F:System.Single.NegativeInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-207">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> is returned.</span></span> <span data-ttu-id="0d12f-208">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" /> równa, jest zwracana. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-208">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-209">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-209">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-210">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-210">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const float E = 2.718282;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 E = (2.718282)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Single  = 2.718282" />
      <MemberSignature Language="C++ CLI" Value="public: float E = 2.718282;" />
      <MemberSignature Language="F#" Value="val mutable E : single" Usage="System.MathF.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>2.718282</MemberValue>
      <Docs>
        <summary><span data-ttu-id="0d12f-211">Reprezentuje logarytm naturalny, określony przez stałą, <see langword="e" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-211">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="0d12f-212">Wartość tej stałej to 2,71828175.</span><span class="sxs-lookup"><span data-stu-id="0d12f-212">The value of this constant is 2.71828175.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static float Exp (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exp(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Exp(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exp(float x);" />
      <MemberSignature Language="F#" Value="static member Exp : single -&gt; single" Usage="System.MathF.Exp x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-213">Liczba określająca potęgę.</span><span class="sxs-lookup"><span data-stu-id="0d12f-213">A number specifying a power.</span></span></param>
        <summary><span data-ttu-id="0d12f-214">Zwraca <see langword="e" /> wartość podniesioną do określonej potęgi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-214">Returns <see langword="e" /> raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="0d12f-215">Liczba <see langword="e" /> podniesiona do potęgi <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-215">The number <see langword="e" /> raised to the power <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-216">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" /> równa lub <see cref="F:System.Single.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-216">If <paramref name="x" /> equals <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="0d12f-217">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NegativeInfinity" />równe, zwracana jest wartość 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-217">If <paramref name="x" /> equals <see cref="F:System.Single.NegativeInfinity" />, 0 is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-218">`e`jest stałą matematyczną, której wartość wynosi około 2,71828.</span><span class="sxs-lookup"><span data-stu-id="0d12f-218">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="0d12f-219">Użyj metody <xref:System.MathF.Pow%2A> , aby obliczyć kompetencje innych baz.</span><span class="sxs-lookup"><span data-stu-id="0d12f-219">Use the <xref:System.MathF.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="0d12f-220"><xref:System.MathF.Exp%2A>jest odwrotnością <xref:System.MathF.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-220"><xref:System.MathF.Exp%2A> is the inverse of <xref:System.MathF.Log%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
        <altmember cref="M:System.MathF.Log(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static float Floor (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Floor(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Floor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Floor(float x);" />
      <MemberSignature Language="F#" Value="static member Floor : single -&gt; single" Usage="System.MathF.Floor x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-221">Liczba zmiennoprzecinkowa pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-221">A single-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="0d12f-222">Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-222">Returns the largest integral value less than or equal to the specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-223">Największa wartość całkowita mniejsza lub równa <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-223">The largest integral value less than or equal to <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-224">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równe ,<see cref="F:System.Single.NegativeInfinity" />, lub<see cref="F:System.Single.PositiveInfinity" />, ta wartość jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-224">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-225">Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4.</span><span class="sxs-lookup"><span data-stu-id="0d12f-225">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="0d12f-226">Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="0d12f-226">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="0d12f-227">Innymi słowy, jeśli `x` ma wartość dodatnią, dowolny składnik częściowy zostanie obcięty.</span><span class="sxs-lookup"><span data-stu-id="0d12f-227">In other words, if `x` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="0d12f-228">Jeśli `x` jest ujemna, obecność dowolnego komponentu ułamkowego powoduje Zaokrąglenie do mniejszej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-228">If `x` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="0d12f-229">Operacja tej metody różni się od <xref:System.MathF.Ceiling%2A> metody, która obsługuje zaokrąglanie w kierunku nieskończoności dodatniej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-229">The operation of this method differs from the <xref:System.MathF.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static float FusedMultiplyAdd (float x, float y, float z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 FusedMultiplyAdd(float32 x, float32 y, float32 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.FusedMultiplyAdd(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Single, y As Single, z As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float FusedMultiplyAdd(float x, float y, float z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : single * single * single -&gt; single" Usage="System.MathF.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="z" Type="System.Single" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-230">Liczba, z <paramref name="y" />którą ma zostać pomnożona wartość.</span><span class="sxs-lookup"><span data-stu-id="0d12f-230">The number to be multiplied with <paramref name="y" />.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-231">Liczba, z <paramref name="x" />którą ma zostać pomnożona wartość.</span><span class="sxs-lookup"><span data-stu-id="0d12f-231">The number to be multiplied with <paramref name="x" />.</span></span></param>
        <param name="z"><span data-ttu-id="0d12f-232">Liczba, która ma zostać dodana do wyniku <paramref name="x" /> mnożenia przez. <paramref name="y" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-232">The number to be added to the result of <paramref name="x" /> multiplied by <paramref name="y" />.</span></span></param>
        <summary><span data-ttu-id="0d12f-233">Zwraca (x \* y) + z, zaokrąglone jako jedna operacja Trzyelementowy.</span><span class="sxs-lookup"><span data-stu-id="0d12f-233">Returns (x \* y) + z, rounded as one ternary operation.</span></span></summary>
        <returns><span data-ttu-id="0d12f-234">(x \* y) + z, zaokrąglone jako jedna operacja Trzyelementowy.</span><span class="sxs-lookup"><span data-stu-id="0d12f-234">(x \* y) + z, rounded as one ternary operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-235">Ta wartość jest `(x * y)` obliczana tak, jakby była nieskończona `z` precyzja, dodaje do tego wyniku tak, jakby była nieskończona precyzja, a wreszcie zaokrągla do najbliższej reprezentacji wartości.</span><span class="sxs-lookup"><span data-stu-id="0d12f-235">This computes `(x * y)` as if to infinite precision, adds `z` to that result as if to infinite precision, and finally rounds to the nearest representable value.</span></span>
  
 <span data-ttu-id="0d12f-236">Różni się to od odrzucanej sekwencji, która może `(x * y)` zostać obliczona tak, jakby była nieskończona preicision, zaokrąglić wynik do najbliższej reprezentacji wartości, dodać "z" do wyniku zaokrąglonego, tak jakby była nieskończona precyzja, a wreszcie zaokrąglić do najbliższej reprezentacji wartościami.</span><span class="sxs-lookup"><span data-stu-id="0d12f-236">This differs from the non-fused sequence which would compute `(x * y)` as if to infinite preicision, round the result to the nearest representable value, add 'z' to the rounded result as if to infinite precision, and finally round to the nearest representable value.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static float IEEERemainder (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 IEEERemainder(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.IEEERemainder(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float IEEERemainder(float x, float y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : single * single -&gt; single" Usage="System.MathF.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-237">Dywidenda.</span><span class="sxs-lookup"><span data-stu-id="0d12f-237">A dividend.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-238">Dzielnik.</span><span class="sxs-lookup"><span data-stu-id="0d12f-238">A divisor.</span></span></param>
        <summary><span data-ttu-id="0d12f-239">Zwraca resztę z dzielenia przez określony numer przez inny określony numer.</span><span class="sxs-lookup"><span data-stu-id="0d12f-239">Returns the remainder resulting from the division of a specified number by another specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-240">Liczba równa <paramref name="x" /> -( <paramref name="y" /> <paramref name="x" /> <paramref name="y" /> <paramref name="x" /> <paramref name="y" /> Q), gdzie  /  Q jest ilorazem zaokrąglonym do najbliższej liczby całkowitej (Jeśli  /  jest w połowie między dwoma liczbami całkowitymi, zwracana jest parzysta liczba całkowita).</span><span class="sxs-lookup"><span data-stu-id="0d12f-240">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span></span>  
  
<span data-ttu-id="0d12f-241">Jeśli <paramref name="x" /> -(<paramref name="y" /> Q) jest zerem, wartość + 0 jest zwracana w przypadku <paramref name="x" /> wartości dodatnich lub-0, <paramref name="x" /> jeśli jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="0d12f-241">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span></span>  
  
<span data-ttu-id="0d12f-242">Jeśli <paramref name="y" /> wartość = 0 <see cref="F:System.Single.NaN" /> , jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-242">If <paramref name="y" /> = 0, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-243">Ta operacja jest zgodna z operacją reszty zdefiniowaną w sekcji 5,1 ANSI/IEEE Std 754-1985; IEEE Standard dla binarnej arytmetycznej liczby zmiennoprzecinkowej; Institute of Electrical and Electronics Engineers, Inc; 1985.</span><span class="sxs-lookup"><span data-stu-id="0d12f-243">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="0d12f-244">Metoda nie jest taka sama jak [operator reszty.](~/docs/csharp/language-reference/operators/remainder-operator.md) <xref:System.MathF.IEEERemainder%2A></span><span class="sxs-lookup"><span data-stu-id="0d12f-244">The <xref:System.MathF.IEEERemainder%2A> method is not the same as the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span> <span data-ttu-id="0d12f-245">Mimo że obie zwracają resztę po dzielenie, używane formuły są różne.</span><span class="sxs-lookup"><span data-stu-id="0d12f-245">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="0d12f-246">Formuła dla <xref:System.MathF.IEEERemainder%2A> metody jest:</span><span class="sxs-lookup"><span data-stu-id="0d12f-246">The formula for the <xref:System.MathF.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * MathF.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="0d12f-247">W przeciwieństwie do formuły dla operatora reszty jest:</span><span class="sxs-lookup"><span data-stu-id="0d12f-247">In contrast, the formula for the remainder operator is:</span></span>  
  
```  
Remainder = (MathF.Abs(dividend) - (MathF.Abs(divisor) *   
            (MathF.Floor(MathF.Abs(dividend) / MathF.Abs(divisor))))) *   
            MathF.Sign(dividend)  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ILogB(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(float x);" />
      <MemberSignature Language="F#" Value="static member ILogB : single -&gt; int" Usage="System.MathF.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-248">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-248">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-249">Zwraca logarytm dziesiętny z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-249">Returns the base 2 integer logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-250">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-250">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="0d12f-251"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="0d12f-251"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="0d12f-252">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-252">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-253">Domyślny</span><span class="sxs-lookup"><span data-stu-id="0d12f-253">Default</span></span> 
 </term><description> <span data-ttu-id="0d12f-254">Dziennik <paramref name="x" />w postaci liczby całkowitej 2, czyli (int) log2 — (<paramref name="x" />).</span><span class="sxs-lookup"><span data-stu-id="0d12f-254">The base 2 integer log of <paramref name="x" />; that is, (int)log2(<paramref name="x" />).</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-255">Zero</span><span class="sxs-lookup"><span data-stu-id="0d12f-255">Zero</span></span> 
 </term><description><see cref="F:System.Int32.MinValue" /></description></item><item><term> <span data-ttu-id="0d12f-256"><see cref="F:System.Single.NaN" /> Równe lub lub<see cref="F:System.Single.PositiveInfinity" /><see cref="F:System.Single.NegativeInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-256">Equal to <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" /> or <see cref="F:System.Single.NegativeInfinity" /></span></span></term><description><see cref="F:System.Int32.MaxValue" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-257">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="0d12f-257">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x);" />
      <MemberSignature Language="F#" Value="static member Log : single -&gt; single" Usage="System.MathF.Log x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-258">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-258">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-259">Zwraca logarytm naturalny (podstawowy <see langword="e" />) podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-259">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-260">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-260">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="0d12f-261"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="0d12f-261"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="0d12f-262">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-262">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-263">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="0d12f-263">Positive</span></span> 
 </term><description> <span data-ttu-id="0d12f-264">Logarytm naturalny z <paramref name="x" />; to jest, LN <paramref name="x" />lub log e<paramref name="x" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-264">The natural logarithm of <paramref name="x" />; that is, ln <paramref name="x" />, or log e <paramref name="x" /></span></span></description></item><item><term> <span data-ttu-id="0d12f-265">Zero</span><span class="sxs-lookup"><span data-stu-id="0d12f-265">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="0d12f-266">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0d12f-266">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-267">Równa się<see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-267">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-268">Równa się<see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-268">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-269">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="0d12f-269">Parameter `x` is specified as a base 10 number.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Exp(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Log : single * single -&gt; single" Usage="System.MathF.Log (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-270">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-270">The number whose logarithm is to be found.</span></span></param>
        <param name="y">To be added.</param>
        <summary><span data-ttu-id="0d12f-271">Zwraca logarytm o podanej liczbie w określonej bazie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-271">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="0d12f-272">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-272">One of the values in the following table.</span></span> <span data-ttu-id="0d12f-273">(+ Nieskończoność <see cref="F:System.Single.PositiveInfinity" />,-nieskończoność <see cref="F:System.Single.NegativeInfinity" /> <see cref="F:System.Single.NaN" />i Nan oznacza.)</span><span class="sxs-lookup"><span data-stu-id="0d12f-273">(+Infinity denotes <see cref="F:System.Single.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Single.NegativeInfinity" />, and NaN denotes <see cref="F:System.Single.NaN" />.)</span></span> 
 <list type="table"><listheader><term><paramref name="x" /></term><description><paramref name="newBase" /></description><description> <span data-ttu-id="0d12f-274">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-274">Return value</span></span> 
 </description></listheader><item><term><span data-ttu-id="0d12f-275"><paramref name="x" />&gt; 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-275"><paramref name="x" />&gt; 0</span></span> 
 </term><description> <span data-ttu-id="0d12f-276">(0 &lt; <paramref name="newBase" /> 1)<paramref name="newBase" /> — lub-(&gt;1) &lt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-276">(0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)</span></span> 
 </description><description> <span data-ttu-id="0d12f-277">lognewBase (a)</span><span class="sxs-lookup"><span data-stu-id="0d12f-277">lognewBase(a)</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-278"><paramref name="x" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-278"><paramref name="x" />&lt; 0</span></span> 
 </term><description> <span data-ttu-id="0d12f-279">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0d12f-279">(any value)</span></span> 
 </description><description> <span data-ttu-id="0d12f-280">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-280">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="0d12f-281">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0d12f-281">(any value)</span></span> 
 </term><description><span data-ttu-id="0d12f-282"><paramref name="newBase" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-282"><paramref name="newBase" />&lt; 0</span></span> 
 </description><description> <span data-ttu-id="0d12f-283">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-283">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-284"><paramref name="x" /> != 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-284"><paramref name="x" /> != 1</span></span> 
 </term><description><span data-ttu-id="0d12f-285"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-285"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="0d12f-286">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-286">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-287"><paramref name="x" /> != 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-287"><paramref name="x" /> != 1</span></span> 
 </term><description><span data-ttu-id="0d12f-288"><paramref name="newBase" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-288"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="0d12f-289">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-289">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-290"><paramref name="x" />= NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-290"><paramref name="x" /> = NaN</span></span> 
 </term><description> <span data-ttu-id="0d12f-291">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0d12f-291">(any value)</span></span> 
 </description><description> <span data-ttu-id="0d12f-292">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-292">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="0d12f-293">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0d12f-293">(any value)</span></span> 
 </term><description><span data-ttu-id="0d12f-294"><paramref name="newBase" />= NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-294"><paramref name="newBase" /> = NaN</span></span> 
 </description><description> <span data-ttu-id="0d12f-295">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-295">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="0d12f-296">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0d12f-296">(any value)</span></span> 
 </term><description><span data-ttu-id="0d12f-297"><paramref name="newBase" /> = 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-297"><paramref name="newBase" /> = 1</span></span> 
 </description><description> <span data-ttu-id="0d12f-298">NaN</span><span class="sxs-lookup"><span data-stu-id="0d12f-298">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-299"><paramref name="x" /> = 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-299"><paramref name="x" /> = 0</span></span> 
 </term><description> <span data-ttu-id="0d12f-300">0 &lt; 1<paramref name="newBase" /> &lt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-300">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="0d12f-301">+ Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-301">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-302"><paramref name="x" /> = 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-302"><paramref name="x" /> = 0</span></span> 
 </term><description><span data-ttu-id="0d12f-303"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-303"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="0d12f-304">-Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-304">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-305"><paramref name="x" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-305"><paramref name="x" /> =  +Infinity</span></span> 
 </term><description> <span data-ttu-id="0d12f-306">0 &lt; 1<paramref name="newBase" /> &lt;</span><span class="sxs-lookup"><span data-stu-id="0d12f-306">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="0d12f-307">-Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-307">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-308"><paramref name="x" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-308"><paramref name="x" /> =  +Infinity</span></span> 
 </term><description><span data-ttu-id="0d12f-309"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-309"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="0d12f-310">+ Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-310">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-311"><paramref name="x" /> = 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-311"><paramref name="x" /> = 1</span></span> 
 </term><description><span data-ttu-id="0d12f-312"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="0d12f-312"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="0d12f-313">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-313">0</span></span> 
 </description></item><item><term><span data-ttu-id="0d12f-314"><paramref name="x" /> = 1</span><span class="sxs-lookup"><span data-stu-id="0d12f-314"><paramref name="x" /> = 1</span></span> 
 </term><description><span data-ttu-id="0d12f-315"><paramref name="newBase" />= + Nieskończoność</span><span class="sxs-lookup"><span data-stu-id="0d12f-315"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="0d12f-316">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-316">0</span></span> 
 </description></item></list></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static float Log10 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log10(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log10(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log10(float x);" />
      <MemberSignature Language="F#" Value="static member Log10 : single -&gt; single" Usage="System.MathF.Log10 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-317">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-317">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-318">Zwraca logarytm dziesiętny z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-318">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-319">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-319">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="0d12f-320"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="0d12f-320"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="0d12f-321">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-321">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-322">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="0d12f-322">Positive</span></span> 
 </term><description> <span data-ttu-id="0d12f-323">Dziennik <paramref name="x" />Base 10; oznacza to, że log 10<paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-323">The base 10 log of <paramref name="x" />; that is, log 10<paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-324">Zero</span><span class="sxs-lookup"><span data-stu-id="0d12f-324">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="0d12f-325">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0d12f-325">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-326">Równa się<see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-326">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-327">Równa się<see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-327">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-328">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="0d12f-328">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static float Log2 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log2(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log2(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log2(float x);" />
      <MemberSignature Language="F#" Value="static member Log2 : single -&gt; single" Usage="System.MathF.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-329">Liczba, której LOGARYTM ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-329">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-330">Zwraca logarytm o podstawie 2 dla podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-330">Returns the base 2 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-331">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-331">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="0d12f-332"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="0d12f-332"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="0d12f-333">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-333">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-334">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="0d12f-334">Positive</span></span> 
 </term><description> <span data-ttu-id="0d12f-335">Dziennik <paramref name="x" />Base 2, czyli dziennik 2<paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-335">The base 2 log of <paramref name="x" />; that is, log 2<paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-336">Zero</span><span class="sxs-lookup"><span data-stu-id="0d12f-336">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="0d12f-337">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0d12f-337">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-338">Równa się<see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-338">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-339">Równa się<see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-339">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-340">Parametr `x` jest określony jako numer podstawowy 10.</span><span class="sxs-lookup"><span data-stu-id="0d12f-340">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.MathF.Max (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-341">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-341">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-342">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-342">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="0d12f-343">Zwraca więcej dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-343">Returns the larger of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="0d12f-344">Parametr <paramref name="x" /> lub<paramref name="y" />, w zależności od tego, jest większy.</span><span class="sxs-lookup"><span data-stu-id="0d12f-344">Parameter <paramref name="x" /> or <paramref name="y" />, whichever is larger.</span></span> <span data-ttu-id="0d12f-345">Opcja <paramref name="x" />IF, <paramref name="y" />or lub or <paramref name="x" /> <paramref name="y" /> jest równa <see cref="F:System.Single.NaN" /> ,<see cref="F:System.Single.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-345">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MaxMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : single * single -&gt; single" Usage="System.MathF.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-346">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-346">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-347">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-347">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="0d12f-348">Zwraca większą liczbę liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-348">Returns the larger magnitude of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="0d12f-349">Parametr <paramref name="x" /> lub <paramref name="y" />, w zależności od tego, czy ma większą wielkość.</span><span class="sxs-lookup"><span data-stu-id="0d12f-349">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the larger magnitude.</span></span> <span data-ttu-id="0d12f-350">Opcja <paramref name="x" />IF, <paramref name="y" />or lub or <paramref name="x" /> <paramref name="y" /> jest równa <see cref="F:System.Single.NaN" /> ,<see cref="F:System.Single.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-350">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.MathF.Min (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-351">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-351">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-352">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-352">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="0d12f-353">Zwraca mniejsze z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-353">Returns the smaller of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="0d12f-354">Parametr <paramref name="x" /> lub<paramref name="y" />, w zależności od tego, jest mniejszy.</span><span class="sxs-lookup"><span data-stu-id="0d12f-354">Parameter <paramref name="x" /> or <paramref name="y" />, whichever is smaller.</span></span> <span data-ttu-id="0d12f-355">Jeśli <paramref name="x" /> <paramref name="x" /> , <paramref name="y" />, lub obiei<paramref name="y" /> są równe ,<see cref="F:System.Single.NaN" />jestzwracanawartość. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-355">If <paramref name="x" />, <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MinMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : single * single -&gt; single" Usage="System.MathF.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-356">Pierwszy z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-356">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-357">Druga z dwóch liczb zmiennoprzecinkowych o pojedynczej precyzji do porównania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-357">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="0d12f-358">Zwraca mniejszą liczbę liczb zmiennoprzecinkowych o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-358">Returns the smaller magnitude of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="0d12f-359">Parametr <paramref name="x" /> lub <paramref name="y" />, w zależności od tego, czy ma mniejszą wartość.</span><span class="sxs-lookup"><span data-stu-id="0d12f-359">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the smaller magnitude.</span></span> <span data-ttu-id="0d12f-360">Opcja <paramref name="x" />IF, <paramref name="y" />or lub or <paramref name="x" /> <paramref name="y" /> jest równa <see cref="F:System.Single.NaN" /> ,<see cref="F:System.Single.NaN" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="0d12f-360">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const float PI = 3.141593;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PI = (3.141593)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Single  = 3.141593" />
      <MemberSignature Language="C++ CLI" Value="public: float PI = 3.141593;" />
      <MemberSignature Language="F#" Value="val mutable PI : single" Usage="System.MathF.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.141593</MemberValue>
      <Docs>
        <summary><span data-ttu-id="0d12f-361">Reprezentuje stosunek obwodu okręgu do jego średnicy, określonego przez stałą, π.</span><span class="sxs-lookup"><span data-stu-id="0d12f-361">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="0d12f-362">Wartość tego pola to 3,14159274.</span><span class="sxs-lookup"><span data-stu-id="0d12f-362">The value of this field is 3.14159274.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static float Pow (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Pow(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Pow(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Pow(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Pow : single * single -&gt; single" Usage="System.MathF.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-363">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która ma zostać podniesiona do potęgi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-363">A single-precision floating-point number to be raised to a power.</span></span></param>
        <param name="y"><span data-ttu-id="0d12f-364">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która określa potęgę.</span><span class="sxs-lookup"><span data-stu-id="0d12f-364">A single-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="0d12f-365">Zwraca określoną liczbę podniesioną do określonej potęgi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-365">Returns a specified number raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="0d12f-366">Liczba <paramref name="x" /> podniesiona do potęgi <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-366">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-367">Poniższa tabela wskazuje wartość zwracaną w przypadku określenia różnych wartości lub zakresów wartości dla `x` parametrów i. `y`</span><span class="sxs-lookup"><span data-stu-id="0d12f-367">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="0d12f-368">Aby uzyskać więcej informacji, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>zobacz <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-368">For more information, see <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="0d12f-369">Parametry</span><span class="sxs-lookup"><span data-stu-id="0d12f-369">Parameters</span></span>|<span data-ttu-id="0d12f-370">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-370">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="0d12f-371">`x`lub `y` . =  `NaN`</span><span class="sxs-lookup"><span data-stu-id="0d12f-371">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="0d12f-372">`x`= Dowolna wartość `NaN`z wyjątkiem; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-372">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="0d12f-373">1</span><span class="sxs-lookup"><span data-stu-id="0d12f-373">1</span></span>|  
|<span data-ttu-id="0d12f-374">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-374">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="0d12f-375">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-375">0</span></span>|  
|<span data-ttu-id="0d12f-376">`x` = `NegativeInfinity`; `y` jest dodatnią nieparzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="0d12f-376">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="0d12f-377">`x` = `NegativeInfinity`; `y` jest dodatnia, ale nie jest parzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="0d12f-377">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="0d12f-378">`x`< 0, ale `NegativeInfinity`nie; nie jest liczbą całkowitą, `NegativeInfinity`lub `PositiveInfinity`. `y`</span><span class="sxs-lookup"><span data-stu-id="0d12f-378">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="0d12f-379">`x`=-1; `y` lub.`PositiveInfinity`  =  `NegativeInfinity`</span><span class="sxs-lookup"><span data-stu-id="0d12f-379">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="0d12f-380">-1 < `x` < 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="0d12f-380">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="0d12f-381">-1 < `x` < 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="0d12f-381">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="0d12f-382">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-382">0</span></span>|  
|<span data-ttu-id="0d12f-383">`x`<-1 lub `x` > 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="0d12f-383">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="0d12f-384">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-384">0</span></span>|  
|<span data-ttu-id="0d12f-385">`x`<-1 lub `x` > 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="0d12f-385">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="0d12f-386">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-386">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="0d12f-387">`x`= 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-387">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="0d12f-388">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-388">0</span></span>|  
|<span data-ttu-id="0d12f-389">`x`= 1; jest dowolną wartością z `NaN`wyjątkiem. `y`</span><span class="sxs-lookup"><span data-stu-id="0d12f-389">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="0d12f-390">1</span><span class="sxs-lookup"><span data-stu-id="0d12f-390">1</span></span>|  
|<span data-ttu-id="0d12f-391">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-391">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="0d12f-392">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-392">0</span></span>|  
|<span data-ttu-id="0d12f-393">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="0d12f-393">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.MathF.Sqrt(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x);" />
      <MemberSignature Language="F#" Value="static member Round : single -&gt; single" Usage="System.MathF.Round x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-394">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="0d12f-394">A single-precision floating-point number to be rounded.</span></span></param>
        <summary><span data-ttu-id="0d12f-395">Zaokrągla wartość zmiennoprzecinkową o pojedynczej precyzji do najbliższej wartości całkowitej i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-395">Rounds a single-precision floating-point value to the nearest integral value, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-396">Najbliższa <paramref name="x" />liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="0d12f-396">The integer nearest <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-397">Jeśli składnik <paramref name="x" /> częściowy jest w połowie między dwoma liczbami całkowitymi, a jednym z nich jest parzystość, a druga nieparzysta, zwracana jest liczba parzysta.</span><span class="sxs-lookup"><span data-stu-id="0d12f-397">If the fractional component of <paramref name="x" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span></span> <span data-ttu-id="0d12f-398">Należy zauważyć, że ta metoda <see cref="T:System.Single" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="0d12f-398">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="0d12f-399">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-399">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="0d12f-400">Jeśli wartość `x` argumentu to <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-400">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d12f-401">Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0d12f-401">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="0d12f-402">Ze względu na utratę precyzji, która może wynikać z reprezentowania wartości dziesiętnych jako liczby zmiennoprzecinkowe lub wykonywania operacji arytmetycznych na wartościach zmiennoprzecinkowych, <see cref="M:System.MathF.Round(System.Single)" /> w niektórych przypadkach Metoda może nie być widoczna w celu zaokrąglania wartości punktu środkowego do Najbliższa parzysta liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="0d12f-402">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.MathF.Round(System.Single)" /> method may not appear to round midpoint values to the nearest even integer.</span></span></para></block>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : single * int -&gt; single" Usage="System.MathF.Round (x, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-403">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="0d12f-403">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="0d12f-404">Liczba cyfr ułamkowych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-404">The number of fractional digits in the return value.</span></span></param>
        <summary><span data-ttu-id="0d12f-405">Zaokrągla wartość zmiennoprzecinkową o pojedynczej precyzji do określonej liczby cyfr ułamkowych i zaokrągla wartości punktu środkowego do najbliższej parzystej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-405">Rounds a single-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-406">Liczba znajdująca się <paramref name="x" /> najbliżej, która zawiera liczbę cyfr dziesiętnych <paramref name="digits" />równą.</span><span class="sxs-lookup"><span data-stu-id="0d12f-406">The number nearest to <paramref name="x" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<span data-ttu-id="0d12f-407">Wartość `digits` argumentu może być z zakresu od 0 do 6.</span><span class="sxs-lookup"><span data-stu-id="0d12f-407">The value of the `digits` argument can range from 0 to 6.</span></span> <span data-ttu-id="0d12f-408">Należy zauważyć, że 6 to maksymalna liczba cyfr całkowitych i ułamkowych obsługiwanych przez <xref:System.Single> typ.</span><span class="sxs-lookup"><span data-stu-id="0d12f-408">Note that 6 is the maximum number of integral and fractional digits supported by the <xref:System.Single> type.</span></span>

<span data-ttu-id="0d12f-409">Ta metoda używa domyślnej Konwencji <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>zaokrąglania.</span><span class="sxs-lookup"><span data-stu-id="0d12f-409">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> 

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="0d12f-410">Jeśli wartość `x` argumentu to <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-410">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d12f-411">Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0d12f-411">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d12f-412"><paramref name="digits" />jest mniejsza niż 0 lub większa niż 6.</span><span class="sxs-lookup"><span data-stu-id="0d12f-412"><paramref name="digits" /> is less than 0 or greater than 6.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-413">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="0d12f-413">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="0d12f-414">Specyfikacja, w której ma <paramref name="x" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="0d12f-414">Specification for how to round <paramref name="x" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="0d12f-415">Zaokrągla wartość zmiennoprzecinkową o pojedynczej precyzji do najbliższej liczby całkowitej i używa określonej konwencji zaokrąglania dla wartości środkowych.</span><span class="sxs-lookup"><span data-stu-id="0d12f-415">Rounds a single-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="0d12f-416">Najbliższa <paramref name="x" />liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="0d12f-416">The integer nearest <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-417">Jeśli <paramref name="x" /> jest w połowie między dwoma liczbami całkowitymi, a jedna z nich jest parzysta, <paramref name="mode" /> a druga nieparzysta, a następnie określa, które z dwóch wartości są zwracane.</span><span class="sxs-lookup"><span data-stu-id="0d12f-417">If <paramref name="x" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span> <span data-ttu-id="0d12f-418">Należy zauważyć, że ta metoda <see cref="T:System.Single" /> zwraca zamiast typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="0d12f-418">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="0d12f-419">Jeśli wartość `x` argumentu to <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-419">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d12f-420">Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0d12f-420">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0d12f-421"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-421"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * int * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-422">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która ma zostać zaokrąglona.</span><span class="sxs-lookup"><span data-stu-id="0d12f-422">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="0d12f-423">Liczba cyfr ułamkowych w wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-423">The number of fractional digits in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="0d12f-424">Specyfikacja, w której ma <paramref name="x" /> zostać zaokrąglona wartość w połowie między dwiema innymi liczbami.</span><span class="sxs-lookup"><span data-stu-id="0d12f-424">Specification for how to round <paramref name="x" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="0d12f-425">Zaokrągla wartość zmiennoprzecinkową o pojedynczej precyzji do określonej liczby cyfr ułamkowych i używa określonej konwencji zaokrąglania dla wartości punktu środkowego.</span><span class="sxs-lookup"><span data-stu-id="0d12f-425">Rounds a single-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="0d12f-426">Liczba <paramref name="x" /> znajdująca się najbliżej, która ma liczbę cyfr dziesiętnych <paramref name="digits" />równą.</span><span class="sxs-lookup"><span data-stu-id="0d12f-426">The number nearest to <paramref name="x" /> that has a number of fractional digits equal to <paramref name="digits" />.</span></span> <span data-ttu-id="0d12f-427">Jeśli <paramref name="x" /> ma mniejszą liczbę cyfr ułamkowych <paramref name="digits" />niż <paramref name="x" /> , jest zwracana bez zmian.</span><span class="sxs-lookup"><span data-stu-id="0d12f-427">If <paramref name="x" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="x" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="0d12f-428">Wartość `digits` argumentu może być z zakresu od 0 do 6.</span><span class="sxs-lookup"><span data-stu-id="0d12f-428">The value of the `digits` argument can range from 0 to 6.</span></span> <span data-ttu-id="0d12f-429">Należy zauważyć, że 6 to maksymalna liczba cyfr całkowitych i ułamkowych obsługiwanych przez <xref:System.Single> typ.</span><span class="sxs-lookup"><span data-stu-id="0d12f-429">Note that 6 is the maximum number of integral and fractional digits supported by the <xref:System.Single> type.</span></span>


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="0d12f-430">Jeśli wartość `x` argumentu to <xref:System.Single.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0d12f-430">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d12f-431">Jeśli `x` jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub ,<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>Metoda zwraca<xref:System.Single.PositiveInfinity?displayProperty=nameWithType> lub<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0d12f-431">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0d12f-432"><paramref name="digits" />jest mniejsza niż 0 lub większa niż 6.</span><span class="sxs-lookup"><span data-stu-id="0d12f-432"><paramref name="digits" /> is less than 0 or greater than 6.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0d12f-433"><paramref name="mode" />nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-433"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static float ScaleB (float x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ScaleB(float32 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ScaleB(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Single, n As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ScaleB(float x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : single * int -&gt; single" Usage="System.MathF.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-434">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która określa wartość bazową.</span><span class="sxs-lookup"><span data-stu-id="0d12f-434">A single-precision floating-point number that specifies the base value.</span></span></param>
        <param name="n"><span data-ttu-id="0d12f-435">Liczba zmiennoprzecinkowa o pojedynczej precyzji, która określa moc.</span><span class="sxs-lookup"><span data-stu-id="0d12f-435">A single-precision floating-point number that specifies the power.</span></span></param>
        <summary><span data-ttu-id="0d12f-436">Zwraca wartość x \* 2 ^ n obliczoną efektywnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-436">Returns x \* 2^n computed efficiently.</span></span></summary>
        <returns><span data-ttu-id="0d12f-437">x \* 2 ^ n obliczono efektywnie.</span><span class="sxs-lookup"><span data-stu-id="0d12f-437">x \* 2^n computed efficiently.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float x);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.MathF.Sign x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-438">Liczba oznaczona.</span><span class="sxs-lookup"><span data-stu-id="0d12f-438">A signed number.</span></span></param>
        <summary><span data-ttu-id="0d12f-439">Zwraca liczbę całkowitą wskazującą znak liczby zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-439">Returns an integer that indicates the sign of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-440">Liczba, która wskazuje znak <paramref name="x" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0d12f-440">A number that indicates the sign of <paramref name="x" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="0d12f-441">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-441">Return value</span></span> 
 </term><description> <span data-ttu-id="0d12f-442">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="0d12f-442">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-443">-1</span><span class="sxs-lookup"><span data-stu-id="0d12f-443">-1</span></span> 
 </term><description><span data-ttu-id="0d12f-444"><paramref name="x" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0d12f-444"><paramref name="x" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-445">0</span><span class="sxs-lookup"><span data-stu-id="0d12f-445">0</span></span> 
 </term><description><span data-ttu-id="0d12f-446"><paramref name="x" />jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="0d12f-446"><paramref name="x" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-447">1</span><span class="sxs-lookup"><span data-stu-id="0d12f-447">1</span></span> 
 </term><description><span data-ttu-id="0d12f-448"><paramref name="x" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="0d12f-448"><paramref name="x" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks></remarks>
        <exception cref="T:System.ArithmeticException"><span data-ttu-id="0d12f-449"><paramref name="x" />jest równe <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-449"><paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static float Sin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sin(float x);" />
      <MemberSignature Language="F#" Value="static member Sin : single -&gt; single" Usage="System.MathF.Sin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-450">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-450">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-451">Zwraca sinus określonego kąta.</span><span class="sxs-lookup"><span data-stu-id="0d12f-451">Returns the sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-452">Sinus <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-452">The sine of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-453">Jeśli <paramref name="x" /> <see cref="F:System.Single.NegativeInfinity" />jest <see cref="F:System.Single.PositiveInfinity" />równa <see cref="F:System.Single.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-453">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-454">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-454">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-455">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-455">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static float Sinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sinh(float x);" />
      <MemberSignature Language="F#" Value="static member Sinh : single -&gt; single" Usage="System.MathF.Sinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-456">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-456">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-457">Zwraca sinus hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-457">Returns the hyperbolic sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-458">Sinus hiperboliczny <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-458">The hyperbolic sine of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-459">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NegativeInfinity" />równe, <see cref="F:System.Single.PositiveInfinity" />, <see cref="T:System.Single" /> lub ,<see cref="F:System.Single.NaN" />ta metoda zwraca wartość równą. <paramref name="x" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-459">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />, this method returns a <see cref="T:System.Single" /> equal to <paramref name="x" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-460">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-460">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-461">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-461">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static float Sqrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sqrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sqrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sqrt(float x);" />
      <MemberSignature Language="F#" Value="static member Sqrt : single -&gt; single" Usage="System.MathF.Sqrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-462">Liczba, której pierwiastek kwadratowy ma zostać znaleziony.</span><span class="sxs-lookup"><span data-stu-id="0d12f-462">The number whose square root is to be found.</span></span></param>
        <summary><span data-ttu-id="0d12f-463">Zwraca pierwiastek kwadratowy z podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0d12f-463">Returns the square root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-464">Jedna z wartości w tabeli poniżej.</span><span class="sxs-lookup"><span data-stu-id="0d12f-464">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="0d12f-465"><paramref name="x" />konstruktora</span><span class="sxs-lookup"><span data-stu-id="0d12f-465"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="0d12f-466">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-466">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="0d12f-467">Zero lub dodatnie</span><span class="sxs-lookup"><span data-stu-id="0d12f-467">Zero or positive</span></span> 
 </term><description> <span data-ttu-id="0d12f-468">Pierwiastek kwadratowy z <paramref name="x" />wartością dodatnią.</span><span class="sxs-lookup"><span data-stu-id="0d12f-468">The positive square root of <paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="0d12f-469">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0d12f-469">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-470">Ubiegł<see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-470">Equals <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="0d12f-471">Ubiegł<see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-471">Equals <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static float Tan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tan(float x);" />
      <MemberSignature Language="F#" Value="static member Tan : single -&gt; single" Usage="System.MathF.Tan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-472">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-472">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-473">Zwraca tangens podanego kąta.</span><span class="sxs-lookup"><span data-stu-id="0d12f-473">Returns the tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-474">Tangens <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-474">The tangent of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-475">Jeśli <paramref name="x" /> <see cref="F:System.Single.NegativeInfinity" />jest <see cref="F:System.Single.PositiveInfinity" />równa <see cref="F:System.Single.NaN" />,, lub, ta metoda zwraca. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-475">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-476">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-476">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-477">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-477">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static float Tanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tanh(float x);" />
      <MemberSignature Language="F#" Value="static member Tanh : single -&gt; single" Usage="System.MathF.Tanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-478">Kąt wyrażony w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-478">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="0d12f-479">Zwraca tangens hiperboliczny odpowiadający podanemu kątowi.</span><span class="sxs-lookup"><span data-stu-id="0d12f-479">Returns the hyperbolic tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="0d12f-480">Tangens hiperboliczny <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="0d12f-480">The hyperbolic tangent of <paramref name="x" />.</span></span> <span data-ttu-id="0d12f-481">Jeśli <paramref name="x" /> jest<see cref="F:System.Single.NegativeInfinity" />równa, ta metoda zwraca wartość-1.</span><span class="sxs-lookup"><span data-stu-id="0d12f-481">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" />, this method returns -1.</span></span> <span data-ttu-id="0d12f-482">Jeśli wartość jest równa <see cref="F:System.Single.PositiveInfinity" />, ta metoda zwraca 1.</span><span class="sxs-lookup"><span data-stu-id="0d12f-482">If value is equal to <see cref="F:System.Single.PositiveInfinity" />, this method returns 1.</span></span> <span data-ttu-id="0d12f-483">Jeśli <paramref name="x" /> jest <see cref="F:System.Single.NaN" />równa, ta metoda zwraca. <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="0d12f-483">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d12f-484">Kąt, `x`, musi być w radianach.</span><span class="sxs-lookup"><span data-stu-id="0d12f-484">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="0d12f-485">Pomnóż przez <xref:System.MathF.PI?displayProperty=nameWithType>/180, aby przekonwertować stopnie na radiany.</span><span class="sxs-lookup"><span data-stu-id="0d12f-485">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static float Truncate (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Truncate(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Truncate(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Truncate(float x);" />
      <MemberSignature Language="F#" Value="static member Truncate : single -&gt; single" Usage="System.MathF.Truncate x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="0d12f-486">Liczba do obcięcia.</span><span class="sxs-lookup"><span data-stu-id="0d12f-486">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="0d12f-487">Oblicza integralną część określonej liczby zmiennoprzecinkowej o pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0d12f-487">Calculates the integral part of a specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="0d12f-488">Integralna część <paramref name="x" />, czyli liczba, która pozostaje po odrzuceniu cyfr ułamkowych, lub jedna z wartości wymienionych w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0d12f-488">The integral part of <paramref name="x" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span></span>  
  
 <list type="table"><listheader><term><paramref name="x" /></term><description> <span data-ttu-id="0d12f-489">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0d12f-489">Return value</span></span> 
 </description></listheader><item><term><see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term><see cref="F:System.Single.NegativeInfinity" /></term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term><see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="0d12f-490"><xref:System.MathF.Truncate%2A>zaokrągla `x` do najbliższej liczby całkowitej w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="0d12f-490"><xref:System.MathF.Truncate%2A> rounds `x` to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
  </Members>
</Type>

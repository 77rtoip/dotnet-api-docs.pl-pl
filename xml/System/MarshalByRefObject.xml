<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="83acfa54440d5b5ba0c4eb247332f63cbe45d467" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30743900" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia dostęp do obiektów poza granice domeny aplikacji w aplikacjach tej komunikacji zdalnej pomocy technicznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domeny aplikacji jest partycją w procesu systemu operacyjnego, w którym znajdują się co najmniej jednej aplikacji. Obiekty w tej samej domenie aplikacji komunikują się bezpośrednio. Obiekty w różnych domenach aplikacji komunikują się przez transport kopie obiektów poza granice domeny aplikacji lub przy użyciu serwera proxy do wymiany wiadomości.  
  
 <xref:System.MarshalByRefObject> Klasa podstawowa dla obiektów, które komunikują się poza granice domeny aplikacji poprzez wymianę wiadomości jest za pomocą serwera proxy. Obiekty, które nie dziedziczą <xref:System.MarshalByRefObject> są niejawnie kierować według wartości. Jeśli zdalna aplikacja odwołuje się obiekt organizowany przez obiekt wartości, kopię obiektu jest przekazywany poza granice domeny aplikacji.  
  
 <xref:System.MarshalByRefObject> obiekty są dostępne bezpośrednio z poziomu granice domeny aplikacji lokalnej. Uzyskuje dostęp do domeny aplikacji po raz pierwszy aplikację w zdalnym <xref:System.MarshalByRefObject>, serwer proxy jest przekazywany do aplikacji zdalnej. Kolejne wywołania na serwerze proxy są przekazywane do obiektów znajdujących się w domenie lokalnej aplikacji.  
  
 Typy musi dziedziczyć z <xref:System.MarshalByRefObject> kiedy typ jest używany przez granice domeny aplikacji i stan obiektu nie należy kopiować ponieważ elementach członkowskich obiektu nie są użyteczne spoza domeny aplikacji, w której zostały utworzone.  
  
 Jeśli pochodzi z obiektu <xref:System.MarshalByRefObject> do użytku poza granice domeny aplikacji, użytkownik powinien nie zastępują któregokolwiek z członków ani powinny można wywoływać metod bezpośrednio. Środowisko uruchomieniowe rozpoznaje, że klasy wyprowadzone z <xref:System.MarshalByRefObject> powinny być przekazywane między granicami domeny aplikacji.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. W pierwszym przykładzie kodu pokazano, jak można utworzyć wystąpienia klasy w innej domenie aplikacji. Drugi przykładowy kod przedstawia prostą klasę, która może służyć do komunikacji zdalnej.  
  
 **Przykład 1**  
  
 Poniższy przykład kodu pokazuje Najprostszym sposobem, aby wykonać kod w innej domenie aplikacji. W przykładzie zdefiniowano klasę o nazwie `Worker` dziedziczącego <xref:System.MarshalByRefObject>, za pomocą metody, która wyświetla nazwę domeny aplikacji, w którym jest wykonywany. W przykładzie jest tworzony wystąpienia `Worker` w domyślnej domeny aplikacji i w nowej domenie aplikacji.  
  
> [!NOTE]
>  Zestaw, który zawiera `Worker` muszą być załadowane do obu domeny aplikacji, ale można go załadować innych zestawów występujących tylko w nowej domenie aplikacji.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 **Przykład 2**  
  
 W poniższym przykładzie pokazano klasę pochodzącą od <xref:System.MarshalByRefObject> czyli używane w dalszej komunikacji zdalnej.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.MarshalByRefObject" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="requestedType">
          <see cref="T:System.Type" /> Obiektu, który nowe <see cref="T:System.Runtime.Remoting.ObjRef" /> będzie odwoływać.</param>
        <summary>Tworzy obiekt, który zawiera wszystkie informacje wymagane do wygenerowania serwera proxy użyte do komunikowania się z obiektu zdalnego.</summary>
        <returns>Informacje o wymaganych do utworzenia serwera proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.MarshalByRefObject.CreateObjRef%2A> Metoda jest wywoływana przez metody tworzenia obiektu zdalnego, takich jak <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> i <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>. W większości przypadków nie ma konieczności przesłonić tę metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">To wystąpienie nie jest obiektem prawidłową komunikację zdalną.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt usługi bieżącego okresu istnienia, który określa okres istnienia zasad dla tego wystąpienia.</summary>
        <returns>Obiekt typu <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> użyć do kontrolowania zasad okres istnienia dla tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o usługach okres istnienia, zobacz <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt usługi okres istnienia do kontrolowania zasad okres istnienia dla tego wystąpienia.</summary>
        <returns>Obiekt typu <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> użyć do kontrolowania zasad okres istnienia dla tego wystąpienia. Jest to bieżąca okres istnienia obiektu usługi dla tego wystąpienia, jeśli istnieje; w przeciwnym razie nowy okres istnienia obiektu usługi zainicjowany z wartością <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o usługach okres istnienia, zobacz <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie dzierżawy.  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kopię pobieżną bieżącego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity">
          <see langword="false" /> Aby usunąć bieżący <see cref="T:System.MarshalByRefObject" /> tożsamości obiektu, co spowoduje, że obiekt, aby można przypisać nowej tożsamości, gdy jest on zorganizować granicy komunikacji zdalnej. Wartość <see langword="false" /> jest zwykle. <see langword="true" /> Aby skopiować bieżące <see cref="T:System.MarshalByRefObject" /> tożsamości obiektu do jego klonowania, co spowoduje zdalnych wywołań klienta przesłana do obiektu zdalnego serwera.</param>
        <summary>Tworzy kopię pobieżną bieżącego <see cref="T:System.MarshalByRefObject" /> obiektu.</summary>
        <returns>Skrócona kopię bieżącego <see cref="T:System.MarshalByRefObject" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> Metoda tworzy kopię pobieżną przez utworzenie nowej <xref:System.MarshalByRefObject> obiekt, a następnie skopiować niestatycznego pola bieżącej <xref:System.MarshalByRefObject> obiektu do nowego obiektu. Jeśli pole jest typu wartości, jest wykonywane kopii bitowej przez bitowej pola. Jeśli pole jest typem referencyjnym, odwołanie jest kopiowana, ale określony obiekt jest; w związku z tym oryginalny obiekt i jego klon odwoływać się do tego samego obiektu.  
  
 Rozważmy na przykład <xref:System.MarshalByRefObject> o nazwie X, który odwołuje się do obiektów A i B. obiektu B, obiekt z kolei odwołuje się do obiektu C. Kopia pobieżna wartości X tworzy nowy obiekt X2 również odwołujących się do obiektów, A i B. Z kolei głęboką kopię X tworzy nowy obiekt X2, który odwołuje się do nowych obiektów A2 i B2, które są kopiami A i B. B2, z kolei odwołuje się nowy obiekt C2, który jest kopią C. Użyj klasy, która implementuje <xref:System.ICloneable> interfejs do wykonania c bezpośrednich lub skrócona Kopiuj obiektu.  
  
 Tożsamość <xref:System.MarshalByRefObject> obiektu jest zdefiniowana jako obiekt serwera zdalnego, który jest elementem docelowym wywołania klienta usług zdalnych. Domyślnie memberwise klonu <xref:System.MarshalByRefObject> obiekt ma inną tożsamość niż oryginalny obiekt, który zwykle nie jest poprawne zachowanie klony obiektów po stronie serwera, które są przekazywane granicy komunikacji zdalnej na komputerach klienckich. Określ `false`, która jest zazwyczaj odpowiednie do usunięcia tożsamości klonu i spowodować nową tożsamość ma być przypisany podczas klonu jest przekazywane granicy remoting, lub `true` spowodować klonu, aby zachować tożsamość oryginalnej <xref:System.MarshalByRefObject> obiektu. <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> Metoda jest przeznaczona do użycia przez deweloperów implementowania obiektów serwera zdalnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
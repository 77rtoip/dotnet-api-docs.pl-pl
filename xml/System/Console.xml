<Type Name="Console" FullName="System.Console">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="378608dd9cc8deec5d2e2002822aed5386d826a9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje standardowych strumieni danych wejściowych, wyjściowych i błędów dla aplikacji konsoli. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsola jest okna systemu operacyjnego, w której użytkownicy mogą operować w systemie operacyjnym lub z aplikacji konsoli tekstowych wprowadzając wprowadzanie tekstu przy użyciu klawiatury komputera, a także odczytywanie tekstu z terminala komputera. Na przykład w systemie operacyjnym Windows, konsoli nosi nazwę okna wiersza polecenia i przyjmuje polecenia systemu MS-DOS. <xref:System.Console> Klasa udostępnia podstawowa pomoc techniczna dla aplikacji, które odczytywanie znaków z oraz zapisywanie znaków do konsoli.  
  
 Aby uzyskać informacje dotyczące programowania za pomocą <xref:System.Console> klasy, zobacz następujące sekcje:  
  
-   [Strumienie konsoli operacji We/Wy](#Streams)  
  
-   [Okno konsoli i buforu ekranu](#Buffer)  
  
-   [Obsługa formatu Unicode w konsoli programu](#Unicode)  
  
-   [Typowe operacje](#Operations)  
  
-   [Uwagi dotyczące programu .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Strumienie wejścia/wyjścia konsoli  
 Po uruchomieniu aplikacji konsoli, systemu operacyjnego automatycznie skojarzy trzy strumieni We/Wy z konsolą: standard danych wejściowych, strumień, Standardowy strumień wyjściowy i błąd standardowy strumień wyjściowy. Aplikacja może odczytać dane wejściowe użytkownika z Standardowy strumień wejściowy; normalne zapisane w standardowym strumieniu wyjściowym; i zapisać dane błąd błąd standardowy strumień wyjściowy. Tych strumieni są widoczne dla aplikacji jako wartości <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, i <xref:System.Console.Error%2A?displayProperty=nameWithType> właściwości.  
  
 Domyślnie wartość <xref:System.Console.In%2A> właściwość jest <xref:System.IO.TextReader?displayProperty=nameWithType> obiekt, który reprezentuje klawiatury i wartości <xref:System.Console.Out%2A> i <xref:System.Console.Error%2A> właściwości są <xref:System.IO.TextWriter?displayProperty=nameWithType> obiektów, które reprezentują okna konsoli. Jednak te właściwości można ustawić do strumieni, które nie reprezentują okna konsoli lub klawiatury; na przykład można ustawić te właściwości do strumieni, które reprezentują plików. Aby przekierować standardowe dane wejściowe standardowe Wyjście i Standardowy strumień błędów, należy wywołać <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, lub <xref:System.Console.SetError%2A?displayProperty=nameWithType> metody odpowiednio. Operacje We/Wy, które używają tych strumieni są zsynchronizowane, co oznacza, że wiele wątków może odczytać lub zapisać informacje do strumieni. Oznacza to, że metody, które są zwykle asynchroniczne, takich jak <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, wykonać synchronicznie, jeśli obiekt reprezentuje strumienia konsoli.  
  
> [!NOTE]
>  Nie używaj <xref:System.Console> klasę, aby wyświetlić dane wyjściowe w instalacji nienadzorowanej aplikacji, takich jak aplikacje serwera. Wywołań metod takich jak <xref:System.Console.Write%2A?displayProperty=nameWithType> i <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> nie mają wpływu na aplikacje z graficznym interfejsem użytkownika.  
  
 <xref:System.Console> elementów członkowskich klasy, które działa normalnie, gdy zasadniczy strumień jest kierowany do konsoli może zgłosić wyjątek, jeśli przekierowanie strumienia, na przykład do pliku. Programowanie aplikacji w celu efektywnej <xref:System.IO.IOException?displayProperty=nameWithType> wyjątki po przekierowaniu Standardowy strumień. Można również użyć <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, i <xref:System.Console.IsErrorRedirected%2A> właściwości, aby określić, czy Standardowy strumień jest przekierowywany przed wykonaniem operacji, która zgłasza <xref:System.IO.IOException?displayProperty=nameWithType> wyjątku.  
  
 Można też jawnie wywołać członkami obiektów strumienia reprezentowany przez <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, i <xref:System.Console.Error%2A> właściwości. Na przykład domyślnie <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> metoda odczytuje dane wejściowe z Standardowy strumień wejściowy. Podobnie <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody zapisuje dane do standardowego strumienia wyjściowego, danych następuje domyślny ciąg zakończenia wiersza, który jest znak powrotu karetki i wysuwu wiersza ("\r\n"). Jednak <xref:System.Console> klasa nie ma odpowiedniej metody do zapisu danych do strumienia wyjściowego błąd standardowy lub właściwości, aby zmienić parametry zakończenia wiersza danych w tym strumieniu.  
  
 Problem można rozwiązać przez ustawienie <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> lub <xref:System.Console.Error%2A> właściwości na inny ciąg zakończenia linii. Na przykład następująca instrukcja C# ustawia ciąg znaków zakończenia wiersza dla błąd standardowy strumień wyjściowy dwóch powrotu karetki i wysuwu sekwencji wiersza:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Następnie można jawnie wywołać <xref:System.IO.TextWriter.WriteLine%2A> metody obiektu strumienia wyjściowego błąd, tak jak następującą instrukcję języka C#:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Bufor ekranu i okno konsoli  
 Dwie funkcje ściśle związanych z konsoli są buforu ekranu i w oknie konsoli. Tekst jest rzeczywiście odczytu lub zapisu do strumieni należących do konsoli, ale są wyświetlane do odczytu lub zapisu do obszaru należących do konsoli o nazwie buforu ekranu. Buforu ekranu jest atrybutem konsoli i jest zorganizowana jako prostokątne siatka wierszy i kolumn, w którym każdy przecięcia siatki lub znaku, może zawierać znaku. Każdy znak ma kolor pierwszego planu, a każda komórka znak ma kolor tła.  
  
 Buforu ekranu jest wyświetlany za pośrednictwem prostokątny obszar okno konsoli. W oknie konsoli jest inny atrybut konsoli; nie jest konsoli, która jest okna systemu operacyjnego. W oknie konsoli są rozmieszczone w wiersze i kolumny, jest większa niż rozmiar buforu ekranu i mogą zostać przeniesione do wyświetlania różnych obszarów podstawowej buforu ekranu. Jeśli buforu ekranu jest większy niż okno konsoli, konsoli automatycznie wyświetlane paski przewijania, w oknie konsoli można położenia nad obszarem buforu ekranu.  
  
 Kursor wskazuje pozycję buforu ekranu, gdy tekst jest obecnie zapisu lub odczytu. Kursor mogą być ukryte lub stają się widoczne, a można zmienić wysokość. Jeśli kursor jest widoczny, pozycja okna konsoli jest przenoszone automatycznie, gdy kursor jest zawsze w widoku.  
  
 Punkt początkowy dla współrzędnych komórki znak w buforze ekranu jest lewym górnym rogu i pozycje kursor i w oknie konsoli są określane względem tego pochodzenia. Użyj indeksów liczony od zera, aby określić położenia; oznacza to Określ wiersz najwyższego poziomu jako 0 wiersza i kolumny jako kolumny 0 z lewej strony. Maksymalna wartość dla indeksów wierszy i kolumn jest <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Obsługa standardu Unicode dla konsoli  
 Ogólnie rzecz biorąc konsoli odczytuje dane wejściowe i zapisuje dane wyjściowe przy użyciu bieżącej strony kodowej konsoli, definiującą domyślne ustawienia regionalne systemu. Strona kodowa może obsługiwać tylko podzestaw dostępnych znaków Unicode, więc Jeśli spróbujesz wyświetlania znaków, które nie są mapowane za pomocą stron kodowych określonego, konsoli programu nie będzie można wyświetlić wszystkie znaki lub ich reprezentować dokładnie. Poniższy przykład przedstawia ten problem. Próbuje wyświetlić znaki cyrylicy z U + 0410 do U + 044F do konsoli. Po uruchomieniu przykładzie w systemie, który używa strona kodowa konsoli 437 każdy znak jest zastępowany przez znak zapytania (?), ponieważ cyrylicy znaki nie są mapowane na znaki w stronie kodowej 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Oprócz obsługi stron kodowych <xref:System.Console> klasa obsługuje UTF-8 z kodowaniem <xref:System.Text.UTF8Encoding> klasy. Począwszy od platformy .NET Framework 4.5 <xref:System.Console> klasa obsługuje również z kodowaniem UTF-16 <xref:System.Text.UnicodeEncoding> klasy. Aby wyświetlić znaków Unicode do konsoli. Możesz ustawić <xref:System.Console.OutputEncoding%2A> właściwości albo <xref:System.Text.UTF8Encoding> lub <xref:System.Text.UnicodeEncoding>.  
  
 Obsługa znaków Unicode wymaga koder rozpoznać określonego znaku Unicode i wymaga także czcionki, która ma symboli wymagane do renderowania tego znaku. Aby pomyślnie wyświetlić znaki Unicode w konsoli, czcionki konsoli musi mieć ustawioną z systemem innym niż rastrowe lub czcionki TrueType, takie jak Consolas lub New konsoli. W poniższym przykładzie pokazano, jak można programowo zmienić czcionkę z czcionki rastrowe New konsoli.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Czcionki TrueType można jednak wyświetlany tylko podzestaw symboli. Na przykład czcionki konsoli New wyświetla tylko 643 około 64 000 znaków dostępne z U + 0021 do U + FB02. Aby zobaczyć, które znaków określonej czcionki obsługuje, otwórz **czcionki** apletu w Panelu sterowania, wybierz **znaleźć znak** opcję i wybierz czcionki, zestaw znaków, których, którego chcesz zbadać ** Czcionki** lista **Tablica znaków** okna.  
  
 System Windows używa łączenia czcionek do wyświetlenia symboli, które nie są dostępne w określonej czcionki. Informacje o łączenie do wyświetlania zestawów dodatkowych znaków czcionek, zobacz [globalizacji krok po kroku: czcionki](http://go.microsoft.com/fwlink/?LinkId=229111). Połączone czcionek są definiowane w HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink podklucz rejestru. Każdy wpis skojarzone z tym podklucz odpowiada nazwie podstawowej czcionki, a jego wartość wynosi tablicy ciągów, który definiuje pliki czcionki i czcionek, które są połączone z czcionka. Każdy element członkowski tablicy definiuje połączonego czcionki i ma postać *nazwy pliku czcionki*,*nazwę czcionki*. Poniższy przykład przedstawia, jak programowo można zdefiniować połączonego czcionki o nazwie SimSun znaleziono w pliku czcionki o nazwie simsun.ttc wyświetlający Han uproszczony znaków.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Obsługa formatu Unicode dla konsoli ma następujące ograniczenia:  
  
-   Kodowanie UTF-32 nie jest obsługiwane. Jedynym obsługiwanym Unicode są kodowania UTF-8 i UTF-16, które są reprezentowane przez <xref:System.Text.UTF8Encoding> i <xref:System.Text.UnicodeEncoding> klasy odpowiednio.  
  
-   Dane wyjściowe dwukierunkowego nie jest obsługiwane.  
  
-   Wyświetlanie znaki spoza płaszczyzny wielojęzyczny podstawowe (oznacza to, z Znaki dwuskładnikowe) nie jest obsługiwana, nawet jeśli są one zdefiniowane w pliku połączonego czcionki.  
  
-   Wyświetlanie znaków złożonych skryptów nie jest obsługiwane.  
  
-   Łączenie sekwencje znaków (to znaczy znaki, które składają się z podstawowej znaków i co najmniej jeden znak łączenie) są wyświetlane jako osobne znaków. Aby obejść to ograniczenie, można znormalizować ciąg do wyświetlania przez wywołanie metody <xref:System.String.Normalize%2A?displayProperty=nameWithType> metody przed wysłaniem danych wyjściowych konsoli. W poniższym przykładzie ciąg, który zawiera znak łączenie sekwencji 0061 U + U + 0308 jest wyświetlana w konsoli jako dwa znaki, przed jest znormalizowany ciągu wyjściowego, a jako pojedynczy znak po <xref:System.String.Normalize%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Zwróć uwagę, że normalizacji skutecznych rozwiązań tylko wtedy, gdy sekwencja znaków standardu wstępnie składa formularz, który odpowiada określonego combining zawiera znak Unicode.  
  
-   Jeśli czcionki udostępnia symbol punktu kodu w obszarze użytek, pojawi się tego symbolu. Jednak ponieważ znaki w obszarze użytek są specyficzne dla aplikacji, nie może to być oczekiwany symbol.  
  
 W poniższym przykładzie przedstawiono zakres znaków Unicode do konsoli. Przykład akceptuje trzy parametry wiersza polecenia: początek zakresu, aby wyświetlić końca zakresu do wyświetlenia i czy ma być używany do kodowania bieżącej konsoli (`false`) lub kodowania UTF-16 (`true`). Przyjęto założenie, że konsoli przy użyciu czcionki TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Typowe operacje  
 <xref:System.Console> Klasa zawiera następujące metody odczytuje dane wejściowe konsoli i zapisuje dane wyjściowe konsoli:  
  
-   Przeciążeń <xref:System.Console.ReadKey%2A> metody odczytu poszczególnych znaków.  
  
-   <xref:System.Console.ReadLine%2A> Metoda odczytuje cały wiersz danych wejściowych.  
  
-   <xref:System.Console.Write%2A> Przeciążenia metody przekonwertować na ciąg sformatowany lub niesformatowany wystąpienia typu wartości, tablicy znaków lub zestaw obiektów, a następnie wpisz ten ciąg do konsoli.  
  
-   Zestaw równoległego <xref:System.Console.WriteLine%2A> metoda przeciąża taki sam ciąg jako dane wyjściowe <xref:System.Console.Write%2A> overloads, ale również dodać ciąg zakończenia linii.  
  
 <xref:System.Console> Klasa zawiera także metody i właściwości, aby wykonać następujące czynności:  
  
-   Uzyskaj lub ustaw rozmiar buforu ekranu. <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości można pobrać lub ustawić buforu wysokość i szerokość, odpowiednio i <xref:System.Console.SetBufferSize%2A> metoda umożliwia ustawienie rozmiaru buforu w wywołaniu pojedynczej metody.  
  
-   Uzyskaj lub ustaw rozmiar okna konsoli. <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości można pobrać lub ustawić okno wysokość i szerokość, odpowiednio i <xref:System.Console.SetWindowSize%2A> metody umożliwia ustawienie rozmiaru okna w wywołaniu pojedynczej metody.  
  
-   Uzyskaj lub ustaw rozmiar kursora. <xref:System.Console.CursorSize%2A> Właściwość określa wysokość kursora w komórce znaków.  
  
-   GET lub set pozycja okna konsoli względem buforu ekranu. <xref:System.Console.WindowTop%2A> i <xref:System.Console.WindowLeft%2A> właściwości można pobrać lub ustawić górnego wiersza i kolumny z lewej strony z buforu ekranu, który jest wyświetlany w oknie konsoli i <xref:System.Console.SetWindowPosition%2A> metoda pozwala ustawić te wartości w wywołaniu pojedynczej metody.  
  
-   Pobrać lub ustawić pozycji kursora pobierania lub ustawiania <xref:System.Console.CursorTop%2A> i <xref:System.Console.CursorLeft%2A> właściwości lub Ustawia położenie kursora przez wywołanie metody <xref:System.Console.SetCursorPosition%2A> metody.  
  
-   Przenieś lub Usuń dane w buforze ekranu przez wywołanie metody <xref:System.Console.MoveBufferArea%2A> lub <xref:System.Console.Clear%2A> metody.  
  
-   Pobrać lub ustawić kolory pierwszego planu i tła przy użyciu <xref:System.Console.ForegroundColor%2A> i <xref:System.Console.BackgroundColor%2A> właściwości, lub zresetuj tła i pierwszego planu do ich domyślnych kolorów, wywołując <xref:System.Console.ResetColor%2A> metody.  
  
-   Odtwarzanie sygnału dźwiękowego za pośrednictwem konsoli prelegenta przez wywołanie metody <xref:System.Console.Beep%2A> metody.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Uwagi  
 W programie .NET Framework na pulpicie <xref:System.Console> klasa korzysta z kodowaniem zwrócony przez `GetConsoleCP` i `GetConsoleOutputCP`, która zwykle jest strona kodowa kodowania. Na przykład kodu w systemach, w których kultury jest angielski (Stany Zjednoczone), strona kodowa 437 jest kodowanie, używany domyślnie. Jednak [!INCLUDE[net_core](~/includes/net-core-md.md)] może udostępnić ograniczonym podzbiorem te kodowania. W przypadku, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> jest używane jako domyślne kodowanie używane do konsoli.  
  
 Jeśli aplikacji zależy od konkretnego kodu strony kodowania, można nadal udostępnić je, wykonując następujące *przed* wywołać dowolną <xref:System.Console> metod:  
  
1.  Dodaj odwołanie do zestawu System.Text.Encoding.CodePages.dll do projektu.  
  
2.  Pobrać <xref:System.Text.EncodingProvider> obiekt z <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> właściwości.  
  
3.  Przekaż <xref:System.Text.EncodingProvider> do obiektu <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> metodę, aby wprowadzić dodatkowe kodowania, obsługiwane przez dostawcę kodowania, która jest dostępna.  
  
 <xref:System.Console> Klasy będzie automatycznie używać systemu domyślne kodowanie zamiast UTF8, pod warunkiem, że zarejestrowano dostawcę kodowania przed wywołaniem dowolnej <xref:System.Console> dane wyjściowe metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób odczytu i zapisu danych na standardowe dane wejściowe i strumienie wyjściowe. Należy pamiętać, że mogą zostać przekierowane tych strumieni przy użyciu <xref:System.Console.SetIn%2A> i <xref:System.Console.SetOut%2A> metody.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła konsoli.</summary>
        <value>Wartość, która określa kolor tła konsoli; oznacza to, kolor tła każdego znaku. Wartość domyślna to czarny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykryto zmianę wprowadzoną do <xref:System.Console.BackgroundColor%2A> właściwość dotyczy tylko dane wyjściowe są zapisywane do komórek indywidualnym po zmianie kolor tła. Aby zmienić kolor tła okna konsoli jako całość, ustaw <xref:System.Console.BackgroundColor%2A> właściwości i wywołanie <xref:System.Console.Clear%2A> metody. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Operacja get dla aplikacji systemu Windows, w którym konsola nie istnieje, zwraca <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład jest zapisywany wartości <xref:System.ConsoleColor> wyliczenie do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem na kolor wartości, które odpowiadają bieżącym tła, a następnie zmienia kolor tła do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst nie jest widoczna). Na koniec wywołuje <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kolor określony w operacji set nie jest prawidłowym elementem członkowskim <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odtwarza dźwięk sygnału dźwiękowego za pośrednictwem prelegenta konsoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odtwarza dźwięk sygnału dźwiękowego za pośrednictwem prelegenta konsoli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie dźwięku odtwarza z częstotliwością 800 Hz czas trwania 200 ms.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Metoda nie jest obsługiwana w 64-bitowych wersjach systemów Windows Vista i Windows XP.  
  
 <xref:System.Console.Beep%2A> opakowuje wywołanie systemu Windows [dźwięk, funkcja](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Czy <xref:System.Console.Beep%2A> tworzy dźwięk w wersjach systemu Windows przed zależy od obecności mikroukładu czasomierza interwału programowalny 8254 systemu Windows 7. Począwszy od systemu Windows 7, to zależy od domyślnego urządzenia dźwiękowego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.Beep%2A> metody. Przykład akceptuje liczba z przedziału od 1 do 9 jako argument wiersza polecenia i odtwarzania dźwięku tej liczby.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Ta metoda została uruchomiona na serwerze, takich jak SQL Server, który nie zezwala na dostęp do interfejsu użytkownika.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">Częstotliwość dźwięk, począwszy od 37 do 32767 Hz.</param>
        <param name="duration">Czas trwania dźwięku mierzony w milisekundach.</param>
        <summary>Odtwarza dźwięk sygnału dźwiękowego określonej częstotliwości i czasu trwania przez osoby mówiącej konsoli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> opakowuje wywołanie systemu Windows [dźwięk, funkcja](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Czy <xref:System.Console.Beep%2A> tworzy dźwięk w wersjach systemu Windows przed zależy od obecności mikroukładu czasomierza interwału programowalny 8254 systemu Windows 7. Począwszy od systemu Windows 7, to zależy od domyślnego urządzenia dźwiękowego.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Metoda nie jest obsługiwana w 64-bitowych wersjach systemów Windows Vista i Windows XP.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.Beep%2A> metody przez odtwarzanie pierwszy uwagi kilka utworów muzycznych przez osoby mówiącej konsoli.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="frequency" /> jest mniejsza niż 37 lub więcej niż 32767 Hz.  - lub - <paramref name="duration" /> jest mniejsza niż lub równa zero.</exception>
        <exception cref="T:System.Security.HostProtectionException">Ta metoda została uruchomiona na serwerze, takich jak SQL Server, który nie zezwala na dostęp do konsoli.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość obszaru buforu.</summary>
        <value>Bieżąca wysokość wierszy obszar buforu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa liczbę wierszy (lub wierszy) przechowywane w buforze, który jest dostępny w trybie okna konsoli. Z kolei <xref:System.Console.WindowHeight%2A> właściwość definiuje liczbę wierszy, które są wyświetlane w oknie konsoli w dowolnym momencie konkretnego. Jeśli liczba wierszy, zapisana w buforze przekracza liczbę wierszy, zdefiniowane przez <xref:System.Console.WindowHeight%2A> właściwość okna może być przewijane w pionie, tak aby wyświetlone ciągłe liczbę wierszy, które są równe <xref:System.Console.WindowHeight%2A> właściwości i są umieszczone dowolne miejsce w buforze.  
  
 Jeśli operację zmniejsza się wartość <xref:System.Console.BufferHeight%2A> właściwość najwyższym wiersze zostaną usunięte. Na przykład jeśli jest zmniejszyć liczbę wierszy od 300 do 250, od 0 do 49 wiersze zostaną usunięte i istniejące wiersze 50 do 299 stają się linii 249 do 0.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Przykładowe raporty wymiary rozmiaru buforu 300 wierszy i kolumn 85 okna systemu operacyjnego.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji set jest mniejsza lub równa zero.  - lub - wartość w operacji set jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - wartość w operacji set jest mniejsza niż <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość obszaru buforu.</summary>
        <value>Bieżąca szerokość kolumn obszaru buforu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operację zmniejsza się wartość <xref:System.Console.BufferWidth%2A> właściwości, są usuwane po prawej stronie kolumny. Na przykład jeśli liczba kolumn został zmniejszony z 80 do 60, kolumny 60 do 79 każdego wiersza są usuwane.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Przykładowe raporty wymiary rozmiaru buforu 300 wierszy i kolumn 85 okna systemu operacyjnego.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji set jest mniejsza lub równa zero.  - lub - wartość w operacji set jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - wartość w operacji set jest mniejsza niż <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="F:System.ConsoleModifiers.Control" /> klawisz modyfikujący (Ctrl), a następnie <see cref="F:System.ConsoleKey.C" /> konsoli (C) podziału klawisz lub naciśnięciu jednocześnie (Ctrl + C lub Ctrl + Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest używany w połączeniu z <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> i <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. <xref:System.Console.CancelKeyPress> Zdarzeń umożliwia aplikacji konsoli przechwycenia sygnał Ctrl + C, aby program obsługi zdarzeń można zdecydować, czy do kontynuowania wykonywania lub przerywania. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 Po naciśnięciu klawiszy Ctrl + C lub Ctrl + Break <xref:System.Console.CancelKeyPress> zdarzenie jest generowane i aplikacji <xref:System.ConsoleCancelEventHandler> program obsługi zdarzeń jest wykonywany. Program obsługi zdarzeń jest przekazywany <xref:System.ConsoleCancelEventArgs> obiektu, który ma dwie właściwości przydatne:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, co pozwala określić, czy program obsługi został wywołany po wysłaniu przez użytkownika, naciskając klawisze Ctrl + C (wartość właściwości jest <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) lub Ctrl + Break (wartość właściwości jest <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, co pozwala określić, jak do aplikacji powinien odpowiedź do użytkownika naciśnięcie klawiszy Ctrl + C lub Ctrl + Break. Domyślnie <xref:System.ConsoleCancelEventArgs.Cancel%2A> właściwość jest `false`, który powoduje, że program wykonywania zakończenie po zamknięciu programu obsługi zdarzeń. Zmiana właściwości do `true` Określa, czy aplikacja powinno być kontynuowane do wykonania.  
  
> [!TIP]
>  Jeśli aplikacja ma prosty wymagania, możesz użyć <xref:System.Console.TreatControlCAsInput%2A> właściwości zamiast tego zdarzenia. Przez ustawienie dla tej właściwości `false`, można zapewnić, że aplikacji zawsze kończy działanie, gdy użytkownik naciśnie klawisz Ctrl + C. Przez ustawienie jej na `true`, można zapewnić, że naciśnięcie klawiszy Ctrl + C nie zakończy aplikacji.  
  
 Program obsługi zdarzeń dla tego zdarzenia jest wykonywany w wątku puli wątków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Console.CancelKeyPress> zdarzenia jest używany. Po naciśnięciu klawiszy Ctrl + C, operacja odczytu zostanie przerwana i `myHandler` jest wywoływana procedura obsługi zdarzeń. Wejścia do programu obsługi zdarzeń <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> właściwość jest `false`, co oznacza, że bieżący proces zakończy, gdy zakończenie obsługi zdarzeń. Jednak Ustawia program obsługi zdarzeń <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> właściwości `true`, co oznacza, że proces nie zostanie zakończona i wznowi operacji odczytu.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy przełącz klawiaturę włączony klawisz CAPS LOCK jest włączony lub wyłączony.</summary>
        <value>
          <see langword="true" /> Jeśli włączony klawisz CAPS LOCK jest włączony; <see langword="false" /> Jeśli włączony klawisz CAPS LOCK jest wyłączony.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści buforu konsoli i odpowiedniego okna konsoli wyświetlanych informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.Console.Clear%2A> metody odpowiada wywoływania MS-DOS `cls` polecenie w oknie wiersza polecenia. Gdy <xref:System.Console.Clear%2A> metoda jest wywoływana, kursor automatycznie przewija do lewego górnego rogu okna i zawartości buforu ekranu są ustawione na puste wartości, przy użyciu bieżącego kolory pierwszego planu w tle.  
  
> [!NOTE]
>  Próba wywołania <xref:System.Console.Clear%2A> zgłasza wyjątek, jeśli dane wyjściowe aplikacji konsoli jest przekierowywany do pliku <xref:System.IO.IOException>. Aby tego uniknąć, zawsze Zawijaj wywołanie <xref:System.Console.Clear%2A> metody w `try`...`catch` Blok.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.Clear%2A> metodę, aby wyczyścić konsoli, przed rozpoczęciem wykonywania pętli, monitu wybierz kolor pierwszego planu i tła i wprowadź ciąg do wyświetlenia. Jeśli użytkownik zdecyduje się nie zakończyć działanie programu, są przywracane oryginalne kolory pierwszego planu i tła konsoli programu i <xref:System.Console.Clear%2A> metoda jest wywoływana ponownie przed ponownym wykonaniem pętli.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 Przykład polega na `GetKeyPress` metodę weryfikacji określonego przez użytkownika kolor pierwszego planu i tła.  
  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości oraz <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. Przykład umieszcza kursor, który określa, gdzie zostanie przeprowadzona kolejnego zapisu, aby narysować 5 znaków przez 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", a "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora w kolumnie w obszarze buforu.</summary>
        <value>Bieżąca pozycja w kolumnach kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości oraz <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. Przykład umieszcza kursor, który określa, gdzie zostanie przeprowadzona kolejnego zapisu, aby narysować 5 znaków przez 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", a "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji set jest mniejsza od zera.  - lub - wartość w operacji set jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość kursor w komórce znaków.</summary>
        <value>Rozmiar kursora wyrażone jako procent wysokość komórki znaków. Właściwość wartości może się wahać od 1 do 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wygląd kursora różni się od linii poziomej w dolnej części komórki, gdy wartość właściwości jest 1, aby całkowicie wypełnianie komórki, gdy wartość właściwości to 100.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorSize%2A> właściwości. Przykład zwiększa rozmiar kursora zawsze dowolny klawisz, konsola zostanie naciśnięty, a następnie przywraca kursor do oryginalnego rozmiaru przed zakończeniem.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona w operacji set jest mniejszy niż 1 lub większa niż 100.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora w wierszu w obszarze buforu.</summary>
        <value>Bieżąca pozycja w wierszach kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości oraz <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. Przykład umieszcza kursor, który określa, gdzie zostanie przeprowadzona kolejnego zapisu, aby narysować 5 znaków przez 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", a "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji set jest mniejsza od zera.  - lub - wartość w operacji set jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kursor jest widoczny.</summary>
        <value>
          <see langword="true" /> Jeśli kursor jest widoczna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorVisible%2A> właściwości. Przykład powoduje, że kursor widoczne, jeśli pierwsza kolumna danych wejściowych jest znak "+" lub niewidoczne, jeśli dane wejściowe są "-" znaków.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera błąd standardowy strumień wyjściowy.</summary>
        <value>A <see cref="T:System.IO.TextWriter" /> reprezentujący błąd standardowy strumień wyjściowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Standardowy strumień błędów jest domyślnie do konsoli. Można ją ustawić do innego strumienia z <xref:System.Console.SetError%2A> metody. Po przekierowania Standardowy strumień błędów można reacquired przez wywołanie metody <xref:System.Console.OpenStandardError%2A> metody.  
  
 W aplikacji konsoli, której wyjście informacyjną często jest przekierowywany do pliku, błąd standardowy strumienia dostępne za pośrednictwem <xref:System.Console.Error%2A> właściwości może służyć do wyświetlania informacji w konsoli, nawet jeśli w danych wyjściowych. W poniższym przykładzie przedstawiono tabelach produktów dla 10 numerów naraz, począwszy od 1. Po każdym zestawie 10 numerów <xref:System.Console.Error%2A> właściwość jest używana do poprosić użytkownika, czy mają być wyświetlane dalej zestawu. Jeśli wyjścia standardowego jest przekierowywany do pliku, użytkownik nadal jest pytany, czy procedura powinna generować dalej zestawu produktów.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład jest narzędzie wiersza polecenia o nazwie ExpandTabs, który zastępuje znaki tabulacji w pliku tekstowym z czterech spacji, wartość zdefiniowana przez `tabSize` zmiennej. Przekierowania standardowych danych wejściowych i wyjściowych strumieni do plików, ale używa <xref:System.Console.Error%2A> właściwość do zapisania Standardowy strumień błędów do konsoli. Mogą być przeprowadzane w wierszu polecenia, podając nazwę pliku, który zawiera znaki tabulacji i nazwę pliku wyjściowego.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Poniższy przykład jest przeglądarka plików zwykły tekst, który wyświetla zawartość jednego lub więcej plików tekstowych w konsoli. Jeśli nie wymaga argumentów wiersza polecenia, lub jeśli nie istnieją wszystkie pliki przekazywane jako argumenty wiersza polecenia, <xref:System.Console.SetError%2A> wywołuje metodę, aby przekierować informacje o błędzie do pliku, <xref:System.Console.OpenStandardError%2A> metody właśnie reacquiring błąd standardowy strumienia i wskazuje, że informacje o błędzie został zapisany do pliku.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Należy pamiętać, że <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true` przed reacquiring strumienia błędów. Dzięki temu, że dane wyjściowe będą można natychmiast wysyłane do konsoli, a nie buforowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu konsoli.</summary>
        <value>A <see cref="T:System.ConsoleColor" /> , który określa kolor pierwszego planu konsoli; oznacza to, kolor każdego znaku, który jest wyświetlany. Wartość domyślna jest szary.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja get dla aplikacji systemu Windows, w którym konsola nie istnieje, zwraca <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie, czy kolor tła konsoli jest czarny, a jeśli tak jest, zmianę koloru tła na czerwony i kolor pierwszego planu na kolor czarny.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 Poniższy przykład jest zapisywany wartości <xref:System.ConsoleColor> wyliczenie do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem na kolor wartości, które odpowiadają bieżącym tła, a następnie zmienia kolor tła do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst nie jest widoczna). Na koniec wywołuje <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kolor określony w operacji set nie jest prawidłowym elementem członkowskim <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Standardowy strumień wejściowy.</summary>
        <value>A <see cref="T:System.IO.TextReader" /> reprezentujący Standardowy strumień wejściowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma ustawioną Standardowy strumień wejściowy domyślnie. Tej właściwości można ustawić inny strumień z <xref:System.Console.SetIn%2A> metody.  
  
 Operacje odczytu na Standardowy strumień wejściowy wykonać synchronicznie. Oznacza to blokują dopiero po ukończeniu określonej operacji odczytu. Dotyczy to nawet jeśli metodę asynchroniczną, takich jak <xref:System.IO.TextReader.ReadLineAsync%2A>, zostanie wywołany dla <xref:System.IO.TextReader> obiektu zwróconego przez <xref:System.Console.In%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `In` właściwości.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie używanych odczytać wejściowych konsoli.</summary>
        <value>Kodowanie, używany do odczytu danych wejściowych konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsoli używa danych wejściowych kodowanie tłumaczenie wprowadzanie z klawiatury w odpowiednich znaków. Kodowanie wejściowy zawiera stronę kodową, która mapuje 256 kody znaków klawiatury do poszczególnych znaków. Inny kod strony zawierają różne znaków specjalnych, zwykle dostosowywane do języka lub grupy języków.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], operacji get właściwości może zwrócić wartość w pamięci podręcznej zamiast z konsoli bieżącego kodowania wejściowego. Taka sytuacja może wystąpić, jeśli wartość <xref:System.Console.InputEncoding%2A> właściwość zostanie zmodyfikowana w sposób niż przypisania do <xref:System.Console.InputEncoding%2A> właściwości, taką jak wywołanie systemu Windows `SetConsoleCP` funkcji lub przy użyciu `chcp` polecenia skryptu programu PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości w operacji set jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Aplikacja nie ma uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">do odczytywania i zapisywania najwyższego poziomu systemu windows i subwindows. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strumień wyjściowy błąd zostały przekierowane z Standardowy strumień błędów.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe błędów jest przekierowywany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dane wejściowe zostały przekierowane z Standardowy strumień wejściowy.</summary>
        <value>
          <see langword="true" /> Jeśli dane wejściowe jest przekierowywany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dane wyjściowe zostały przekierowane z standardowego strumienia wyjściowego.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe zostanie przekierowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy naciśnięcie klawisza są dostępne w strumieniu wejściowym.</summary>
        <value>
          <see langword="true" /> Jeśli naciśnięcie klawisza jest dostępna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest zwracana natychmiast; oznacza to, że <xref:System.Console.KeyAvailable%2A> właściwości nie są blokowane w danych wejściowych do czasu udostępnienia naciśnięcie klawisza.  
  
 Użyj <xref:System.Console.KeyAvailable%2A> właściwość w połączeniu z tylko <xref:System.Console.ReadKey%2A> metody, nie <xref:System.Console.Read%2A> lub <xref:System.Console.ReadLine%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Console.KeyAvailable%2A> właściwość, aby utworzyć pętlę wykonywana do czasu naciśnięcia klawisza.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.InvalidOperationException">Standardowe dane wejściowe jest przekierowywany do pliku zamiast klawiatury.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera największej liczby konsoli wierszy okna, na podstawie bieżącej rozdzielczości czcionkę i ekranu.</summary>
        <value>Wysokość okna konsoli możliwe największy mierzona w wierszach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera największej liczby konsoli kolumny okna, na podstawie bieżącej rozdzielczości czcionkę i ekranu.</summary>
        <value>Szerokość okna konsoli możliwe największy mierzona w kolumnach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Kolumny z lewej strony obszaru źródła.</param>
        <param name="sourceTop">Wiersz znajdujących się na górze obszaru źródła.</param>
        <param name="sourceWidth">Liczba kolumn w obszarze źródło.</param>
        <param name="sourceHeight">Liczba wierszy w obszarze źródło.</param>
        <param name="targetLeft">Kolumny z lewej strony obszaru docelowego.</param>
        <param name="targetTop">Wiersz znajdujących się na górze obszaru docelowego.</param>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli parametry źródłowym i docelowym określić pozycji znajduje się poza granicami bieżącego buforu ekranu, jest kopiowany tylko część obszaru źródłowego, który mieści się w obszarze docelowym. Oznacza to, że obszar źródłowy jest przycięta bieżącego buforu ekranu.  
  
 <xref:System.Console.MoveBufferArea%2A> Metody kopiuje obszaru źródłowego do docelowego obszaru. Jeśli w obszarze docelowym nie intersect obszar źródłowy, obszar źródłowy jest wypełniony puste wartości, przy użyciu bieżącego kolory pierwszego planu i tła. W przeciwnym razie wartość przecięcia część obszaru źródła nie jest wypełnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z parametrów jest mniejsza od zera.  - lub - <paramref name="sourceLeft" /> lub <paramref name="targetLeft" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  - lub - <paramref name="sourceTop" /> lub <paramref name="targetTop" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  - lub - <paramref name="sourceTop" />  +  <paramref name="sourceHeight" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  - lub - <paramref name="sourceLeft" />  +  <paramref name="sourceWidth" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Kolumny z lewej strony obszaru źródła.</param>
        <param name="sourceTop">Wiersz znajdujących się na górze obszaru źródła.</param>
        <param name="sourceWidth">Liczba kolumn w obszarze źródło.</param>
        <param name="sourceHeight">Liczba wierszy w obszarze źródło.</param>
        <param name="targetLeft">Kolumny z lewej strony obszaru docelowego.</param>
        <param name="targetTop">Wiersz znajdujących się na górze obszaru docelowego.</param>
        <param name="sourceChar">Znak używany do wypełnienia obszaru źródłowego.</param>
        <param name="sourceForeColor">Kolor pierwszego planu używany do wypełnienia obszaru źródłowego.</param>
        <param name="sourceBackColor">Kolor tła używany do wypełnienia obszaru źródłowego.</param>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli parametry źródłowym i docelowym określić pozycji znajduje się poza granicami bieżącego buforu ekranu, jest kopiowany tylko część obszaru źródłowego, który mieści się w obszarze docelowym. Oznacza to, że obszar źródłowy jest przycięta bieżącego buforu ekranu.  
  
 <xref:System.Console.MoveBufferArea%2A> Metody kopiuje obszaru źródłowego do docelowego obszaru. Jeśli obszar docelowy nie intersect obszar źródłowy, obszar źródłowy jest wypełniony znak określony przez `sourceChar`, przy użyciu kolorów określonych przez `sourceForeColor` i `sourceBackColor`. W przeciwnym razie wartość przecięcia część obszaru źródła nie jest wypełnione.  
  
 <xref:System.Console.MoveBufferArea%2A> Jeśli nie metoda wykonuje żadnych operacji `sourceWidth` lub `sourceHeight` wynosi zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z parametrów jest mniejsza od zera.  - lub - <paramref name="sourceLeft" /> lub <paramref name="targetLeft" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  - lub - <paramref name="sourceTop" /> lub <paramref name="targetTop" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  - lub - <paramref name="sourceTop" />  +  <paramref name="sourceHeight" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  - lub - <paramref name="sourceLeft" />  +  <paramref name="sourceWidth" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z parametrów kolor nie jest elementem członkowskim <see cref="T:System.ConsoleColor" /> wyliczenia.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy przełącznik klawiatury NUM LOCK jest włączony lub wyłączony.</summary>
        <value>
          <see langword="true" /> Jeśli NUM LOCK jest włączony; <see langword="false" /> Jeżeli NUM LOCK jest wyłączony.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje Standardowy strumień błędów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje Standardowy strumień błędów.</summary>
        <returns>Standardowy strumień błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień błędów po zmianie przez <xref:System.Console.SetError%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład jest przeglądarka plików zwykły tekst, który wyświetla zawartość jednego lub więcej plików tekstowych w konsoli. Jeśli nie wymaga argumentów wiersza polecenia, lub jeśli nie istnieją wszystkie pliki przekazywane jako argumenty wiersza polecenia, <xref:System.Console.SetError%2A> wywołuje metodę, aby przekierować informacje o błędzie do pliku, <xref:System.Console.OpenStandardError%2A> metody właśnie reacquiring błąd standardowy strumienia i wskazuje, że informacje o błędzie został zapisany do pliku.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Należy pamiętać, że <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true` przed reacquiring strumienia błędów. Dzięki temu, że dane wyjściowe będą można natychmiast wysyłane do konsoli, a nie buforowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Uzyskuje Standardowy strumień błędów, która jest ustawiona na określony rozmiar buforu.</summary>
        <returns>Standardowy strumień błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień błędów po zmianie przez <xref:System.Console.SetError%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest mniejsza lub równa zero.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje Standardowy strumień wejściowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje Standardowy strumień wejściowy.</summary>
        <returns>Standardowy strumień wejściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień wejściowy po zmianie przez <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `OpenStandardInput` właściwości.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Uzyskuje Standardowy strumień wejściowy ma ustawioną wartość określony rozmiar buforu.</summary>
        <returns>Standardowy strumień wejściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień wyjściowy po zmianie przez <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `OpenStandardInput` właściwości.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest mniejsza lub równa zero.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ukończone operacje w standardowym strumieniu wyjściowym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukończone operacje w standardowym strumieniu wyjściowym.</summary>
        <returns>Standardowy strumień wyjściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień wyjściowy po zmianie przez <xref:System.Console.SetOut%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Console.OpenStandardOutput%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby go uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Ukończone operacje w standardowym strumieniu wyjściowym, która jest ustawiona na określony rozmiar buforu.</summary>
        <returns>Standardowy strumień wyjściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do ponownie pozyskać Standardowy strumień wyjściowy po zmianie przez <xref:System.Console.SetOut%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Console.OpenStandardOutput%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby go uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest mniejsza lub równa zero.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera standardowego strumienia wyjściowego.</summary>
        <value>A <see cref="T:System.IO.TextWriter" /> reprezentujący standardowego strumienia wyjściowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest domyślnie do standardowego strumienia wyjściowego. Tej właściwości można ustawić inny strumień z <xref:System.Console.SetOut%2A> metody.  
  
 Należy pamiętać, że wywołań `Console.Out.WriteLine` są odpowiednikiem wywołania do odpowiedniej metody <xref:System.Console.WriteLine%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.Out%2A> właściwość, aby wyświetlić tablicę zawierającą nazwy plików w katalogu bieżącej aplikacji na urządzeniu standardowe dane wyjściowe. Następnie ustawia standardowe dane wyjściowe do pliku o nazwie Files.txt i wyświetla listę elementów tablicy do pliku. Na koniec ustawia dane wyjściowe do standardowego strumienia wyjściowego i ponownie wyświetla elementy tablicy na urządzeniu standardowe dane wyjściowe.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie, używanych do zapisywania danych wyjściowych konsoli.</summary>
        <value>Kodowanie, używany do zapisywania danych wyjściowych konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsola używa kodowania danych wyjściowych do przekształcania znaków napisane przez aplikację na odpowiadające im znaki wyświetlania konsoli. Domyślna strona kodowa konsoli używa zależy od ustawień regionalnych systemu.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], operacji get właściwości może zwrócić wartość w pamięci podręcznej zamiast bieżącego kodowania dane wyjściowe z konsoli. Taka sytuacja może wystąpić, jeśli wartość <xref:System.Console.OutputEncoding%2A> właściwość zostanie zmodyfikowana w sposób niż przypisania do <xref:System.Console.OutputEncoding%2A> właściwości, taką jak wywołanie systemu Windows `SetConsoleOutputCP` funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości w operacji set jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Aplikacja nie ma uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">do odczytywania i zapisywania najwyższego poziomu systemu windows i subwindows.  Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Z kodowania Unicode <see cref="T:System.Console" /> klasa obsługuje UTF-8 z kodowaniem <see cref="T:System.Text.UTF8Encoding" /> klasy a, począwszy od [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] obsługuje UTF-16 z kodowaniem <see cref="T:System.Text.UnicodeEncoding" /> klasy. Kodowanie UTF-32 z <see cref="T:System.Text.UTF32Encoding" /> klasa nie jest obsługiwana. Trwa próba skonfigurowania danych wyjściowych kodowanie UTF-32 zgłasza <see cref="T:System.IO.IOException" />.  Należy pamiętać, że pomyślnie wyświetlanie znaków Unicode do konsoli ma następujące wymagania:-konsoli musi Użyj czcionki TrueType, takich jak konsola New lub Consolas, aby wyświetlić znaki.  -Czcionki używany przez konsolę programu należy zdefiniować określonego symbolu lub symbole, który będzie wyświetlany. Konsoli można korzystać z czcionki łączenia do wyświetlenia symboli z połączonego czcionki, jeśli czcionka nie zawiera definicji dla tego symbolu.  Aby uzyskać więcej informacji o obsłudze standardu Unicode kodowanie przez konsolę, zobacz sekcję "Unicode obsługuje dla Konsola" w <see cref="T:System.Console" /> klasy.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny znak z Standardowy strumień wejściowy.</summary>
        <returns>Następnej znak ze strumienia wejściowego, lub wartość ujemną (-1) Jeśli obecnie nie istnieją żadne więcej znaków do odczytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Read%2A> Metody blokuje jego powrotu podczas pisania wprowadzanie znaków; kończy się po naciśnięciu <xref:System.ConsoleKey.Enter> klucza. Naciśnięcie klawisza Enter dołącza dane wejściowe sekwencji zakończenia wiersza zależny od platformy (na przykład Windows dołącza sekwencji wysuwu wiersza powrotu karetki). Kolejne wywołania <xref:System.Console.Read%2A> metody pobierania z wejściowego o jeden znak. Po pobraniu ostatni znak <xref:System.Console.Read%2A> blokuje jego powrotu ponownie i cykl powtarza się.  
  
> [!IMPORTANT]
>  <xref:System.Console.ReadLine%2A> Metody, lub <xref:System.Console.KeyAvailable%2A> właściwości i <xref:System.Console.ReadKey%2A> metody są używane zamiast <xref:System.Console.Read%2A> metody.  
  
 Należy pamiętać, że metoda nie Zwróć -1, chyba że wykonaj jedną z następujących czynności:  
  
-   Naciśnij jednocześnie klawisz <xref:System.ConsoleModifiers.Control> klawisz modyfikujący i <xref:System.ConsoleKey.Z> klucza konsoli (Ctrl + Z), która sygnalizuje warunku końcowego z pliku.  
  
-   Naciśnij klawisz równoważne sygnalizującego warunek końca pliku, takie jak klawisz F6 funkcji w systemie Windows.  
  
-   Przekieruj strumień wejściowy do źródła, takich jak plik tekstowy, ze znakiem rzeczywisty plik końcowy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.Read%2A> metody.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika. Naciśnięty klawisz jest wyświetlany w oknie konsoli.</summary>
        <returns>Obiekt, który opisuje <see cref="T:System.ConsoleKey" /> stała i znak Unicode, który odpowiada klucz naciśniętego konsoli. <see cref="T:System.ConsoleKeyInfo" /> Również opis obiektu, z bitowego połączenia <see cref="T:System.ConsoleModifiers" /> wartości, czy co najmniej jeden Shift, Alt i Ctrl klawisze modyfikujące naciśnięto jednocześnie z kluczem konsoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> — Metoda czeka, oznacza to, bloków na urzędzie wystawiającym certyfikaty wątku <xref:System.Console.ReadKey%2A> metody, dopóki nie zostanie naciśnięty klawisz znak lub funkcji. W połączeniu z co najmniej jeden Alt, Ctrl lub Shift klawisze modyfikujące można można naciśnięty klawisz znak lub funkcji. Jednakże, naciskając klawisz modyfikujący samodzielnie nie spowoduje <xref:System.Console.ReadKey%2A> metody do zwrócenia.  
  
 W zależności od aplikacji, możesz chcieć użyć <xref:System.Console.ReadKey%2A> w połączeniu z metody <xref:System.Console.KeyAvailable%2A> właściwości.  
  
 <xref:System.Console.ReadKey%2A> Metoda odczytuje z klawiatury, nawet jeśli standardowe dane wejściowe jest przekierowywany do pliku z <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Jedną z najbardziej typowych zastosowań <xref:System.Console.ReadKey> metoda jest zatrzymanie wykonania programu, dopiero po naciśnięciu klawisza i kończy lub wyświetla dodatkowe okna informacji o aplikacji. W poniższym przykładzie użyto <xref:System.Console.ReadKey> metodę, aby czekać, aż użytkownik o naciśnięcie klawisza Enter przed zakończeniem aplikacji.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Należy pamiętać, że to przeciążenia z <xref:System.Console.ReadKey%2A> metody domyślnie echa dowolnych wyświetlanej kluczy, które użytkownik naciśnie do konsoli. Aby je wyłączyć, należy wywołać <xref:System.Console.ReadKey%2A> metody z `intercept` argument `true`.  
  
 W poniższym przykładzie użyto <xref:System.Console.ReadKey> metodę, aby wyświetlić informacje o klucz, do którego użytkownik nacisnął klawisz...  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Console.In" /> Właściwości jest przekierowywany niektórych strumienia niż konsoli.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Określa, czy mają być wyświetlane naciśnięty klawisz w oknie konsoli. <see langword="true" /> Aby nie wyświetlać naciśnięty klawisz; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika. Naciśnięty klawisz opcjonalnie jest wyświetlany w oknie konsoli.</summary>
        <returns>Obiekt, który opisuje <see cref="T:System.ConsoleKey" /> stała i znak Unicode, który odpowiada klucz naciśniętego konsoli. <see cref="T:System.ConsoleKeyInfo" /> Również opis obiektu, z bitowego połączenia <see cref="T:System.ConsoleModifiers" /> wartości, czy co najmniej jeden Shift, Alt i Ctrl klawisze modyfikujące naciśnięto jednocześnie z kluczem konsoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> — Metoda czeka, oznacza to, bloków na urzędzie wystawiającym certyfikaty wątku <xref:System.Console.ReadKey%2A> metody, dopóki nie zostanie naciśnięty klawisz znak lub funkcji. W połączeniu z co najmniej jeden Alt, Ctrl lub Shift klawisze modyfikujące można można naciśnięty klawisz znak lub funkcji. Jednakże, naciskając klawisz modyfikujący samodzielnie nie spowoduje <xref:System.Console.ReadKey%2A> metody do zwrócenia.  
  
 Jeśli `intercept` parametr jest `true`, naciśnięty klawisz zostaje zatrzymana i nie wyświetlany w oknie konsoli; w przeciwnym razie naciśnięty klawisz jest wyświetlany.  
  
 W zależności od aplikacji, możesz chcieć użyć <xref:System.Console.ReadKey%2A> w połączeniu z metody <xref:System.Console.KeyAvailable%2A> właściwości.  
  
 <xref:System.Console.ReadKey%2A> Metoda odczytuje z klawiatury, nawet jeśli standardowe dane wejściowe jest przekierowywany do pliku z <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Jedną z najbardziej typowych zastosowań <xref:System.Console.ReadKey%2A> metoda jest zatrzymanie wykonania programu, dopiero po naciśnięciu klawisza i kończy lub wyświetla dodatkowe okna informacji o aplikacji. W poniższym przykładzie użyto <xref:System.Console.ReadKey%28System.Boolean%29> metodę, aby czekać, aż użytkownik o naciśnięcie klawisza Enter przed zakończeniem aplikacji. Należy pamiętać, że gdy użytkownik naciśnie innego klucza, jego jest nie powtarzana konsoli.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 W poniższym przykładzie użyto <xref:System.Console.ReadKey%28System.Boolean%29> metodę w celu wyświetlenia informacji o kluczu naciśnięty przez użytkownika bez wyświetlania tego klucza do konsoli.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Console.In" /> Właściwości jest przekierowywany niektórych strumienia niż konsoli.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny wiersz znaków z Standardowy strumień wejściowy.</summary>
        <returns>Następnego wiersza znaków ze strumienia wejściowego lub <see langword="null" /> Jeśli dostępnych jest więcej wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadLine%2A> Metoda odczytuje wiersz z Standardowy strumień wejściowy. (Dla definicji wiersza, zobacz akapitu po poniżej). Oznacza to, że:  
  
-   Jeśli standardowa urządzenia wejściowego jest klawiatury, <xref:System.Console.ReadLine%2A> bloki metody, dopóki użytkownik naciśnie **Enter** klucza.  
  
     Jedną z najbardziej typowych zastosowań <xref:System.Console.ReadLine%2A> metodą jest wstrzymuje wykonywanie programu przed wyczyszczenie konsoli i wyświetlanie nowych informacji do niego lub monitowanie użytkownika o naciśnięcie klawisza Enter przed zakończeniem aplikacji. Ilustruje to poniższy przykład.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Jeśli standardowe dane wejściowe jest przekierowywany do pliku, <xref:System.Console.ReadLine%2A> metoda odczytuje wiersz tekstu z pliku. Na przykład następujące jest plik tekstowy o nazwie ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     W poniższym przykładzie użyto <xref:System.Console.ReadLine%2A> metodę, aby odczytać dane wejściowe z pliku. Operacja odczytu kończy działanie, gdy metoda zwraca `null`, co oznacza pozostawienie żadnych wierszy do odczytania.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Po kompilowanie przykładu do pliku wykonywalnego o nazwie ReadLine1.exe, można go uruchomić z wiersza polecenia przy użyciu składni  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     zawartość pliku do odczytu i wyświetlić je w konsoli.  
  
 Wiersz jest zdefiniowany jako sekwencja znaków powrotu karetki (0x000d szesnastkowe), wysuwu wiersza (0x000a szesnastkowym) lub wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości. Zwracany ciąg nie zawiera znaków zakończenia. Domyślnie metoda odczytuje dane wejściowe z buforu wejściowego 256 znaków. Ponieważ w tym <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> znaki, metoda może być odczytany wiersze zawierające do 254 znaków. Aby przeczytać więcej wierszy, należy wywołać <xref:System.Console.OpenStandardInput%28System.Int32%29> metody.  
  
 <xref:System.Console.ReadLine%2A> Metoda jest wykonywana synchronicznie. Oznacza to blokuje aż do wiersza jest do odczytu lub naciśnięciu kombinację klawiszy Ctrl + Z. <xref:System.Console.In%2A> Zwraca <xref:System.IO.TextReader> obiekt reprezentujący Standardowy strumień wejściowy i ma zarówno synchronicznego <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> — metoda i asynchroniczne <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> metody. Jednakże, gdy jest używany jako Standardowy strumień wejściowy konsoli, <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> wykonuje synchronicznie, a nie asynchronicznie i zwraca `Task<String>` dopiero po zakończeniu operacji odczytu.  
  
 Jeśli ta metoda zgłasza <xref:System.OutOfMemoryException> wyjątek, pozycja czytelnika w odpowiadającego <xref:System.IO.Stream> obiektu jest zaawansowane według liczby znaków metody był w stanie odczytywać, ale znaki odczytane już do wewnętrznej <xref:System.Console.ReadLine%2A> są buforu odrzucone. Ponieważ nie można zmienić położenia czytnika w strumieniu, znaki odczytane już jest nieodwracalny i jest możliwy tylko za pomocą ponownego inicjowania <xref:System.IO.TextReader>. Jeśli początkowe położenie w obrębie strumień jest nieznany lub strumień nie obsługuje wyszukiwania, odpowiadającego <xref:System.IO.Stream> musi również zostać zainicjowane ponownie. Aby uniknąć tej sytuacji i utworzyć niezawodny kod, należy używać <xref:System.Console.KeyAvailable%2A> właściwości i <xref:System.Console.ReadKey%2A> — metoda i magazynu znaków wstępnie przydzielić buforu odczytu.  
  
 Jeśli znak Ctrl + Z zostanie naciśnięty, gdy metoda to dane wejściowe odczytu z konsoli, metoda zwraca `null`. Umożliwia to aby uniemożliwić dalsze klawiatury danych wprowadzonych przez użytkownika podczas <xref:System.Console.ReadLine%2A> metoda jest wywoływana w pętli. Poniższy przykład przedstawia, w tym scenariuszu.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład wymaga dwóch argumentów wiersza polecenia: nazwa istniejącego pliku tekstowego, a nazwa pliku wyjściowego do zapisu. Otwiera istniejący plik i przekierowuje standardowe dane wejściowe z klawiatury do tego pliku. Przekierowuje standardowe dane wyjściowe z konsoli do pliku wyjściowego. Następnie używa <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> metody do odczytu każdego wiersza w pliku, zastępuje co sekwencji czterech spacji znak tabulacji i używa <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metodę, aby zapisać wyniki do pliku wyjściowego.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków w następnym wierszu znaków jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pierwszego planu i tła konsoli kolory domyślne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolory pierwszego planu i tła zostaną przywrócone do kolorów, które były dostępne w momencie rozpoczęcia bieżącego procesu. Aby uzyskać więcej informacji, zobacz <xref:System.Console.ForegroundColor%2A> i <xref:System.Console.BackgroundColor%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład jest zapisywany wartości <xref:System.ConsoleColor> wyliczenie do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem na kolor wartości, które odpowiadają bieżącym tła, a następnie zmienia kolor tła do każdego koloru <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst nie jest widoczna). Na koniec wywołuje <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Szerokość obszaru buforu mierzony w kolumnach.</param>
        <param name="height">Wysokość obszaru buforu mierzona w wierszach.</param>
        <summary>Ustawia wysokość i szerokość obszaru buforu ekranu do określonych wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu na podstawie szerokości buforu ekranu. Następnie przykładzie przesuwa okno konsoli w odpowiedzi, do którego Strzałka w górę, naciśnięciu klawisza konsoli Strzałka w dół, strzałki w lewo lub Strzałka w prawo. Grid — wzorzec pomaga zobacz Przenoszenie okna konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="height" /> lub <paramref name="width" /> jest mniejsza niż lub równa zero.  - lub - <paramref name="height" /> lub <paramref name="width" /> jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - <paramref name="width" /> jest mniejsza niż <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.  - lub - <paramref name="height" /> jest mniejsza niż <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Pozycja kolumny kursora. Kolumny są ponumerowane od lewej do prawej, począwszy od 0.</param>
        <param name="top">Położenie wiersza kursora. Wiersze są ponumerowane od góry do dołu, począwszy od 0.</param>
        <summary>Ustawia położenie kursora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Console.SetCursorPosition%2A> metodę, aby określić, w którym ma rozpocząć następnej operacji zapisu w oknie konsoli. W przypadku pozycji kursora określony poza obszarem, który jest aktualnie widoczne w oknie konsoli, pochodzenia okno zmienia się automatycznie uwidocznić kursora.  
  
 Kursor automatycznie przenosi do następnego znaku na pozycji znaku zawsze są zapisywane w oknie konsoli. Jeśli kursor znajduje się na pozycji znak po prawej dolnej części okna konsoli, kolejnego zapisu powoduje, że operacja okna konsoli do przewijania, gdy kursor pozostaje widoczna. Jeśli chcesz zapisać znak na pozycji znaku prawy dolny bez spowodowania, że okno konsoli przewiń, należy użyć <xref:System.Console.MoveBufferArea%2A> metody, aby przenieść znak na tej pozycji.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości oraz <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. Przykład umieszcza kursor, który określa, gdzie zostanie przeprowadzona kolejnego zapisu, aby narysować 5 znaków przez 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", a "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> lub <paramref name="top" /> jest mniejsza od zera.  - lub - <paramref name="left" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  - lub - <paramref name="top" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Strumień, który jest nowe dane wyjściowe błędów.</param>
        <summary>Ustawia <see cref="P:System.Console.Error" /> właściwości do określonego <see cref="T:System.IO.TextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.Error%2A> właściwość jest ustawiona na błąd standardowy strumień wyjściowy.  
  
 A <xref:System.IO.StreamWriter> która hermetyzuje <xref:System.IO.FileStream> może służyć do wysyłania komunikatów o błędach do pliku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przekierowania Standardowy strumień błędów w pliku.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newError" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Strumień, który jest nowe standardowe dane wejściowe.</param>
        <summary>Ustawia <see cref="P:System.Console.In" /> właściwości do określonego <see cref="T:System.IO.TextReader" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.In%2A> właściwość jest ustawiona na Standardowy strumień wejściowy.  
  
 A <xref:System.IO.StreamReader> która hermetyzuje <xref:System.IO.FileStream> służy do odbierania danych z pliku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Console.SetIn%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby go uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newIn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Strumień, który jest nowy wyjścia standardowego.</param>
        <summary>Ustawia <see cref="P:System.Console.Out" /> właściwości do określonego <see cref="T:System.IO.TextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.Out%2A> właściwość jest ustawiona na Standardowy strumień wyjściowy.  
  
 A <xref:System.IO.StreamWriter> która hermetyzuje <xref:System.IO.FileStream> może służyć do wysyłania danych wyjściowych do pliku. Na przykład:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Console.SetOut%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby go uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newOut" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Pozycja kolumny lewym górnym rogu okna konsoli.</param>
        <param name="top">Położenie wiersza w lewym górnym rogu okna konsoli.</param>
        <summary>Ustawia położenie okna konsoli względem buforu ekranu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W oknie konsoli Wyświetla okna systemu operacyjnego oraz w oknie konsoli część buforu ekranu. <xref:System.Console.SetWindowPosition%2A> Metody wpływa na położenie okna konsoli względem buforu ekranu, ale nie ma wpływu na położenie okna systemu operacyjnego względem pulpitu.  
  
 Konsola i systemu operacyjnego windows zazwyczaj nie wpływają na siebie. Jednak jeśli nie można wyświetlić buforu ekranu w granicach bieżącego okna konsoli, systemu operacyjnego automatycznie dołącza paski przewijania okna systemu operacyjnego. W takim przypadku przenoszenie pasków przewijania okna systemu operacyjnego ma wpływ na położenie okna konsoli i przenoszenie okna konsoli z <xref:System.Console.SetWindowPosition%2A> metoda ma wpływ na położenie pasków przewijania okna systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu na podstawie szerokości buforu ekranu. Następnie przykładzie przesuwa okno konsoli w odpowiedzi, do którego Strzałka w górę, naciśnięciu klawisza konsoli Strzałka w dół, strzałki w lewo lub Strzałka w prawo. Grid — wzorzec pomaga zobacz Przenoszenie okna konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> lub <paramref name="top" /> jest mniejsza od zera.  - lub - <paramref name="left" />  +  <see cref="P:System.Console.WindowWidth" /> jest większa niż <see cref="P:System.Console.BufferWidth" />.  - lub - <paramref name="top" />  +  <see cref="P:System.Console.WindowHeight" /> jest większa niż <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Szerokość okna konsoli mierzona w kolumnach.</param>
        <param name="height">Wysokość okna konsoli mierzona w wierszach.</param>
        <summary>Ustawia określone wartości wysokość i szerokość okna konsoli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary okna konsoli równa 85 kolumnami i wierszami 43, a następnie czeka na klucz, aby zostać naciśnięte. Po naciśnięciu dowolny klawisz, wymiary okna konsoli są o połowę, nowe wymiary są raportowane i przykładzie oczekuje na inną naciśnięcie klawisza. Na koniec po naciśnięciu dowolnego klucza w oknie konsoli zostanie przywrócona do oryginalnego wymiary i kończy przykładzie.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="width" /> lub <paramref name="height" /> jest mniejsza niż lub równa zero.  - lub - <paramref name="width" /> plus <see cref="P:System.Console.WindowLeft" /> lub <paramref name="height" /> plus <see cref="P:System.Console.WindowTop" /> jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - <paramref name="width" /> lub <paramref name="height" /> jest większa niż największa szerokość okna możliwe lub wysokości dla bieżącej czcionki konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł, aby wyświetlić na pasku tytułu konsoli.</summary>
        <value>Ciąg, który ma być wyświetlany w pasku tytułu konsoli. Maksymalna długość ciągu tytuł jest 24500 znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.Title%2A> właściwości. Przykład wyświetla bieżący tytuł okna systemu operacyjnego, czeka na naciśnięcie klawisza, a następnie wyświetla nowy tytuł.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">W ramach operacji get pobrane tytuł jest dłuższa niż 24500 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">W ramach operacji set podany tytuł jest dłuższa niż 24500 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">W ramach operacji set podany tytuł jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy kombinacja <see cref="F:System.ConsoleModifiers.Control" /> klawisz modyfikujący i <see cref="F:System.ConsoleKey.C" /> klucza konsoli (Ctrl + C) jest traktowane jako dane wejściowe zwykłej lub przerwania, który jest obsługiwany przez system operacyjny.</summary>
        <value>
          <see langword="true" /> Jeśli klawisze Ctrl + C jest traktowany jako dane wejściowe zwykłej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Console.TreatControlCAsInput%2A> właściwość jest `false` i naciśnięciu klawiszy Ctrl + C, naciśniętego klucze nie są przechowywane w buforze wejściowym i systemu operacyjnego kończy proces aktualnie wykonywane. Jest to wartość domyślna.  
  
> [!CAUTION]
>  Należy rozważnie używać tej właściwości, ponieważ ustawieniem dla niego `true` ma taki efekt. Większość użytkowników oczekiwać klawisze Ctrl + C, aby zakończyć aplikację konsoli. Jeśli wyłączysz efekt klawisze Ctrl + C, użytkownik musi Pamiętaj, aby umożliwia zakończenie aplikacji, które są mniej znanych kombinację klawiszy Ctrl + Break.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.TreatControlCAsInput%2A> właściwości.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można pobrać lub ustawić tryb wprowadzania konsoli buforu wejściowego.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość obszaru okna konsoli.</summary>
        <value>Wysokość okna konsoli mierzona w wierszach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podjęto próbę ustawienia wartości <xref:System.Console.WindowHeight%2A> właściwości po danych wyjściowych zgłasza albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tylko wtedy, gdy właściwość <xref:System.Console.IsOutputRedirected%2A> zwraca właściwość `false`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary równa 85 kolumnami i wierszami 43 okna konsoli, a następnie czeka na naciśnięcie klawisza. Po naciśnięciu dowolny klawisz, wymiary okna konsoli są o połowę, nowe wymiary są raportowane i przykładzie oczekuje na inną naciśnięcie klawisza. Na koniec po naciśnięciu klawisza wszystkie okna konsoli zostanie przywrócona do oryginalnego wymiary i kończy przykładzie.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <see cref="P:System.Console.WindowWidth" /> właściwości lub wartości <see cref="P:System.Console.WindowHeight" /> właściwość jest mniejsza niż lub równa 0.  - lub - wartość <see cref="P:System.Console.WindowHeight" /> właściwości oraz wartość <see cref="P:System.Console.WindowTop" /> właściwość jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - wartość <see cref="P:System.Console.WindowWidth" /> właściwości lub wartości <see cref="P:System.Console.WindowHeight" /> właściwości jest większa niż największa szerokość okna możliwe lub wysokości dla bieżącej czcionki konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie lewej strony obszaru okna konsoli względem buforu ekranu.</summary>
        <value>Pozycja okna konsoli po lewej stronie mierzony w kolumnach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę reprezentuje prostokątne okna na większy bufor prostokątny obszar. Oknie oraz w buforze są mierzone w pionie według ich liczby wierszy i w poziomie przez ich liczbę kolumn. Wymiary obszar buforu są definiowane przez <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Wymiary obszaru konsoli są definiowane przez <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości. <xref:System.Console.WindowLeft%2A> Właściwość określa, która kolumna obszaru bufor jest wyświetlany w pierwszej kolumnie okna konsoli. Wartość <xref:System.Console.WindowLeft%2A> właściwości mogą należeć do zakresu od 0 do <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Próba ustawioną wartość poza tym, że zakres zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Gdy konsola najpierw zostanie otwarte okno, domyślna wartość <xref:System.Console.WindowLeft%2A> właściwości jest równa zero, co oznacza, że odpowiada pierwszej kolumny (kolumna w pozycji zero) w obszarze buforu pierwszej kolumny wyświetlane w konsoli. Domyślna szerokość okna konsoli i obszar buforu to 80 kolumn. Oznacza to, że <xref:System.Console.WindowLeft%2A> właściwości można modyfikować tylko wtedy, gdy okno konsoli staje się mniejszą niż lub obszar buforu staje się szersze.  
  
 Należy pamiętać, że jeśli szerokość obszaru buforu przekracza szerokość okna konsoli wartość <xref:System.Console.WindowLeft%2A> właściwość jest automatycznie dostosowywany, gdy użytkownik używa poziomy pasek przewijania w celu zdefiniowania relacji okna do obszaru buforu.  
  
 Podjęto próbę ustawienia wartości <xref:System.Console.WindowLeft%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tylko wtedy, gdy właściwość <xref:System.Console.IsOutputRedirected%2A> zwraca właściwość `false`.  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie okna konsoli kolumny 80 i definiuje obszar buforu, który jest 120 kolumn. Wyświetla informacje dla rozmiaru okna i buforu, a następnie czeka na użytkownika o naciśnięcie klawisza Strzałka w lewo lub Strzałka w prawo. W pierwszym przypadku go zmniejsza wartość <xref:System.Console.WindowLeft%2A> właściwości przez jeden wynik jest dozwoloną wartością. W drugim przypadku zwiększa wartość <xref:System.Console.WindowLeft%2A> właściwości przez jeden z wynikiem byłby prawnych. Należy pamiętać, że nie ma przykład do obsługi <xref:System.ArgumentOutOfRangeException>, ponieważ sprawdza, czy wartość do przypisania do <xref:System.Console.WindowLeft%2A> właściwość nie jest ujemny i nie powoduje, że suma <xref:System.Console.WindowLeft%2A> i <xref:System.Console.WindowWidth%2A> właściwości przekroczenie <xref:System.Console.BufferWidth%2A> wartość właściwości.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">W ramach operacji set przypisywanie wartości jest mniejsza od zera.  - lub - wyniku przypisania <see cref="P:System.Console.WindowLeft" /> plus <see cref="P:System.Console.WindowWidth" /> przekroczyłby <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie górny obszar okna konsoli względem buforu ekranu.</summary>
        <value>Pozycja okna konsoli najwyższym mierzony w wierszach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę reprezentuje prostokątne okna na większy bufor prostokątny obszar. Oknie oraz w buforze są mierzone w pionie według ich liczby wierszy i w poziomie przez ich liczbę kolumn. Wymiary obszar buforu są definiowane przez <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Wymiary obszaru konsoli są definiowane przez <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości. <xref:System.Console.WindowTop%2A> Właściwość określa, który wiersz obszaru bufor jest wyświetlany w pierwszej kolumnie okna konsoli. Wartość <xref:System.Console.WindowTop%2A> właściwości mogą należeć do zakresu od 0 do <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Próba ustawioną wartość poza tym, że zakres zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Podjęto próbę ustawienia wartości <xref:System.Console.WindowTop%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tylko wtedy, gdy właściwość <xref:System.Console.IsOutputRedirected%2A> zwraca właściwość `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu na podstawie szerokości buforu ekranu. Następnie przykładzie przesuwa okno konsoli w odpowiedzi, do którego Strzałka w górę, naciśnięciu klawisza konsoli Strzałka w dół, strzałki w lewo lub Strzałka w prawo. Grid — wzorzec pomaga zobacz Przenoszenie okna konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">W ramach operacji set przypisywanie wartości jest mniejsza od zera.  - lub - wyniku przypisania <see cref="P:System.Console.WindowTop" /> plus <see cref="P:System.Console.WindowHeight" /> przekroczyłby <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość okna konsoli.</summary>
        <value>Szerokość okna konsoli mierzona w kolumnach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podjęto próbę ustawienia wartości <xref:System.Console.WindowWidth%2A> właściwości po danych wyjściowych zgłasza albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tylko wtedy, gdy właściwość <xref:System.Console.IsOutputRedirected%2A> zwraca właściwość `false`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary równa 85 kolumnami i wierszami 43 okna konsoli, a następnie czeka na naciśnięcie klawisza. Po naciśnięciu dowolny klawisz, wymiary okna konsoli są o połowę, nowe wymiary są raportowane i przykładzie oczekuje na inną naciśnięcie klawisza. Na koniec po naciśnięciu klawisza wszystkie okna konsoli zostanie przywrócona do oryginalnego wymiary i kończy przykładzie.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <see cref="P:System.Console.WindowWidth" /> właściwości lub wartości <see cref="P:System.Console.WindowHeight" /> właściwość jest mniejsza niż lub równa 0.  - lub - wartość <see cref="P:System.Console.WindowHeight" /> właściwości oraz wartość <see cref="P:System.Console.WindowTop" /> właściwość jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  - lub - wartość <see cref="P:System.Console.WindowWidth" /> właściwości lub wartości <see cref="P:System.Console.WindowHeight" /> właściwości jest większa niż największa szerokość okna możliwe lub wysokości dla bieżącej czcionki konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje tekst reprezentację określonej wartości lub wartości do standardowego strumienia wyjściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje Reprezentacja tekstowa typu wartość logiczna określony w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, który generuje albo <xref:System.Boolean.TrueString?displayProperty=nameWithType> lub <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość znaku Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <summary>Zapisuje określonej tablicy znaków Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację określonego <see cref="T:System.Decimal" /> wartość do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje Reprezentacja tekstowa określonej wartości zmiennoprzecinkowej podwójnej precyzji w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Double.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej 32-bitowej liczby całkowitej ze znakiem w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej 64-bitowej liczby całkowitej ze znakiem w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Int64.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisania, lub <see langword="null" />.</param>
        <summary>Zapisuje tekst reprezentację określonego obiektu w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, nic nie zostanie zapisany i nie jest wyjątek. W przeciwnym razie `ToString` metoda `value` jest wywoływana w celu utworzenia reprezentacji ciągu wynikowy ciąg jest zapisywane do standardowego strumienia wyjściowego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację określonej wartości zmiennoprzecinkowych pojedynczej precyzji w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość ciągu do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest `null`, nic nie są zapisywane do standardowego strumienia wyjściowego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej liczby całkowitej bez znaku 32-bitowej do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej liczby całkowitej bez znaku 64-bitowe w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonego obiektu w standardowym strumieniu wyjściowym korzystając z informacji zawartych w określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody, aby zademonstrować standard formatowania specyfikatory liczb, dat i wyliczenia.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład przedstawia użycie <xref:System.Console.Write%2A> metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg">Tablica obiektów przy użyciu <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonej tablicy obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `arg` Parametr jest tablicą parametrów. Argumenty mogą zostać przekazane do metody jako tablicy lub listy pięć lub więcej elementów. Przykłady przedstawiają obu metod wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy o liczbie właściwości, które dostarczają informacji na temat osoby. Jego `GetDescription` metoda zwraca tablicę, która zawiera wszystkie wartości właściwości z wyjątkiem jednego. W przykładzie użyto następnie tablica zwrócona przez `GetDescription` metodę w celu wyświetlenia wartości obiektu osoby.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Należy pamiętać, że w przykładzie <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> metody zamiast <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> — metoda ponieważ próbuje on wyświetlić wartość `Person.Remarks` właściwości w tym samym wierszu. Aby to zrobić, sprawdza, czy wartość <xref:System.Console.CursorLeft%2A> i <xref:System.Console.WindowWidth%2A> właściwości, aby określić, czy jest wystarczająco dużo miejsca na uwagi do dopasowania.  Jeśli, wyświetla wiersz. W przeciwnym razie go zapisuje linii, wcięcia trzy spacje i wyświetla uwagi.  
  
 Poniższy przykład jest taka sama jak pierwsza strona, z wyjątkiem tego, że podaje listę pięciu elementu jako `arg` argument zamiast tablicy parametrów.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="arg" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Ta metoda nie jest wywoływany przez kod w języku C++. Kompilator języka C++ rozpoznaje wywołania [System.Console.Write](xref:System.Console.Write*) zawierające ciąg oraz listę cztery lub więcej parametrów obiektu wywołania <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Umożliwia rozwiązanie wywołania [System.Console.Write](xref:System.Console.Write*) zawierające ciąg i Tablica obiektów wywołania <see cref="M:System.Console.Write(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <param name="index">Położenie początkowe w <c>buforu</c>.</param>
        <param name="count">Liczba znaków, jaka ma zostać zapisana.</param>
        <summary>Zapisuje określony subarray znaków Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje `count` znaków, zaczynając od pozycji `index` z `buffer` do standardowego strumienia wyjściowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> plus <paramref name="count" /> określić, która nie jest w stanie <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody, aby zademonstrować standard formatowania specyfikatory liczb, dat i wyliczenia.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <param name="arg2">Trzeci obiektu do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody, aby zademonstrować standard formatowania specyfikatory liczb, dat i wyliczenia.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład przedstawia użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <param name="arg2">Trzeci obiektu do zapisania za pomocą <c>format</c>.</param>
        <param name="arg3">Czwarty obiektu do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów i lista parametrów zmiennej długości do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywnym, zgodnym ze specyfikacją CLS jest <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory języka C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie zmiennych parametrów z <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody. Metoda jest wywoływana z ciągu formatu złożone i pięć elementów formatu.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Ta metoda jest oznaczona atrybutem <see langword="vararg" /> — słowo kluczowe, które oznacza, że obsługuje ona zmienną liczbą parametrów. Metoda może zostać wywołana z języka Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory języka C# i Visual Basic rozwiązać wywołania <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> jako wywołań <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określone dane, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślna to ciąg, którego wartość jest znak powrotu karetki następuje znak wysuwu wiersza ("\r\n" w języku C# lub `vbCrLf` w języku Visual Basic). Terminator wiersza można zmienić, określając <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> właściwości do innego ciągu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje bieżący terminator wiersza w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślna to ciąg, którego wartość jest znak powrotu karetki następuje znak wysuwu wiersza ("\r\n" w języku C# lub `vbCrLf` w języku Visual Basic). Terminator wiersza można zmienić, określając <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> właściwości do innego ciągu. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Przykład umożliwia zmianę terminator wiersza z jego wartość domyślna "\r\n" lub `vbCrLf` do "\r\n\r\n" lub `vbCrLf`  +  `vbCrLf`. Następnie wywołuje <xref:System.Console.WriteLine> i <xref:System.Console.WriteLine%28System.String%29> metody, aby wyświetlić dane wyjściowe do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekst określona wartość logiczna, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 W poniższym przykładzie generuje dziesięć losowych liczb całkowitych i używa <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> metody, aby wskazać, czy są one jeszcze.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określony znak Unicode, następuje terminator wiersza bieżąca wartość do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <summary>Zapisuje określonej tablicy znaków Unicode, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację określonego <see cref="T:System.Decimal" /> wartość następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekst podwójnej precyzji zmiennoprzecinkowe określona, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Double.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej 32-bitowej liczby całkowitej ze znakiem, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej 64-bitowej liczby całkowitej ze znakiem, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Int64.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację określonego obiektu następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, są zapisywane tylko terminator wiersza. W przeciwnym razie `ToString` metoda `value` jest wywoływana w celu utworzenia reprezentacji ciągu wynikowy ciąg jest zapisywane do standardowego strumienia wyjściowego.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.WriteLine%28System.Object%29> metodę w celu wyświetlenia każdej wartości w tablicy obiektów do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekst pojedynczej precyzji zmiennoprzecinkowe określona, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość ciągu, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest `null`, terminator wiersza są zapisywane do standardowego strumienia wyjściowego.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine> metody.  
  
   
  
## Examples  
 Przykład umożliwia zmianę terminator wiersza z jego wartość domyślna "\r\n" lub `vbCrLf` do "\r\n\r\n" lub `vbCrLf`  +  `vbCrLf`. Następnie wywołuje <xref:System.Console.WriteLine> i <xref:System.Console.WriteLine%28System.String%29> metody, aby wyświetlić dane wyjściowe do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej liczby całkowitej bez znaku 32-bitowy, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje tekst reprezentację wartości określonej liczby całkowitej bez znaku 64-bitowych, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa typu `value` jest generowany przez wywołanie metody <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonego obiektu następuje terminator bieżący wiersz do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> metodę, aby wyświetlić pięć losowo generowany <xref:System.Boolean> wartości.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 Następujące przykładowe wywołania <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> metodę, aby wyświetlić bieżącą datę.   Należy pamiętać, że format elementu `format` argumentu "D" [standardowa Data i godzina ciąg formatu](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Aby wyświetlić datę w formacie daty długiej bieżącej kultury.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg">Tablica obiektów przy użyciu <c>format</c>.</param>
        <summary>Zapisuje reprezentację tekstu w określonej tablicy obiektów następują terminator bieżący wiersz do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="arg" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Ta metoda nie jest wywoływany przez kod w języku C++. Kompilator języka C++ rozpoznaje wywołania [System.Console.WriteLine](xref:System.Console.WriteLine*) zawierające ciąg oraz listę cztery lub więcej parametrów obiektu wywołania <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Umożliwia rozwiązanie wywołania [System.Console.WriteLine](xref:System.Console.WriteLine*) zawierające ciąg i Tablica obiektów wywołania <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <param name="index">Położenie początkowe w <c>buforu</c>.</param>
        <param name="count">Liczba znaków, jaka ma zostać zapisana.</param>
        <summary>Zapisuje określony subarray znaków Unicode, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje `count` znaków, zaczynając od pozycji `index` z `buffer` do standardowego strumienia wyjściowego.  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> plus <paramref name="count" /> określić, która nie jest w stanie <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów następują terminator bieżący wiersz do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <param name="arg2">Trzeci obiektu do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów następują terminator bieżący wiersz do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład jest Kalkulator Porada oblicza Porada 18% i używa <xref:System.Console.WriteLine%2A> metodę, aby wyświetlić oryginalne opłaty, ilość porady i sumy. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <c>format</c>.</param>
        <param name="arg1">Drugi obiekt do zapisu przy użyciu <c>format</c>.</param>
        <param name="arg2">Trzeci obiektu do zapisania za pomocą <c>format</c>.</param>
        <param name="arg3">Czwarty obiektu do zapisania za pomocą <c>format</c>.</param>
        <summary>Zapisuje tekst reprezentację określonych obiektów i lista parametrów zmiennej długości, następuje terminator bieżący wiersz do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywnym, zgodnym ze specyfikacją CLS jest <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory języka C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektu z listy wartości parametru tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, który określa obowiązkowe indeks, długość opcjonalne i wyrównanie tekstu sformatowanego oraz opcjonalny ciąg znaki specyfikatora formatu, które kontrolują sposób formatowania wartości odpowiedni obiekt.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji o złożonych funkcji formatowania obsługiwane przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>i niektóre przeciążeń <xref:System.Console.WriteLine%2A>, zobacz [złożone formatowanie](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o datę i godzinę specyfikatorów formatu, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatory formatu wyliczenie zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminator wiersza, zobacz sekcję uwag <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie zmiennych argumentów, które mają <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody. Metoda jest wywoływana z ciągu formatu złożone i pięć elementów formatu.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">W specyfikacji formatu <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Ta metoda jest oznaczona atrybutem <see langword="vararg" /> — słowo kluczowe, które oznacza, że obsługuje ona zmienną liczbą parametrów. Metoda może zostać wywołana z języka Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory języka C# i Visual Basic rozwiązać wywołania <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> jako wywołań <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Console" FullName="System.Console">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1e0cfe8c8256881b084e78ae928c00c2f577f253" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56376098" /></Metadata><TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje standardowych strumieni danych wejściowych, wyjściowych i błędów dla aplikacji konsoli. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsola jest okna systemu operacyjnego, w którym użytkownicy wchodzą w interakcję z systemu operacyjnego lub aplikacji konsolowej oparte na tekście, wprowadzając wprowadzanie tekstu przy użyciu klawiatury komputera, a, zapoznając się z poziomu terminalu komputera tekst wyjściowy. Na przykład w systemie operacyjnym Windows, konsoli jest wywoływana w oknie wiersza polecenia i akceptuje poleceń systemu MS-DOS. <xref:System.Console> Klasa udostępnia podstawowej pomocy technicznej dla aplikacji, które odczytywanie znaków z oraz zapisywanie znaków do konsoli.  
  
 Aby uzyskać informacje dotyczące programowania za pomocą <xref:System.Console> klasy, zobacz następujące sekcje:  
  
-   [Strumienie wejścia/wyjścia konsoli](#Streams)  
  
-   [Bufor ekranu i okno konsoli](#Buffer)  
  
-   [Obsługa formatu Unicode dla konsoli](#Unicode)  
  
-   [Typowe operacje](#Operations)  
  
-   [Informacje o .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Strumienie wejścia/wyjścia konsoli  
 Po uruchomieniu aplikacji konsoli systemu operacyjnego automatycznie kojarzy trzy strumieniach we/wy za pomocą konsoli: standardowe dane wejściowe strumienia, Standardowy strumień wyjściowy i błąd standardowy strumień wyjściowy. Twoja aplikacja może odczytywać dane wejściowe użytkownika ze standardowego strumienia wejściowego; normalne zapisane w standardowym strumieniu wyjściowym; i zapisu danych o błędach do błędu standardowego strumienia wyjściowego. Te strumienie są prezentowane do aplikacji jako wartości <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, i <xref:System.Console.Error%2A?displayProperty=nameWithType> właściwości.  
  
 Domyślnie wartość <xref:System.Console.In%2A> właściwość <xref:System.IO.TextReader?displayProperty=nameWithType> obiekt, który reprezentuje klawiatury i wartości <xref:System.Console.Out%2A> i <xref:System.Console.Error%2A> właściwości są <xref:System.IO.TextWriter?displayProperty=nameWithType> obiekty reprezentujące okna konsoli. Jednak te właściwości można ustawić do strumieni, które reprezentuje okno konsoli lub klawiatury; na przykład można ustawić te właściwości do strumieni, które reprezentują pliki. Aby przekierować standardowe dane wejściowe, standardowe dane wyjściowe lub Standardowy strumień błędów, należy wywołać <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, lub <xref:System.Console.SetError%2A?displayProperty=nameWithType> metody, odpowiednio. Operacje We/Wy, które używają tych strumieni są zsynchronizowane, co oznacza, że wiele wątków może odczytywać lub zapisu do strumieni. Oznacza to, że metody, które są zazwyczaj asynchronicznych, takich jak <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, uruchamiane synchronicznie, jeśli obiekt reprezentuje strumień konsoli.  
  
> [!NOTE]
>  Nie używaj <xref:System.Console> klasy, aby wyświetlić dane wyjściowe w instalacji nienadzorowanej aplikacji, takich jak aplikacje serwera. Wywołania do metod, takich jak <xref:System.Console.Write%2A?displayProperty=nameWithType> i <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> nie mają wpływu na aplikacje graficznego interfejsu użytkownika.  
  
 <xref:System.Console> elementy członkowskie klasy, które działa normalnie, gdy zasadniczy strumień zostanie skierowany do konsoli może zgłosić wyjątek, jeśli strumień jest przekierowywany na przykład do pliku. Programowanie aplikacji w celu przechwytywania <xref:System.IO.IOException?displayProperty=nameWithType> wyjątki, jeśli zostanie przekierowany Standardowy strumień. Można również użyć <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, i <xref:System.Console.IsErrorRedirected%2A> właściwości w celu określenia, czy Standardowy strumień jest przekierowywany przed przystąpieniem do wykonywania operacji, która zgłasza <xref:System.IO.IOException?displayProperty=nameWithType> wyjątku.  
  
 Czasami jest to przydatne jawnie wywołać składowe klasy obiektów strumienia reprezentowanego przez <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, i <xref:System.Console.Error%2A> właściwości. Na przykład domyślnie <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> metoda odczytuje dane wejściowe ze standardowego strumienia wejściowego. Podobnie <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda zapisuje dane do strumienia wyjścia standardowego i danych następuje domyślny ciąg zakończenia wiersza, czyli znak powrotu karetki i wysuwu wiersza ("\r\n"). Jednak <xref:System.Console> klasa nie zapewnia odpowiedniej metody w celu zapisania danych do błędu standardowego strumienia wyjściowego lub właściwości, aby zmienić parametry zakończenia wiersza danych w tym strumieniu.  
  
 Ten problem można rozwiązać przez ustawienie <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> lub <xref:System.Console.Error%2A> właściwości do innego ciągu zakończenia wiersza. Na przykład następująca instrukcja języka C# ustawia ciąg znaków zakończenia wiersza dla błędu standardowego strumienia wyjściowego na dwóch znaku powrotu karetki i LF sekwencji:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Następnie możesz jawnie wywołać <xref:System.IO.TextWriter.WriteLine%2A> metoda obiekt strumienia wyjściowego. błąd, tak jak następująca instrukcja języka C#:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Bufor ekranu i okno konsoli  
 Dwie funkcje ściśle powiązanych konsoli są buforu ekranu i okno konsoli. Tekst jest faktycznie zapisu lub odczytu z do strumieni posiadane przez konsolę, ale wydaje się być odczytywany lub zapisywane w obszarze należące do konsoli o nazwie buforu ekranu. Buforu ekranu jest atrybutem konsoli i jest uporządkowany w postaci prostokątny siatka wierszy i kolumn, gdzie każdy przecięcia siatki lub komórki znaków może zawierać znaku. Każdy znak ma swój własny kolor pierwszego planu, a każda komórka znak ma swój własny kolor tła.  
  
 Bufor ekranu jest wyświetlane za pomocą prostokątny obszar, który wywołuje się, w oknie konsoli. W oknie konsoli jest inny atrybut konsoli; nie ma konsoli, czyli okna systemu operacyjnego. W oknie konsoli są rozmieszczone w wiersze i kolumny, jest mniejsza niż lub równy rozmiarowi buforu ekranu i mogą zostać przeniesione do wyświetlenia różnych obszarów podstawowego buforu ekranu. Jeśli buforu ekranu jest większy niż w oknie konsoli, konsoli automatycznie wyświetla pasków przewijania, dlatego w oknie konsoli może być przeniesiony za pośrednictwem obszaru buforu ekranu.  
  
 Kursor wskazuje pozycję bufora ekranu, jeżeli tekst jest obecnie zapisu lub odczytu. Kursor może być ukryty lub widoczny i można zmienić wysokość. Jeśli kursor znajduje się widoczne, położenie okna konsoli jest przenoszony automatycznie, więc kursora jest zawsze w widoku.  
  
 Punkt początkowy dla współrzędnych komórki znaków w buforze ekranu jest lewym górnym rogu, a następnie pozycji kursora i w oknie konsoli są mierzone względem tego źródła. Użyj indeksy od zera, aby określić położenie; oznacza to należy określić wiersz najwyższego poziomu jako wiersz 0 i skrajnej lewej kolumnie jako kolumna 0. Maksymalna wartość dla indeksów wierszy i kolumn jest <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Obsługa standardu Unicode dla konsoli  
 Ogólnie rzecz biorąc konsoli odczytuje dane wejściowe i zapisuje dane wyjściowe przy użyciu bieżącej strony kodowej konsoli, która określa ustawienia regionalne systemu, domyślnie. Strona kodowa może obsługiwać tylko podzbiór dostępnych znaków Unicode, więc Jeśli spróbujesz znaki wyświetlania, które nie są zamapowane przy określonej strony kodowej konsoli będą mogli wyświetlić wszystkie znaki lub ich reprezentacji dokładnie. Poniższy przykład ilustruje ten problem. Próbuje wyświetlić znaków cyrylicy od U + 0410 do U + 044F do konsoli. Po uruchomieniu przykładu w systemie, który używa konsoli strony kodowej 437 każdy znak jest zastępowany przez znak zapytania (?), ponieważ znaków cyrylicy nie są mapowane do znaków w stronie kodowej 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Oprócz obsługi stron kodowych <xref:System.Console> klasa obsługuje kodowanie przy użyciu UTF-8 <xref:System.Text.UTF8Encoding> klasy. Począwszy od programu .NET Framework 4.5 <xref:System.Console> klasy obsługuje również UTF-16 kodowania z <xref:System.Text.UnicodeEncoding> klasy. Aby wyświetlić znaki Unicode w konsoli. Możesz ustawić <xref:System.Console.OutputEncoding%2A> właściwości albo <xref:System.Text.UTF8Encoding> lub <xref:System.Text.UnicodeEncoding>.  
  
 Obsługa znaków Unicode wymaga kodera, rozpoznawał określony znak Unicode, a także wymaga czcionkę, która zawiera symbole wymagane do renderowania tego znaku. Aby pomyślnie wyświetlić znaki Unicode w konsoli, czcionki konsoli musi być równa bez rastrowych lub czcionki TrueType, takie jak Consolas lub New konsoli. Poniższy przykład pokazuje, jak można programowo zmienić czcionkę z czcionki rastrowe New konsoli.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Jednak czcionki TrueType można wyświetlić tylko podzbiór symbole. Na przykład czcionki konsoli New wyświetla tylko 643 około 64 000 znaków dostępne od U + 0021 do U + FB02. Aby zobaczyć, w którym znaki wybranej czcionki obsługuje, otwórz **czcionki** apletu w Panelu sterowania wybierz **znaleźć znak** opcji, a następnie wybierz czcionkę zestawu znaków, którego chcesz zbadać  **Czcionka** listę **tablicy znaków** okna.  
  
 Windows używa łączenia czcionek, aby wyświetlić symbole, które nie są dostępne w określonej czcionki. Aby uzyskać informacji na temat łączenia czcionek, aby wyświetlić zestawy znaków dodatkowych, zobacz [globalizacji krok po kroku: Czcionki](https://go.microsoft.com/fwlink/?LinkId=229111). Połączone czcionki są definiowane w podklucz rejestru HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink. Każdy wpis skojarzone z tego podklucza odpowiada nazwa czcionki podstawowej i jej wartość jest tablicą ciągów, który definiuje pliki czcionek i czcionek, które są połączone z czcionki podstawowej. Każdy element członkowski tablicy definiuje połączone czcionki i ma postać *nazwy pliku czcionki*,*nazwa czcionki*. W poniższym przykładzie pokazano, jak programowo można zdefiniować połączone czcionki o nazwie SimSun znaleziono plik czcionki o nazwie simsun.ttc wyświetlającą uproszczony Hanowi znaków.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Obsługa formatu Unicode dla konsoli ma następujące ograniczenia:  
  
-   Kodowanie UTF-32 nie jest obsługiwane. Obsługiwana jest tylko Unicode kodowania to UTF-8 i UTF-16, które są reprezentowane przez <xref:System.Text.UTF8Encoding> i <xref:System.Text.UnicodeEncoding> klasy, odpowiednio.  
  
-   Dane wyjściowe dwukierunkowe nie jest obsługiwane.  
  
-   Wyświetlanie znaków poza podstawowe płaszczyzny wielojęzyczny (oznacza to, z pary zastępcze) nie jest obsługiwane, nawet jeśli są zdefiniowane w pliku połączonego czcionki.  
  
-   Wyświetlanie znaków w złożonych skryptach nie jest obsługiwane.  
  
-   Łączenie sekwencje znaków (oznacza to, znaki, które składają się z podstawowego znak i łączenia znaków) są wyświetlane jako osobne znaków. Aby obejść to ograniczenie, można normalizacji ciągów, które mają być wyświetlane przez wywołanie metody <xref:System.String.Normalize%2A?displayProperty=nameWithType> metoda przed wysłaniem danych wyjściowych do konsoli. W poniższym przykładzie ciąg, który zawiera znak łączenie sekwencji 0061 U + U + 0308 jest wyświetlana w konsoli jako dwa znaki, przed ciągu danych wyjściowych jest znormalizować i jako pojedynczy znak po <xref:System.String.Normalize%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Zwróć uwagę, że normalizacji możliwego do użycia rozwiązania tylko wtedy, gdy Unicode standard dla znaku zawiera wstępnie złożone formularz, który odnosi się do określonego combining znak sekwencji.  
  
-   Jeśli czcionkę udostępnia symbol punktu kodu w obszarze użytku prywatnego, pojawi się ten glif. Jednak ponieważ znaki w obszarze użytek są specyficzne dla aplikacji, to może nie być oczekiwany symbol.  
  
 Poniższy przykład wyświetla zakresu znaków Unicode do konsoli. Przykład przyjmuje trzy parametry wiersza polecenia: początek zakresu, aby wyświetlić koniec zakresu do wyświetlenia i czy ma być używane kodowanie bieżącej konsoli (`false`) lub kodowanie UTF-16 (`true`). Przyjęto założenie, że konsoli przy użyciu czcionki TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Typowe operacje  
 <xref:System.Console> Klasa zawiera następujące metody do odczytywania dane wejściowe konsoli i zapisywania danych wyjściowych konsoli:  
  
-   Przeciążenia <xref:System.Console.ReadKey%2A> metody odczytu pojedynczy znak.  
  
-   <xref:System.Console.ReadLine%2A> Metoda odczytuje cały wiersz danych wejściowych.  
  
-   <xref:System.Console.Write%2A> Przeciążenia metody przekonwertować wystąpienie typu wartości, tablicy znaków lub zestaw obiektów sformatowany lub niesformatowany ciąg, a następnie zapisać ciąg do konsoli.  
  
-   Zestaw równoległy <xref:System.Console.WriteLine%2A> taki sam ciąg jako dane wyjściowe przeciążenia metod <xref:System.Console.Write%2A> przeciążenia, ale także dodać ciąg zakończenia wiersza.  
  
 <xref:System.Console> Klasa zawiera także metody i właściwości, aby wykonywać następujące operacje:  
  
-   Pobierz lub ustaw rozmiar buforu ekranu. <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości umożliwiają pobieranie lub ustawianie buforu wysokości i szerokości, odpowiednio i <xref:System.Console.SetBufferSize%2A> metoda pozwala na ustalanie rozmiaru buforu w pojedynczym wywołaniu metody.  
  
-   Pobierz lub ustaw rozmiar okna konsoli. <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości umożliwiają pobieranie lub ustawianie wysokości i szerokości okna, odpowiednio i <xref:System.Console.SetWindowSize%2A> metoda pozwala na ustalanie rozmiaru okna w pojedynczym wywołaniu metody.  
  
-   Pobierz lub ustaw rozmiar kursora. <xref:System.Console.CursorSize%2A> Właściwość określa wysokość kursora w komórce znaków.  
  
-   Pobierz lub ustaw położenie okna konsoli względem buforu ekranu. <xref:System.Console.WindowTop%2A> i <xref:System.Console.WindowLeft%2A> właściwości umożliwiają pobieranie lub ustawianie górny wiersz i skrajnej lewej kolumnie buforu ekranu, który pojawia się w oknie konsoli i <xref:System.Console.SetWindowPosition%2A> metody umożliwia określenie tych wartości w pojedynczym wywołaniu metody.  
  
-   Pobierz lub ustaw położenie kursora przez pobieranie lub ustawianie <xref:System.Console.CursorTop%2A> i <xref:System.Console.CursorLeft%2A> właściwości lub Ustawia położenie kursora, wywołując <xref:System.Console.SetCursorPosition%2A> metody.  
  
-   Przenieść lub usunąć dane w buforze ekranu, wywołując <xref:System.Console.MoveBufferArea%2A> lub <xref:System.Console.Clear%2A> metody.  
  
-   Pobieranie lub ustawianie pierwszego planu i tła kolorów przy użyciu <xref:System.Console.ForegroundColor%2A> i <xref:System.Console.BackgroundColor%2A> właściwości lub przywrócenia tła i pierwszego planu ich kolory domyślne, wywołując <xref:System.Console.ResetColor%2A> metody.  
  
-   Odtwarzanie sygnału dźwiękowego za za pośrednictwem konsoli osoby mówiącej, wywołując <xref:System.Console.Beep%2A> metody.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Informacje o  
 W programie .NET Framework na komputerze stacjonarnym <xref:System.Console> klasa używa kodowania, zwracany przez `GetConsoleCP` i `GetConsoleOutputCP`, który zazwyczaj jest strona kodowa kodowania. Na przykład kodu w systemach, w których kultura jest angielski (Stany Zjednoczone), strony kodowej 437 jest kodowania, które jest używane domyślnie. Jednak [!INCLUDE[net_core](~/includes/net-core-md.md)] tylko ograniczony podzestaw tych kodowaniach mogą być dostępne. W przypadku, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> służy jako domyślnego kodowania dla konsoli.  
  
 Jeśli aplikacja jest zależna od określonych stron kodowych, można nadal udostępnić je, wykonując następujące czynności *przed* wywołać dowolną <xref:System.Console> metody:  
  
1.  Dodaj odwołanie do zestawu System.Text.Encoding.CodePages.dll do projektu.  
  
2.  Pobieranie <xref:System.Text.EncodingProvider> obiektu z <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> właściwości.  
  
3.  Przekaż <xref:System.Text.EncodingProvider> obiekt <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> metodę, aby wprowadzić dodatkowe kodowania obsługiwane przez dostawcę kodowania, która jest dostępna.  
  
 <xref:System.Console> Klasy będzie automatycznie używać domyślnego kodowania systemu zamiast UTF8, pod warunkiem, że zarejestrowano dostawcę kodowania przed wywołaniem dowolnej <xref:System.Console> danych wyjściowych metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do odczytu i zapisu danych na standardowe dane wejściowe i strumieni wyjściowych. Należy pamiętać, że te strumienie może zostać przekierowany przy użyciu <xref:System.Console.SetIn%2A> i <xref:System.Console.SetOut%2A> metody.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła w konsoli.</summary>
        <value>Wartość, która określa kolor tła konsoli; oznacza to, że kolor wyświetlany za każdym znaku. Wartość domyślna to czarny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana <xref:System.Console.BackgroundColor%2A> właściwość dotyczy tylko danych wyjściowych, który jest zapisywany do komórek pojedynczy znak, po zmianie koloru tła. Aby zmienić kolor tła okna konsoli jako całości, należy ustawić <xref:System.Console.BackgroundColor%2A> właściwości i wywołania <xref:System.Console.Clear%2A> metody. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Operacja get, oparte na Windows aplikacji, w którym konsola nie istnieje, zwraca <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wartości <xref:System.ConsoleColor> wyliczenia do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu na każdy kolor <xref:System.ConsoleColor> wyliczenie, z wyjątkiem na kolor, który odpowiada bieżącej tła i zmienia kolor tła na każdy kolor <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst jest widoczna). Na koniec wywoływanych przez nią <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kolor określony w operacji zestawu nie jest prawidłowym elementem <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odtwarza dźwięk dźwiękowego za pomocą głośników konsoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odtwarza dźwięk dźwiękowego za pomocą głośników konsoli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie dźwiękowego odtwarza z częstotliwością 800 hertz — czas trwania 200 ms.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Metoda nie jest obsługiwana na 64-bitowe wersje systemu Windows Vista i Windows XP.  
  
 <xref:System.Console.Beep%2A> Zawija wywołanie do Windows [głośnik funkcja](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Czy <xref:System.Console.Beep%2A> tworzy dźwięk w wersjach systemu Windows przed Windows 7 jest zależna od obecności chipa 8254 programowany czasomierz. Począwszy od Windows 7 to zależy od domyślnego urządzenia dźwiękowego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.Beep%2A> metody. Przykład akceptuje liczba z przedziału od 1 do 9 jako argument wiersza polecenia i odtwarza dźwięk tę liczbę razy.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Ta metoda została wykonana na serwerze, takich jak SQL Server zezwala na dostęp do interfejsu użytkownika.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">Częstotliwość dźwiękowego, począwszy od 37 do 32767 Hz.</param>
        <param name="duration">Czas trwania dźwięku mierzony w milisekundach.</param>
        <summary>Odtwarza dźwięk sygnał dźwiękowy z określoną częstotliwością i czas trwania za pośrednictwem konsoli osoby mówiącej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> Zawija wywołanie do Windows [głośnik funkcja](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Czy <xref:System.Console.Beep%2A> tworzy dźwięk w wersjach systemu Windows przed Windows 7 jest zależna od obecności chipa 8254 programowany czasomierz. Począwszy od Windows 7 to zależy od domyślnego urządzenia dźwiękowego.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Metoda nie jest obsługiwana na 64-bitowe wersje systemu Windows Vista i Windows XP.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.Beep%2A> metoda przez odtworzenie pierwsze kilka uwagi dotyczące utworu za pośrednictwem konsoli osoby mówiącej.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="frequency" /> jest mniejsza niż 37 lub więcej niż Hz 32767.  
  
—lub— 
 <paramref name="duration" /> jest mniejsza niż lub równy zeru.</exception>
        <exception cref="T:System.Security.HostProtectionException">Ta metoda została wykonana na serwerze, takich jak SQL Server zezwala na dostęp do konsoli.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość obszaru buforu.</summary>
        <value>Bieżąca wysokość w wierszach obszaru buforu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa liczbę wierszy (lub wierszy), przechowywane w buforze, która jest dostępna w trybie okna konsoli. Z kolei <xref:System.Console.WindowHeight%2A> właściwość definiuje liczbę wierszy, które są wyświetlane w oknie konsoli w danym momencie. Jeśli liczba wierszy, które rzeczywiście zapisanych w buforze przekracza liczbę wierszy, zdefiniowane przez <xref:System.Console.WindowHeight%2A> właściwości okna może być przewijane w pionie, tak, aby wyświetlał ciągłych liczbę wierszy, które są równe <xref:System.Console.WindowHeight%2A> właściwości i znajdują się dowolne miejsce w buforze.  
  
 Jeśli operacja ustawienia zmniejsza wartość <xref:System.Console.BufferHeight%2A> właściwości najwyższym wiersze są usuwane. Na przykład jeśli liczbę wierszy, które jest mniejsze od 300 do 250, od 0 do 49 wiersze zostaną usunięte i istniejące wiersze 50 do 299 stają się linii 249 do 0.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Przykład raporty wymiary okna systemu operacyjnego, rozmiaru buforu 300 wierszy i kolumn 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza niż lub równy zeru.  
  
—lub— 
Wartość w operacji zestawu jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
Wartość w operacji zestawu jest mniejsza niż <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość obszaru buforu.</summary>
        <value>Bieżący szerokość kolumn obszaru buforu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja ustawienia zmniejsza wartość <xref:System.Console.BufferWidth%2A> właściwość po prawej stronie kolumny są usuwane. Na przykład w przypadku liczby kolumn z 80 do 60 kolumny 60 do 79 każdego wiersza są usuwane.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Przykład raporty wymiary okna systemu operacyjnego, rozmiaru buforu 300 wierszy i kolumn 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza niż lub równy zeru.  
  
—lub— 
Wartość w operacji zestawu jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
Wartość w operacji zestawu jest mniejsza niż <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="F:System.ConsoleModifiers.Control" /> klawisz modyfikujący (Ctrl), a następnie <see cref="F:System.ConsoleKey.C" /> konsoli (C) podziału klawisz lub naciśnięciu jednocześnie (Ctrl + C lub Ctrl + Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest używany w połączeniu z <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> i <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. <xref:System.Console.CancelKeyPress> Zdarzeń umożliwia aplikacji konsoli aby przechwycić Ctrl + C sygnalizuje, dlatego program obsługi zdarzeń można zdecydować, czy do kontynuowania wykonywania lub przerywania. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 Gdy użytkownik naciśnie klawisz Ctrl + C lub Ctrl + Break <xref:System.Console.CancelKeyPress> zdarzenie jest generowane i aplikacji <xref:System.ConsoleCancelEventHandler> program obsługi zdarzeń jest wykonywane. Program obsługi zdarzeń jest przekazywany <xref:System.ConsoleCancelEventArgs> obiekt, który ma dwie właściwości przydatne:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, co pozwala określić, czy program obsługi został wywołany po wysłaniu przez użytkownika, naciskając klawisze Ctrl + C (wartość właściwości jest <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) lub Ctrl + Break (wartość właściwości jest <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, co pozwala określić, jak do aplikacji należy odpowiadanie na użytkownika naciskając klawisze Ctrl + C lub Ctrl + Break. Domyślnie <xref:System.ConsoleCancelEventArgs.Cancel%2A> właściwość jest `false`, który powoduje, że program wykonywania, aby zakończyć, gdy zamyka program obsługi zdarzeń. Zmiana jego właściwość `true` Określa, czy aplikacja powinna w dalszym ciągu wykonują.  
  
> [!TIP]
>  Jeśli aplikacja ma proste wymagania, możesz użyć <xref:System.Console.TreatControlCAsInput%2A> właściwości zamiast tego zdarzenia. Przez ustawienie tej właściwości na `false`, można upewnić się, że aplikacja zawsze zakończy działanie, gdy użytkownik naciśnie klawisz Ctrl + C. Ustawiając wartość `true`, upewnij się, naciskając klawisze Ctrl + C nie zostanie zakończona aplikacja.  
  
 Program obsługi zdarzeń dla tego zdarzenia jest wykonywane w wątku z puli wątków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób, w jaki <xref:System.Console.CancelKeyPress> zdarzenie jest używane. Po naciśnięciu klawiszy Ctrl + C, operacja odczytu zostanie przerwana i `myHandler` zostanie wywołana procedura obsługi zdarzeń. Po wejściu do narzędzia obsługi zdarzeń <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> właściwość `false`, co oznacza, że bieżący proces zostanie zakończona, gdy kończy program obsługi zdarzeń. Jednakże Ustawia program obsługi zdarzeń <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> właściwości `true`, co oznacza, że proces nie zostanie zakończona, operacja odczytu zostanie wznowiona.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy przełączania klawiatury włączony klawisz CAPS LOCK jest włączony lub wyłączony.</summary>
        <value><see langword="true" /> Jeśli włączony klawisz CAPS LOCK jest włączony; <see langword="false" /> Jeśli włączony klawisz CAPS LOCK jest wyłączony.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści bufor konsoli i odpowiednie okno konsoli wyświetlanych informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.Console.Clear%2A> metoda jest równoważna wywoływania MS-DOS `cls` polecenia w oknie wiersza polecenia. Gdy <xref:System.Console.Clear%2A> metoda jest wywoływana, kursor automatycznie przewija widok w lewym górnym rogu okna i zawartości buforu ekranu są ustawione na pustych elementów przy użyciu bieżącego kolory pierwszego planu w tle.  
  
> [!NOTE]
>  Próba wywołania <xref:System.Console.Clear%2A> zgłasza metody, gdy dane wyjściowe z aplikacji konsoli są przekierowywane do pliku <xref:System.IO.IOException>. Aby temu zapobiec, zawsze opakować wywołanie <xref:System.Console.Clear%2A> method in Class metoda `try`...`catch` blok.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.Clear%2A> metodę, aby wyczyścić konsoli, przed rozpoczęciem wykonywania pętli, wyświetli użytkownikowi wybierz kolor pierwszego planu i tła i wprowadzić ciąg do wyświetlenia. Jeśli użytkownik zdecyduje się nie zakończyć program, zostaną przywrócone oryginalne kolory pierwszego planu i tła konsoli i <xref:System.Console.Clear%2A> metoda jest wywoływana ponownie przed ponownym wykonaniem pętli.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 Przykład opiera się na `GetKeyPress` metody w celu sprawdzenia wybranych przez użytkownika kolor pierwszego planu i tła.  
  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości, a <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. W przykładzie następuje ustawienie kursora, który określa, gdzie następnego zapisu nastąpi, aby narysować 5 znaków przy 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", i "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora w kolumnie w obszarze buforu.</summary>
        <value>Bieżąca pozycja w kolumnach kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości, a <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. W przykładzie następuje ustawienie kursora, który określa, gdzie następnego zapisu nastąpi, aby narysować 5 znaków przy 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", i "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza od zera.  
  
—lub— 
Wartość w operacji zestawu jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość kursor w komórce znaków.</summary>
        <value>Rozmiar kursora, wyrażone jako procent wysokość komórki znaków. Właściwość wartości z zakresu od 1 do 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyglądem kursora zależy od linii poziomej w dolnej krawędzi komórki, gdy wartość właściwości wynosi 1, aby całkowicie wypełnianie komórki, gdy wartość właściwości wynosi 100.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorSize%2A> właściwości. Przykład zwiększa rozmiar kursora każdorazowo dowolny klawisz, konsola zostanie naciśnięty, a następnie przywraca kursor oryginalnego rozmiaru przed przerwaniem.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona w operacji zestawu jest mniejsza od 1 lub większa niż 100.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora w wierszu w obszarze buforu.</summary>
        <value>Bieżąca pozycja w wierszach kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości, a <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. W przykładzie następuje ustawienie kursora, który określa, gdzie następnego zapisu nastąpi, aby narysować 5 znaków przy 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", i "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza od zera.  
  
—lub— 
Wartość w operacji zestawu jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kursor jest widoczny.</summary>
        <value><see langword="true" /> Jeśli kursor znajduje się widoczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorVisible%2A> właściwości. Przykład powoduje, że kursor widoczny, jeśli pierwsza kolumna danych wejściowych jest znak "+" lub niewidoczne, jeśli dane wejściowe są "-" znaków.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera błąd standardowy strumień wyjściowy.</summary>
        <value>A <see cref="T:System.IO.TextWriter" /> reprezentujący błąd standardowy strumień wyjściowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten Standardowy strumień błędów jest domyślnie do konsoli. Może być ustawiona na inny przesyłanie strumieniowe przy użyciu <xref:System.Console.SetError%2A> metody. Po zostanie przekierowany Standardowy strumień błędów, może być reacquired przez wywołanie metody <xref:System.Console.OpenStandardError%2A> metody.  
  
 W aplikacjach konsoli, których informacyjne dane wyjściowe często są przekierowywane do pliku, błędu standardowego przesyłania strumieniowego dostępne za pośrednictwem <xref:System.Console.Error%2A> właściwość może służyć do wyświetlania informacji w konsoli, nawet wtedy, gdy dane wyjściowe jest przekierowywany. Poniższy przykład wyświetla tabele produktu dla 10 kolejnych liczb w czasie, począwszy od 1. Po każdym zestawie 10 numerów <xref:System.Console.Error%2A> właściwość jest używana do poprosić użytkownika, czy mają być wyświetlane następnego zestawu. Jeśli standardowe dane wyjściowe są przekierowywane do pliku, użytkownik zostanie poproszony nadal czy procedura powinien wygenerować następny zestaw produktów.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład to narzędzie wiersza polecenia o nazwie ExpandTabs, która zastępuje znaki karty w pliku tekstowym z czterech spacji, wartość zdefiniowana przez `tabSize` zmiennej. Przekierowuje standardowe dane wejściowe i dane wyjściowe przesyła strumieniowo do plików, ale używa <xref:System.Console.Error%2A> właściwość do zapisania Standardowy strumień błędów do konsoli. Można je uruchomić z wiersza polecenia, podając nazwę pliku, który zawiera znaki tabulacji i nazwa pliku wyjściowego.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Poniższy przykład jest przeglądarka plików zwykłego tekstu, która wyświetla zawartość jednego lub więcej plików tekstowych w konsoli. Jeśli nie wymaga argumentów wiersza polecenia lub jeśli nie istnieją pliki przekazywane jako argumenty wiersza polecenia, <xref:System.Console.SetError%2A> wywołuje metodę, aby przekierować informacje o błędzie do pliku, <xref:System.Console.OpenStandardError%2A> metoda właśnie reacquiring błędu standardowego przesyłanie strumieniowe i wskazuje, czy informacje o błędzie zostały zapisane do pliku.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Należy pamiętać, że <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true` przed reacquiring strumienia błędów. Daje to gwarancję, że dane wyjściowe będzie można natychmiast wysyłane do konsoli, a nie buforowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu konsoli.</summary>
        <value>Element <see cref="T:System.ConsoleColor" /> , który określa kolor pierwszego planu konsoli; oznacza to, że kolor każdego znaku, który jest wyświetlany. Ustawieniem domyślnym jest szary.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja get, oparte na Windows aplikacji, w którym konsola nie istnieje, zwraca <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy kolor tła konsoli jest czarny, a jeśli tak jest, zmienia kolor tła na czerwony i kolor na czarny.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 Poniższy przykład zapisuje wartości <xref:System.ConsoleColor> wyliczenia do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu na każdy kolor <xref:System.ConsoleColor> wyliczenie, z wyjątkiem na kolor, który odpowiada bieżącej tła i zmienia kolor tła na każdy kolor <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst jest widoczna). Na koniec wywoływanych przez nią <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kolor określony w operacji zestawu nie jest prawidłowym elementem <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera standardowego strumienia wejściowego.</summary>
        <value>A <see cref="T:System.IO.TextReader" /> reprezentujący standardowego strumienia wejściowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest domyślnie do standardowego strumienia wejściowego. Tę właściwość można ustawić do innego strumienia z <xref:System.Console.SetIn%2A> metody.  
  
 Operacje odczytu w standardowego strumienia wejściowego były uruchamiane synchronicznie. Oznacza to powodują one blokadę przed ukończeniem określonej operacji odczytu. Ta zasada obowiązuje nawet jeśli metoda asynchroniczna, takich jak <xref:System.IO.TextReader.ReadLineAsync%2A>, jest wywoływana w <xref:System.IO.TextReader> obiektu zwróconego przez <xref:System.Console.In%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `In` właściwości.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie, używanych przez konsolę do odczytywania danych wejściowych.</summary>
        <value>Kodowanie, używany do odczytu dane wejściowe konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę korzysta z danych wejściowych kodowanie tłumaczenie klawiatury do odpowiedniego znaku. Szyfrowanie danych wejściowych zawiera stronę kodową, która mapuje 256 kody znaków klawiatury do pojedynczych znaków. Różne strony kodowe obejmują różne znaki specjalne, zwykle dostosowane do języka lub grupy z języków.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], operacji pobierania właściwości może zwracać wartość w pamięci podręcznej zamiast z konsoli bieżącego kodowania wejściowego. Taka sytuacja może wystąpić, jeśli wartość <xref:System.Console.InputEncoding%2A> właściwość jest modyfikowana za pomocą środków innych niż przypisania do <xref:System.Console.InputEncoding%2A> właściwości, takich jak wywoływanie Windows `SetConsoleCP` funkcji lub przy użyciu `chcp` polecenia skryptu programu PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości w operacji zestawu jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Aplikacja nie ma uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">do odczytywania i zapisywania okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy strumień wyjściowy błąd został przekierowany z Standardowy strumień błędów.</summary>
        <value><see langword="true" /> Jeśli dane wyjściowe błędu jest przekierowywany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dane wejściowe zostały przekierowane ze standardowego strumienia wejściowego.</summary>
        <value><see langword="true" /> Jeśli dane wejściowe są przekierowywane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zostały przekierowane dane wyjściowe z w standardowym strumieniu wyjściowym.</summary>
        <value><see langword="true" /> Jeśli dane wyjściowe są przekierowywane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy naciśnięcie klawisza są dostępne w strumieniu wejściowym.</summary>
        <value><see langword="true" /> Jeśli naciśnięcie klawisza jest dostępna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Od razu; zostanie zwrócona wartość właściwości oznacza to, że <xref:System.Console.KeyAvailable%2A> właściwości nie są blokowane w danych wejściowych do czasu udostępnienia naciśnięcie klawisza.  
  
 Użyj <xref:System.Console.KeyAvailable%2A> właściwość w połączeniu z tylko <xref:System.Console.ReadKey%2A> metody nie <xref:System.Console.Read%2A> lub <xref:System.Console.ReadLine%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Console.KeyAvailable%2A> właściwości, aby utworzyć pętlę, która jest uruchamiana, dopóki nie zostanie naciśnięty klawisz.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.InvalidOperationException">Standardowe dane wejściowe jest przekierowywane do pliku zamiast z klawiatury.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera największej liczby konsoli wiersze okna, oparte na bieżącej czcionki i rozdzielczości ekranu.</summary>
        <value>Wysokość okna największych możliwych konsoli mierzona w wierszach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera największej liczby konsoli kolumny okna, oparte na bieżącej czcionki i rozdzielczości ekranu.</summary>
        <value>Szerokość okna największych możliwych konsoli mierzona w kolumnach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Skrajnej lewej kolumnie obszaru źródłowy.</param>
        <param name="sourceTop">Najwyższego poziomu wiersz obszaru źródłowy.</param>
        <param name="sourceWidth">Liczba kolumn w obszarze źródła.</param>
        <param name="sourceHeight">Liczba wierszy w obszarze źródła.</param>
        <param name="targetLeft">Skrajnej lewej kolumnie obszaru docelowego.</param>
        <param name="targetTop">Najwyższego poziomu wiersz obszaru docelowego.</param>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametry źródłowym i docelowym określają położenie znajdujących się poza granicami bieżącego buforu ekranu, tylko część obszaru źródłowy, który mieści się w obszarze docelowym jest kopiowany. Oznacza to, że obszaru źródłowy zostanie przycięty bieżącego buforu ekranu.  
  
 <xref:System.Console.MoveBufferArea%2A> Metoda kopiuje obszaru źródłowy do obszaru docelowego. Jeśli w obszarze docelowym nie przecinają obszaru źródłowy, obszaru źródłowy jest wypełniony pustych elementów przy użyciu bieżącego kolory pierwszego planu i tła. W przeciwnym razie przecinające się część obszaru danych źródłowych nie jest wypełnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z parametrów jest mniejsza niż zero.  
  
—lub— 
 <paramref name="sourceLeft" /> lub <paramref name="targetLeft" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  
  
—lub— 
 <paramref name="sourceTop" /> lub <paramref name="targetTop" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  
  
—lub— 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  
  
—lub— 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Skrajnej lewej kolumnie obszaru źródłowy.</param>
        <param name="sourceTop">Najwyższego poziomu wiersz obszaru źródłowy.</param>
        <param name="sourceWidth">Liczba kolumn w obszarze źródła.</param>
        <param name="sourceHeight">Liczba wierszy w obszarze źródła.</param>
        <param name="targetLeft">Skrajnej lewej kolumnie obszaru docelowego.</param>
        <param name="targetTop">Najwyższego poziomu wiersz obszaru docelowego.</param>
        <param name="sourceChar">Znak używany do wypełnienia obszaru źródłowy.</param>
        <param name="sourceForeColor">Kolor pierwszego planu, używany do wypełnienia obszaru źródłowy.</param>
        <param name="sourceBackColor">Kolor tła używany do wypełniania obszaru źródłowy.</param>
        <summary>Kopiuje wybrany obszaru źródłowy bufora ekranu do wskazanego obszaru docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametry źródłowym i docelowym określają położenie znajdujących się poza granice bieżącego buforu ekranu, tylko część obszaru źródłowy, który mieści się w obszarze docelowym jest kopiowany. Oznacza to, że obszaru źródłowy zostanie przycięty bieżącego buforu ekranu.  
  
 <xref:System.Console.MoveBufferArea%2A> Metoda kopiuje obszaru źródłowy do obszaru docelowego. Jeśli obszaru docelowego nie przecinają obszaru źródłowy, znak określony przez jest wypełniany obszaru źródłowy `sourceChar`, przy użyciu kolorów, określona przez `sourceForeColor` i `sourceBackColor`. W przeciwnym razie przecinające się część obszaru danych źródłowych nie jest wypełnione.  
  
 <xref:System.Console.MoveBufferArea%2A> Metoda wykonuje żadnej operacji, jeśli `sourceWidth` lub `sourceHeight` wynosi zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z parametrów jest mniejsza niż zero.  
  
—lub— 
 <paramref name="sourceLeft" /> lub <paramref name="targetLeft" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  
  
—lub— 
 <paramref name="sourceTop" /> lub <paramref name="targetTop" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  
  
—lub— 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.  
  
—lub— 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z parametrów kolorów nie jest członkiem <see cref="T:System.ConsoleColor" /> wyliczenia.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy przełączania klawiatury NUM LOCK jest włączony czy wyłączony.</summary>
        <value><see langword="true" /> Jeśli NUM LOCK jest włączony; <see langword="false" /> Jeśli NUM LOCK jest wyłączony.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje Standardowy strumień błędów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje Standardowy strumień błędów.</summary>
        <returns>Standardowy strumień błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać Standardowy strumień błędów po zmianie przez <xref:System.Console.SetError%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład jest przeglądarka plików zwykłego tekstu, która wyświetla zawartość jednego lub więcej plików tekstowych w konsoli. Jeśli nie wymaga argumentów wiersza polecenia lub jeśli nie istnieją pliki przekazywane jako argumenty wiersza polecenia, <xref:System.Console.SetError%2A> wywołuje metodę, aby przekierować informacje o błędzie do pliku, <xref:System.Console.OpenStandardError%2A> metoda właśnie reacquiring błędu standardowego przesyłanie strumieniowe i wskazuje, czy informacje o błędzie zostały zapisane do pliku.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Należy pamiętać, że <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true` przed reacquiring strumienia błędów. Daje to gwarancję, że dane wyjściowe będzie można natychmiast wysyłane do konsoli, a nie buforowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Uzyskuje Standardowy strumień błędów, która jest ustawiona na określony rozmiar buforu.</summary>
        <returns>Standardowy strumień błędów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać Standardowy strumień błędów po zmianie przez <xref:System.Console.SetError%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> jest mniejsza niż lub równy zeru.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje standardowego strumienia wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje standardowego strumienia wejściowego.</summary>
        <returns>Standardowy strumień wejściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać standardowego strumienia wejściowego, po zmianie przez <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `OpenStandardInput` właściwości.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Uzyskuje standardowego strumienia wejściowego, który jest ustawiony na określony rozmiar buforu.</summary>
        <returns>Standardowy strumień wejściowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać w standardowym strumieniu wyjściowym, po zmianie przez <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `OpenStandardInput` właściwości.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> jest mniejsza niż lub równy zeru.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje w standardowym strumieniu wyjściowym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje w standardowym strumieniu wyjściowym.</summary>
        <returns>W standardowym strumieniu wyjściowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać w standardowym strumieniu wyjściowym, po zmianie przez <xref:System.Console.SetOut%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Console.OpenStandardOutput%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby je uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Rozmiar buforu wewnętrznego strumienia.</param>
        <summary>Uzyskuje w standardowym strumieniu wyjściowym, która jest ustawiona na określony rozmiar buforu.</summary>
        <returns>W standardowym strumieniu wyjściowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można ponownie pobrać w standardowym strumieniu wyjściowym, po zmianie przez <xref:System.Console.SetOut%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Console.OpenStandardOutput%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby je uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> jest mniejsza niż lub równy zeru.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera w standardowym strumieniu wyjściowym.</summary>
        <value>A <see cref="T:System.IO.TextWriter" /> reprezentujący w standardowym strumieniu wyjściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest domyślnie do standardowego strumienia wyjściowego. Tę właściwość można ustawić do innego strumienia z <xref:System.Console.SetOut%2A> metody.  
  
 Należy zauważyć, że wywołania `Console.Out.WriteLine` metody są odpowiednikiem wywołania do odpowiednich <xref:System.Console.WriteLine%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.Out%2A> właściwość, aby wyświetlić tablicę zawierającą nazwy plików w bieżącym katalogu aplikacji na urządzeniu standardowe dane wyjściowe. Następnie ustawia standardowe dane wyjściowe do pliku o nazwie Files.txt i wyświetla listę elementów tablicy, do pliku. Na koniec ustawia dane wyjściowe do strumienia wyjścia standardowego i ponownie elementów tablicy jest wyświetlana na urządzeniu standardowe dane wyjściowe.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie, używanych przez konsolę do zapisywania danych wyjściowych.</summary>
        <value>Kodowanie, używany do zapisywania danych wyjściowych konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę używa kodowania, dane wyjściowe do translacji znaków zapisanych przez aplikację na odpowiadające im znaki wyświetlania konsoli. Domyślną stronę kodową, która korzysta z konsoli programu jest określany przez ustawienia regionalne systemu.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], operacji pobierania właściwości może zwracać wartość w pamięci podręcznej zamiast bieżącego kodowania dane wyjściowe z konsoli. Taka sytuacja może wystąpić, jeśli wartość <xref:System.Console.OutputEncoding%2A> właściwość jest modyfikowana za pomocą środków innych niż przypisania do <xref:System.Console.OutputEncoding%2A> właściwości, takich jak wywoływanie Windows `SetConsoleOutputCP` funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość właściwości w operacji zestawu jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas wykonywania tej operacji.</exception>
        <exception cref="T:System.Security.SecurityException">Aplikacja nie ma uprawnień do wykonania tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">do odczytywania i zapisywania okien najwyższego poziomu i okien podrzędnych.  Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Z kodowania Unicode <see cref="T:System.Console" /> klasa obsługuje kodowanie przy użyciu UTF-8 <see cref="T:System.Text.UTF8Encoding" /> klasy i, począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], obsługuje on UTF-16 kodowania z <see cref="T:System.Text.UnicodeEncoding" /> klasy. Kodowanie UTF-32, za pomocą <see cref="T:System.Text.UTF32Encoding" /> klasy nie jest obsługiwane. Trwa próba skonfigurowania danych wyjściowych kodowania na UTF-32 zgłasza <see cref="T:System.IO.IOException" />.  
  
Należy zwrócić uwagę na to, że pomyślnie wyświetlanie znaków Unicode do konsoli usługi wymagane są następujące elementy: 
-Konsoli, należy użyć czcionki TrueType, takich jak konsola New lub Consolas, aby wyświetlić znaki.  
  
-Czcionki używany przez konsolę programu należy zdefiniować symbol określonego lub symbole, które mają być wyświetlane. Konsolę korzystać z zalet czcionek, łączenie do wyświetlenia symbole z połączonych czcionek, jeśli czcionki podstawowej nie zawiera definicji dla tego symbolu.  
  
Aby uzyskać więcej informacji na temat obsługi standardu Unicode kodowania, konsoli, zobacz sekcję "Unicode pomocy technicznej dla konsoli" w <see cref="T:System.Console" /> klasy.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny znak ze standardowego strumienia wejściowego.</summary>
        <returns>Następne znak ze strumienia wejściowego lub wartość ujemną (-1) Jeśli obecnie nie istnieją żadne więcej znaków do odczytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Read%2A> Metoda blokuje jego powrotu podczas wpisywania wprowadzonych znaków; kończy się po naciśnięciu klawisza <xref:System.ConsoleKey.Enter> klucza. Naciśnięcie klawisza Enter dołącza sekwencji zakończenia wiersza zależny od platformy do dane wejściowe (na przykład Windows dołącza sekwencji wysuwu wiersza powrotu karetki). Kolejne wywołania <xref:System.Console.Read%2A> metody pobierania usługi danych wejściowych o jeden znak w danym momencie. Po pobraniu ostatni znak <xref:System.Console.Read%2A> blokuje jego powrotu ponownie i cykl się powtarza.  
  
> [!IMPORTANT]
>  <xref:System.Console.ReadLine%2A> Metody lub <xref:System.Console.KeyAvailable%2A> właściwości i <xref:System.Console.ReadKey%2A> metody są preferowane w porównaniu do korzystania z <xref:System.Console.Read%2A> metody.  
  
 Należy zwrócić uwagę na to, że metoda nie zwracają wartość -1, chyba że wykonujesz jedno z następujących czynności:  
  
-   Naciśnij jednocześnie <xref:System.ConsoleModifiers.Control> klawisz modyfikujący i <xref:System.ConsoleKey.Z> klucz konsoli (Ctrl + Z), które sygnalizują warunek końca pliku.  
  
-   Naciśnij klawisz równoważne, które sygnalizują warunek końca pliku, takie jak klawisza F6 w Windows.  
  
-   Przekieruj strumienia wejściowego, do źródła, takiego jak plik tekstowy, który zawiera rzeczywiste znak końca pliku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.Read%2A> metody.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika. Po naciśnięciu klawisza jest wyświetlany w oknie konsoli.</summary>
        <returns>Obiekt, który opisuje <see cref="T:System.ConsoleKey" /> stałych i znak Unicode, odpowiadające klucza po naciśnięciu konsoli. <see cref="T:System.ConsoleKeyInfo" /> Obiektu również w tym artykule opisano, w bitowa kombinacja <see cref="T:System.ConsoleModifiers" /> wartości, czy co najmniej jeden Shift, Alt i Ctrl klawisze modyfikujące został naciśnięty równocześnie z kluczem konsoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Metoda oczekuje oznacza to, że bloki wydawania wątku <xref:System.Console.ReadKey%2A> metody, dopóki nie zostanie naciśnięty klawisz znak lub funkcję. W połączeniu z co najmniej jeden klawisz Alt, Ctrl lub Shift klawisze modyfikujące może być naciśnięty klawisz znak lub funkcję. Jednakże, naciskając klawisz modyfikujący samodzielnie nie spowodują <xref:System.Console.ReadKey%2A> metody do zwrócenia.  
  
 W zależności od aplikacji, możesz chcieć użyć <xref:System.Console.ReadKey%2A> metody w połączeniu z <xref:System.Console.KeyAvailable%2A> właściwości.  
  
 <xref:System.Console.ReadKey%2A> Metoda odczytuje przy użyciu klawiatury, nawet wtedy, gdy standardowe dane wejściowe jest przekierowywane do pliku za pomocą <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Jedną z najbardziej typowych sposobów użycia <xref:System.Console.ReadKey> metodą jest zatrzymanie wykonywania programu, dopóki użytkownik naciśnie klawisz i aplikacja kończy lub wyświetla okno dodatkowych informacji. W poniższym przykładzie użyto <xref:System.Console.ReadKey> metodę, aby czekać na użytkownika poprzez naciśnięcie klawisza Enter przed zakończeniem aplikacji.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Należy zauważyć, że to przeciążenia <xref:System.Console.ReadKey%2A> metoda domyślnie informujące o dowolnej zawiera klucze, które użytkownik naciśnie do konsoli. Aby pominąć je, należy wywołać <xref:System.Console.ReadKey%2A> metody z `intercept` argument `true`.  
  
 W poniższym przykładzie użyto <xref:System.Console.ReadKey> metodę w celu wyświetlenia informacji na temat klucza, który użytkownik nacisnął klawisz. 
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Console.In" /> Właściwość jest przekierowywany z niektórych strumienia niż konsoli.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Określa, czy mają być wyświetlane po naciśnięciu klawisza w oknie konsoli. <see langword="true" /> Aby nie były wyświetlane po naciśnięciu klawisza; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera następny znak lub funkcję wskutek naciśnięcia klawisza przez użytkownika. Po naciśnięciu klawisza opcjonalnie jest wyświetlany w oknie konsoli.</summary>
        <returns>Obiekt, który opisuje <see cref="T:System.ConsoleKey" /> stałych i znak Unicode, odpowiadające klucza po naciśnięciu konsoli. <see cref="T:System.ConsoleKeyInfo" /> Obiektu również w tym artykule opisano, w bitowa kombinacja <see cref="T:System.ConsoleModifiers" /> wartości, czy co najmniej jeden Shift, Alt i Ctrl klawisze modyfikujące został naciśnięty równocześnie z kluczem konsoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Metoda oczekuje oznacza to, że bloki wydawania wątku <xref:System.Console.ReadKey%2A> metody, dopóki nie zostanie naciśnięty klawisz znak lub funkcję. W połączeniu z co najmniej jeden klawisz Alt, Ctrl lub Shift klawisze modyfikujące może być naciśnięty klawisz znak lub funkcję. Jednakże, naciskając klawisz modyfikujący samodzielnie nie spowodują <xref:System.Console.ReadKey%2A> metody do zwrócenia.  
  
 Jeśli `intercept` parametr jest `true`, po naciśnięciu klawisza zostaje zatrzymana i nie wyświetlanych w oknie konsoli; w przeciwnym razie jest wyświetlany po naciśnięciu klawisza.  
  
 W zależności od aplikacji, możesz chcieć użyć <xref:System.Console.ReadKey%2A> metody w połączeniu z <xref:System.Console.KeyAvailable%2A> właściwości.  
  
 <xref:System.Console.ReadKey%2A> Metoda odczytuje przy użyciu klawiatury, nawet wtedy, gdy standardowe dane wejściowe jest przekierowywane do pliku za pomocą <xref:System.Console.SetIn%2A> metody.  
  
   
  
## Examples  
 Jedną z najbardziej typowych sposobów użycia <xref:System.Console.ReadKey%2A> metodą jest zatrzymanie wykonywania programu, dopóki użytkownik naciśnie klawisz i aplikacja kończy lub wyświetla okno dodatkowych informacji. W poniższym przykładzie użyto <xref:System.Console.ReadKey%28System.Boolean%29> metodę, aby czekać na użytkownika poprzez naciśnięcie klawisza Enter przed zakończeniem aplikacji. Należy pamiętać, gdy użytkownik naciśnie inny klawisz, jego jest nie powtarzana do konsoli.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 W poniższym przykładzie użyto <xref:System.Console.ReadKey%28System.Boolean%29> metodę w celu wyświetlenia informacji na temat wskutek naciśnięcia klawisza przez użytkownika bez wyświetlania tego klucza do konsoli.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Console.In" /> Właściwość jest przekierowywany z niektórych strumienia niż konsoli.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny wiersz znaków ze standardowego strumienia wejściowego.</summary>
        <returns>Następny wiersz znaków ze strumienia wejściowego lub <see langword="null" /> Jeśli dostępnych jest więcej wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadLine%2A> Metoda odczytuje wiersz ze standardowego strumienia wejściowego. (Dla definicji wiersza, zobacz akapitu po poniżej). Oznacza to, że:  
  
-   W przypadku standardowych urządzenia wejściowego klawiatury, <xref:System.Console.ReadLine%2A> metoda bloków, dopóki użytkownik naciśnie **Enter** klucza.  
  
     Jedną z najbardziej typowych sposobów użycia <xref:System.Console.ReadLine%2A> metodą jest wstrzymuje wykonywanie programu przed wyczyszczenie konsoli i wyświetlanie nowych informacji do niego lub aby monitować użytkownika o naciśnięcie klawisza Enter przed zakończeniem aplikacji. Ilustruje to poniższy przykład.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Jeśli standardowe dane wejściowe jest przekierowywane do pliku, <xref:System.Console.ReadLine%2A> metoda odczytuje wiersz tekstu z pliku. Na przykład Oto plik tekstowy o nazwie ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     W poniższym przykładzie użyto <xref:System.Console.ReadLine%2A> metodę w celu odczytania danych wejściowych, który jest przekierowywany z pliku. Operacja odczytu kończy działanie, gdy metoda ta zwraca `null`, co oznacza, że żadnych wierszy pozostają do odczytania.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Po kompilacji w przykładzie do pliku wykonywalnego o nazwie ReadLine1.exe, możesz go uruchomić z wiersza polecenia przy użyciu składni  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     Aby odczytać zawartość pliku i wyświetla je w konsoli.  
  
 Wiersz jest zdefiniowany jako sekwencja znaków, a następnie przez powrót karetki (0x000d szesnastkowe), wysuwu wiersza (szesnastkowa 0x000a) lub wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości. Zwracany ciąg nie zawiera znaki kończącego. Domyślnie metoda odczytuje wejściowych buforu wejściowego 256 znaków. Ponieważ w tym <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> znaki, metoda może odczytywać wiersze zawierające do 254 znaków. Aby dowiedzieć się więcej wierszy, należy wywołać <xref:System.Console.OpenStandardInput%28System.Int32%29> metody.  
  
 <xref:System.Console.ReadLine%2A> Metoda jest wykonywana synchronicznie. Oznacza to blokuje, aż do wiersza jest do odczytu lub naciśnięciu kombinacja klawiszy Ctrl + Z. <xref:System.Console.In%2A> Właściwość zwraca <xref:System.IO.TextReader> obiekt reprezentujący standardowego strumienia wejściowego i ma zarówno przez synchroniczny <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> metody i asynchronicznego <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> metody. Jednakże, gdy jest używana jako konsoli standardowego strumienia wejściowego, <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> jest wykonywana synchronicznie zamiast asynchronicznie, a następnie zwraca `Task<String>` tylko wtedy, gdy operacja odczytu została zakończona.  
  
 Jeśli ta metoda wyrzuca <xref:System.OutOfMemoryException> wyjątek, pozycja czytelnika w źródłowym <xref:System.IO.Stream> obiektu jest zaawansowany według liczby znaków, metoda nie może odczytać, ale znaki już odczytywany przez wewnętrzny <xref:System.Console.ReadLine%2A> są buforu odrzucone. Ponieważ nie można zmienić położenie czytnika w strumieniu, znaki odczytane już są nie do odzyskania i jest możliwy tylko za pomocą ponownego inicjowania <xref:System.IO.TextReader>. Jeśli początkowe położenie w strumieniu jest nieznany lub strumień nie obsługuje wyszukiwania, podstawowe <xref:System.IO.Stream> musi także zostać zainicjowane ponownie. Aby uniknąć tej sytuacji i utworzyć niezawodny kod, należy używać <xref:System.Console.KeyAvailable%2A> właściwości i <xref:System.Console.ReadKey%2A> metody i magazynu odczytu znaków wstępnie przydzielonego buforu.  
  
 Jeśli znak Ctrl + Z jest wciśnięty, gdy metodą jest odczyt danych wejściowych, z poziomu konsoli, metoda zwraca `null`. Dzięki temu można uniknąć dalszych klawiaturze dane wprowadzane przez użytkownika podczas <xref:System.Console.ReadLine%2A> metoda jest wywoływana w pętli. Poniższy przykład ilustruje ten scenariusz.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład wymaga dwóch argumentów wiersza polecenia: nazwa istniejącego pliku tekstowego oraz nazwę pliku do zapisywania danych wyjściowych. Otwiera istniejący plik i przekierowuje standardowe dane wejściowe z klawiatury do tego pliku. Przekierowuje wyjścia standardowego z konsoli do pliku wyjściowego. Następnie używa <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> metodę w celu odczytania każdy wiersz w pliku, zastępuje każdy kolejny czterech spacji znak tabulacji i używa <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metodę, aby zapisać wyniki do pliku wyjściowego.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków w następnym wierszu znaków jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pierwszego planu i tła kolorów konsoli do wartości domyślnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolory pierwszego planu i tła zostaną przywrócone do kolorów, które istniały w momencie rozpoczęcia bieżącego procesu. Aby uzyskać więcej informacji, zobacz <xref:System.Console.ForegroundColor%2A> i <xref:System.Console.BackgroundColor%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wartości <xref:System.ConsoleColor> wyliczenia do tablicy i zapisuje bieżące wartości <xref:System.Console.BackgroundColor%2A> i <xref:System.Console.ForegroundColor%2A> właściwości do zmiennych. Następnie zmienia kolor pierwszego planu na każdy kolor <xref:System.ConsoleColor> wyliczenie, z wyjątkiem na kolor, który odpowiada bieżącej tła i zmienia kolor tła na każdy kolor <xref:System.ConsoleColor> wyliczenie z wyjątkiem kolor, który jest zgodny Bieżący pierwszego planu. (Jeśli kolor pierwszego planu jest taka sama jak kolor tła, tekst jest widoczna). Na koniec wywoływanych przez nią <xref:System.Console.ResetColor%2A> metodę, aby przywrócić oryginalne kolory konsoli.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Szerokość obszaru buforu jest mierzony w kolumnach.</param>
        <param name="height">Wysokość obszaru buforu jest mierzony w wierszach.</param>
        <summary>Dostosuje wysokość i szerokość obszaru buforu ekranu do określonej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu, na podstawie szerokości buforu ekranu. Następnie przykład przesuwa okno konsoli w odpowiedzi, do której Strzałka w górę, naciśnięciu klawisza konsoli strzałkę w dół, Strzałka w lewo lub Strzałka w prawo. Wzorzec siatki ułatwia uzyskiwanie informacji przepływu w oknie konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="height" /> lub <paramref name="width" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="height" /> lub <paramref name="width" /> jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
 <paramref name="width" /> jest mniejsza niż <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.  
  
—lub— 
 <paramref name="height" /> jest mniejsza niż <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Kolumna pozycja kursora. Kolumny są numerowane od lewej do prawej, począwszy 0.</param>
        <param name="top">Położenie wiersza kursora. Wiersze są numerowane od góry do dołu, począwszy od 0.</param>
        <summary>Ustawia położenie kursora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Console.SetCursorPosition%2A> metodę, aby określić, gdzie jest następnej operacji zapisu w oknie konsoli aby rozpocząć. Jeśli pozycja kursora określony jest poza obszarem, który jest aktualnie widoczne w oknie konsoli, pochodzenia okno zmienia się automatycznie, aby uwidocznić kursora.  
  
 Kursor przesuwa się automatycznie do następnej pozycji znaku każdym znaku są zapisywane w oknie konsoli. Jeśli kursor znajduje się w położeniu znak po prawej dolnej części okna konsoli, następnego zapisu operacja powoduje, że w oknie konsoli, aby przewijać więc kursor pozostaje widoczne. Jeśli chcesz napisać znak na pozycji znaku prawym dolnym bez powodowania w oknie konsoli przewijać, użyj <xref:System.Console.MoveBufferArea%2A> metodę, aby przenieść znak tej pozycji.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.CursorLeft%2A> i <xref:System.Console.CursorTop%2A> właściwości, a <xref:System.Console.SetCursorPosition%2A> i <xref:System.Console.Clear%2A> metody. W przykładzie następuje ustawienie kursora, który określa, gdzie następnego zapisu nastąpi, aby narysować 5 znaków przy 5 prostokąt znak, przy użyciu kombinacji "+", "&#124;", i "-" ciągów. Należy zauważyć, że prostokąt można narysować za pomocą mniejszej liczby czynności, używając kombinacji innych ciągów.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> lub <paramref name="top" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="left" /> jest większa niż lub równa <see cref="P:System.Console.BufferWidth" />.  
  
—lub— 
 <paramref name="top" /> jest większa niż lub równa <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Strumień, który jest nowe dane wyjściowe błędu standardowego.</param>
        <summary>Zestawy <see cref="P:System.Console.Error" /> właściwości określonej <see cref="T:System.IO.TextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.Error%2A> właściwość jest ustawiona na błąd standardowy strumień wyjściowy.  
  
 A <xref:System.IO.StreamWriter> która hermetyzuje <xref:System.IO.FileStream> może służyć do wysyłania komunikatów o błędach do pliku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przekierowania Standardowy strumień błędów do pliku.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newError" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Strumień, który jest nowe standardowe dane wejściowe.</param>
        <summary>Zestawy <see cref="P:System.Console.In" /> właściwości określonej <see cref="T:System.IO.TextReader" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.In%2A> właściwość jest ustawiona do standardowego strumienia wejściowego.  
  
 A <xref:System.IO.StreamReader> która hermetyzuje <xref:System.IO.FileStream> może służyć do odbierania danych z pliku.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Console.SetIn%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby je uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newIn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Strumień, który jest nowe standardowe dane wyjściowe.</param>
        <summary>Zestawy <see cref="P:System.Console.Out" /> właściwości określonej <see cref="T:System.IO.TextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Console.Out%2A> właściwość jest ustawiona na standardowym strumieniu wyjściowym.  
  
 A <xref:System.IO.StreamWriter> która hermetyzuje <xref:System.IO.FileStream> może służyć do wysyłania danych wyjściowych do pliku. Na przykład:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Console.SetOut%2A> metody. Zastępuje cztery następujące po sobie znaki spacji w ciągu zawierającym znak tabulacji. Aby je uruchomić, należy podać dwa argumenty wiersza polecenia. Pierwszy to nazwa istniejącego pliku tekstowego, do którego zostanie przekierowany standardowy strumień danych wejściowych. Drugi to nazwa pliku, do którego zostanie przekierowany standardowy strumień danych wyjściowych. Ten plik nie musi istnieć. Jeśli istnieje, jego zawartość zostanie zastąpiona.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newOut" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Pozycja kolumny lewym górnym rogu okna konsoli.</param>
        <param name="top">Położenie wiersza w lewym górnym rogu okna konsoli.</param>
        <summary>Ustawia położenie okna konsoli względem buforu ekranu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W oknie systemu operacyjnego zostaną wyświetlone w oknie konsoli, a część buforu ekranu jest wyświetlana w oknie konsoli. <xref:System.Console.SetWindowPosition%2A> Metoda ma wpływ na położenie okna konsoli względem buforu ekranu, ale nie ma wpływu na położenie okna systemu operacyjnego względem pulpitu.  
  
 Okna konsoli i systemu operacyjnego ogólnie nie wpływają na siebie nawzajem. Jednak nie można wyświetlić buforu ekranu w granicach bieżącego okna konsoli, systemu operacyjnego automatycznie dołącza pasków przewijania do okna systemu operacyjnego. W takim przypadku przenoszenie pasków przewijania okna systemu operacyjnego ma wpływ na położenie okna konsoli i przenoszenie okna konsoli za pomocą <xref:System.Console.SetWindowPosition%2A> metoda ma wpływ na położenie pasków przewijania okna systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu, na podstawie szerokości buforu ekranu. Następnie przykład przesuwa okno konsoli w odpowiedzi, do której Strzałka w górę, naciśnięciu klawisza konsoli strzałkę w dół, Strzałka w lewo lub Strzałka w prawo. Wzorzec siatki ułatwia uzyskiwanie informacji przepływu w oknie konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> lub <paramref name="top" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> jest większa niż <see cref="P:System.Console.BufferWidth" />.  
  
—lub— 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> jest większa niż <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Szerokość okna konsoli jest mierzona w kolumnach.</param>
        <param name="height">Wysokość okna konsoli jest mierzona w wierszach.</param>
        <summary>Dostosuje wysokość i szerokość okna konsoli do określonej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary równa 43 wierszy i kolumn 85 okna konsoli, a następnie czeka na klucz naciśnięcia. Po naciśnięciu dowolnego klawisza w filtrach są wymiary okna konsoli, nowe wymiary są zgłaszane i przykład czeka na naciśnięcie klawisza innego. Na koniec po naciśnięciu dowolnego klawisza w oknie konsoli zostaną przywrócone w swoich oryginalnych wymiarów i kończy się przykładu.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="width" /> lub <paramref name="height" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="width" /> plus <see cref="P:System.Console.WindowLeft" /> lub <paramref name="height" /> oraz <see cref="P:System.Console.WindowTop" /> jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
 <paramref name="width" /> lub <paramref name="height" /> jest większa niż największa szerokość okna możliwe lub wysokość dla mierników bieżącą czcionkę konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.Security.SecurityException">Użytkownik nie ma uprawnienia do wykonania tej czynności.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł wyświetlany na pasku tytułu konsoli.</summary>
        <value>Ciąg, który ma być wyświetlany w pasku tytułu konsoli. Maksymalna długość ciągu tytuł jest 24500 znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.Title%2A> właściwości. Przykład wyświetla bieżący tytuł okna systemu operacyjnego, czeka na naciśnięcie klawisza, a następnie wyświetla nowy tytuł.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">W ramach operacji get pobrane tytuł jest dłuższa niż 24500 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">W operacji zestawu podany tytuł jest dłuższa niż 24500 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">W operacji zestawu, jest podany tytuł <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy kombinacja <see cref="F:System.ConsoleModifiers.Control" /> klawisz modyfikujący i <see cref="F:System.ConsoleKey.C" /> klucz konsoli (Ctrl + C) jest traktowana jako zwykłe dane wejściowe lub przerwania, który jest obsługiwany przez system operacyjny.</summary>
        <value><see langword="true" /> Jeśli klawisze Ctrl + C jest traktowany jako zwykłe dane wejściowe w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Console.TreatControlCAsInput%2A> właściwość `false` i naciśnięciu klawiszy Ctrl + C, po naciśnięciu klawiszy nie są przechowywane w buforze wejściowym i systemu operacyjnego kończy działanie aktualnie wykonywanego procesu. Jest to wartość domyślna.  
  
> [!CAUTION]
>  Tej właściwości należy użyć rozwagą, ponieważ ustawienie `true` jest taki efekt. Ctrl + C, aby zakończyć aplikację konsolową w języku oczekiwać, że większość użytkowników. Jeśli wyłączysz efekt klawisze Ctrl + C, użytkownik musi Pamiętaj, aby umożliwia zakończenie aplikacji, które są mniej znanych kombinacji klawiszy Ctrl + Break.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.TreatControlCAsInput%2A> właściwości.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można pobrać lub ustawić tryb wprowadzania konsoli buforu wejściowego.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość obszaru okna konsoli.</summary>
        <value>Wysokość okna konsoli jest mierzona w wierszach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trwa próba skonfigurowania wartość <xref:System.Console.WindowHeight%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątkowi, należy ustawić wartość tej właściwości tylko wtedy, gdy <xref:System.Console.IsOutputRedirected%2A> właściwość zwraca `false`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary równa 43 wierszy i kolumn 85 okna konsoli, a następnie czeka na naciśnięcie klawisza. Po naciśnięciu dowolnego klawisza w filtrach są wymiary okna konsoli, nowe wymiary są zgłaszane i przykład czeka na naciśnięcie klawisza innego. Na koniec po naciśnięciu dowolnego klawisza w oknie konsoli zostaną przywrócone w swoich oryginalnych wymiarów i kończy się przykładu.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <see cref="P:System.Console.WindowWidth" /> właściwość lub wartość <see cref="P:System.Console.WindowHeight" /> właściwość jest mniejsze niż lub równe 0.  
  
—lub— 
Wartość <see cref="P:System.Console.WindowHeight" /> właściwości oraz wartość <see cref="P:System.Console.WindowTop" /> właściwość jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
Wartość <see cref="P:System.Console.WindowWidth" /> właściwość lub wartość <see cref="P:System.Console.WindowHeight" /> właściwości jest większa niż największa szerokość okna możliwe lub wysokość dla mierników bieżącą czcionkę konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie skrajnie po lewej stronie obszaru okna konsoli względem buforu ekranu.</summary>
        <value>Położenie okna konsoli skrajnie po lewej stronie są mierzone w kolumnach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę reprezentuje okno programu prostokątnych w większy bufor prostokątny obszar. Okno i buforu są mierzone w pionie przez ich liczbę wierszy i w poziomie przez ich liczbę kolumn. Wymiary powierzchni buforu są definiowane przez <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Wymiary powierzchni konsoli są definiowane przez <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości. <xref:System.Console.WindowLeft%2A> Właściwość określa, która kolumna w obszarze buforu jest wyświetlany w pierwszej kolumnie w oknie konsoli. Wartość <xref:System.Console.WindowLeft%2A> właściwości mogą należeć do zakresu od 0 do <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Podjęto próbę równa wartości spoza, zakres zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Gdy konsola najpierw zostanie otwarte okno, wartością domyślną <xref:System.Console.WindowLeft%2A> właściwości wynosi zero, co oznacza, że pierwszej kolumny, które są wyświetlane w konsoli programu odpowiada w pierwszej kolumnie (kolumna w pozycji zero) w obszarze buforu. Domyślną szerokość okna konsoli i obszar buforu to 80 kolumn. Oznacza to, że <xref:System.Console.WindowLeft%2A> właściwości można modyfikować tylko wtedy, gdy okno konsoli jest wykonywane mniejszą niż lub obszar bufor składa się szersze.  
  
 Należy pamiętać, że jeśli szerokość obszaru buforu przekracza szerokość okna konsoli, a wartość <xref:System.Console.WindowLeft%2A> właściwości jest automatycznie dostosowywany, gdy użytkownik używa poziomych pasków przewijania w celu zdefiniowania relacji okna do obszaru buforu.  
  
 Trwa próba skonfigurowania wartość <xref:System.Console.WindowLeft%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tej właściwości tylko wtedy, gdy <xref:System.Console.IsOutputRedirected%2A> właściwość zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie zostanie otwarte okno konsoli kolumny 80 i definiuje obszar buforu, który jest 120 kolumn. Wyświetla informacje o wielkości okna i buforu, a następnie czeka na zatwierdzenie użytkownika poprzez naciśnięcie klawisza Strzałka w lewo lub Strzałka w prawo. W pierwszym przypadku go zmniejsza wartość <xref:System.Console.WindowLeft%2A> właściwość, według jedną, jeśli wynik jest wartością prawnych. W tym ostatnim przypadku zwiększa wartość <xref:System.Console.WindowLeft%2A> właściwość, według jedną, jeśli wynik byłby prawnych. Należy zauważyć, że przykład nie będzie musiał obsługiwać <xref:System.ArgumentOutOfRangeException>, ponieważ sprawdza, czy wartość do przypisania do <xref:System.Console.WindowLeft%2A> właściwość nie jest ujemny i nie powoduje, że suma <xref:System.Console.WindowLeft%2A> i <xref:System.Console.WindowWidth%2A> właściwości, aby przekroczyć <xref:System.Console.BufferWidth%2A> wartość właściwości.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">W operacji zestawu wartość do przypisania jest mniejsza od zera.  
  
—lub— 
W wyniku przypisania <see cref="P:System.Console.WindowLeft" /> oraz <see cref="P:System.Console.WindowWidth" /> spowoduje przekroczenie <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia górną pozycję obszar okna konsoli względem buforu ekranu.</summary>
        <value>Położenie okna konsoli najwyższym mierzony w wierszach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konsolę reprezentuje okno programu prostokątnych w większy bufor prostokątny obszar. Okno i buforu są mierzone w pionie przez ich liczbę wierszy i w poziomie przez ich liczbę kolumn. Wymiary powierzchni buforu są definiowane przez <xref:System.Console.BufferHeight%2A> i <xref:System.Console.BufferWidth%2A> właściwości. Wymiary powierzchni konsoli są definiowane przez <xref:System.Console.WindowHeight%2A> i <xref:System.Console.WindowWidth%2A> właściwości. <xref:System.Console.WindowTop%2A> Właściwość określa, który wiersz obszar buforu jest wyświetlany w pierwszej kolumnie w oknie konsoli. Wartość <xref:System.Console.WindowTop%2A> właściwości mogą należeć do zakresu od 0 do <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Podjęto próbę równa wartości spoza, zakres zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Trwa próba skonfigurowania wartość <xref:System.Console.WindowTop%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątek, należy ustawić wartość tej właściwości tylko wtedy, gdy <xref:System.Console.IsOutputRedirected%2A> właściwość zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, i <xref:System.Console.CursorVisible%2A> właściwości; i <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, i <xref:System.Console.ReadKey%2A> metody. Przykład rysuje wzorca siatki w buforze ekranu, na podstawie szerokości buforu ekranu. Następnie przykład przesuwa okno konsoli w odpowiedzi, do której Strzałka w górę, naciśnięciu klawisza konsoli strzałkę w dół, Strzałka w lewo lub Strzałka w prawo. Wzorzec siatki ułatwia uzyskiwanie informacji przepływu w oknie konsoli względem buforu ekranu.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">W operacji zestawu wartość do przypisania jest mniejsza od zera.  
  
—lub— 
W wyniku przypisania <see cref="P:System.Console.WindowTop" /> oraz <see cref="P:System.Console.WindowHeight" /> spowoduje przekroczenie <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość okna konsoli.</summary>
        <value>Szerokość okna konsoli jest mierzona w kolumnach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trwa próba skonfigurowania wartość <xref:System.Console.WindowWidth%2A> właściwości, gdy dane wyjściowe są przekierowywane zgłasza albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.IO.IOException> wyjątku. Aby zapobiec wyjątkowi, należy ustawić wartość tej właściwości tylko wtedy, gdy <xref:System.Console.IsOutputRedirected%2A> właściwość zwraca `false`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono <xref:System.Console.SetWindowSize%2A> metody i <xref:System.Console.WindowWidth%2A> i <xref:System.Console.WindowHeight%2A> właściwości. Należy uruchomić przykład, aby wyświetlić pełną efekt zmiany rozmiaru okna konsoli.  
  
 Przykład raporty wymiary równa 43 wierszy i kolumn 85 okna konsoli, a następnie czeka na naciśnięcie klawisza. Po naciśnięciu dowolnego klawisza w filtrach są wymiary okna konsoli, nowe wymiary są zgłaszane i przykład czeka na naciśnięcie klawisza innego. Na koniec po naciśnięciu dowolnego klawisza w oknie konsoli zostaną przywrócone w swoich oryginalnych wymiarów i kończy się przykładu.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <see cref="P:System.Console.WindowWidth" /> właściwość lub wartość <see cref="P:System.Console.WindowHeight" /> właściwość jest mniejsze niż lub równe 0.  
  
—lub— 
Wartość <see cref="P:System.Console.WindowHeight" /> właściwości oraz wartość <see cref="P:System.Console.WindowTop" /> właściwość jest większa niż lub równa <see cref="F:System.Int16.MaxValue" />.  
  
—lub— 
Wartość <see cref="P:System.Console.WindowWidth" /> właściwość lub wartość <see cref="P:System.Console.WindowHeight" /> właściwości jest większa niż największa szerokość okna możliwe lub wysokość dla mierników bieżącą czcionkę konsoli i rozdzielczość ekranu.</exception>
        <exception cref="T:System.IO.IOException">Błąd podczas odczytywania lub zapisywania informacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje reprezentację tekstową z określoną wartością lub wartościami w standardowym strumieniu wyjściowym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określoną wartość logiczną reprezentację tekstową do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, która wysyła <xref:System.Boolean.TrueString?displayProperty=nameWithType> lub <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość znaku Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <summary>Zapisuje określoną tablicę znaków Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonym <see cref="T:System.Decimal" /> wartości do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określoną wartość zmiennoprzecinkową podwójnej precyzji w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Double.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonej 32-bitowe podpisane liczby całkowitej do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonej 64-bitowej podpisanej liczby całkowitej do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Int64.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisania, lub <see langword="null" />.</param>
        <summary>Zapisuje tekst reprezentujący określony obiekt do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, nic nie jest zapisywane i jest zgłaszany żaden wyjątek. W przeciwnym razie `ToString` metoda `value` jest wywoływana w celu wygenerowania jego reprezentację ciągu, a wynikowy ciąg jest zapisywany do strumienia wyjścia standardowego.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określoną wartość zmiennoprzecinkową o pojedynczej dokładności w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość ciągu do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest `null`, nic nie są zapisywane do strumienia wyjścia standardowego.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową wartości określonego 32-bitowej nieoznaczonej liczby całkowitej do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową wartości określonego 64-bitowej nieoznaczonej liczby całkowitej do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje tekst reprezentujący określony obiekt do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody do pokazania standardowych specyfikatorów liczb, dat i wyliczeń formatowania.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład ilustruje użycie <xref:System.Console.Write%2A> metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg">Tablica obiektów przy użyciu <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową z określonej tablicy obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `arg` Parametr jest tablicą parametrów. Argumenty można przekazać do metody w postaci tablicy lub jako wykaz pięć lub więcej elementów. W przykładach pokazano oba rodzaje wywołania metody.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy z liczbą właściwości, które dostarczają informacji na temat osoby. Jego `GetDescription` metoda zwraca tablicę zawierającą wszystkie wartości właściwości, z wyjątkiem jednego. Następnie w przykładzie wykorzystano tablica zwrócona przez `GetDescription` metodę, aby wyświetlić wartości obiektu osoba.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Należy pamiętać, że w przykładzie <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> metody zamiast <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> metody ponieważ próbuje wyświetlić wartość `Person.Remarks` właściwości w tym samym wierszu. Aby to zrobić, sprawdza, czy wartość <xref:System.Console.CursorLeft%2A> i <xref:System.Console.WindowWidth%2A> właściwości w celu określenia, czy jest za mało miejsca dla uwagi w celu dopasowania.  Jeśli, wyświetla wiersz. W przeciwnym razie go zapisuje linii, wcięcia trzech miejsc do magazynowania i wyświetla uwagi.  
  
 Poniższy przykład jest identyczny z pierwszym, z tą różnicą, że dostarcza mu pięciu elementu listy jako `arg` argument zamiast tablicy parametrów.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> lub <paramref name="arg" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Ta metoda nie jest wywoływana przez kod języka C++. Kompilator języka C++ jest rozpoznawana jako wywołania [System.Console.Write](xref:System.Console.Write*) zawierające ciągu oraz listę parametrów obiektu co najmniej cztery jako wywołanie <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Rozpoznaje wywołania [System.Console.Write](xref:System.Console.Write*) zawierające ciąg i Tablica obiektów jako wywołanie <see cref="M:System.Console.Write(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <param name="index">Pozycja początkowa w <paramref name="buffer" />.</param>
        <param name="count">Liczba znaków, jaka ma zostać zapisana.</param>
        <summary>Zapisuje określony element członkowski podtablicy znaków Unicode w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje `count` znaków, zaczynając od pozycji `index` z `buffer` do standardowego strumienia wyjściowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> plus <paramref name="count" /> określić położenie, który nie jest w ramach <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową z określonych obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody do pokazania standardowych specyfikatorów liczb, dat i wyliczeń formatowania.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg2">Trzeci obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową z określonych obiektów do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `WriteLine` metody do pokazania standardowych specyfikatorów liczb, dat i wyliczeń formatowania.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład ilustruje użycie `Write` metody.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg2">Trzeci obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg3">Czwarty obiekt do zapisania, za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową określone obiekty i listy parametrów o zmiennej długości do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze specyfikacją CLS to <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie parametrów zmiennych z <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody. Metoda jest wywoływana z ciąg formatu złożonego i pięć elementów formatu.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Ta metoda jest oznaczona za pomocą <see langword="vararg" /> — słowo kluczowe, co oznacza, że obsługuje ona zmienną liczbę parametrów. Metoda może być wywoływana z Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory C# i Visual Basic rozwiązać wywołania do <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> jako wywołania <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określone dane, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślną jest ciąg, którego wartością jest znak powrotu karetki i wysuwu wiersza ("\r\n" w języku C# lub `vbCrLf` w języku Visual Basic). Terminator wiersza można zmienić, określając <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> właściwości do innego ciągu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje bieżący terminator wiersza w standardowym strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślną jest ciąg, którego wartością jest znak powrotu karetki i wysuwu wiersza ("\r\n" w języku C# lub `vbCrLf` w języku Visual Basic). Terminator wiersza można zmienić, określając <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwość <xref:System.Console.Out%2A> właściwości do innego ciągu. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 W przykładzie zmienił terminator wiersza z jego wartość domyślna "\r\n" lub `vbCrLf` do "\r\n\r\n" lub `vbCrLf`  +  `vbCrLf`. Następnie wywołuje <xref:System.Console.WriteLine> i <xref:System.Console.WriteLine%28System.String%29> metody, aby wyświetlić dane wyjściowe do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określoną wartość logiczną, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład generuje dziesięć losowych liczb całkowitych i używa <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> metodę w celu wskazania, czy są one jeszcze.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określony znak Unicode, a następnie terminator wiersza z bieżącej wartości do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <summary>Zapisuje określoną tablicę znaków Unicode, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonym <see cref="T:System.Decimal" /> wartości, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonym podwójnej precyzji wartość zmiennoprzecinkowa, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Double.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonej 32-bitowe podpisane liczby całkowitej, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonej 64-bitowej podpisanej liczby całkowitej, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Int64.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonego obiektu, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, są zapisywane tylko terminator wiersza. W przeciwnym razie `ToString` metoda `value` jest wywoływana w celu wygenerowania jego reprezentację ciągu, a wynikowy ciąg jest zapisywany do strumienia wyjścia standardowego.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Console.WriteLine%28System.Object%29> metodę w celu wyświetlenia każdej wartości w tablicy obiektu do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową z określonym pojedynczej precyzji wartość zmiennoprzecinkowa, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje określona wartość ciągu, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest `null`, tylko terminator wiersza są zapisywane do strumienia wyjścia standardowego.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine> metody.  
  
   
  
## Examples  
 W przykładzie zmienił terminator wiersza z jego wartość domyślna "\r\n" lub `vbCrLf` do "\r\n\r\n" lub `vbCrLf`  +  `vbCrLf`. Następnie wywołuje <xref:System.Console.WriteLine> i <xref:System.Console.WriteLine%28System.String%29> metody, aby wyświetlić dane wyjściowe do konsoli.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową wartości określonego 32-bitowej nieoznaczonej liczby całkowitej, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje reprezentację tekstową wartości określonego 64-bitowej nieoznaczonej liczby całkowitej, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tekstowa reprezentacja `value` jest generowany przez wywołanie metody <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową z określonego obiektu, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> metodę, aby wyświetlić pięć losowo generowany <xref:System.Boolean> wartości.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 Poniższy przykład wywołuje <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> metodę, aby wyświetlić bieżącą datą.   Należy zauważyć, że format elementu w `format` argumentu "D" [ciąg formatu standardowego daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Aby wyświetlić datę w formacie daty długiej bieżącej kultury.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg">Tablica obiektów przy użyciu <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową z określonej tablicy obiektów, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> lub <paramref name="arg" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Ta metoda nie jest wywoływana przez kod języka C++. Kompilator języka C++ jest rozpoznawana jako wywołania [System.Console.WriteLine](xref:System.Console.WriteLine*) zawierające ciągu oraz listę parametrów obiektu co najmniej cztery jako wywołanie <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Rozpoznaje wywołania [System.Console.WriteLine](xref:System.Console.WriteLine*) zawierające ciąg i Tablica obiektów jako wywołanie <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków Unicode.</param>
        <param name="index">Pozycja początkowa w <paramref name="buffer" />.</param>
        <param name="count">Liczba znaków, jaka ma zostać zapisana.</param>
        <summary>Zapisuje określony element członkowski podtablicy znaków Unicode, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje `count` znaków, zaczynając od pozycji `index` z `buffer` do standardowego strumienia wyjściowego.  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> plus <paramref name="count" /> określić położenie, który nie jest w ramach <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową określone obiekty, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg2">Trzeci obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową określone obiekty, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje standardowe specyfikatory formatowania liczb, dat i wyliczeń.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Poniższy przykład to Kalkulator napiwków oblicza Porada 18%, a następnie używa <xref:System.Console.WriteLine%2A> metodę w celu wyświetlenia kwota należności, kwotę napiwku i łącznej kwoty. W przykładzie występuje aplikacja konsoli, która wymaga, aby użytkownik podał kwotę bazowej należności jako parametr wiersza polecenia.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg1">Drugi obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg2">Trzeci obiekt do zapisania za pomocą <paramref name="format" />.</param>
        <param name="arg3">Czwarty obiekt do zapisania, za pomocą <paramref name="format" />.</param>
        <summary>Zapisuje reprezentację tekstową określone obiekty i listy parametrów o zmiennej długości, następuje bieżącego terminator wiersza do standardowego strumienia wyjściowego przy użyciu informacji o określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten interfejs API nie jest zgodny ze specyfikacją CLS. Alternatywa zgodna ze specyfikacją CLS to <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Kompilatory C# i Visual Basic automatycznie rozwiązać wywołania do tej metody jako wywołanie <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w ciągu. Wynikowy ciąg jest zapisywany do strumienia wyjściowego.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają obiektowi na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu tekstową reprezentacja wartości odpowiedniego obiektu.  
  
 Składnia elementu formatu jest `{` *indeksu*[`,`*wyrównanie*] [`:`*formatString*]`}`, która określa obowiązkowy indeks, opcjonalna długość i wyrównanie sformatowanego tekstu oraz opcjonalny ciąg znaków specyfikatora formatu, które określają sposób formatowania wartości odpowiedniego obiektu.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat funkcji formatowania złożonego obsługiwanych przez metody takie jak <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, a niektóre przeciążenia <xref:System.Console.WriteLine%2A>, zobacz [formatowania złożonego](~/docs/standard/base-types/composite-formatting.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat daty i godziny, specyfikatory formatu, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Aby uzyskać więcej informacji na temat terminatora wiersza, zobacz sekcję Uwagi <xref:System.Console.WriteLine%2A> metodę, która nie przyjmuje żadnych parametrów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie zmiennych argumentów <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody. Metoda jest wywoływana z ciąg formatu złożonego i pięć elementów formatu.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Specyfikacja formatu w <paramref name="format" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Modyfikowanie bezpiecznych okien najwyższego poziomu i okien podrzędnych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Ta metoda jest oznaczona za pomocą <see langword="vararg" /> — słowo kluczowe, co oznacza, że obsługuje ona zmienną liczbę parametrów. Metoda może być wywoływana z Visual C++, ale nie można wywołać z kodu C# lub Visual Basic. Kompilatory C# i Visual Basic rozwiązać wywołania do <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> jako wywołania <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
      </Docs>
    </Member>
  </Members>
</Type>
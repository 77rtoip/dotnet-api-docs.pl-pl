<Type Name="DateTime" FullName="System.DateTime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="17335cf7a00859f035135c41af24fcd3718d5ca9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36434299" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DateTime extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.DateTime&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.DateTime&gt;, class System.IFormattable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.DateTime" />
  <TypeSignature Language="VB.NET" Value="Public Structure DateTime&#xA;Implements IComparable, IComparable(Of DateTime), IConvertible, IEquatable(Of DateTime), IFormattable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type DateTime = struct&#xA;    interface IFormattable&#xA;    interface IConvertible&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje moment w czasie, zwykle wyrażone jako datę i godzinę.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## <a name="quick-links-to-example-code"></a>Szybkie linki do przykładowy kod

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Ten artykuł zawiera kilka przykładów, które używają `DateTime` typu:

**Przykłady inicjowania**      
 [Wywołanie konstruktora](#initialization-01)     
 [Wywołanie konstruktora domyślnego niejawne](#initialization-02)     
 [Przypisanie z wartości zwracanej](#initialization-03)     
 [Podczas analizowania ciąg reprezentujący datę i godzinę](#initialization-04)     
 [Składnia języka Visual Basic zainicjować daty i godziny](#initialization-05)     

**Formatowanie `DateTime` obiekty jako ciągi**  
 [Użyj domyślny format daty i godziny](#formatting-01)     
 [Format daty i godziny, używając określonej kultury](#formatting-02)     
 [Format daty godziny przy użyciu ciągu formatu standardowych lub niestandardowych](#formatting-03)     
 [Określ parametry ciągu formatu i określoną kulturę](#formatting-04)     
 [Format daty godziny przy użyciu standardu ISO 8601 dla usług sieci web](#formatting-05)     

**Analizowanie ciągów jako `DateTime` obiektów**  
 [Użyj `Parse` lub `TryParse` do przekonwertowania ciągu na datę i godzinę](#parsing-01)     
 [Użyj `ParseExact` lub `TryParseExact` można przekonwertować na ciąg w formacie znane](#parsing-02)     
 [Konwertowanie ISO 8601 reprezentacja ciągu na datę i godzinę](#parsing-03)     

**`DateTime` Rozdzielczość**  
 [Eksploruj rozpoznawanie wartości daty i godziny](#resolution-01)     
 [Porównywanie równości w granicach tolerancji](#comparison-01)     

**Kultura i kalendarzy**  
 [Wyświetl wartości daty i godziny przy użyciu kalendarzy określonej kultury](#calendars-01)     
 [Analizowanie ciągów kalendarza określonej kultury](#calendars-02)     
 [Inicjowanie datę i godzinę, z określoną kulturę kalendarza](#calendars-03)     
 [Uzyskiwanie dostępu do właściwości daty i godziny przy użyciu określonej kultury kalendarza](#calendars-04)     
 [Trwa pobieranie tydzień roku przy użyciu kalendarzy określonej kultury](#calendars-05)     

**Trwałość**  
 [Utrwalanie wartości daty i godziny jako ciągi w lokalnej strefie czasowej](#persistence-01)     
 [Utrwalanie wartości daty i godziny jako ciąg w formacie Niezmienna kultura i czas](#persistence-02)     
 [Utrwalanie wartości daty i godziny jako liczby całkowite](#persistence-03)     
 [Utrwalanie Data i godzina wartości przy użyciu `XmlSerializer`](#persistence-04)     
 [Utrwalanie Data i godzina wartości przy użyciu `BinaryFormatter`](#persistence-05)     
 [Strefa czasowa danych trwałych wartości daty i godziny](#persistence-06)     

## <a name="quick-links-to-remarks-topics"></a>Szybkie linki do tematów uwagi.

Ta sekcja zawiera tematy dotyczące wielu typowych zastosowań `DateTime` struktury:
  
 [Inicjowanie `DateTime` obiektu](#initializing-a-datetime-object)   
 [Wartości daty/godziny i ich reprezentacji ciągu](#datetime-values-and-their-string-representations)   
 [Analizowanie wartości daty/godziny z ciągów](#parsing-datetime-values-from-strings)   
 [Wartości daty/godziny](#datetime-values)   
 [Operacje daty i godziny](#datetime-operations)   
 [Rozpoznawanie daty i godziny](#datetime-resolution)   
 [Wartości typu DateTime i kalendarzy](#datetime-values-and-calendars)   
 [Utrwalanie wartości daty/godziny](#persisting-datetime-values)   
 [Vs daty/godziny. TimeSpan](#datetime-vs-timespan)   
 [Porównywanie równości w granicach tolerancji](#comparing-for-equality-within-tolerance) [zagadnienia dotyczące współdziałania COM](#com-interop-considerations)  
   
<xref:System.DateTime> Typ wartości reprezentuje daty i godziny z wartości z zakresu od 00:00:00 (północ), 1 stycznia 0001 Anno Domini (typowe Era) za pośrednictwem 11:59:59 PM, 31 grudnia 9999 r. (R) w kalendarza gregoriańskiego.  
  
Wartości czasu są mierzone w jednostkach 100-nanosekundowych o nazwie znaczniki osi. Określonej daty to liczbę taktów od momentu 12:00, a 1 stycznia, 0001 r. N.E. (R) w <xref:System.Globalization.GregorianCalendar> kalendarza. Liczba nie obejmuje Takty dodanych sekund przestępnym. Na przykład wartość impulsów 31241376000000000L reprezentuje piątek, 01 stycznia 0100 daty północy 12:00:00. A <xref:System.DateTime> wartość jest zawsze wyrażona w kontekście jawnego lub domyślna kalendarz.  
  
> [!NOTE]
>  Jeśli pracujesz z wartość impulsów, że ma zostać przekonwertowany na niektóre inne interwał czasu, takich jak minut i sekund, należy użyć <xref:System.TimeSpan.TicksPerDay?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerHour?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerMinute?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerSecond?displayProperty=nameWithType>, lub <xref:System.TimeSpan.TicksPerMillisecond?displayProperty=nameWithType> stała, aby dokonać konwersji. Na przykład, aby dodać liczbę sekund reprezentowany przez określoną liczbę znaczniki osi <xref:System.DateTime.Second%2A> składnika <xref:System.DateTime> wartości, można użyć wyrażenia `dateValue.Second + nTicks/Timespan.TicksPerSecond`.  

Źródło dla całego zestawu przykłady z tego artykułu można wyświetlić w jednym [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/) lub [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/) z repozytorium dokumentów w witrynie GitHub.

> [!NOTE]
>  Zamiast <xref:System.DateTime> struktury Praca z wartości daty i godziny w szczególności strefach czasowych jest <xref:System.DateTimeOffset> struktury. <xref:System.DateTimeOffset> Struktury przechowuje informacje o datę i godzinę w prywatnej <xref:System.DateTime> pola i liczbę minut, przez które które daty i godziny różni się od czasu UTC w prywatnym <xref:System.Int16> pola. Dzięki temu dla <xref:System.DateTimeOffset> wartość do uwzględnienia czasu, w szczególności strefie czasowej, natomiast <xref:System.DateTime> wartość jednoznacznie można uwzględnić tylko UTC oraz czas lokalnej strefy czasowej. Aby uzyskać informacje o tym, kiedy należy używać <xref:System.DateTime> struktury lub <xref:System.DateTimeOffset> struktury podczas pracy z wartości daty i godziny, zobacz [wybór pomiędzy DateTime, DateTimeOffset, TimeSpan i TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md).  
  
### <a name="initializing-a-datetime-object"></a>Podczas inicjowania obiektu daty i godziny  

Wartość początkowa można przypisać do nowego `DateTime` wartość na wiele sposobów:

- Wywołanie konstruktora, jedną której określić argumenty dla wartości, lub użyj konstruktora domyślnego niejawnej.
- Przypisywanie `DateTime` do zwracanych wartości właściwości lub metody.
- Podczas analizowania `DateTime` wartość z reprezentacji ciągu.
- Korzystanie z funkcji języka Visual Basic można utworzyć wystąpienia `DateTime`. 

Poniższe fragmenty kodu przedstawiają przykłady każdego z nich:

#### <a name="invoke-constructors"></a>Wywołania konstruktorów

Należy wywołać dowolną z przeciążeń <xref:System.DateTime> Konstruktor, który określania elementów wartość daty i godziny (np. rok, miesiąc i dzień lub liczbę taktów). Poniższy kod tworzy przy użyciu określonej daty <xref:System.DateTime> konstruktora, określając rok, miesiąc, godzinę, minutę i sekundę.  

<a name="initialization-01"></a> [!code-vb[System.DateTime.Instantiation#1](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#1)]  
[!code-csharp-interactive[System.DateTime.Instantiation#1](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#1)]

Wywołuje się `DateTime` struktury niejawne domyślnego konstruktora należy `DateTime` zainicjowany do wartości domyślnej. (Aby uzyskać szczegółowe informacje na niejawne domyślny konstruktor obiektu typu wartości, zobacz [typów wartości](~/docs/csharp/language-reference/keywords/value-types.md).) Niektóre kompilatory również obsługiwać deklarowanie <xref:System.DateTime> wartość bez jawnego przypisywanie wartości do niego. Powoduje również utworzenie wartość bez jawnego inicjowania wartości domyślnej. Poniższy przykład przedstawia <xref:System.DateTime> niejawne domyślnego konstruktora w języku C# i Visual Basic, a także <xref:System.DateTime> deklaracja bez przypisania w języku Visual Basic.  

<a name="initialization-02"></a> [!code-vb[System.DateTime.Instantiation#5](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#5)]  
[!code-csharp-interactive[System.DateTime.Instantiation#5](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#5)]
    
#### <a name="assigning-a-computed-value"></a>Przypisywanie obliczona wartość

Można przypisać <xref:System.DateTime> obiektów zwrócona przez właściwość lub metoda wartość daty i godziny. W poniższym przykładzie przypisano bieżącej daty i czasu, bieżącą datę w formacie uniwersalnego czasu koordynowanego (UTC) i czas i bieżącą datę do trzech nowych <xref:System.DateTime> zmiennych.  

<a name="initialization-03"></a> [!code-vb[System.DateTime.Instantiation#3](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#3)]  
[!code-csharp[System.DateTime.Instantiation#3](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#3)]

#### <a name="parsing-a-string-that-represents-a-datetime"></a>Podczas analizowania ciąg reprezentujący wartości daty i godziny

<xref:System.DateTime.Parse%2A>, <xref:System.DateTime.ParseExact%2A>, <xref:System.DateTime.TryParse%2A>, I <xref:System.DateTime.TryParseExact%2A> wszystkie metody konwertowanie ciągu na jej odpowiednik wartość daty i godziny. W poniższych przykładach użyto <xref:System.DateTime.Parse%2A> i <xref:System.DateTime.ParseExact%2A> metody do analizowania i przekonwertować go na <xref:System.DateTime> wartość. Format drugi używa formularza obsługiwane przez [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard reprezentująca datę i godzinę w formacie ciągu. Taka reprezentacja standardowego jest często używane do przekazywania informacji daty w usługach sieci web.

<a name="initialization-04"></a> [!code-vb[System.DateTime.Instantiation#4](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#4)]  
[!code-csharp[System.DateTime.Instantiation#4](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#4)]

<xref:System.DateTime.TryParse%2A> i <xref:System.DateTime.TryParseExact%2A> metody wskazuje, czy ciąg jest nieprawidłowa reprezentacja <xref:System.DateTime> wartość, a jeśli tak jest, wykonuje konwersję.  

#### <a name="language-specific-syntax-for-visual-basic"></a>Składnia specyficzny dla języka Visual Basic

Inicjuje nowy następującą instrukcję języka Visual Basic <xref:System.DateTime> wartość.  

<a name="initialization-05"></a> [!code-vb[System.DateTime.Instantiation#2](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#2)]  

### <a name="datetime-values-and-their-string-representations"></a>Wartości daty/godziny i ich reprezentacji ciągu  

Wewnętrznie, wszystkie <xref:System.DateTime> wartości są reprezentowane jako liczbę znaczników (Liczba 100-nanosekundowych interwałów), które upłynęły od północy 12:00:00 1 stycznia 0001. Rzeczywiste <xref:System.DateTime> niezależnie od sposobu, w którym ta wartość jest wyświetlany, gdy wyświetlana jest wartość. Wygląd <xref:System.DateTime> wartość jest wynik operacji formatowania, który konwertuje wartości do reprezentacji ciągu.  
  
Wyświetlanie wartości daty i godziny jest zależna od kultury, międzynarodowe standardy, wymagania dotyczące aplikacji i osobistych preferencji. <xref:System.DateTime> Struktura zapewnia elastyczność w formatowaniu wartości daty i godziny za pomocą przeciążenia metody <xref:System.DateTime.ToString%2A>. Wartość domyślna <xref:System.DateTime.ToString?displayProperty=nameWithType> metoda zwraca reprezentację ciągu przy użyciu bieżącej kultury krótkiej daty i długi czas wzorzec wartość daty i godziny. W poniższym przykładzie użyto domyślnie <xref:System.DateTime.ToString?displayProperty=nameWithType> metody. Wyświetla datę i godzinę za pomocą krótkiej daty i długi czas wzorzec dla bieżącej kultury. Kultura en US jest bieżącej kultury, na komputerze, na którym uruchomiono przykładzie.  
  
<a name="formatting-01"></a> [!code-csharp-interactive[System.DateTime.Formatting#1](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#1)]
[!code-vb[System.DateTime.Formatting#1](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#1)]  

Konieczne może być formatowania dat w określonej kultury na potrzeby obsługi scenariuszy sieci web, których serwer może być w inną kulturę od klienta. Należy określić przy użyciu kultury <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę w celu utworzenia daty krótkiej i długi czas reprezentacja w określonej kultury. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby wyświetlić datę i godzinę, przy użyciu krótkiej daty i długi czas wzorca dla kultury fr-FR.  
  
<a name="formatting-02"></a> [!code-csharp-interactive[System.DateTime.Formatting#2](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#2)]
[!code-vb[System.DateTime.Formatting#2](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#2)]  

 Inne aplikacje mogą wymagać reprezentacje inny ciąg daty. <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> Metoda zwraca ciąg reprezentujący zdefiniowane przez specyfikator formatu standardowych lub niestandardowych przy użyciu konwencji formatowania bieżącej kultury. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metodę w celu wyświetlenia pełnej daty i czasu wzorzec en US kultury bieżącej kultury, na komputerze, na którym uruchomiono przykładzie.  
  
<a name="formatting-03"></a> [!code-csharp-interactive[System.DateTime.Formatting#3](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#3)]
[!code-vb[System.DateTime.Formatting#3](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#3)]  

 Ponadto można określić culture i format za pomocą <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę w celu wyświetlenia pełnej daty i czasu wzorca dla kultury fr-FR.  

<a name="formatting-04"></a> [!code-csharp-interactive[System.DateTime.Formatting#4](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#4)]
[!code-vb[System.DateTime.Formatting#4](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#4)]  

<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> Przeciążenia można również zawierające ciąg formatu niestandardowego do określenia formatów. Poniższy przykład przedstawia formatującej ciąg za pomocą [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) formatem często używanych na potrzeby usług sieci web. W formacie Iso 8601 nie ma odpowiedniego ciągu standardowym formacie.

<a name="formatting05"></a> [!code-csharp-interactive[System.DateTime.Formatting#5](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#5)]
[!code-vb[System.DateTime.Formatting#5](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#5)]  

Aby uzyskać więcej informacji na temat formatowania <xref:System.DateTime> wartości, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  

### <a name="parsing-datetime-values-from-strings"></a>Analizowanie wartości daty/godziny z ciągów

Podczas analizowania konwertuje reprezentację ciągu daty i godziny do <xref:System.DateTime> wartości. Zazwyczaj ciągi daty i godziny są dwie różne metody użycia w aplikacjach:  
  
-   Data i godzina ma różne formy i odzwierciedla konwencje bieżącej kultury lub określoną kulturę. Na przykład aplikacja pozwala użytkownikowi którego bieżącej kultury jest en US, aby wprowadzić wartość daty "12/15/2013" lub "Grudnia 15 maja 2013 r". Umożliwia użytkownika, którego bieżącej kultury jest pl pl. wprowadzanie wartości daty "12/15/2013" lub "15 grudniu 2013."  
  
-   Data i godzina jest reprezentowane w formacie wstępnie zdefiniowane. Na przykład aplikacja serializuje daty w postaci "20130103", niezależnie od kultury, na którym jest uruchomiona aplikacja. Aplikacja może wymagać dat należy wprowadzić w formacie daty krótkiej bieżącej kultury.
  
Możesz użyć <xref:System.DateTime.Parse%2A> lub <xref:System.DateTime.TryParse%2A> metody do przekonwertowania ciągu na jednym z typowych formatów daty i godziny używany przez kultury do <xref:System.DateTime> wartości. W poniższym przykładzie pokazano, jak używasz <xref:System.DateTime.TryParse%2A> do konwertowania ciągów daty w różnych formatach specyficzne dla kultury do <xref:System.DateTime> wartości. Zmienia bieżącej kultury angielski (Polska) i wywołania <xref:System.DateTime.GetDateTimeFormats> metody do wygenerowania tablica ciągów daty i godziny. Następnie przekazuje każdego elementu w tablicy, tak aby <xref:System.DateTime.TryParse%2A> metody. Dane wyjściowe w przykładzie przedstawiono metodę analizowania udało się pomyślnie skonwertować wszystkich specyficzne dla kultury ciągów daty i godziny.  
  
<a name="parsing-01"></a> [!code-csharp-interactive[System.DateTime.Parsing#1](~/samples/snippets/csharp/System.DateTime/Parsing.cs#1)]
[!code-vb[System.DateTime.Parsing#1](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#1)]  

Możesz użyć <xref:System.DateTime.ParseExact%2A> i <xref:System.DateTime.TryParseExact%2A> metod można przekonwertować na ciąg, który musi odpowiadać określony format lub formaty <xref:System.DateTime> wartość. Należy określić co najmniej jeden ciągi daty i czasu format jako parametr do metody analizy. W poniższym przykładzie użyto <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metodę, aby przekonwertować ciągów, które muszą być w formacie "RRRRMMDD" lub "HHmmss" format <xref:System.DateTime> wartości.  
  
<a name="parsing-02"></a> [!code-csharp-interactive[System.DateTime.Parsing#2](~/samples/snippets/csharp/System.DateTime/Parsing.cs#2)]
[!code-vb[System.DateTime.Parsing#2](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#2)]  

Jeden użycia <xref:System.DateTime.ParseExact%2A> polega na konwertowaniu reprezentacji w postaci ciągu z usługi sieci web, zazwyczaj w [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standardowym formacie. Poniższy kod przedstawia parametry poprawnego formatu do użycia:

<a name="parsing-03"></a> [!code-csharp-interactive[System.DateTime.Parsing#3](~/samples/snippets/csharp/System.DateTime/Parsing.cs#3)]
[!code-vb[System.DateTime.Parsing#3](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#3)]  

Jeśli nie można przeanalizować ciągu, <xref:System.DateTime.Parse%2A> i <xref:System.DateTime.ParseExact%2A> metody zgłoszenia wyjątku. <xref:System.DateTime.TryParse%2A> i <xref:System.DateTime.TryParseExact%2A> metody zwracają <xref:System.Boolean> wartość wskazującą, czy konwersja powiodła się czy nie. Należy używać <xref:System.DateTime.TryParse%2A> lub <xref:System.DateTime.TryParseExact%2A> metod w scenariuszach, w których wydajności jest ważna. Podczas analizowania operacji dla ciągów daty i godziny zwykle współczynnik awaryjności wysokiej i obsługi wyjątków jest kosztowna. Użyj tych metod, jeśli ciągi są wejściowych przez użytkowników lub pochodzi z nieznanego źródła. 
  
Aby uzyskać więcej informacji na temat analizowania wartości daty i godziny, zobacz [ciągów analizowania daty i godziny](~/docs/standard/base-types/parsing-datetime.md).  

### <a name="datetime-values"></a>Wartości typu DateTime

Opisy wartości czasu w <xref:System.DateTime> typu są często wyrażane przy użyciu standardu uniwersalny czas koordynowany (UTC). Uniwersalny czas koordynowany jest nazwą uznanych czas uniwersalny Greenwich (GMT). Uniwersalny czas koordynowany to czas mierzony na zerowej długości stopni, punktem początkowym UTC. Czas letni nie jest stosowana na czas UTC.  
  
Czas lokalny jest określana względem daną strefę czasową. Strefa czasowa jest skojarzony z przesunięcia strefy czasowej. Przesunięcie strefy czasowej jest przesunięcie strefy czasowej, wartość jest podawana w godzinach od punktu pochodzenia UTC. Ponadto czasu lokalnego, opcjonalnie dotyczy czasu letniego, które zwiększa lub zmniejsza regulacji interwał czasu. Czas lokalny jest obliczany przez dodanie przesunięcia strefy czasowej UTC i dopasowywanie czasu w razie potrzeby. Przesunięcie strefy czasowej w miejscu pochodzenia UTC wynosi zero.  
  
Czas UTC jest odpowiednia do obliczeń, porównania i przechowywania daty i godziny w plikach. Czas lokalny jest odpowiednia do wyświetlania na interfejsy użytkownika aplikacji klasycznych. Strefa czasowa aplikacjami (np. wiele aplikacji sieci Web) muszą pracować z wieloma innymi stref czasowych.  
  
Jeśli <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, jest nieokreślony, w czy czas reprezentowany jest czasu lokalnego, czasu UTC lub czasu w innych strefy czasowej.  

### <a name="datetime-resolution"></a>Rozpoznawanie daty i godziny
  
> [!NOTE]
>  Jako alternatywę do wykonania na arytmetyczne daty i czasu <xref:System.DateTime> wartości do mierzenia czas, który upłynął, można użyć <xref:System.Diagnostics.Stopwatch> klasy.  
  
<xref:System.DateTime.Ticks%2A> Właściwość wyraża wartości daty i godziny w jednostkach co 10 milionowych sekundy. <xref:System.DateTime.Millisecond%2A> Właściwość zwraca tysięczne drugiej wartości daty i godziny. Przy użyciu powtarzane wywołania <xref:System.DateTime.Now%2A?displayProperty=nameWithType> właściwości do mierzenia czas jest zależna od zegara systemowego. Zegar systemowy w systemach Windows 7 i Windows 8 ma rozdzielczość około 15 milisekund. To rozwiązanie ma wpływ na przedziały czasu małych mniej niż 100 MS. 
  
Poniższy przykład przedstawia zależność wartości bieżącej daty i godziny na podstawie rozdzielczości zegara systemowego. W tym przykładzie zewnętrzne pętli powtarza 20 razy, i wewnętrzny pętli służy do opóźnienia zewnętrzne pętli. Jeśli wartość licznika pętli zewnętrzne wynosi 10, wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody opóźnienia pięciu milisekund. Poniższy przykład przedstawia liczbę milisekund zwrócony przez `DateTime.Now.Milliseconds` właściwości zostanie zmieniona tylko po wywołaniu <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>.  

<a name="resolution-01"></a> [!code-csharp-interactive[System.DateTime.Resolution#1](~/samples/snippets/csharp/System.DateTime/Resolution.cs#1)]
[!code-vb[System.DateTime.Resolution#1](~/samples/snippets/visualbasic/System.DateTime/Resolution.vb#1)]  

### <a name="datetime-operations"></a>Operacje typu DateTime  

Obliczanie przy użyciu <xref:System.DateTime> struktury, takich jak <xref:System.DateTime.Add%2A> lub <xref:System.DateTime.Subtract%2A>, nie modyfikuje wartość struktury. Zamiast tego obliczenia zwraca nową <xref:System.DateTime> struktury, którego wartość jest wynikiem obliczenia.  
  
Operacje konwersji między strefami czasowymi (np. między czasem UTC a lokalnym lub między strefami czasowymi) uwzględnienia czasu letniego, ale operacje arytmetyczne i porównania nie.  
  
<xref:System.DateTime> Struktury sam oferuje ograniczoną obsługę do konwertowania z jedną strefę czasową. Można użyć <xref:System.DateTime.ToLocalTime%2A> metoda konwersji UTC na czas lokalny lub użytkownik może używać <xref:System.DateTime.ToUniversalTime%2A> metodę, aby przekonwertować od lokalnego czasu na czas UTC. Jednak pełny zestaw metod konwersji strefy czasowej jest dostępna w <xref:System.TimeZoneInfo> klasy. Czas w jednym stref czasowych na świecie konwersji na czas w innych strefy czasowej, za pomocą tych metod.  
  
Obliczenia i porównania <xref:System.DateTime> obiekty mają znaczenie tylko wtedy, gdy obiekty reprezentują razy w tej samej strefie czasowej. Można użyć <xref:System.TimeZoneInfo> obiektu do reprezentowania <xref:System.DateTime> wartości czasu strefy, mimo że dwa są luźno powiązane. A <xref:System.DateTime> obiekt nie ma właściwości, która zwraca obiekt reprezentujący tej daty i godziny wartości strefy czasowej. <xref:System.DateTime.Kind%2A> Właściwość wskazuje, czy `DateTime` reprezentuje UTC, czas lokalny lub nieokreślona. W aplikacji obsługujących strefę czasową, konieczne jest zastosowanie mechanizmu zewnętrznych, aby określić strefę czasową, w którym <xref:System.DateTime> obiekt został utworzony. Można użyć struktury, która opakowuje zarówno <xref:System.DateTime> wartość i <xref:System.TimeZoneInfo> obiekt, który reprezentuje <xref:System.DateTime> wartości strefy czasowej. Aby uzyskać szczegółowe informacje o użyciu czasu UTC w obliczeniach i porównania z <xref:System.DateTime> wartości, zobacz [wykonywania operacje arytmetyczne przy użyciu daty i godziny](~/docs/standard/datetime/performing-arithmetic-operations.md).  
  
Każdy <xref:System.DateTime> elementu członkowskiego niejawnie korzysta z kalendarza gregoriańskiego do wykonania tej operacji. Wyjątki są metody, które jawnie określić kalendarz. Obejmują one konstruktorów Określ kalendarz i metody z parametrem pochodzące z <xref:System.IFormatProvider>, takich jak <xref:System.Globalization.DateTimeFormatInfo?displayProperty=nameWithType>.  
  
Działania członków <xref:System.DateTime> typu uwzględnia szczegóły konta, takich jak przestępnego i liczbę dni w miesiącu.  

## <a name="datetime-values-and-calendars"></a>Wartości typu DateTime i kalendarzy  

Biblioteka klas programu .NET Framework zawiera szereg klas kalendarz, z których pochodzą od <xref:System.Globalization.Calendar> klasy.  Są to:  
  
-   <xref:System.Globalization.ChineseLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.EastAsianLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.GregorianCalendar> Klasy.  
-   <xref:System.Globalization.HebrewCalendar> Klasy.  
-   <xref:System.Globalization.HijriCalendar> Klasy.  
-   <xref:System.Globalization.JapaneseCalendar> Klasy.  
-   <xref:System.Globalization.JapaneseLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.JulianCalendar> Klasy.  
-   <xref:System.Globalization.KoreanCalendar> Klasy.  
-   <xref:System.Globalization.KoreanLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.PersianCalendar> Klasy.  
-   <xref:System.Globalization.TaiwanCalendar> Klasy.  
-   <xref:System.Globalization.TaiwanLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.ThaiBuddhistCalendar> Klasy.  
-   <xref:System.Globalization.UmAlQuraCalendar> Klasy.  
  
Każdej kultury używa domyślnego kalendarza wynika z jego tylko do odczytu <xref:System.Globalization.CultureInfo.Calendar%2A?displayProperty=nameWithType> właściwości. Każdy kultury może obsługiwać jeden lub więcej kalendarzy wynika z jego tylko do odczytu <xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType> właściwości. Kalendarza aktualnie używane przez konkretnego <xref:System.Globalization.CultureInfo> obiektu jest zdefiniowana przez jego <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> właściwości. Musi to być jedna kalendarzy w <xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType> tablicy.  
  
Kultura bieżącego kalendarza jest używany podczas wszystkich operacji formatowania dla tej kultury. Na przykład domyślna Kalendarz tajski buddyjski kultury jest kalendarza tajski ery buddyjski, która jest reprezentowana przez <xref:System.Globalization.ThaiBuddhistCalendar> klasy.  Gdy <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tajski buddyjski kultury jest używany w formatowania daty i godziny operacji, Kalendarz tajski buddyjski ery jest używany domyślnie. Kalendarz gregoriański jest używana tylko wtedy, gdy kultury <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> zmienić właściwości, jak przedstawiono na poniższym przykładzie:  

<a name="calendars-01"></a> [!code-csharp-interactive[System.DateTime.Calendar#1](~/samples/snippets/csharp/System.DateTime/Calendar.cs#1)]
[!code-vb[System.DateTime.Calendar#1](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#1)]  

Kultura bieżącego kalendarza służy także we wszystkich operacjach przetwarzania dla tej kultury, jak przedstawiono na poniższym przykładzie.  
  
<a name="calendars-02"></a> [!code-csharp-interactive[System.DateTime.Calendar#2](~/samples/snippets/csharp/System.DateTime/Calendar.cs#2)]
[!code-vb[System.DateTime.Calendar#2](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#2)]  

Można utworzyć wystąpienia <xref:System.DateTime> wartości za pomocą Data i godzina elementów (liczba rok, miesiąc i dzień) kalendarza określonego przez wywołanie metody [konstruktora elementu DateTime](xref:System.DateTime.%23ctor%2A) zawierającą `calendar` parametr i przekazanie jej <xref:System.Globalization.CultureInfo.Calendar%2A>obiekt, który reprezentuje tego kalendarza. W poniższym przykładzie użyto Data i godzina elementy z <xref:System.Globalization.ThaiBuddhistCalendar> kalendarza.  
  
<a name="calendars-03"></a> [!code-csharp-interactive[System.DateTime.Calendar#3](~/samples/snippets/csharp/System.DateTime/Calendar.cs#3)]
[!code-vb[System.DateTime.Calendar#3](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#3)]  

<xref:System.DateTime> Konstruktory, które nie zawierają `calendar` parametru założono, że elementy daty i godziny są wyrażone jako jednostki w kalendarza gregoriańskiego.  
  
Wszystkie inne <xref:System.DateTime> właściwości i metody Użyj kalendarza gregoriańskiego. Na przykład <xref:System.DateTime.Year%2A?displayProperty=nameWithType> właściwość zwraca rok kalendarza gregoriańskiego i <xref:System.DateTime.IsLeapYear%28System.Int32%29?displayProperty=nameWithType> metody, przy założeniu, że `year` parametr jest rok kalendarza gregoriańskiego.  Każdy <xref:System.DateTime> elementu członkowskiego, który korzysta z kalendarza gregoriańskiego ma odpowiednie członkiem <xref:System.Globalization.CultureInfo.Calendar%2A> klasy, która korzysta z określonego kalendarza. Na przykład <xref:System.Globalization.Calendar.GetYear%2A?displayProperty=nameWithType> metoda zwraca roku w kalendarzu określonych i <xref:System.Globalization.Calendar.IsLeapYear%2A?displayProperty=nameWithType> interpretuje metody `year` parametru jako liczba roku w kalendarzu określonych. W poniższym przykładzie użyto zarówno <xref:System.DateTime> i odpowiednich członków <xref:System.Globalization.ThaiBuddhistCalendar> klasy.  
  
<a name="calendars-04"></a> [!code-csharp-interactive[System.DateTime.Calendar#4](~/samples/snippets/csharp/System.DateTime/Calendar.cs#4)]
[!code-vb[System.DateTime.Calendar#4](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#4)]  

<xref:System.DateTime> Struktura zawiera <xref:System.DateTime.DayOfWeek%2A> właściwości, która zwraca dzień tygodnia w kalendarzu kalendarza gregoriańskiego. Nie ma elementu członkowskiego, który pozwala na pobieranie numer tygodnia w roku. Można pobrać tydzień roku, wywołaj kalendarza poszczególnych <xref:System.Globalization.Calendar.GetWeekOfYear%2A?displayProperty=nameWithType> metody. Poniższy przykład stanowi ilustrację.  
  
<a name="calendars-05"></a> [!code-csharp-interactive[System.DateTime.Calendar#5](~/samples/snippets/csharp/System.DateTime/Calendar.cs#5)]
[!code-vb[System.DateTime.Calendar#5](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#5)]  

Aby uzyskać więcej informacji na daty i kalendarzy, zobacz [Praca z kalendarzami](~/docs/standard/datetime/working-with-calendars.md).  
  
### <a name="persisting-datetime-values"></a>Utrwalanie wartości daty/godziny  

Można ją utrwalić <xref:System.DateTime> wartości na cztery sposoby:  
  
-   Możesz [przekonwertować je na ciągi](#persisting-values-as-strings) i utrwala ciągi.  
-   Możesz [przekonwertować je na 64-bitowe wartości całkowite](#persisting-values-as-integers) (wartość <xref:System.DateTime.Ticks%2A> właściwości) i utrwala liczby całkowite.  
-   Możesz [serializować wartości typu DateTime](#serializing-dateTime-values).  
-   Możesz [serializacji wartości daty/godziny oraz informacje o strefie czasowej](#serializing-datetime-and-time-zone-data).  
  
Upewnij się, że procedura, która przywraca <xref:System.DateTime> wartości nie spowodować utratę danych lub zgłosić wyjątek, niezależnie od tego, która metoda zostanie wybrana. <xref:System.DateTime> w przypadku obustronne wartości. Oznacza to, że oryginalna wartość i przywrócone wartości powinny być takie same. I w przypadku oryginalnej <xref:System.DateTime> wartość reprezentuje pojedynczy błyskawicznych czasu, należy zidentyfikować tym momencie czas po przywróceniu.  
  
#### <a name="persisting-values-as-strings"></a>Utrwalanie wartości jako ciągi  

Aby pomyślnie przywrócić <xref:System.DateTime> wartości, które są trwałe jako ciągi, wykonać następujące czynności:  
  
-   Mieć tej samej wartości domyślne specyficzne dla kultury formatowanie po przywróceniu ciągu jako utrwalone po. Aby upewnić się, że ciąg mogą być przywracane na komputerze, na których bieżącej kultury różni się od kultury systemu został zapisany na, należy wywołać <xref:System.DateTime.ToString%2A> przeciążenia, aby zapisać parametry przy użyciu konwencji Niezmienna kultura. Wywołanie <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> lub <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> przeciążenia, aby przywrócić ciąg przy użyciu konwencji Niezmienna kultura. Nigdy nie używaj <xref:System.DateTime.ToString>, <xref:System.DateTime.Parse%28System.String%29>, lub <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29> przeciążenia, które używają konwencje bieżącej kultury wątku.  
  
-   Data reprezentuje pojedynczy chwilę czasu, upewnij się, reprezentuje tej samej chwili po jego przywróceniu, nawet w innej strefie czasowej. Konwertuj <xref:System.DateTime> wartość uniwersalny czas koordynowany (UTC) przed zapisaniem. Można również serializacji wartości oraz informacje o strefie czasowej. Aby uzyskać więcej informacji na temat tej metody, zobacz [dane serializacji daty/godziny i strefy czasowej](#TimeZone).  
  
 Najbardziej typowe błąd po trwałym <xref:System.DateTime> wartości jako ciągi jest zależne od Konwencji formatowania domyślne lub bieżącej kultury. Jeśli bieżącej kultury jest inny, gdy zapisywanie i przywracanie ciągi wystąpienia problemów. Poniższy przykład przedstawia tych problemów. Zapisuje pięć daty przy użyciu konwencji formatowania bieżącej kultury, w tym przypadku jest angielski (Stany Zjednoczone). Przywraca go daty przy użyciu konwencji formatowania z inną kulturę, czyli w tym przypadku języka angielskiego (Polska). Ponieważ Konwencji formatowania dwóch kultur są różne, dwa dat nie można przywrócić, a pozostałe trzy daty będą interpretowane niepoprawnie. Ponadto jeśli oryginalne wartości daty i godziny reprezentują pojedynczego chwil w czasie przywróconej czasy są nieprawidłowe, ponieważ informacje o strefie czasowej zostaną utracone.  
  
<a name="persistence-01"></a> [!code-csharp[System.DateTime.Persistence#1](~/samples/snippets/csharp/System.DateTime/Persistence.cs#1)]
[!code-vb[System.DateTime.Persistence#1](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#1)]  

Przesyłania danych <xref:System.DateTime> wartości pomyślnie, wykonaj następujące kroki:  
  
1.  Jeśli wartości reprezentują pojedynczego chwil czasu, przekonwertować je od lokalnego czasu na czas UTC przez wywołanie metody <xref:System.DateTime.ToUniversalTime%2A> metody.  
1.  Przekonwertować daty na ich oświadczenia ciąg przez wywołanie metody <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> przeciążenia. Użyj konwencji formatowania z kulturą niezmienną określając <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> jako `provider` argumentu. Określ, czy wartość należy obustronne przy użyciu standardowego formatu ciągu "O" lub "R".  
  
Aby przywrócić utrwalonego <xref:System.DateTime> wartości bez utraty danych, wykonaj następujące kroki:  
  
1.  Przeanalizował danych przez wywołanie metody <xref:System.DateTime.ParseExact%2A> lub <xref:System.DateTime.TryParseExact%2A> przeciążenia. Określ <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> jako `provider` argument, a następnie użyj tego samego standardowego formatu ciągu użyte do `format` argumentu podczas konwersji. Obejmują <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> wartość w `styles` argumentu.  
1.  Jeśli <xref:System.DateTime> wartości reprezentują pojedynczego chwil w czasie, wywołanie <xref:System.DateTime.ToLocalTime%2A> metodę, aby przekonwertować tę datę przeanalizowane w formacie UTC na czas lokalny.  
  
W poniższym przykładzie użyto Niezmienna kultura i ciągu standardowym formacie "O", aby upewnić się, że <xref:System.DateTime> wartości zapisywany i przywracany reprezentują tego samego moment w czasie, niezależnie od systemu, kultury i strefy czasowej z systemów źródłowych i docelowych.  
  
<a name="persistence-02"></a> [!code-csharp[System.DateTime.Persistence#2](~/samples/snippets/csharp/System.DateTime/Persistence.cs#2)]
[!code-vb[System.DateTime.Persistence#2](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#2)]  

#### <a name="persisting-values-as-integers"></a>Utrwalanie wartości jako liczby całkowite  

Można ją utrwalić datę i godzinę jako <xref:System.Int64> wartość reprezentującą liczbę znaczników. W takim przypadku nie trzeba wziąć pod uwagę kultury systemów <xref:System.DateTime> wartości są zachowywane i przywrócone na.  
  
Aby zachować <xref:System.DateTime> wartość jako liczbę całkowitą:  
  
-   Jeśli <xref:System.DateTime> wartości reprezentują pojedynczego chwil w czasie, przekonwertować je na czas UTC, wywołując <xref:System.DateTime.ToUniversalTime%2A> metody.  
-   Pobrać liczbę znaczników reprezentowany przez <xref:System.DateTime> wartość z jego <xref:System.DateTime.Ticks%2A> właściwości.  
  
Aby przywrócić <xref:System.DateTime> wartość, która utrwaleniu liczbą całkowitą:  
  
1.  Utwórz wystąpienie nowego <xref:System.DateTime> obiektu przez przekazywanie <xref:System.Int64> do wartości <xref:System.DateTime.%23ctor%28System.Int64%29> konstruktora.  
1.  Jeśli <xref:System.DateTime> wartość reprezentuje pojedynczy moment w czasie, należy konwertować go od czasu UTC na czas lokalny, wywołując <xref:System.DateTime.ToLocalTime%2A> metody.  
  
Poniższy przykład będzie się powtarzał tablicę <xref:System.DateTime> wartości jako liczby całkowite w systemie w Stanach Zjednoczonych Czas pacyficzny strefy. Go przywraca w systemie w strefie UTC. Zawiera plik, który zawiera liczby całkowite <xref:System.Int32> wartość, która wskazuje całkowitą liczbę <xref:System.Int64> wartości, które od razu po nim.  
  
<a name="persistence-03"></a> [!code-csharp[System.DateTime.Persistence#3](~/samples/snippets/csharp/System.DateTime/Persistence.cs#3)]
[!code-vb[System.DateTime.Persistence#3](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#3)]  

#### <a name="serializing-datetime-values"></a>Serializacji wartości daty/godziny  

Można ją utrwalić <xref:System.DateTime> wartości za pomocą serializacji do strumienia lub plik, a następnie przywróć je do deserializacji. <xref:System.DateTime> danych jest serializowany w niektórych format określonego obiektu. Obiekty te zostaną przywrócone, gdy są one deserializacji. Element formatujący lub serializator, takich jak <xref:System.Xml.Serialization.XmlSerializer> lub <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, obsługuje proces serializacji i deserializacji. Aby uzyskać więcej informacji na temat serializacji i typy serializacji obsługiwane przez program .NET Framework, zobacz [szeregowanie](~/docs/standard/serialization/index.md).
  
W poniższym przykładzie użyto <xref:System.Xml.Serialization.XmlSerializer> klasy do serializacji i deserializacji <xref:System.DateTime> wartości. Wartości reprezentują wszystkie dni roku przestępnego w wieku dwudziestego pierwszego. Dane wyjściowe reprezentuje wynik, jeśli przykładzie jest uruchamiana w systemie, w których bieżącej kultury jest angielski (Polska). Ponieważ został zdeserializowany <xref:System.DateTime> obiekt, kod nie musi obsługiwać wiele języków różnice w formatów daty i godziny.  
  
<a name="persistence-04"></a> [!code-csharp[System.DateTime.Persistence#4](~/samples/snippets/csharp/System.DateTime/Persistence.cs#4)]
[!code-vb[System.DateTime.Persistence#4](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#4)]  

Poprzedni przykład nie zawiera informacje o czasie. Jeśli <xref:System.DateTime> wartość reprezentuje moment, w czasie i jest wyrażona jako czas lokalny, należy konwertować go od lokalnego czasu na czas UTC, przed rozpoczęciem serializacji go przez wywołanie metody <xref:System.DateTime.ToUniversalTime%2A> metody. Po deserializacji się go, przekonwertować go od czasu UTC na czas lokalny przez wywołanie metody <xref:System.DateTime.ToLocalTime%2A> metody. W poniższym przykładzie użyto <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> klasy do serializacji <xref:System.DateTime> danych w systemie w Stanach Zjednoczonych Pacyficzny standardowa strefy czasowej i zdeserializować w systemie w Stanach Zjednoczonych Centralna standardowa strefy.  
  
<a name="persistence-05"></a> [!code-csharp[System.DateTime.Persistence#5](~/samples/snippets/csharp/System.DateTime/Persistence.cs#5)]
[!code-vb[System.DateTime.Persistence#5](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#5)]  

#### <a name="serializing-datetime-and-time-zone-data"></a>Serializacja danych daty i godziny i strefy czasowej  

Wszystkich poprzednich przykładach założono, że <xref:System.DateTime> wartości są wyrażane jako czas lokalny. Kod konwersji wartości między czasem UTC a lokalnym, odzwierciedlają sam moment, w czasie w systemach źródłowych i docelowych. <xref:System.DateTime> wartości mogą również uwzględniać chwil w czasie w strefie czasowej niż lokalne i UTC. Ponieważ <xref:System.DateTime> struktury nie są znane strefy czasowej, należy go serializować zarówno <xref:System.DateTime> wartość i <xref:System.TimeZoneInfo> obiekt, który reprezentuje jego strefy czasowej. Tworzenie typu, których pola zawiera zarówno <xref:System.DateTime> wartość i strefy czasowej. W poniższym przykładzie zdefiniowano `DateWithTimeZone` struktury.  
  
<a name="persistence-06"></a> [!code-csharp[System.DateTime.Persistence#6](~/samples/snippets/csharp/System.DateTime/DateWithTimeZone.cs#6)]
[!code-vb[System.DateTime.Persistence#6](~/samples/snippets/visualbasic/System.DateTime/DateWithTimeZone.vb#6)]  

> [!IMPORTANT]
>  `DateWithTimeZone` Struktura jest używana w kolejnych dwóch przykładach, w których serializacji i deserializacji tablicy `DateWithTimeZone` obiektów. Źródło dla całego zestawu przykłady z tego artykułu można wyświetlić w jednym [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/) lub [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/) z repozytorium dokumentów w witrynie GitHub.
  
Za pomocą `DateWithTimeZone` struktury, można następnie zachować daty i godziny oraz informacje o strefie czasowej. W poniższym przykładzie użyto <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> klasy do serializacji tablicę `DateWithTimeZone` obiektów.  
  
[!code-csharp[System.DateTime.Persistence#7](~/samples/snippets/csharp/System.DateTime/Persistence.cs#7)]
[!code-vb[System.DateTime.Persistence#7](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#7)]  

Poniższy przykład wywołuje <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType> metody do deserializacji.  
  
[!code-csharp[System.DateTime.Persistence#8](~/samples/snippets/csharp/System.DateTime/Persistence.cs#8)]
[!code-vb[System.DateTime.Persistence#8](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#8)]  

### <a name="datetime-vs-timespan"></a>Vs daty/godziny. Zakres czasu  

<xref:System.DateTime> i <xref:System.TimeSpan> typów wartości różnią się w tym <xref:System.DateTime> reprezentuje moment w czasie, podczas gdy <xref:System.TimeSpan> reprezentuje przedział czasu. Można odejmować jedno wystąpienie <xref:System.DateTime> z innego uzyskanie <xref:System.TimeSpan> obiekt, który reprezentuje czas między nimi. Lub można dodać dodatnią <xref:System.TimeSpan> do bieżącego <xref:System.DateTime> uzyskanie <xref:System.DateTime> wartość, która reprezentuje datą przyszłą.  
  
Można dodawać lub odjęcia przedział czasu z <xref:System.DateTime> obiektu. Przedziały czasu może być ujemna lub dodatnia i może zostać wyrażona w jednostkach, takich jak znaczniki, sekund, lub jako <xref:System.TimeSpan> obiektu.  

### <a name="comparing-for-equality-within-tolerance"></a>Porównywanie równości w granicach tolerancji

Porównywanie równości dla <xref:System.DateTime> wartości są dokładne. Oznacza to, że dwie wartości muszą być wyrażone jako taką samą liczbę znaczników wziąć pod uwagę taki sam. Dokładność jest często niepotrzebne lub nawet niepoprawne dla wielu aplikacji. Często chcesz sprawdzić, czy <xref:System.DateTime> obiekty są **równa około**. 

W poniższym przykładzie pokazano sposób porównywania około równoważne <xref:System.DateTime> . Akceptuje małych margines różnicy przy deklarowaniu im takie same.  
  
<a name="comparison-02"></a> [!code-csharp[System.DateTime.Comparisons#1](~/samples/snippets/csharp/System.DateTime/DateTimeComparisons.cs#1)]
[!code-vb[System.DateTime.Comparisons#1](~/samples/snippets/visualbasic/System.DateTime/DateTimeComparisons.vb#1)]  

### <a name="com-interop-considerations"></a>Uwagi dotyczące współdziałania COM  

A <xref:System.DateTime> wartość, która jest przenoszona do aplikacji modelu COM, a następnie jest przenoszona z powrotem do aplikacji zarządzanej, jest nazywany przesyłania danych. Jednak <xref:System.DateTime> nie ma wartość, która określa tylko raz obustronne zgodnie z oczekiwaniami może.  
  
Jeśli zostanie wyrównana 30 grudnia 1899 r. N.E. jest tylko raz, takie jak 3 godziny, końcowego Data i godzina na 3:00 w dniu, zamiast, 1 stycznia 0001 r. at 3:00 P.M. .NET Framework i COM założono domyślnej daty, gdy został określony tylko raz. Jednak COM system zakłada podstawowej daty 30 grudnia 1899 r. N.E., gdy podstawowy daty, 1 stycznia 0001 r. N.E. przyjęto założenie, .NET Framework  
  
Po upływie tylko raz z programu .NET Framework modelowi COM specjalne przetwarzanie jest realizowane konwertujący czas do formatu używanego przez COM. Po upływie tylko raz z modelu COM programu .NET Framework Brak specjalnego przetwarzania odbywa się ponieważ który spowoduje uszkodzenie uzasadnionych daty i godziny w tym miejscu lub przed 30 grudnia 1899. Jeśli datę rozpoczyna się jego przesyłania danych z modelu COM, .NET Framework i COM należy zachować daty.  
  
Zachowanie środowiska .NET Framework i COM oznacza, że jeśli przechodzenia Twojej aplikacji <xref:System.DateTime> określający tylko raz, aplikacji należy pamiętać zmodyfikować lub Ignoruj błędne datę z końcowym <xref:System.DateTime> obiektu.  
     
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.DateTimeOffset" />
    <altmember cref="T:System.TimeSpan" />
    <altmember cref="T:System.Globalization.Calendar" />
    <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
    <altmember cref="T:System.TimeZoneInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 -&gt; DateTime" Usage="new System.DateTime ticks" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ticks">Data i czas wyrażony w liczbie 100-nanosekundowych interwałów, które upłynęły od 1 stycznia 0001 na 00:00:00.000 w kalendarza gregoriańskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury do określonej liczby znaczników.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano jeden z <xref:System.DateTime> konstruktorów.  
  
 [!code-cpp[datetime.ctor_Int64#1](~/samples/snippets/cpp/VS_Snippets_CLR/datetime.ctor_Int64/CPP/ticks.cpp#1)]
 [!code-csharp[datetime.ctor_Int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/datetime.ctor_Int64/CS/ticks.cs#1)]
 [!code-vb[datetime.ctor_Int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/datetime.ctor_Int64/VB/ticks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="ticks" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (ticks, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="ticks">Data i czas wyrażony w liczbie 100-nanosekundowych interwałów, które upłynęły od 1 stycznia 0001 na 00:00:00.000 w kalendarza gregoriańskiego.</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje, czy <c>Takty</c> określa czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określoną liczbę znaczników i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="ticks" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc i dzień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje `year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTime> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 Godzinę dnia powstałe w ten sposób <xref:System.DateTime> oznacza północ (00: 00:00). <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość. Przykładzie pokazano, że tego przeciążenia tworzy <xref:System.DateTime> wartość, której składnik czasu jest równe Północ (lub równa 0:00).  
  
 [!code-csharp[System.DateTime.Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#1)]
 [!code-vb[System.DateTime.Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Roku (1-Liczba lat <c>kalendarza</c>).</param>
        <param name="month">Miesiąc (1-Liczba miesięcy w <c>kalendarza</c>).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="calendar">Kalendarz, który służy do interpretowania <c>roku</c>, <c>miesiąca</c>, i <c>dzień</c>.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> ze określony rok, miesiąc i dzień kalendarza określonej struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Godzinę dnia powstałe w ten sposób <xref:System.DateTime> oznacza północ (00: 00:00). <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` są zależne od `calendar`. Jest zwracany wyjątek, jeśli określonej daty i godziny nie można wyrazić przy użyciu `calendar`.  
  
 <xref:System.Globalization> Przestrzeń nazw zawiera kilka kalendarzy tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy wystąpienie <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ perska kalendarza nie może zostać wyznaczony jako domyślny kalendarz dla kultury, wyświetlanie datę w kalendarzu perska wymaga wywołania poszczególnych jego <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Tworzy drugie wywołanie konstruktora <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ bieżącej kultury domyślnej kalendarza Hijri <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa go do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone) w tym przypadku), <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa kalendarza gregoriańskiego bieżącej kultury domyślnej do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample2.cs#2)]
 [!code-vb[System.DateTime.Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> nie znajduje się w zakresie obsługiwanych przez <paramref name="calendar" />.  - lub - <paramref name="month" /> jest mniejszy niż 1 lub większa niż liczba miesięcy w <paramref name="calendar" />.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, godziny, minuty i sekundy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 Ten konstruktor interpretuje`year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTime> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%2A> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#3)]
 [!code-vb[System.DateTime.Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje, czy <c>roku</c>, <c>miesiąca</c>, <c>dzień</c>, <c>godzina</c>, <c>minutę</c>i <c>drugi</c> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, dzień, godzinę, minuty, sekundy i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje`year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTime> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> konstruktora.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#7)]
 [!code-vb[System.DateTime.Constructor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Roku (1-Liczba lat <c>kalendarza</c>).</param>
        <param name="month">Miesiąc (1-Liczba miesięcy w <c>kalendarza</c>).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="calendar">Kalendarz, który służy do interpretowania <c>roku</c>, <c>miesiąca</c>, i <c>dzień</c>.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, godzinę, minutę i sekundę dla określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` są zależne od `calendar`. Jest zwracany wyjątek, jeśli określonej daty i godziny nie można wyrazić przy użyciu `calendar`.  
  
 <xref:System.Globalization> Przestrzeń nazw zawiera kilka kalendarzy tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy wystąpienie <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ perska kalendarza nie może zostać wyznaczony jako domyślny kalendarz dla kultury, wyświetlanie datę w kalendarzu perska wymaga wywołania poszczególnych jego <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Tworzy drugie wywołanie konstruktora <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ bieżącej kultury domyślnej kalendarza Hijri <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa go do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone) w tym przypadku), <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa kalendarza gregoriańskiego bieżącej kultury domyślnej do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample4.cs#4)]
 [!code-vb[System.DateTime.Constructor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> nie znajduje się w zakresie obsługiwanych przez <paramref name="calendar" />.  - lub - <paramref name="month" /> jest mniejszy niż 1 lub większa niż liczba miesięcy w <paramref name="calendar" />.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23 - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, dzień, godzinę, minutę, sekundę i milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje`year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTime> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#5)]
 [!code-vb[System.DateTime.Constructor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje, czy <c>roku</c>, <c>miesiąca</c>, <c>dzień</c>, <c>godzina</c>, <c>minutę</c>, <c>drugi</c>, i <c>milisekund</c> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, dzień, godzina, minuty, sekundy, milisekund i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje`year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTime> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> konstruktora.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#8)]
 [!code-vb[System.DateTime.Constructor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Roku (1-Liczba lat <c>kalendarza</c>).</param>
        <param name="month">Miesiąc (1-Liczba miesięcy w <c>kalendarza</c>).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="calendar">Kalendarz, który służy do interpretowania <c>roku</c>, <c>miesiąca</c>, i <c>dzień</c>.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, dzień, godziny, minuty, sekundy i milisekundy określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana na <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` są zależne od `calendar`. Jest zwracany wyjątek, jeśli określonej daty i godziny nie można wyrazić przy użyciu `calendar`.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
 <xref:System.Globalization> Przestrzeń nazw zawiera kilka kalendarzy tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy wystąpienie <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ perska kalendarza nie może zostać wyznaczony jako domyślny kalendarz dla kultury, wyświetlanie datę w kalendarzu perska wymaga wywołania poszczególnych jego <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Tworzy drugie wywołanie konstruktora <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ bieżącej kultury domyślnej kalendarza Hijri <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa go do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone) w tym przypadku), <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa kalendarza gregoriańskiego bieżącej kultury domyślnej do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample6.cs#6)]
 [!code-vb[System.DateTime.Constructor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> nie znajduje się w zakresie obsługiwanych przez <paramref name="calendar" />.  - lub - <paramref name="month" /> jest mniejszy niż 1 lub większa niż liczba miesięcy w <paramref name="calendar" />.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar,System.DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Roku (1-Liczba lat <c>kalendarza</c>).</param>
        <param name="month">Miesiąc (1-Liczba miesięcy w <c>kalendarza</c>).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="calendar">Kalendarz, który służy do interpretowania <c>roku</c>, <c>miesiąca</c>, i <c>dzień</c>.</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje, czy <c>roku</c>, <c>miesiąca</c>, <c>dzień</c>, <c>godzina</c>, <c>minutę</c>, <c>drugi</c>, i <c>milisekund</c> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, dzień, godzina, minuty, sekundy, milisekund i uniwersalny czas koordynowany (UTC) lub czas lokalny dla określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopuszczalne wartości dla `year`, `month`, i `day` parametry są zależne od `calendar` parametru. Jest zwracany wyjątek, jeśli określonej daty i godziny nie można wyrazić przy użyciu `calendar`.  
  
 W przypadku zastosowania, w których przenośność danych daty i godziny lub ograniczonym stopniu strefy czasowej świadomości jest ważne, można użyć odpowiadającego <xref:System.DateTimeOffset> konstruktora.  
  
 <xref:System.Globalization> Przestrzeń nazw zawiera kilka kalendarzy tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy wystąpienie <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ perska kalendarza nie może zostać wyznaczony jako domyślny kalendarz dla kultury, wyświetlanie datę w kalendarzu perska wymaga wywołania poszczególnych jego <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Tworzy drugie wywołanie konstruktora <xref:System.DateTime> wartość przy użyciu <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ bieżącej kultury domyślnej kalendarza Hijri <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa go do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone) w tym przypadku), <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa kalendarza gregoriańskiego bieżącej kultury domyślnej do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample9.cs#9)]
 [!code-vb[System.DateTime.Constructor#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> nie znajduje się w zakresie obsługiwanych przez <paramref name="calendar" />.  - lub - <paramref name="month" /> jest mniejszy niż 1 lub większa niż liczba miesięcy w <paramref name="calendar" />.  - lub - <paramref name="day" /> jest mniejszy niż 1 lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż 0 lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public DateTime Add (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Add(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Add(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Add(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Add : TimeSpan -&gt; DateTime" Usage="dateTime.Add value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">Przedział czasu dodatnią lub ujemną.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje wartość określonego <see cref="T:System.TimeSpan" /> wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.DateTime.Add%2A> metodę, aby dodać więcej niż jednego rodzaju interwału czasu (dni, godziny, minuty, sekundy lub milisekund) w ramach jednej operacji. Ta metoda jest identyczna jak operator dodawania. <xref:System.DateTime> Struktury obsługuje również metody dodawania specjalne (takie jak <xref:System.DateTime.AddDays%2A>, <xref:System.DateTime.AddHours%2A>, i <xref:System.DateTime.AddMinutes%2A>) dla każdego interwału czasu.  
  
 <xref:System.DateTime.Add%2A> Metoda uwzględnia przestępnego konta i liczbę dni w miesiącu przy wykonywania arytmetyczne daty.  
  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji. <xref:System.DateTime.Kind%2A> Właściwości nowej <xref:System.DateTime> wystąpienie jest takie samo jak bieżące wystąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Add%2A> metody. Dzień tygodnia, w których jest 36 dni (godziny 864) w tej chwili jest obliczana.  
  
 [!code-cpp[DateTime.Add#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Add/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Add/CS/class1.cs#1)]
 [!code-vb[DateTime.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Add/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="M:System.TimeSpan.Add(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="AddDays">
      <MemberSignature Language="C#" Value="public DateTime AddDays (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddDays(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddDays(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDays (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddDays(double value);" />
      <MemberSignature Language="F#" Value="member this.AddDays : double -&gt; DateTime" Usage="dateTime.AddDays value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba całych i ułamkowych dni. <c>Wartość</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę dni do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i liczbę dni reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Części ułamkowej `value` jest ułamkową część dnia. Na przykład 4.5 jest odpowiednikiem 4 dni, 12 godzin, 0 minut, 0 sekund, 0 milisekund i znaczniki 0.  
  
 `value` Parametr jest zaokrąglana do najbliższego milisekund.  
  
 <xref:System.DateTime.AddDays%2A> Metoda uwzględnia przestępnego konta i liczbę dni w miesiącu przy wykonywania arytmetyczne daty.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddDays%2A> metodę, aby określić dzień tygodnia 36 dni po bieżącej dacie.  
  
 [!code-cpp[DateTime.AddDays#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.AddDays/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.AddDays#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.AddDays/CS/class1.cs#1)]
 [!code-vb[DateTime.AddDays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.AddDays/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddHours">
      <MemberSignature Language="C#" Value="public DateTime AddHours (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddHours(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddHours(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddHours (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddHours(double value);" />
      <MemberSignature Language="F#" Value="member this.AddHours : double -&gt; DateTime" Usage="dateTime.AddHours value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba godzin całość lub część. <c>Wartość</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę godzin na wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i liczbę godzin reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji. <xref:System.DateTime.Kind%2A> Właściwości zwracana <xref:System.DateTime> obiekt jest taki sam, jak te `value`.  
  
 Części ułamkowej `value` jest część ułamkowa godziny. Na przykład 4.5 jest odpowiednikiem 4 godzin, 30 minut, 0 sekund, 0 milisekund i znaczniki 0.  
  
 `value` Parametr jest zaokrąglana do najbliższego milisekund.  
  
 Konwertowanie przedziały czasu niecałej godziny ułamka może obejmować zmniejszenie precyzji, jeśli wynik wynosi powtarzanie niepowodujący wartości dziesiętnej. (Na przykład jedna minuta jest 0.016667 godzinę). Jeśli jest to problem, możesz użyć <xref:System.DateTime.Add%2A> metodę, która można określić więcej niż jednego rodzaju interwał czasu w wywołaniu metody pojedynczego i eliminuje potrzebę przekonwertować przedziały czasu ułamkowych części godzinę.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddHours%2A> metody w celu dodania całość lub część wartości daty i czasu. Utrata dokładności spowodowane przez przekazanie metody wartość, która zawiera składnik ułamkowych również dwie.  
  
 [!code-csharp[System.DateTime.AddHours#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.AddHours/cs/AddHours1.cs#1)]
 [!code-vb[System.DateTime.AddHours#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.AddHours/vb/AddHours1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="AddMilliseconds">
      <MemberSignature Language="C#" Value="public DateTime AddMilliseconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMilliseconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMilliseconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMilliseconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMilliseconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMilliseconds : double -&gt; DateTime" Usage="dateTime.AddMilliseconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba milisekund całość lub część. <c>Wartość</c> parametr może być ujemna lub dodatnia. Należy pamiętać, że ta wartość jest zaokrąglana do najbliższej liczby całkowitej.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę milisekund do wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i wyrażony w milisekundach czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Części ułamkowej `value` jest część ułamkowa milisekundy. Na przykład 4.5 jest odpowiednikiem 4 milisekundy i 5000 znaczniki, gdy jedna milisekund = 10000 znaczniki osi.  
  
 `value` Parametr jest zaokrąglana do najbliższej liczby całkowitej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddMilliseconds%2A> metody w celu dodania jednej milisekundy i 1,5 milisekund <xref:System.DateTime> wartość. Następnie wyświetla każdej nowej wartości, a wartość to różnica między nim a oryginalnej wartości. Różnica jest wyświetlany przedział czasu oraz w liczbę znaczników. Przykład ułatwia wyczyść co 10 000 impulsów equals milisekund. Zawiera także że ułamkowych milisekund są zaokrąglane przed wykonaniem operacji dodawania; <xref:System.DateTime> wartość będącą wynikiem Dodawanie milisekund 1,5 do pierwotna data jest późniejsza niż data oryginalnego 2 milisekund.  
  
 [!code-csharp[System.DateTime.AddMilliseconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmilliseconds/cs/addmilliseconds2.cs#1)]
 [!code-vb[System.DateTime.AddMilliseconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmilliseconds/vb/addmilliseconds2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddMinutes">
      <MemberSignature Language="C#" Value="public DateTime AddMinutes (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMinutes(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMinutes(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMinutes (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMinutes(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMinutes : double -&gt; DateTime" Usage="dateTime.AddMinutes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba minut całość lub część. <c>Wartość</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę minut na wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i liczbę minut reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Części ułamkowej `value` jest części ułamkowej minutę. Na przykład 4.5 jest odpowiednikiem 4 minut, 30 sekund, 0 milisekund i znaczniki 0.  
  
 `value` Parametr jest zaokrąglana do najbliższego milisekund.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddMinutes%2A> metody w celu dodania całość lub część wartości daty i czasu.  
  
 [!code-cpp[System.DateTime.AddMinutes#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.addminutes/cpp/addminutes1.cpp#1)]
 [!code-csharp[System.DateTime.AddMinutes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addminutes/cs/addminutes1.cs#1)]
 [!code-vb[System.DateTime.AddMinutes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addminutes/vb/addminutes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddMonths">
      <MemberSignature Language="C#" Value="public DateTime AddMonths (int months);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMonths(int32 months) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMonths(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMonths (months As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMonths(int months);" />
      <MemberSignature Language="F#" Value="member this.AddMonths : int -&gt; DateTime" Usage="dateTime.AddMonths months" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="months" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="months">Liczba miesięcy. <c>Miesięcy</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę miesięcy do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez to wystąpienie i <paramref name="months" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime> obiektu. Zamiast tego zwraca nową <xref:System.DateTime> obiektu, którego wartość jest wynik tej operacji.  
  
 <xref:System.DateTime.AddMonths%2A> Metody oblicza wynikowy miesiąca i roku, biorąc pod uwagę przestępnego i liczbę dni w miesiącu, następnie koryguje część dnia powstałe w ten sposób <xref:System.DateTime> obiektu. Jeśli wynikowy dzień nie jest prawidłowym dniem miesiąca wynikowy, używana jest ostatni dzień prawidłowy wynikowy miesiąca. Na przykład, 31 marca + 1 miesiąc = kwietnia 30 i 31 marca - = 1 miesiąc 28 lutego dla innych niż — roku przestępnego i lutego 29, dla roku przestępnego.  
  
 Część czasu dnia powstałe w ten sposób <xref:System.DateTime> obiekt pozostaje taki sam, jak to wystąpienie.  
  
   
  
## Examples  
 W następującym przykładzie dodano przedziału od 0 do 15 miesięcy do ostatniego dnia grudnia 2015 r. W tym przypadku metoda AddMonths zwraca datę ostatniego dnia każdego miesiąca i pomyślnie obsługuje przestępnego.  
  
 [!code-csharp[System.DateTime.AddMonths#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmonths/cs/addmonths1.cs#1)]
 [!code-vb[System.DateTime.AddMonths#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmonths/vb/addmonths1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.  - lub - <paramref name="months" /> jest mniejsza niż-120,000 lub większa niż 120 000.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddSeconds">
      <MemberSignature Language="C#" Value="public DateTime AddSeconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddSeconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddSeconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSeconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddSeconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddSeconds : double -&gt; DateTime" Usage="dateTime.AddSeconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba całych i ułamkowych części sekundy. <c>Wartość</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę sekund na wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i liczbę sekund reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Części ułamkowej `value` jest ułamkowych części sekundy. Na przykład 4.5 jest odpowiednikiem 4 sekundy, 500 milisekund i znaczniki 0.  
  
 `value` Parametr jest zaokrąglana do najbliższego milisekund.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddSeconds%2A> metody w celu dodania 30 sekund i liczbę sekund w ciągu jednego dnia do <xref:System.DateTime> wartości. Następnie wyświetla każdej nowej wartości, a wartość to różnica między nim a oryginalnej wartości. Różnica jest wyświetlany przedział czasu oraz w liczbę znaczników.  
  
 [!code-csharp[System.DateTime.AddSeconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addseconds/cs/addseconds1.cs#1)]
 [!code-vb[System.DateTime.AddSeconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addseconds/vb/addseconds1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddTicks">
      <MemberSignature Language="C#" Value="public DateTime AddTicks (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddTicks(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddTicks(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTicks (value As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddTicks(long value);" />
      <MemberSignature Language="F#" Value="member this.AddTicks : int64 -&gt; DateTime" Usage="dateTime.AddTicks value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Liczba 100-nanosekundowych znaczniki osi. <c>Wartość</c> parametr może być liczbą dodatnią lub ujemną.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę znaczników wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="AddYears">
      <MemberSignature Language="C#" Value="public DateTime AddYears (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddYears(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddYears(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddYears (value As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddYears(int value);" />
      <MemberSignature Language="F#" Value="member this.AddYears : int -&gt; DateTime" Usage="dateTime.AddYears value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Kilka lat temu. <c>Wartość</c> parametr może być ujemna lub dodatnia.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> dodaje określoną liczbę lat do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie daty i godziny reprezentowany przez to wystąpienie i liczbę lat reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartości to <xref:System.DateTime> obiektu. Zamiast tego zwraca nową <xref:System.DateTime> obiektu, którego wartość jest wynik tej operacji.  
  
 <xref:System.DateTime.AddYears%2A> Metody oblicza wynikowy roku, biorąc pod uwagę przestępnego. Miesiąc i dzień czasowej część powstałe w ten sposób <xref:System.DateTime> obiekt pozostaje taki sam, jak to wystąpienie.  
  
 Jeśli bieżące wystąpienie reprezentuje przestępnego dzień w roku przestępnym, zwracana wartość zależy od daty docelowej:  
  
-   Jeśli `value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType> jest również roku przestępnego, zwracana wartość reprezentuje dzień tego roku przestępnego. Na przykład jeśli czterech lat jest dodawany do 29 lutego 2012 Data zwracane jest 29 lutego 2016 r.  
  
-   Jeśli `value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType> nie jest rokiem przestępnym, zwracana wartość reprezentuje dzień przed na dzień tego roku przestępnego. Na przykład jeśli rok jest dodawany do 29 lutego 2012 Data zwracane jest 28 lutego 2013.  
  
 Poniższy przykład przedstawia przy użyciu <xref:System.DateTime.AddYears%2A> metody z <xref:System.DateTime> wartość reprezentującą dzień roku przestępnego. Wyświetla datę 15 lat przed i 15 lat, które należy wykonać 29 lutego 2000.  
  
 [!code-csharp[System.DateTime.AddYears#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addyears/cs/addyears1.cs#1)]
 [!code-vb[System.DateTime.AddYears#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addyears/vb/addyears1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> lub powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (t1 As DateTime, t2 As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Compare : DateTime * DateTime -&gt; int" Usage="System.DateTime.Compare (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Porównuje dwa wystąpienia <see cref="T:System.DateTime" /> i zwraca liczbę całkowitą, która wskazuje, czy pierwsze wystąpienie jest wcześniejsza niż takie same jak lub nowsza drugie wystąpienie.</summary>
        <returns>Podpisem liczbę określającą wartości <paramref name="t1" /> i <paramref name="t2" />.  
  
 <list type="table"><listheader><term> Typ wartości </term><description> warunku </description></listheader><item><term> mniejsza od zera </term><description><paramref name="t1" /> jest starsza niż <paramref name="t2" />.  </description></item><item><term> Zero </term><description><paramref name="t1" /> jest taka sama jak <paramref name="t2" />.  </description></item><item><term> Większa od zera </term><description><paramref name="t1" /> jest nowsza niż <paramref name="t2" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację `t1` do `t2`, <xref:System.DateTime.Compare%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwość `t1` i `t2` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Compare%2A> metody.  
  
 [!code-csharp[System.DateTime.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.compare/cs/compare1.cs#1)]
 [!code-vb[System.DateTime.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.compare/vb/compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje wartość tego wystąpienia określonej <see cref="T:System.DateTime" /> wartości i wskazuje, czy to wystąpienie jest wcześniejsza niż takie same jak lub późniejszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Overloads dwa z <xref:System.DateTime.CompareTo%2A> zwracany przez metodę podpisem liczba, która określa względne wartość tego wystąpienia i `value` argumentu, jak pokazano w poniższej tabeli.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|Mniej niż zero|To wystąpienie jest wcześniejsza niż `value`.|  
|Zero|To wystąpienie jest taki sam jak `value`.|  
|Większe od zera|To wystąpienie jest nowsza niż `value`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(DateTime value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : DateTime -&gt; int&#xA;override this.CompareTo : DateTime -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Porównuje wartość tego wystąpienia określonej <see cref="T:System.DateTime" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie jest wcześniejsza niż takie same jak lub późniejszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość </term><description> opis </description></listheader><item><term> mniejsza od zera </term><description> to wystąpienie jest wcześniejsza niż <paramref name="value" />.  </description></item><item><term> Zero </term><description> to wystąpienie jest taki sam jak <paramref name="value" />.  </description></item><item><term> Większa od zera </term><description> to wystąpienie jest nowsza niż <paramref name="value" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić relacji do bieżącego wystąpienia `value`, <xref:System.DateTime.CompareTo%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwości bieżącego wystąpienia i `value` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości.  Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.DateTime.CompareTo%28System.Object%29?displayProperty=nameWithType> — metoda przeciążenia, ponieważ nie muszą być konwertowane `value` parametru do obiektu.  
  
   
  
## Examples  
 Poniższy przykład tworzy trzy <xref:System.DateTime> obiektów, który reprezentuje bieżącą datę, inny reprezentujący wcześniej rok i trzeciego reprezentujący datę w przyszłości jeden rok. Następnie wywołuje <xref:System.DateTime.CompareTo%28System.DateTime%29> — metoda i wynik porównania.  
  
 [!code-csharp[DateTime.CompareTo.2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo.2/CS/CompareTo_CS1_24564.cs#1)]
 [!code-vb[DateTime.CompareTo.2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo.2/VB/CompareTo_VB1_24564.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Opakowany obiekt do porównania, lub <see langword="null" />.</param>
        <summary>Porównuje wartość tego wystąpienia określony obiekt, który zawiera określonej <see cref="T:System.DateTime" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie jest wcześniejsza niż takie same jak lub późniejszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość </term><description> opis </description></listheader><item><term> mniejsza od zera </term><description> to wystąpienie jest wcześniejsza niż <paramref name="value" />.  </description></item><item><term> Zero </term><description> to wystąpienie jest taki sam jak <paramref name="value" />.  </description></item><item><term> Większa od zera </term><description> to wystąpienie jest nowsza niż <paramref name="value" />, lub <paramref name="value" /> jest <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić relacji do bieżącego wystąpienia `value`, <xref:System.DateTime.CompareTo%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwości bieżącego wystąpienia i `value` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Wszystkie wystąpienia <xref:System.DateTime>, niezależnie od jego wartość jest uznawany za większy niż `null`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.CompareTo%2A> metody.  
  
 [!code-cpp[DateTime.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.CompareTo/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo/CS/class1.cs#1)]
 [!code-vb[DateTime.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.DateTime" />.</exception>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Date" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime" Usage="System.DateTime.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik daty tego wystąpienia.</summary>
        <value>Nowy obiekt z tego samego dnia, jak to wystąpienie i wartość czasu ustawioną 12:00:00 północ (00: 00:00).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> wartość jest taka sama, jak bieżące wystąpienie.  
  
 Ponieważ <xref:System.DateTime> typu reprezentuje obu dat i razy w jednym typie, ważne jest, aby uniknąć misinterpreting datę zwrócony przez <xref:System.DateTime.Date%2A> właściwość jako datę i godzinę.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Date%2A> właściwość, aby wyodrębnić składnik daty z <xref:System.DateTime> wartości z jej składnik godziny z wartości zero (lub równa 0:00:00 lub północ). Również dwie, w zależności od ciąg formatu używany podczas wyświetlania <xref:System.DateTime> wartość, składnik czasu można nadal wyświetlana na sformatowane dane wyjściowe.  
  
 [!code-cpp[System.DateTime.Date#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Date/cpp/date1.cpp#1)]
 [!code-csharp[System.DateTime.Date#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Date/cs/Date1.cs#1)]
 [!code-vb[System.DateTime.Date#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Date/vb/Date1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Day">
      <MemberSignature Language="C#" Value="public int Day { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Day" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Day" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Day As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Day { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Day : int" Usage="System.DateTime.Day" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień miesiąca reprezentowanym przez to wystąpienie.</summary>
        <value>Składnik dni, wyrażony jako wartość z zakresu od 1 do 31.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Day%2A> Właściwość zawsze zwraca dzień miesiąca kalendarza gregoriańskiego nawet wtedy, gdy bieżący <xref:System.DateTime> wartość wystąpienia niektórych innych kalendarza lub jeśli bieżącego wątku kultury domyślnej kalendarza nie jest kalendarza gregoriańskiego. Aby pobrać dzień miesiąca o określonej dacie niektóre inne kalendarza, należy wywołać tego kalendarza <xref:System.Globalization.Calendar.GetDayOfMonth%2A?displayProperty=nameWithType> metody. W poniższym przykładzie użyto zarówno <xref:System.DateTime.Day%2A> właściwości i <xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType> metoda pobierania dzień miesiąca dla <xref:System.DateTime> wartość, która zostanie uruchomiony przy użyciu kalendarza Hijri.  
  
 [!code-csharp[System.DateTime.Day#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day1.cs#1)]
 [!code-vb[System.DateTime.Day#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day1.vb#1)]  
  
 Podobnie, w poniższym przykładzie użyto zarówno <xref:System.DateTime.Day%2A> właściwości i <xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType> metoda pobierania dzień miesiąca, po ar-SA, który używa jako jego domyślny kalendarza Hijri bieżącej kultury wątku.  
  
 [!code-csharp[System.DateTime.Day#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day2.cs#2)]
 [!code-vb[System.DateTime.Day#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day2.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Day%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfWeek">
      <MemberSignature Language="C#" Value="public DayOfWeek DayOfWeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DayOfWeek DayOfWeek" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfWeek" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfWeek As DayOfWeek" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DayOfWeek DayOfWeek { DayOfWeek get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfWeek : DayOfWeek" Usage="System.DateTime.DayOfWeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DayOfWeek</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień tygodnia, reprezentowany przez to wystąpienie.</summary>
        <value>Wyliczany stała, który wskazuje dzień tygodnia tego <see cref="T:System.DateTime" /> wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości stałe w <xref:System.DayOfWeek> wyliczenie zakresów z <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType> do <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>. Jeśli rzutowania na liczbę całkowitą, jego wartość należy do zakresu od 0 (co oznacza <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>) na sześć (co oznacza <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>).  
  
 <xref:System.DateTime.DayOfWeek%2A> Właściwość zwraca wyliczany stała; odzwierciedlają ustawienia regionalne i językowe systemu. Aby pobrać ciąg reprezentujący nazwę zlokalizowanej dzień tygodnia dla określonej daty, wywoływanie jednego z przeciążeń <xref:System.DateTime.ToString%2A> metodę, która obejmuje `format` parametru i przekaż go albo `ddd` lub `dddd` niestandardowych ciągów formatu. Aby uzyskać więcej informacji, zobacz [porady: wyodrębnianie dnia tygodnia z określonej daty](~/docs/standard/base-types/how-to-extract-the-day-of-the-week-from-a-specific-date.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.DayOfWeek%2A> właściwości i <xref:System.DayOfWeek?displayProperty=nameWithType> wyliczenia.  
  
 [!code-cpp[DateTime.DayOfWeek#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DayOfWeek/CPP/dow.cpp#1)]
 [!code-csharp[DateTime.DayOfWeek#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DayOfWeek/CS/dow.cs#1)]
 [!code-vb[DateTime.DayOfWeek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DayOfWeek/VB/dow.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="DayOfYear">
      <MemberSignature Language="C#" Value="public int DayOfYear { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DayOfYear" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfYear" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfYear As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DayOfYear { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfYear : int" Usage="System.DateTime.DayOfYear" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień roku, reprezentowanym przez to wystąpienie.</summary>
        <value>Dzień roku, wyrażony jako wartość z zakresu od 1 do 366.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DayOfYear%2A> Właściwość uwzględnia przestępnego podczas obliczania dzień roku. Wartość właściwości zawsze odzwierciedla dzień roku w kalendarzu gregoriański, niezależnie od bieżącego kalendarza bieżącej kultury wątku. Aby pobrać dzień roku w kalendarzu innego, należy wywołać <xref:System.Globalization.Calendar.GetDayOfYear%2A?displayProperty=nameWithType> metoda tego kalendarza.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dzień roku 31 grudnia w roku 2010 2020 w kalendarza gregoriańskiego. Należy pamiętać, że w przykładzie pokazano 31 grudnia jest 366th dzień roku przestępnego.  
  
 [!code-csharp[System.DateTime.DayOfYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.dayofyear/cs/dayofyear2.cs#1)]
 [!code-vb[System.DateTime.DayOfYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.dayofyear/vb/dayofyear2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.Calendar.GetDayOfYear(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="DaysInMonth">
      <MemberSignature Language="C#" Value="public static int DaysInMonth (int year, int month);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DaysInMonth(int32 year, int32 month) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.DaysInMonth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DaysInMonth (year As Integer, month As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DaysInMonth(int year, int month);" />
      <MemberSignature Language="F#" Value="static member DaysInMonth : int * int -&gt; int" Usage="System.DateTime.DaysInMonth (year, month)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok.</param>
        <param name="month">Miesiąc (liczba z zakresu od 1 do 12).</param>
        <summary>Zwraca liczbę dni w określonym miesiącu i roku.</summary>
        <returns>Liczba dni w <paramref name="month" /> dla określonego <paramref name="year" />.  Na przykład jeśli <paramref name="month" /> lutego jest równa 2, wartość zwracana jest 28 lub 29 czy zależności <paramref name="year" /> jest rokiem przestępnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DaysInMonth%2A> Metody zawsze interpretuje `month` i `year` jako miesiąc i rok kalendarza gregoriańskiego kalendarza, nawet jeśli nie jest kalendarza gregoriańskiego bieżącego kalendarza bieżącej kultury. Aby uzyskać liczbę dni w określonym miesiącu określonego kalendarza, należy wywołać tego kalendarza <xref:System.Globalization.Calendar.GetDaysInMonth%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.DateTime.DaysInMonth%2A> metodę, aby określić liczbę dni w lipcu 2001 lutego 1998 (z systemem innym niż — roku przestępnym) i lutego 1996 (roku przestępnego).  
  
 [!code-cpp[DateTime.DaysInMonth#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DaysInMonth/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DaysInMonth/CS/class1.cs#1)]
 [!code-vb[DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DaysInMonth/VB/class1.vb#1)]  
  
 W poniższym przykładzie przedstawiono liczbę dni w każdym miesiącu roku określone w tablicy liczby całkowitej.  
  
 [!code-csharp[System.DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.daysinmonth/cs/daysinmonth3.cs#1)]
 [!code-vb[System.DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.daysinmonth/vb/daysinmonth3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="month" /> jest mniejsza niż 1 lub większą niż 12.  - lub - <paramref name="year" /> jest mniejszy niż 1 lub większa niż 9999.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.DateTime" /> obiektów, lub <see cref="T:System.DateTime" /> wystąpienia a innym obiektem lub <see cref="T:System.DateTime" />, mają taką samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(DateTime value);" />
      <MemberSignature Language="F#" Value="override this.Equals : DateTime -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy wartość tego wystąpienia jest równa wartości określonego <see cref="T:System.DateTime" /> wystąpienia.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> parametr ma wartość wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące wystąpienie i `value` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są wliczane testowanie równości.  
  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco lepsza niż <xref:System.DateTime.Equals%2A> — metoda ponieważ `value` do przekonwertowania na obiekt nie ma parametru.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.DateTime" /> i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące wystąpienie i `value` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są wliczane testowanie równości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Equals : DateTime * DateTime -&gt; bool" Usage="System.DateTime.Equals (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.DateTime" /> wystąpienia mają taką samą wartość daty i godziny.</summary>
        <returns>
          <see langword="true" /> Jeśli dwie wartości są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t1` i `t2` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są wliczane testowanie równości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-cpp[DateTime.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Equals/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Equals/CS/class1.cs#1)]
 [!code-vb[DateTime.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Equals/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FromBinary">
      <MemberSignature Language="C#" Value="public static DateTime FromBinary (long dateData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromBinary(int64 dateData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromBinary(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBinary (dateData As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromBinary(long dateData);" />
      <MemberSignature Language="F#" Value="static member FromBinary : int64 -&gt; DateTime" Usage="System.DateTime.FromBinary dateData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateData" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dateData">64-bitowe liczby całkowite ze znakiem koduje <see cref="P:System.DateTime.Kind" /> właściwości w pole bitowe 2 i <see cref="P:System.DateTime.Ticks" /> właściwości w pole bitowe 62.</param>
        <summary>Deserializuje wartość binarną 64-bitowe i odtwarza oryginalny serializacji <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Obiekt, który jest odpowiednikiem <see cref="T:System.DateTime" /> obiekt, który został serializowany przez <see cref="M:System.DateTime.ToBinary" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować wartość bieżącej klasy <xref:System.DateTime> obiektu na wartość binarną. Następnie należy użyć wartości binarne i <xref:System.DateTime.FromBinary%2A> metodę, aby ponownie utworzyć oryginalną <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  W niektórych przypadkach <xref:System.DateTime> wartość zwrócona przez <xref:System.DateTime.FromBinary%2A> metoda nie jest taka sama jak oryginalny <xref:System.DateTime> wartość dostarczona do <xref:System.DateTime.ToBinary%2A> metody. Aby uzyskać więcej informacji zobacz następną sekcję, "Czas lokalny dopasowania".  
  
## <a name="local-time-adjustment"></a>Ustawianie czasu lokalnego  
 Czas lokalny, będący skoordynowanego czasu uniwersalnego dostosowana do lokalnej strefy czasowej, jest reprezentowana przez <xref:System.DateTime> struktury, którego <xref:System.DateTime.Kind%2A> właściwość ma wartość <xref:System.DateTimeKind.Local>. Podczas przywracania lokalnym <xref:System.DateTime> wartość binarna reprezentacja, który jest generowany przez <xref:System.DateTime.ToBinary%2A> metody <xref:System.DateTime.FromBinary%2A> — metoda może dostosować wartość do odtworzenia, dzięki czemu nie jest taki sam, jak oryginalna wartość. Taka sytuacja może wystąpić w następujących warunkach:  
  
-   Jeśli na komputerze lokalnym <xref:System.DateTime> serializowany jest obiekt w jednej strefie czasowej przez <xref:System.DateTime.ToBinary%2A> metody, a następnie deserializowany w innej strefie czasowej przez <xref:System.DateTime.FromBinary%2A> metoda, czas lokalny reprezentowany przez powstałe w ten sposób <xref:System.DateTime> obiektu jest automatycznie dostosowywany drugi strefę czasową.  
  
     Rozważmy na przykład <xref:System.DateTime> obiekt, który reprezentuje czasu lokalnego, o godzinie 3 Aplikacja, która jest wykonywany w Stanach Zjednoczonych Używa strefy czas pacyficzny <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować który <xref:System.DateTime> obiektu na wartość binarną. Inna aplikacja, który jest wykonywany w Stanach Zjednoczonych Następnie używa strefy czasowej Wschodniej <xref:System.DateTime.FromBinary%2A> metodę, aby przekonwertować wartość binarną na nowy <xref:System.DateTime> obiektu. Wartość nowego <xref:System.DateTime> obiekt jest 18: 00, reprezentujący tego samego punktu w czasie, gdy oryginalne godzinie 3 wartość, ale jest dostosowana do czasu lokalnego w strefie czasowej Wschodniej.  
  
-   Jeśli reprezentacja binarna lokalnym <xref:System.DateTime> wartość reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej systemu, na którym <xref:System.DateTime.FromBinary%2A> jest wywoływana, czas jest uwzględniany, aby była nieprawidłowa.  
  
     Na przykład przejście ze wsch. czas letni występuje w strefie czas pacyficzny Stanów Zjednoczonych na 14 marca 2010 o 2:00, gdy czas przechodzi przez godzinę, 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartości binarnej przez jest konwertowany ten zakres <xref:System.DateTime.ToBinary%2A> metody, a następnie przywróceniu przez <xref:System.DateTime.FromBinary%2A> metody oryginalnej wartości jest dostosowana do stają się czas ważności. Można określić, czy określoną datę i godzinę może podlegać modyfikacji, przekazując go do <xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType> metody, co w przykładzie przedstawiono.  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.DateTime> struktury składa się prywatnej pola rodzaju, który wskazuje, czy określony czas jest czasu lokalnego, uniwersalny czas koordynowany (UTC) lub nie, połączony z polem Takty prywatnych, które zawiera liczbę taktów 100-nanosekundowych, które Określ datę i godzinę. Liczbę znaczników jest możliwy z <xref:System.DateTime.Ticks%2A> właściwości i theKind pola jest możliwy z <xref:System.DateTime.Kind%2A> właściwości.  
  
 Przed programu .NET Framework 2.0, jeśli można serializować <xref:System.DateTime> obiektu zamiast ręcznie przy użyciu interfejsu serializacji, takich jak <xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>, potrzebne do serializacji danych tylko z taktami <xref:System.DateTime>. Począwszy od programu .NET Framework 2.0, należy również serializować rodzaju danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateData" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.ToBinary" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTime">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTime (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTime(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTime(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTime (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTime(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTime : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTime fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">Czas plików systemu Windows wyrażony w taktach.</param>
        <summary>Konwertuje określony czas systemu Windows w pliku odpowiedni czas lokalny.</summary>
        <returns>Obiekt, który reprezentuje czas lokalny odpowiednikiem daty i godziny reprezentowany przez <paramref name="fileTime" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 `fileTime` Parametr określa plik czasowy w taktach 100-nanosekundowych.  
  
 W programie .NET Framework w wersji 2.0, jest zwracana wartość <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.FromFileTime%2A> metody.  
  
 [!code-cpp[DateTime.FromFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.FromFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.FromFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.FromFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileTime" /> jest mniejsza niż 0 lub reprezentuje czasu dłuższego niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <block subset="none" type="usage">
          <para>Zwykle <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> przywraca metody <see cref="T:System.DateTime" /> wartość, która została zapisana przez <see cref="M:System.DateTime.ToFileTime" /> metody. Jednak te dwie wartości mogą się różnić w następujących warunkach: — w przypadku serializacji i deserializacji <see cref="T:System.DateTime" /> wartość występują w różnych strefach czasowych. Na przykład jeśli <see cref="T:System.DateTime" /> wartości z godzina 12:00. w Stanach Zjednoczonych Strefa czasowa Wschodniej serializacji, a następnie deserializowany w Stanach Zjednoczonych Czas pacyficzny strefy, oryginalnej wartości o godzinie 12:30 jest dostosowywana do 9:30:00 odzwierciedlać różnicę między dwiema strefami czasowymi.  -Jeśli <see cref="T:System.DateTime" /> wartość, która jest serializowany reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej. W takim przypadku <see cref="M:System.DateTime.ToFileTime" /> metody dopasowuje przywróconej <see cref="T:System.DateTime" /> tak, aby reprezentuje prawidłową godzinę w lokalnej strefie czasowej.  Na przykład następuje przejście wsch. czas letni w Stanach Zjednoczonych Czas pacyficzny strefy na 14 marca 2010 o 2:00, gdy czas przechodzi przez godzinę, 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, że gdy czas, który mieści się w ten zakres jest przekonwertowana na wartość długich liczb całkowitych przez <see cref="M:System.DateTime.ToFileTime" /> metody, a następnie przywróceniu przez <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> metody oryginalnej wartości jest dostosowana do stają się czas ważności. Można określić, czy określoną datę i godzinę może podlegać modyfikacji, przekazując go do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, co w przykładzie przedstawiono.  [! code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [! code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTimeUtc (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTimeUtc(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTimeUtc(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTimeUtc (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTimeUtc(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTimeUtc : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTimeUtc fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">Czas plików systemu Windows wyrażony w taktach.</param>
        <summary>Konwertuje określony czas systemu Windows w pliku odpowiedni czas UTC.</summary>
        <returns>Obiekt reprezentujący odpowiednikiem czasu UTC Data i czas reprezentowany przez <paramref name="fileTime" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 `fileTime` Parametr określa plik czasowy w taktach 100-nanosekundowych.  
  
 W programie .NET Framework w wersji 2.0, jest zwracana wartość <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileTime" /> jest mniejsza niż 0 lub reprezentuje czasu dłuższego niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.DateTime.FromFileTime(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FromOADate">
      <MemberSignature Language="C#" Value="public static DateTime FromOADate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromOADate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromOADate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOADate (d As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromOADate(double d);" />
      <MemberSignature Language="F#" Value="static member FromOADate : double -&gt; DateTime" Usage="System.DateTime.FromOADate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty automatyzacji OLE.</param>
        <summary>Zwraca <see cref="T:System.DateTime" /> odpowiednikiem określonego OLE automatyzacji daty.</summary>
        <returns>Obiekt reprezentujący takie same daty i godziny jako <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `d` Parametr jest liczbie zmiennoprzecinkowej podwójnej precyzji, reprezentujący datę jako liczbę dni przed lub po daty podstawowej, północy, 30 grudnia 1899. Znak, a następnie całkowite część `d` kodowania datę dnia dodatnie lub ujemne przesunięcie od 30 grudnia 1899 i wartość bezwzględna ułamkowych części `d` koduje godzinę jako ułamek przesunięcie dzień od północy. `d` musi być wartością z zakresu od ujemna 657435.0 za pośrednictwem 2958465.99999999 dodatnią.  
  
 Należy pamiętać, że ze względu na sposób, w jaki są zakodowane daty, reprezentujący dowolną porę dnia na 30 grudnia 1899 na dwa sposoby. Na przykład -0,5 i 0,5 oznacza południe na 30 grudnia 1899, ponieważ przesunięcie dnia plus lub minus zero dni od daty podstawowej jest nadal daty podstawowej i przesunięcie pół dnia od północy południe.  
  
 Zobacz <xref:System.DateTime.ToOADate%2A> Aby uzyskać więcej informacji na temat automatyzacji OLE.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Data nie jest prawidłową wartością daty automatyzacji OLE.</exception>
        <altmember cref="M:System.DateTime.ToOADate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDateTimeFormats">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez standardowy format daty i czasu specyfikatory formatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie należy zakładać, że wiele wywołań <xref:System.DateTime.GetDateTimeFormats%2A> przeciążenia zwróci identyczne dane. W zależności od określonego przeciążenia danych zwróconych przez tę metodę można zmienić, jeśli bieżące zmiany kultury, użytkownik zastępuje poszczególne ustawienia kultury lub kultury danych systemu nastąpi aktualizacja.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : unit -&gt; string[]" Usage="dateTime.GetDateTimeFormats " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez standardowy format daty i czasu specyfikatory formatu.</summary>
        <returns>Tablica ciągów, gdzie każdy element jest reprezentacja wartość tego wystąpienia sformatowany za pomocą jednego z standardowa Data i godzina specyfikatory formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablicy ciągów zwrócony przez <xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType> metoda jest odpowiednikiem łączenie tablic ciąg zwrócony przez wywołań <xref:System.DateTime.GetDateTimeFormats%28System.Char%29?displayProperty=nameWithType> metody za pomocą "d", "D", "f", "F", "g", "G", "m", "o", "r", "s", "t", "T", "u", "U" i "y" standardowe ciągi formatujące. Aby uzyskać więcej informacji na temat specyfikatory formatu standardowych, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartości zwracanej jest sformatowany przy użyciu informacji z bieżącej kultury. Aby uzyskać więcej informacji dotyczących formatowania informacje specyficzne dla kultury dla bieżącej kultury, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z uwzględnieniem kultury danych, nie należy zakładać, że wiele wywołań metod zwróci identyczne dane. Danych zwróconych przez tę metodę można zmienić, jeśli bieżące zmiany kultury, użytkownik zastępuje poszczególne ustawienia kultury lub kultury danych systemu nastąpi aktualizacja.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType> metody. Wyświetla datę przy użyciu wszystkich możliwych standardowe formaty daty i godziny w bieżącej kultury komputera, w tym przypadku jest en US reprezentację ciągu.  
  
 [!code-cpp[DateTime.GetDateTimeFormats#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.GetDateTimeFormats#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#1)]
 [!code-vb[DateTime.GetDateTimeFormats#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#1)]  
  
 W przykładzie przedstawiono następujące dane wyjściowe:  
  
```  
7/28/2009  
7/28/09  
07/28/09  
07/28/2009  
09/07/28  
2009-07-28  
28-Jul-09  
Tuesday, July 28, 2009  
July 28, 2009  
Tuesday, 28 July, 2009  
28 July, 2009  
Tuesday, July 28, 2009 5:23 AM  
Tuesday, July 28, 2009 05:23 AM  
Tuesday, July 28, 2009 5:23  
Tuesday, July 28, 2009 05:23  
July 28, 2009 5:23 AM  
July 28, 2009 05:23 AM  
July 28, 2009 5:23  
July 28, 2009 05:23  
Tuesday, 28 July, 2009 5:23 AM  
Tuesday, 28 July, 2009 05:23 AM  
Tuesday, 28 July, 2009 5:23  
Tuesday, 28 July, 2009 05:23  
28 July, 2009 5:23 AM  
28 July, 2009 05:23 AM  
28 July, 2009 5:23  
28 July, 2009 05:23  
Tuesday, July 28, 2009 5:23:15 AM  
Tuesday, July 28, 2009 05:23:15 AM  
Tuesday, July 28, 2009 5:23:15  
Tuesday, July 28, 2009 05:23:15  
July 28, 2009 5:23:15 AM  
July 28, 2009 05:23:15 AM  
July 28, 2009 5:23:15  
July 28, 2009 05:23:15  
Tuesday, 28 July, 2009 5:23:15 AM  
Tuesday, 28 July, 2009 05:23:15 AM  
Tuesday, 28 July, 2009 5:23:15  
Tuesday, 28 July, 2009 05:23:15  
28 July, 2009 5:23:15 AM  
28 July, 2009 05:23:15 AM  
28 July, 2009 5:23:15  
28 July, 2009 05:23:15  
7/28/2009 5:23 AM  
7/28/2009 05:23 AM  
7/28/2009 5:23  
7/28/2009 05:23  
7/28/09 5:23 AM  
7/28/09 05:23 AM  
7/28/09 5:23  
7/28/09 05:23  
07/28/09 5:23 AM  
07/28/09 05:23 AM  
07/28/09 5:23  
07/28/09 05:23  
07/28/2009 5:23 AM  
07/28/2009 05:23 AM  
07/28/2009 5:23  
07/28/2009 05:23  
09/07/28 5:23 AM  
09/07/28 05:23 AM  
09/07/28 5:23  
09/07/28 05:23  
2009-07-28 5:23 AM  
2009-07-28 05:23 AM  
2009-07-28 5:23  
2009-07-28 05:23  
28-Jul-09 5:23 AM  
28-Jul-09 05:23 AM  
28-Jul-09 5:23  
28-Jul-09 05:23  
7/28/2009 5:23:15 AM  
7/28/2009 05:23:15 AM  
7/28/2009 5:23:15  
7/28/2009 05:23:15  
7/28/09 5:23:15 AM  
7/28/09 05:23:15 AM  
7/28/09 5:23:15  
7/28/09 05:23:15  
07/28/09 5:23:15 AM  
07/28/09 05:23:15 AM  
07/28/09 5:23:15  
07/28/09 05:23:15  
07/28/2009 5:23:15 AM  
07/28/2009 05:23:15 AM  
07/28/2009 5:23:15  
07/28/2009 05:23:15  
09/07/28 5:23:15 AM  
09/07/28 05:23:15 AM  
09/07/28 5:23:15  
09/07/28 05:23:15  
2009-07-28 5:23:15 AM  
2009-07-28 05:23:15 AM  
2009-07-28 5:23:15  
2009-07-28 05:23:15  
28-Jul-09 5:23:15 AM  
28-Jul-09 05:23:15 AM  
28-Jul-09 5:23:15  
28-Jul-09 05:23:15  
July 28  
July 28  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
5:23 AM  
05:23 AM  
5:23  
05:23  
5:23:15 AM  
05:23:15 AM  
5:23:15  
05:23:15  
2009-07-28 05:23:15Z  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15  
Tuesday, July 28, 2009 12:23:15  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15  
July 28, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15  
28 July, 2009 12:23:15  
July, 2009  
July, 2009  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char -&gt; string[]" Usage="dateTime.GetDateTimeFormats format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowa Data i godzina.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwana przez określony standardowa Data i czas specyfikator formatu.</summary>
        <returns>Sformatowane w tablicy ciągów, gdzie każdy element jest reprezentacja wartość tego wystąpienia <paramref name="format" /> standardowa Data i godzina specyfikator formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametru może być dowolny z standardowa Data i godzina specyfikatory formatu. Obejmują one d, D, f, F, g, G, M (lub m) O (lub o), R (lub r), s, t, T, u, U, a Y (lub y). Aby uzyskać więcej informacji, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartości zwracanej jest sformatowany przy użyciu informacji z bieżącej kultury. Aby uzyskać więcej informacji dotyczących formatowania informacje specyficzne dla kultury dla bieżącej kultury, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z uwzględnieniem kultury danych, nie należy zakładać, że wiele wywołań metod zwróci identyczne dane. Danych zwróconych przez tę metodę można zmienić, jeśli bieżące zmiany kultury, użytkownik zastępuje poszczególne ustawienia kultury lub kultury danych systemu nastąpi aktualizacja.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.Char%29> metody. Wyświetla reprezentację ciągu daty przy użyciu specyfikatora formatu daty długiej ("D") dla bieżącej kultury.  
  
 [!code-csharp[DateTime.GetDateTimeFormats#3](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#3)]
 [!code-vb[DateTime.GetDateTimeFormats#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłową datę standardowe i znak specyfikator formatu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu tego wystąpienia specyficzne dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez standardowa Data i czas specyfikatory formatu i określonego formatowania informacje specyficzne dla kultury.</summary>
        <returns>Tablica ciągów, gdzie każdy element jest reprezentacja wartość tego wystąpienia sformatowany za pomocą jednego z standardowa Data i godzina specyfikatory formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablicy ciągów zwrócony przez <xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType> metoda jest odpowiednikiem łączenie tablic ciąg zwrócony przez wywołań <xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody za pomocą "d", "D", "f", "F", "g", "G", "m", "o", "r", "s", "t", "T", "u", "U" i "y" standardowe ciągi formatujące. Aby uzyskać więcej informacji na temat specyfikatory formatu standardowych, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartości zwracanej jest sformatowany przy użyciu dostarczonych przez informacje specyficzne dla kultury `provider`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z uwzględnieniem kultury danych, nie należy zakładać wielu wywołań metody zwróci identyczne dane o ile `provider` jest <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje Niezmienna kultura. Danych zwróconych przez tę metodę można zmienić, jeśli użytkownik zastępuje poszczególne ustawienia kultury `provider` lub jeśli do danych kultury systemu nastąpi aktualizacja `provider`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType> metody. Wyświetla datę przy użyciu wszystkich możliwych standardowe formaty daty i godziny dla kultury fr-FR reprezentację ciągu.  
  
 [!code-cpp[DateTime.GetDateTimeFormats#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#2)]
 [!code-csharp[DateTime.GetDateTimeFormats#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#2)]
 [!code-vb[DateTime.GetDateTimeFormats#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#2)]  
  
 W przykładzie przedstawiono następujące dane wyjściowe:  
  
```  
28/07/2009  
28/07/09  
28.07.09  
28-07-09  
2009-07-28  
mardi 28 juillet 2009  
28 juil. 09  
28 juillet 2009  
mardi 28 juillet 2009 05:23  
mardi 28 juillet 2009 5:23  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23  
28 juil. 09 5:23  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23  
28 juillet 2009 5:23  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
mardi 28 juillet 2009 05:23:15  
mardi 28 juillet 2009 5:23:15  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23:15  
28 juil. 09 5:23:15  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23:15  
28 juillet 2009 5:23:15  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
28/07/2009 05:23  
28/07/2009 5:23  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23  
28/07/09 5:23  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23  
28.07.09 5:23  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23  
28-07-09 5:23  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23  
2009-07-28 5:23  
2009-07-28 05.23  
2009-07-28 05 h 23  
28/07/2009 05:23:15  
28/07/2009 5:23:15  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23:15  
28/07/09 5:23:15  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23:15  
28.07.09 5:23:15  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23:15  
28-07-09 5:23:15  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23:15  
2009-07-28 5:23:15  
2009-07-28 05.23  
2009-07-28 05 h 23  
28 juillet  
28 juillet  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
05:23  
5:23  
05.23  
05 h 23  
05:23:15  
5:23:15  
05.23  
05 h 23  
2009-07-28 05:23:15Z  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12.23  
mardi 28 juillet 2009 12 h 23  
28 juil. 09 12:23:15  
28 juil. 09 12:23:15  
28 juil. 09 12.23  
28 juil. 09 12 h 23  
28 juillet 2009 12:23:15  
28 juillet 2009 12:23:15  
28 juillet 2009 12.23  
28 juillet 2009 12 h 23  
juillet 2009  
juillet 2009  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char, provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char * IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats (format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu daty i godziny.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu tego wystąpienia specyficzne dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwana przez określony standardowa Data i specyfikator formatu czasu i formatowania informacje specyficzne dla kultury.</summary>
        <returns>Tablica ciągów, gdzie każdy element jest reprezentacja wartość tego wystąpienia sformatowany za pomocą jednego z standardowa Data i godzina specyfikatory formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format parametru może być dowolny z standardowa Data i godzina specyfikatory formatu. Obejmują one d, D, f, F, g, G, M (lub m) O (lub o), R (lub r), s, t, T, u, U, a Y (lub y). Aby uzyskać więcej informacji, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartości zwracanej jest sformatowany przy użyciu dostarczonych przez informacje specyficzne dla kultury `provider`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z uwzględnieniem kultury danych, nie należy zakładać wielu wywołań metody zwróci identyczne dane o ile `provider` jest <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje Niezmienna kultura. Danych zwróconych przez tę metodę można zmienić, jeśli użytkownik zastępuje poszczególne ustawienia kultury `provider` lub jeśli do danych kultury systemu nastąpi aktualizacja `provider`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29> metody. Wyświetla reprezentacji ciągu daty dla kultury fr-FR przy użyciu specyfikatora formatu daty krótkiej ("d").  
  
 [!code-csharp[DateTime.GetDateTimeFormats#4](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#4)]
 [!code-vb[DateTime.GetDateTimeFormats#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłową datę standardowe i znak specyfikator formatu czasu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dateTime.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="dateTime.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla typu wartości <see cref="T:System.DateTime" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.DateTime" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hour">
      <MemberSignature Language="C#" Value="public int Hour { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Hour" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Hour" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hour As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Hour { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Hour : int" Usage="System.DateTime.Hour" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik godziny z wartości daty reprezentowanym przez to wystąpienie.</summary>
        <value>Składnik godziny wyrażony jako wartość z zakresu od 0 do 23.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.DateTime.Hour%2A> właściwość zawsze jest wyrażona w 24-godzinnym. Aby pobrać ciąg, który reprezentuje godzinę Data i godzina 12-godzinnym, należy wywołać <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> lub <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metoda ze specyfikatorem formatu niestandardowego "h". Na przykład:  
  
 [!code-csharp[System.DateTime.Hour#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Hour/cs/Hour1.cs#1)]
 [!code-vb[System.DateTime.Hour#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Hour/vb/Hour1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Hour%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsDaylightSavingTime" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDaylightSavingTime () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime();" />
      <MemberSignature Language="F#" Value="member this.IsDaylightSavingTime : unit -&gt; bool" Usage="dateTime.IsDaylightSavingTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy to wystąpienie <see cref="T:System.DateTime" /> znajduje się w zakresie czasu letniego dla bieżącej strefy czasowej.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <see cref="P:System.DateTime.Kind" /> właściwość jest <see cref="F:System.DateTimeKind.Local" /> lub <see cref="F:System.DateTimeKind.Unspecified" /> i wartość tego wystąpienia <see cref="T:System.DateTime" /> znajduje się w zakresie czasu letniego na podstawie lokalnej strefy czasowej; <see langword="false" /> Jeśli <see cref="P:System.DateTime.Kind" /> jest <see cref="F:System.DateTimeKind.Utc" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy bieżący <xref:System.DateTime> wartość znajduje się w zakresie czasu letniego w lokalnej strefie czasowej, która jest zwracana przez <xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType> właściwości. Można określić, czy strefa czasowa obsługuje czasu letniego, pobierając zaletą jego <xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A?displayProperty=nameWithType> właściwości. Dla stref czasowych honorujących czasu letniego, można określić, kiedy następuje przejście do i z czasu letniego przez pobranie <xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType> tablica zwrócona przez strefę czasową <xref:System.TimeZoneInfo.GetAdjustmentRules%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli bieżący <xref:System.DateTime> wartość reprezentuje niejednoznaczne lub nieprawidłową wartość czas w lokalnej strefie czasowej, metoda zwraca `false`.  
  
 Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów, <xref:System.DateTime.IsDaylightSavingTime%2A> metody rozpoznaje tylko bieżącej regule korekty podczas ustalania, czy bieżące wystąpienie jest czasu letniego. W związku z tym metoda może nie dokładnie zgłaszać czy bieżące wystąpienie jest czasu letniego dla okresów przed wprowadzenia bieżącej regule dopasowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="IsLeapYear">
      <MemberSignature Language="C#" Value="public static bool IsLeapYear (int year);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLeapYear(int32 year) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsLeapYear(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLeapYear (year As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLeapYear(int year);" />
      <MemberSignature Language="F#" Value="static member IsLeapYear : int -&gt; bool" Usage="System.DateTime.IsLeapYear year" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok 4-cyfrowego.</param>
        <summary>Zwraca wskazuje, czy określony rok jest rokiem przestępnym.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="year" /> jest rokiem przestępnym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `year` jest określony jako podstawowy numer 10 4-cyfrowego; na przykład 1996.  
  
 `year` zawsze jest interpretowany jako rok kalendarza gregoriańskiego. Aby ustalić, czy danego roku jest rokiem przestępnym w niektórych innych kalendarza, wywołania tego obiektu kalendarza `IsLeapYear` metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.IsLeapYear%2A> metodę, aby ustalić, które lat między 1994 r. a 2014 są przestępnego. Wynik również pokazano w przykładzie podczas <xref:System.DateTime.AddYears%2A> metoda jest używana do dodawania roku do dnia przestępnym.  
  
 [!code-csharp[System.DateTime.IsLeapYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/cs/IsLeapYear1.cs#1)]
 [!code-vb[System.DateTime.IsLeapYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/vb/IsLeapYear1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż 1 lub większą niż 9999.</exception>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public DateTimeKind Kind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeKind Kind" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Kind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Kind As DateTimeKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTimeKind Kind { DateTimeKind get(); };" />
      <MemberSignature Language="F#" Value="member this.Kind : DateTimeKind" Usage="System.DateTime.Kind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy czas reprezentowany przez to wystąpienie jest oparta na czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</summary>
        <value>Jedna z wartości wyliczenia, które wskazuje reprezentuje bieżący czas. Wartość domyślna to <see cref="F:System.DateTimeKind.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ustawić jawnie <xref:System.DateTime.Kind%2A> właściwości nowej <xref:System.DateTime> wartość do określonego <xref:System.DateTimeKind> wartości przez wywołanie metody <xref:System.DateTime.SpecifyKind%2A> metody.  
  
 <xref:System.DateTime.Kind%2A> Właściwość umożliwia <xref:System.DateTime> wartość wyraźnie uwzględnienie uniwersalny czas koordynowany (UTC) lub czasu lokalnego. Z kolei <xref:System.DateTimeOffset> struktury może jednoznacznie odzwierciedlać dowolnym momencie w dowolnej strefie czasowej jako pojedynczy punkt w czasie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metody, aby zademonstrować sposób <xref:System.DateTime.Kind%2A> wpływ właściwości <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MaxValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxValue : DateTime" Usage="System.DateTime.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.DateTime" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest odpowiednikiem 23:59:59.9999999 UTC, 31 grudnia 9999 w kalendarza gregoriańskiego dokładnie jeden znaczników 100-nanosekundowych przed UTC 00:00:00 1 stycznia 10000.  
  
 Niektóre kalendarzy, takich jak <xref:System.Globalization.ThaiBuddhistCalendar>, obsługuje górnego zakresu, starszej niż <xref:System.DateTime.MaxValue>. W takich przypadkach próby uzyskania dostępu do <xref:System.DateTime.MaxValue> w przypisań zmiennych lub formatowania ani do analizowania operacje może zgłosić <xref:System.ArgumentOutOfRangeException>. Zamiast pobierania wartości <xref:System.DateTime.MaxValue?displayProperty=nameWithType>, można pobrać wartość określonej kultury najnowsze prawidłowej wartości daty z <xref:System.Globalization.Calendar.MaxSupportedDateTime?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.DateTime> obiektu przez przekazanie jej konstruktora <xref:System.Int64> wartość reprezentującą liczbę znaczników. Przed wywołaniem konstruktora, przykładzie zapewnia, że ta wartość jest większa niż lub równa `DateTime.MinValue.Ticks` i mniejsza niż lub równa `DateTime.MaxValue.Ticks`. Jeśli nie, zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.DateTime.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Millisecond">
      <MemberSignature Language="C#" Value="public int Millisecond { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Millisecond" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Millisecond" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Millisecond As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Millisecond { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Millisecond : int" Usage="System.DateTime.Millisecond" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik milisekund dacie reprezentowane przez to wystąpienie.</summary>
        <value>Składnik milisekund, wyrażony jako wartość z zakresu od 0 do 999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można wyświetlić reprezentację ciągu <xref:System.DateTime.Millisecond%2A> właściwości przy użyciu specyfikatora formatu "fff". Na przykład poniższy kod wyświetla ciąg, który zawiera liczbę milisekund w datę i godzinę do konsoli.  
  
 [!code-csharp[System.DateTime.Millisecond#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#1)]
 [!code-vb[System.DateTime.Millisecond#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#1)]  
  
 Można również wyświetlić składnika milisekund razem z innymi składnikami wartości daty i godziny przy użyciu specyfikatora formatu standardowych "o". Na przykład:  
  
 [!code-csharp[System.DateTime.Millisecond#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#2)]
 [!code-vb[System.DateTime.Millisecond#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#2)]  
  
 Jednak specyfikator formatu "o" ma mniej do wyświetlania niż dwustronną komunikację lub przechowywania <xref:System.DateTime> wartość. Można również wyświetlić milisekund razem z innymi składnikami daty i godziny przy użyciu ciągu formatu niestandardowego, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.DateTime.Millisecond#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#3)]
 [!code-vb[System.DateTime.Millisecond#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Millisecond%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Minute">
      <MemberSignature Language="C#" Value="public int Minute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Minute" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Minute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minute As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Minute { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Minute : int" Usage="System.DateTime.Minute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik minuty z wartości daty reprezentowanym przez to wystąpienie.</summary>
        <value>Składnik minuty, wyrażony jako wartość z zakresu od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Minute%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MinValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MinValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinValue : DateTime" Usage="System.DateTime.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje najniższą możliwą wartość elementu <see cref="T:System.DateTime" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest odpowiednikiem 00:00:00.0000000 UTC, 1 stycznia 0001 w kalendarza gregoriańskiego.  
  
 <xref:System.DateTime.MinValue> Określa datę i godzinę, która jest przypisana do niezainicjowanego <xref:System.DateTime> zmiennej. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.DateTime.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#1)]
 [!code-vb[System.DateTime.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#1)]  
  
 <xref:System.DateTime.MinValue> i <xref:System.DateTime.MaxValue> właściwości może służyć do zapewnienia, że wartość znajduje się w obsługiwanym zakresie przed przekazaniem go do <xref:System.DateTime> konstruktora. Kod w sekcji przykład przedstawia użycie tego.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.DateTime> obiektu przez przekazanie jej konstruktora <xref:System.Int64> wartość reprezentującą liczbę znaczników. Przed wywołaniem konstruktora, przykładzie zapewnia, że ta wartość jest większa niż lub równa `DateTime.MinValue.Ticks` i mniejsza niż lub równa `DateTime.MaxValue.Ticks`. Jeśli nie, zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Month">
      <MemberSignature Language="C#" Value="public int Month { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Month" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Month" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Month As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Month { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Month : int" Usage="System.DateTime.Month" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik miesiąca o dacie reprezentowane przez to wystąpienie.</summary>
        <value>Składnik miesiąca, wyrażony jako wartość z zakresu od 1 do 12.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Month%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Now">
      <MemberSignature Language="C#" Value="public static DateTime Now { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Now" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Now" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Now As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Now { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Now : DateTime" Usage="System.DateTime.Now" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> obiekt, który jest ustawiona na bieżącą datę i godzinę na tym komputerze, który jest wyrażona jako czas lokalny.</summary>
        <value>Obiekt, którego wartość jest bieżącą lokalnego datę i godzinę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Now%2A> Zwraca <xref:System.DateTime> wartość, która reprezentuje bieżącą datę i godzinę na komputerze lokalnym. Należy pamiętać, że występuje różnica między <xref:System.DateTime> wartość, która reprezentuje liczbę znaczników, które upłynęły od północy 1 stycznia 0001, i reprezentację ciągu, który <xref:System.DateTime> wartość, która określa wartość daty i godziny format określonych określonej kultury. Informacje dotyczące formatowania wartości daty i godziny, sekcji <xref:System.DateTime.ToString%2A> metody. W poniższym przykładzie przedstawiono ciągu daty krótkiej i godziny w wielu formatach specyficzne dla kultury.  
  
 [!code-cpp[System.DateTime.Now#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now1.cpp#2)]
 [!code-csharp[System.DateTime.Now#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now1.cs#2)]
 [!code-vb[System.DateTime.Now#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now1.vb#2)]  
  
 Rozdzielczość tej właściwości jest zależna od czasomierz systemu, który jest zależny od systemu operacyjnego. Zwykle należeć do zakresu od 0,5 i 15 milisekund. W związku z tym powtarzane wywołania <xref:System.DateTime.Now%2A> właściwość interwał krótki czas, taki jak pętlę, mogą zwracać taką samą wartość.  
  
 <xref:System.DateTime.Now%2A> Jest często używana do pomiaru wydajności. Jednak ze względu na jego niskiej rozdzielczości, nie jest odpowiednie do użycia jako narzędzie wzorcowe. Lepszym jest użycie <xref:System.Diagnostics.Stopwatch> klasy.  
  
 W programie .NET Framework w wersji 2.0, jest zwracana wartość <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> zwraca właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Można również użyć <xref:System.DateTimeOffset.Now%2A?displayProperty=nameWithType> właściwości można pobrać bieżącego lokalnego datę i godzinę. Umożliwia on czasu lokalnego, wyrażane jednoznacznie jako pojedynczy punkt w czasie, co z kolei sprawia, że ta wartość czasu przenośne na komputerach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Now%2A> i <xref:System.DateTime.UtcNow%2A> właściwości do pobrania z bieżącą lokalną datę i godzinę i bieżący uniwersalny koordynowane Data i godzina (UTC). Następnie używa konwencji formatowania liczby kultur do wyświetlenia ciągów, wraz z wartościami ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Now#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now2.cpp#3)]
 [!code-csharp[System.DateTime.Now#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now2.cs#3)]
 [!code-vb[System.DateTime.Now#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.Now" />
        <altmember cref="P:System.DateTime.UtcNow" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static DateTime operator + (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Addition(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Addition(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator +(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( + ) : DateTime * TimeSpan -&gt; DateTime" Usage="d + t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty i godziny do dodania.</param>
        <param name="t">Przedział czasu, aby dodać.</param>
        <summary>Dodaje określony interwał do określonej daty i godziny, reaguje, Nowa data i godzina.</summary>
        <returns>Obiekt, który jest sumą wartości <paramref name="d" /> i <paramref name="t" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.DateTime.Add%28System.TimeSpan%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano operator dodawania.  
  
 [!code-cpp[DateTime Operators#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#1)]
 [!code-csharp[DateTime Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#1)]
 [!code-vb[DateTime Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Equality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : DateTime * DateTime -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="d2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone wystąpienia elementu <see cref="T:System.DateTime" /> są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> i <paramref name="d2" /> reprezentują tego samego Data i godzina; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Equality%2A> Operator określa, czy dwa <xref:System.DateTime> wartości są równe, porównując ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano operatora równości.  
  
 [!code-cpp[DateTime Operators#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#2)]
 [!code-csharp[DateTime Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#2)]
 [!code-vb[DateTime Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTime" /> jest nowsza niż innego określony <see cref="T:System.DateTime" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="t1" /> jest nowsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThan%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTime" /> reprezentuje datę i godzinę, jest taka sama wcześniejsza niż innego określony <see cref="T:System.DateTime" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="t1" /> jest taka sama jak lub późniejsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThanOrEqual%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Inequality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : DateTime * DateTime -&gt; bool" Usage="System.DateTime.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="d2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone wystąpienia elementu <see cref="T:System.DateTime" /> nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="d1" /> i <paramref name="d2" /> nie reprezentują tego samego Data i godzina; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Inequality%2A> Operator określa, czy dwa <xref:System.DateTime> wartości nie są takie same, porównując ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTime" /> jest starsza niż innego określony <see cref="T:System.DateTime" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="t1" /> jest starsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThan%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTime" /> reprezentuje datę i godzinę, która jest taka sama jak lub starszej wersji niż inny określony <see cref="T:System.DateTime" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="t1" /> jest taka sama jak lub starszej niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThanOrEqual%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę znaczników. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określoną <see cref="T:System.DateTime" /> lub<see cref="T:System.TimeSpan" /> z określonej <see cref="T:System.DateTime" />.</summary>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static TimeSpan operator - (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Subtraction(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As DateTime, d2 As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeSpan operator -(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * DateTime -&gt; TimeSpan" Usage="d1 - d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Wartość daty i godziny, które chcesz odjąć od (minuend).</param>
        <param name="d2">Wartość daty i czasu do odjęcia (subtrahend).</param>
        <summary>Odejmuje określonej daty i czasu od innego określonej daty i godziny i zwraca przedział czasu.</summary>
        <returns>Odstęp czasu między <paramref name="d1" /> i <paramref name="d2" />, <paramref name="d1" /> minus <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Subtraction%28System.DateTime%2CSystem.DateTime%29> — Metoda nie należy wziąć pod uwagę wartość <xref:System.DateTime.Kind%2A> właściwości dwóch <xref:System.DateTime> wartości podczas przeprowadzania odejmowania. Przed odjęcie <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. W przeciwnym razie wynik będzie zawierać różnica między strefą czasową.  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.op_Subtraction%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType> Metody należy wziąć pod uwagę różnice między strefami czasowymi podczas wykonywania odejmowania.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> — metoda i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static DateTime operator - (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Subtraction(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator -(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * TimeSpan -&gt; DateTime" Usage="d - t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty i godziny, które chcesz odjąć od.</param>
        <param name="t">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje określony interwał z określoną datą i godziną i zwraca nową datę i godzinę.</summary>
        <returns>Obiekt, którego wartość jest wartością elementu <paramref name="d" /> minus wartość <paramref name="t" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odejmuje wartość impulsów `t` od wartości znaczniki `d`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> — metoda i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Subtract(System.TimeSpan)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
 [Która metoda zostanie wywołana?](#Tasks)   
 [Ciąg do analizy](#StringToParse)   
 [Konwencje analizy i kultury](#Culture)   
 [Styl i analizowanie elementów](#Styles)   
 [Wartość zwracana i DateTime.Kind](#kind)
 
<a name="Tasks"></a>   
### <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Do|wywołania|  
|--------|----------|  
|Przeanalizować ciągu daty i godziny przy użyciu konwencji bieżącej kultury.|<xref:System.DateTime.Parse%28System.String%29> Przeciążenia|  
|Przeanalizować ciągu daty i godziny przy użyciu konwencji określoną kulturę.|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> przeciążenia (zobacz [analizowaniem i konwencje kultury](#Culture))|  
|Przeanalizować ciągu daty i godziny z elementów stylu specjalnych (na przykład biały znak lub odstęp nie).|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> Przeciążenia|  
|Przeanalizować ciąg daty i godziny, który musi znajdować się w określonym formacie.|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> lub <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>|
|Analizowanie ciąg daty i godziny i dokonać konwersji do czasu UTC lub czasu lokalnego.|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> Przeciążenia|  
|Przeanalizować ciągu daty i godziny bez obsługi wyjątków.|<xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> — Metoda|  
|Przywróć (wyrównana) wartość daty i godziny utworzone przez operację formatowania.|Przekazać ciąg standardowy format "o" lub "r", aby <xref:System.DateTime.ToString%28System.String%29> — metoda i wywołanie <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia z <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>|  
|Przeanalizować ciągu daty i godziny w ustalonym formacie bariery komputera (i prawdopodobnie kultury).|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> lub <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> — metoda|  
  
<a name="StringToParse"></a>   
### <a name="the-string-to-parse"></a>Ciąg do analizy  
 <xref:System.DateTime.Parse%2A> Metody podejmuje próbę przekonwertowania reprezentacja ciągu wartości daty i godziny do jego <xref:System.DateTime> równoważne. Próbuje przeanalizować ciągu wejściowego całkowicie bez generowania <xref:System.FormatException> wyjątku.  
  
> [!IMPORTANT]
>  Jeśli podczas analizowania kończy się niepowodzeniem z powodu nierozpoznany format ciągu, <xref:System.DateTime.Parse%2A> metoda zgłasza <xref:System.FormatException>, podczas gdy <xref:System.DateTime.TryParse%2A> metoda zwraca `false`. Obsługa wyjątków mogą być kosztowne, należy użyć <xref:System.DateTime.Parse%2A> gdy analizy operacja oczekuje się powieść, ponieważ źródło danych wejściowych jest zaufany. <xref:System.DateTime.TryParse%2A> preferowane jest prawdopodobnie błędy podczas analizowania, szczególnie, ponieważ źródło danych wejściowych nie jest zaufany lub mieć wartości domyślne uzasadnione do zastąpienia dla ciągów, które nie przeanalizować pomyślnie.   

 Ciąg do przeanalizowania może mieć jedną z następujących formatów:  
  
-   Ciąg daty i składnika.  
  
-   Ciąg o daty, ale nie składnik czasu. Jeśli składnik czasu jest nieobecne, metoda zakłada północy 12:00. Jeśli składnik daty rokiem dwucyfrowym, zostanie przekonwertowane na rok, na podstawie <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> bieżącego kalendarza bieżącej kultury lub bieżącego kalendarza określonej kultury (Jeśli używasz przeciążenia z inną niż null `provider` argument).  
  
- Ciąg z składnik daty, która zawiera tylko miesiąc i rok, ale nie składnik dni. Metoda przyjmuje pierwszy dzień miesiąca.

- Ciąg z składnik daty, zawierającą tylko miesiąc i dzień, ale nie składnik roku. Metoda założono w bieżącym roku.

-   Ciąg o czasie, ale nie składnik daty. Metoda zakłada bieżącą datę, chyba, że należy wywołać <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia i obejmują <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> w `styles` argumentu, w którym przypadku metoda zakłada dnia 1 stycznia 0001.  

- Ciąg z składnik czasu, który zawiera tylko godzinę i oznaczenie AM/PM z nie składnik daty. Metoda zakłada aktualnej daty i godziny nie minut i sekund nie. To zachowanie można zmienić, wywołując <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia i obejmują <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> w `styles` argumentu, w którym przypadku metoda zakłada dnia 1 stycznia 0001.

-   Ciąg, który zawiera informacje o strefie czasowej i zgodne z normą ISO 8601. W poniższych przykładach pierwszy ciąg wyznacza uniwersalny czas koordynowany (UTC), a drugi określa czas w strefie czasowej, który wynosi siedem godziny wcześniejszy niż czas UTC:  
  
    "2008-11-01T19:35:00.0000000Z"   
    "2008-11-01T19:35:00.0000000-07:00"  
  
-   Ciąg, który zawiera określenia GMT i jest zgodny z formatem czasu RFC 1123; na przykład:  
  
     "SO 01 lis 2008 19:35:00 GMT"  
  
-   Ciąg, który zawiera datę i godzinę, wraz z informacjami przesunięcia strefy czasowej; na przykład:  
  
     "2009-03-01 05:42:00 -5:00"  

Poniższy przykład analizuje ciągów w każdym z tych formatów przy użyciu konwencji formatowania bieżącej kultury, w tym przypadku jest kulturą en US:

[!code-csharp-interactive[Default parsing](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse6.cs)]
[!code-vb[Default parsing](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse6.vb)]  
  
 Jeśli ciąg wejściowy reprezentuje przestępnego dzień w roku przestępnym w kalendarzu używana przez metodę analizowania (zobacz [konwencje analizy i kultury](#Culture)), <xref:System.DateTime.Parse%2A> metodę analizowania ciągu pomyślnie. Jeśli ciąg wejściowy reprezentuje dzień przestępnego w innych niż — roku przestępnego, metoda wygeneruje <xref:System.FormatException>.  
  
 Ponieważ <xref:System.DateTime.Parse%2A> metody podejmuje próbę przeanalizować reprezentacji ciągu daty i godziny przy użyciu reguły formatowania bieżącego lub określonej kultury, w trakcie analizowania przez innych kultur może zakończyć się niepowodzeniem. Aby przeanalizować określonych format daty i godziny w różnych ustawień regionalnych, użyj jednego z przeciążeń <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> — metoda i podaj specyfikator formatu.  
  
<a name="Culture"></a>   
### <a name="parsing-and-cultural-conventions"></a>Konwencje analizy i kultury  
 Skompilowanie wszystkich przeciążeń <xref:System.DateTime.Parse%2A> metody są zależne od kultury chyba że ciąg do przeanalizowania (reprezentowany przez `s` w poniższej tabeli) jest zgodna z wzorcem ISO 8601. Operacja analizowania używa informacje dotyczące formatowania w <xref:System.Globalization.DateTimeFormatInfo> obiekt, który jest uzyskiwana w następujący sposób:  
  
|Jeśli należy wywołać|I `provider` jest|Informacje dotyczące formatowania jest pochodną|  
|-----------------|-----------------------|--------------------------------------------|  
|<xref:System.DateTime.Parse%28System.String%29>|-|Bieżącej kultury wątku (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType> właściwości)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|A <xref:System.Globalization.DateTimeFormatInfo> obiektu|Określony <xref:System.Globalization.DateTimeFormatInfo> obiektu|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|`null`|Bieżącej kultury wątku (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType> właściwości)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|A <xref:System.Globalization.CultureInfo> obiektu|<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> Właściwości|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|Niestandardowe <xref:System.IFormatProvider> implementacji|<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> — Metoda|  
  
 Podczas formatowania informacji jest pochodną <xref:System.Globalization.DateTimeFormatInfo> obiektu <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> właściwość definiuje kalendarz używany w operacji analizy.  
  
 Jeśli przeanalizować ciągu daty i godziny przy użyciu <xref:System.Globalization.DateTimeFormatInfo> obiektu o dostosowane ustawienia, które są inne niż standardowe kultury, użyj <xref:System.DateTime.ParseExact%2A> zamiast metody <xref:System.DateTime.Parse%2A> metodę, aby zwiększyć prawdopodobieństwo pomyślnego konwersji. Niestandardowe daty i czasu ciąg może być skomplikowane i trudne do analizy. <xref:System.DateTime.Parse%2A> Metoda próbuje przeanalizować ciągu z kilku wzorców niejawne analizy, które może zakończyć się niepowodzeniem. Z kolei <xref:System.DateTime.ParseExact%2A> metoda wymaga jawnie określić wzorce dokładne analizy, które prawdopodobnie powiodą się. Aby uzyskać więcej informacji, zobacz sekcję "DateTimeFormatInfo i danych dynamicznych" w <xref:System.Globalization.DateTimeFormatInfo> tematu.  
  
> [!IMPORTANT]
>  Należy pamiętać, że Konwencji formatowania dla określonej kultury są dynamiczne i może być może ulec zmianie. Oznacza to, że podczas analizowania operacje, które są zależne od Konwencji formatowania domyślną kulturę (bieżącego) lub określ <xref:System.IFormatProvider> obiekt, który reprezentuje kultury niż Niezmienna kultura mogą nieoczekiwanie zakończyć się niepowodzeniem żadnego z następujących sytuacji:  
>   
> -   Dane specyficzne dla kultury zostały zmienione między mniejszym lub wersji programu .NET Framework lub w wyniku aktualizacji do istniejącej wersji programu .NET Framework.  
> -   Dane specyficzne dla kultury odzwierciedla preferencje użytkownika, które mogą się różnić od komputera lub sesjami.  
> -   Dane specyficzne dla kultury reprezentuje kultury zastąpienia, który zastępuje ustawienia standardowe kultury lub kultury niestandardowej.  
>   
>  Aby zapobiec trudności podczas analizowania danych oraz czasu ciągów, które są skojarzone z zmiany danych kultury, ciągi daty i czasu można analizować przy użyciu Niezmienna kultura, lub można wywołać <xref:System.DateTime.ParseExact%2A> lub <xref:System.DateTime.TryParseExact%2A> — metoda i określ dokładnego formatu ciąg do przeanalizowania. Jeśli są serializacji i deserializacji danych daty i godziny, możesz użyć konwencji formatowania z kulturą niezmienną albo można serializacji i deserializacji <xref:System.DateTime> wartość w formacie binarnym.  
>   
>  Aby uzyskać więcej informacji, zobacz sekcję "dane dynamiczne kultury" w <xref:System.Globalization.CultureInfo> w sekcji "wartości daty/godziny Persisting" i tematu <xref:System.DateTime> tematu.  
  
<a name="Styles"></a>   
### <a name="parsing-and-style-elements"></a>Analizowanie i elementy stylu  
 Wszystkie <xref:System.DateTime.Parse%2A> przeciążenia Ignoruj znaków spacji wiodących, wewnętrzny lub końcowych w ciągu wejściowym (reprezentowany przez `s` w poniższej tabeli). Data i godzina może być oddzielona z parą początkowe i końcowe znaki znaku numeru ("#", U + 0023) i może trailed z jedną lub więcej wartości NULL znaków (U + 0000).  
  
 Ponadto <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenie ma `styles` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.DateTimeStyles> wyliczenia. Ten parametr określa sposób `s` powinny być rozumiane i jak należy przekonwertować operacji analizowania `s` datę i godzinę. W poniższej tabeli opisano wpływ każdego <xref:System.Globalization.DateTimeStyles> elementu członkowskiego w operacji analizy.  
  
|Element członkowski DateTimeStyles|Wpływ na konwersji|  
|---------------------------|--------------------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC, w następujący sposób:<br /><br /> -Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> do wartości Czas UTC i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.<br />-Jeśli `s` wskazuje, że reprezentuje UTC, lub, jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.<br />-We wszystkich innych przypadkach flagi nie ma znaczenia.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Ta wartość jest ignorowana. Wewnętrzny biały znak jest zawsze dozwolone w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Ta wartość jest ignorowana. Wiodące biały znak jest zawsze dozwolone w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Ta wartość jest ignorowana. Końcowe biały znak jest zawsze dozwolone w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych. Jest to zachowanie domyślne. Nie można zastąpić podając bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wartości wyliczenia, takich jak <xref:System.Globalization.DateTimeStyles.None>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` brakuje zakłada, że wszystkie informacje o strefie czasowej czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` brakuje zakłada, że wszystkie informacje o strefie czasowej UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.None>|Choć ważna, wartość ta jest ignorowana.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje konwersji ciąg daty i godziny, aby zapobiec <xref:System.DateTime> wartość, która reprezentuje czas lokalny z jego <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Zazwyczaj taki ciąg jest tworzony przez wywołanie metody <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> — metoda i przy użyciu specyfikatora formatu standardowych "o", "r" lub "u".|  

<a name="kind"></a>   
### <a name="the-return-value-and-datetimekind"></a>Wartość zwracana i DateTime.Kind

`DateTime.Parse` Overloads powrotu <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind> właściwość zawiera informacje o strefie czasowej. Może oznaczać, że czas jest:

- Uniwersalny czas koordynowany (<xref:System.DateTimeKind.Utc?displayProperty=fullName>).
- Czas w lokalnej strefie czasowej (<xref:System.DateTimeKind.Local?displayProperty=fullName>).
- Czas w nieznanej strefie czasowej (xref:System.DateTimeKind.Unspecified?displayProperty=fullName >).
 
 Ogólnie rzecz biorąc <xref:System.DateTime.Parse%2A> metoda zwraca <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jednak <xref:System.DateTime.Parse%2A> metody może także dokonać konwersji strefy czasowej oraz ustaw wartość <xref:System.DateTime.Kind%2A> właściwości różnie w zależności od wartości `s` i `styles` parametry:  
  
|IF|Konwersji strefy czasowej|Właściwość Kind|  
|--------|--------------------------|-------------------|  
|`s` zawiera informacje o strefie czasowej.|Data i godzina jest konwertowana na czas w lokalnej strefie czasowej.|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|`s` zawiera informacje o strefie czasowej, a `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagi.|Data i godzina jest konwertowana na uniwersalny czas koordynowany (UTC).|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`s` zawiera oznaczeniem strefy czasowej Z lub GMT i `styles` obejmuje <xref:System.Globalization.DateTimeStyles.RoundtripKind> flagi.|Data i godzina są interpretowane jako czas UTC.|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
  
 Poniższy przykład konwertuje ciągi daty, które zawierają informacje o strefie czasowej czasu w lokalnej strefie czasowej:  
  
 [!code-csharp-interactive[System.DateTime.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse2.cs#2)]
 [!code-vb[System.DateTime.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse2.vb#2)]  

  Można również zachować wartość daty i czasu <xref:System.DateTime.Kind%2A> właściwości podczas formatowania ani do analizowania operacji za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi. Poniższy przykład przedstawia sposób <xref:System.Globalization.DateTimeStyles.RoundtripKind> flaga ma wpływ operacji analizy na <xref:System.DateTime> wartości, które są konwertowane na ciągi za pomocą specyfikator formatu "o", "r" lub "u".  
  
 [!code-csharp-interactive[System.DateTime.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse5.cs#5)]
 [!code-vb[System.DateTime.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse5.vb#5)]  
  
### Examples

Wiele przykłady, które wywołują `DateTime.Parse` metody rozmieszczonymi w [uwagi](#remarks) sekcji tego artykułu, w dokumentacji dla poszczególnych `DateTime.Parse` przeciążenia.

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Możesz również pobrać kompletny zestaw `DateTime.Parse` przykłady, które są zawarte w [projekt .NET Core 2.0 C#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/DateTime.Parse.zip) i [projekt Visual Basic .NET Core 2.0](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/DateTime.Parse.zip), z [dotnet/docs Repozytorium GitHub](https://github.com/dotnet/docs).

 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
        <altmember cref="Overload:System.DateTime.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; DateTime" Usage="System.DateTime.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg parse](#StringToParse), aby uzyskać więcej informacji.</param>
        <summary>Konwertuje reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu konwencji bieżącej kultury wątku.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Jeśli `s` zawiera informacje o strefie czasowej, ta metoda zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType> i konwertuje datę i godzinę w `s` na czas lokalny. W przeciwnym razie wykonuje brak konwersji strefy czasowej i zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.

To przeciążenie próbuje przeanalizować `s` przy użyciu konwencji formatowania bieżącej kultury. Bieżąca kultura jest określane przez <xref:System.Globalization.CultureInfo.CurrentCulture> właściwości. Aby przeanalizować ciągu przy użyciu konwencji formatowania z określoną kulturę, należy wywołać <xref:System.DateTime.Parse(System.String,System.IFormatProvider)> lub <xref:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)> przeciążenia.

To przeciążenie próbuje przeanalizować `s` przy użyciu <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType> stylu.

## <a name="example"></a>Przykład

Poniższy przykład analizuje reprezentację ciągu przez kilka wartości daty i godziny:

- Przy użyciu domyślnego dostawcę format, zapewniające Konwencji formatowania bieżącej kultury wątku komputera użyta do wyprodukowania przykładowe dane wyjściowe. Dane wyjściowe w tym przykładzie odzwierciedla Konwencji formatowania kultury en US.

- Przy użyciu wartości domyślnej styl, który jest <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWIthType>. 

Obsługuje on <xref:System.FormatException> wyjątek zgłaszany, gdy metoda spróbuje przeanalizować reprezentację ciągu daty i godziny przy użyciu niektóre inne kultury formatowanie Konwencji. Widoczny jest również sposób pomyślnie przeanalizować wartość daty i godziny, która nie używa konwencji formatowania bieżącej kultury wątku.  
  
 [!code-csharp-interactive[System.DateTime.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.DateTime.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse1.vb#1)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg parse](#StringToParse), aby uzyskać więcej informacji.</param>
        <param name="provider">Obiekt, który dostarcza informacji o formacie specyficzne dla kultury o <c>s</c>.  Zobacz [analizowaniem i conventions](#Culture) kultury</param>
        <summary>Konwertuje reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu informacji o formacie specyficzne dla kultury.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" /> określone przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Jeśli `s` zawiera informacje o strefie czasowej, ta metoda zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType> i konwertuje datę i godzinę w `s` na czas lokalny. W przeciwnym razie wykonuje brak konwersji strefy czasowej i zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.

To przeciążenie próbuje przeanalizować `s` przy użyciu <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType> stylu.

## <a name="example"></a>Przykład

Poniższy przykład analizuje tablica ciągów daty przy użyciu konwencji en US, fr-FR i de-DE kultur. Pokazuje go, że reprezentacji ciągu jednym dniu może zostać zinterpretowany inaczej w różnych kultur.  
  
[!code-csharp-interactive[System.DateTime.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse3.cs#3)]
[!code-vb[System.DateTime.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider = null, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional provider As IFormatProvider = null, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider, styles As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg parse](#StringToParse), aby uzyskać więcej informacji.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.  Zobacz [analizowaniem i conventions](#Culture) kultury</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>s</c> dla analizy operacja się powiodła oraz że definiuje sposób interpretacji daty analizowany w odniesieniu do bieżącej strefy czasowej lub Bieżąca data. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu informacji o formacie specyficzne dla kultury i styl formatowania.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" />, zgodnie z określonym <paramref name="provider" /> i <paramref name="styles" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

To przeciążenie metody Konwertuje datę i godzinę w `s` i ustawia <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> wartość w następujący sposób:

|IF |Konwersji strefy czasowej|Właściwość Kind|   
|-----|-----|-----|  
|`s` nie zawiera żadnych informacji o strefie czasowej.|Brak.|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|
|`s` zawiera informacje o strefie czasowej.|Godzinę w lokalnej strefie czasowej|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|
|`s` zawiera informacje o strefie czasowej, a "obejmuje style <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi.|Czas uniwersalne do skoordynowanego (UTC)|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|
|`s` zawiera oznaczeniem strefy czasowej Z lub GMT i `styles` obejmuje <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>.|Brak.|<xref:System.DateTimeKind.Utc>| 

## <a name="example"></a>Przykład

W poniższym przykładzie pokazano <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> — metoda i wyświetla wartość <xref:System.DateTime.Kind%2A> właściwość powstałe w ten sposób <xref:System.DateTime> wartości.  
  
[!code-csharp-interactive[System.DateTime.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse4.cs#4)]
[!code-vb[System.DateTime.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne. Format ciągu reprezentującego muszą być zgodne określonego formatu lub jest zgłaszany wyjątek.</summary>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="format">Specyfikator formatu, który definiuje wymagany format <c>s</c>. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza informacji o formacie specyficzne dla kultury o <c>s</c>.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" />, zgodnie z określonym <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. On również wymaga, aby \<Data > i \<czasu > elementy reprezentację ciągu daty i godziny są wyświetlane w kolejności określonej przez `format`oraz że `s` ma nie białe inną niż dozwolone przez `format`. Jeśli `format` definiuje datę żaden element czas i analizy operacja zakończy się powodzeniem, powstałe w ten sposób <xref:System.DateTime> wartość ma czas północ (00: 00:00). Jeśli `format` definiuje czas, Brak elementu dat i analizy operacja zakończy się powodzeniem, powstałe w ten sposób <xref:System.DateTime> data ma wartość `DateTime.Now.Date`.  
  
 Jeśli `s` nie reprezentuje czas w daną strefę czasową i operacji analizowania zakończy się powodzeniem, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> wartość jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli `s` odpowiadają za czas, w szczególności strefę czasową i `format` umożliwia informacji o strefie czasowej obecności (na przykład, jeśli `format` jest równa "o", "r" lub "u" specyfikatory formatu standardowych, lub jeśli zawiera "z", "zz" lub "zzz" Specyfikatory formatu niestandardowego), <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> wartość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
 `format` Parametr jest ciąg znaków zawierający pojedynczy standardowy specyfikator formatu lub specyfikatory formatu niestandardowego, które definiują wymagany format `s`. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) lub [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
> [!NOTE]
>  Jeśli `format` to wzorzec formatu niestandardowego, który nie obejmują separatorów daty lub godziny (na przykład "yyyyMMddHHmm"), użyj Niezmienna kultura `provider` specyfikator formatu parametru i najszerszych formę każdej niestandardowej. Na przykład jeśli chcesz określić godziny we wzorcu format, określ szerszy formularza, "HH", zamiast formularzu mniejszą niż "H".  
  
 Określonej daty i czasu symbole i ciągi (na przykład nazwy dni tygodnia w określonym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładne format `s` Jeśli `format` jest standardowym formacie Specyfikator ciąg. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury sposób interpretowania `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ParseExact%2A> metody.  
  
 [!code-csharp[System.DateTime.ParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/ParseExact1.cs#1)]
 [!code-vb[System.DateTime.ParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/ParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> lub <paramref name="format" /> jest pustym ciągiem.  - lub - <paramref name="s" /> nie zawiera datę i godzinę, umożliwiająca wzorca określonego w <paramref name="format" />.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie są zgodne.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="format">Specyfikator formatu, który definiuje wymagany format <c>s</c>. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia, które zawiera dodatkowe informacje na temat <c>s</c>, informacje o elementach stylu, które mogą być obecne w <c>s</c>, lub o konwersji z <c>s</c>do <see cref="T:System.DateTime" /> wartości. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego muszą być zgodne określony format lub jest zgłaszany wyjątek.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" />, zgodnie z określonym <paramref name="format" />, <paramref name="provider" />, i <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. Wymagane jest także, że elementy daty i godziny w `s` są wyświetlane w kolejności określonej przez `format`. Jeśli `s` nie pasuje do wzorca z `format` parametru z żadnych zmian, zdefiniowane przez `style` parametr, metoda wygeneruje <xref:System.FormatException>. Z kolei <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody analizuje reprezentację ciągu na datę w jednym z formatów rozpoznany przez dostawcę format <xref:System.Globalization.DateTimeFormatInfo> obiektu. <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody umożliwia także data i godzina elementów w `s` pojawią się w dowolnej kolejności.  
  
 Jeśli `s` parametr zawiera tylko godzina i data nie jest używany bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślna data (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę, a nie czas, północ (00: 00:00) jest używany. `style` Określa również parametr czy `s` parametr może zawierać wiodących, wewnętrzny lub końcowych białych znaków.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, które zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, w razie potrzeby i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi nie skonwertować uniwersalny czas koordynowany (UTC) na czas lokalny i ustawić <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `format` Parametru definiuje wymagany wzorzec `s` parametru. Może się składać z co najmniej jeden specyfikatorów formatu niestandardowego z [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub pojedynczy standardowy specyfikatora formatu, identyfikujący wzorzec wstępnie zdefiniowane z [standardowa Data i Ciągi formatu godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, użyj Niezmienna kultura `provider` specyfikator formatu parametru i najszerszych formę każdej niestandardowej. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
> [!NOTE]
>  Zamiast które `s` zgodne z jednego formatu do pomyślnego operacji analizy, można wywołać <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody oraz określić wiele formatów dozwolonych. Dzięki temu operacji analizowania częściej powiodło się.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, która określa, czy i w którym biały znak nie zdefiniowany przez `format` może występować w `s` i które kontrolują zachowanie dokładne operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC. Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może wystąpić między wszystkie daty lub czasu elementu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych nie jest zdefiniowany przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera czas bez informacje o dacie, Data zwracana wartość jest ustawiana `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametr jest analizowana przy użyciu wartości domyślnych. Nie białe innego niż się, że w `format` jest dozwolone. Jeśli `s` nie ma składnik daty Data zwróconego elementu <xref:System.DateTime> ma wartość 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje zapobiec konwersja <xref:System.DateTime> wartość daty i godziny z jego <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
 Określonej daty i czasu symbole i ciągi (na przykład nazwy dni tygodnia w określonym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładne format `s` Jeśli `format` jest standardowym formacie Specyfikator ciąg. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury sposób interpretowania `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29> metody. Należy pamiętać, że ciąg "2009-5-01 8:30 AM" nie może zostać przeanalizowany pomyślnie po `styles` parametr ma wartość <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType> ponieważ spacje początkowe nie są dozwolone w `format`. Ponadto ciąg "2009-5-01 09:00" nie może zostać przeanalizowany pomyślnie z `format` z "MM/dd/yyyyhh:mm", ponieważ ciąg daty nie poprzedza numer miesiąca z zerem, jako `format` wymaga.  
  
 [!code-csharp[System.DateTime.ParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact2.cs#2)]
 [!code-vb[System.DateTime.ParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> lub <paramref name="format" /> jest pustym ciągiem.  - lub - <paramref name="s" /> nie zawiera datę i godzinę, umożliwiająca wzorca określonego w <paramref name="format" />.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie są zgodne.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica dopuszczalne formaty <c>s</c>. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza informacji o formacie specyficzne dla kultury o <c>s</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>s</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu określonej tablicy formatów, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego muszą być zgodne co najmniej jednym z formatów określony lub jest zgłaszany wyjątek.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w <paramref name="s" />, zgodnie z określonym <paramref name="formats" />, <paramref name="provider" />, i <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, który pasuje do jednej z wzorców przypisane do `formats` parametru. Jeśli ciąg `s` niezgodny któregokolwiek z tych wzorców ze wszystkimi zmian zdefiniowane przez `styles` parametr, metoda wygeneruje <xref:System.FormatException>. Jako uzupełnienie porównanie `s` do wielu wzorców formatowania, a nie do pojedynczego wzorca formatowania, to przeciążenie zachowuje się tak samo do <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody.  
  
 `s` Parametr zawiera datę i godzinę, można przeanalizować. Jeśli `s` parametr zawiera tylko godzina i data nie jest używany bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślna data (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę, a nie czas, północ (00: 00:00) jest używany. `style` Określa również parametr czy `s` parametr może zawierać wiodących, wewnętrzny i końcowych białych znaków innych niż dozwolone przez jeden z ciągów formatu w `formats`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, które zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, w razie potrzeby i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi nie Konwertuj uniwersalny czas koordynowany (UTC) na czas lokalny i ustawić <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `formats` Parametr zawiera tablicę wzorców, z których jedna `s` musi odpowiadać dokładnie w przypadku operacji analizowania powiodło się. Wzorce w `formats` parametru składa się z co najmniej jeden specyfikatorów formatu niestandardowego z [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub pojedynczy standardowy specyfikatora formatu, identyfikujący wzorzec wstępnie zdefiniowane z [Standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, użyj Niezmienna kultura `provider` specyfikator formatu parametru i najszerszych formę każdej niestandardowej. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, która określa, czy i w którym biały znak nie zdefiniowany przez `format` może występować w `s` i które kontrolują zachowanie dokładne operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC. Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może wystąpić między wszystkie daty lub czasu elementu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych nie jest zdefiniowany przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera czas bez informacje o dacie, Data zwracana wartość jest ustawiana `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametr jest analizowana przy użyciu wartości domyślnych. Nie białe innego niż się, że w `format` jest dozwolone. Jeśli `s` nie ma składnik daty Data zwróconego elementu <xref:System.DateTime> ma wartość 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje zapobiec konwersja na datę i godzinę z jego <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
 Określonej daty i czasu symbole i ciągi (na przykład nazwy dni tygodnia w określonym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładne format `s` Jeśli `format` jest standardowym formacie Specyfikator ciąg. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury sposób interpretowania `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, aby upewnić się, że ciąg na wiele formatów możliwych można pomyślnie przeanalizować.  
  
 [!code-csharp[System.Datetime.ParseExact#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact3.cs#3)]
 [!code-vb[System.Datetime.ParseExact#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> lub <paramref name="formats" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> jest pustym ciągiem.  - lub - element <paramref name="formats" /> jest pustym ciągiem.  - lub - <paramref name="s" /> nie zawiera datę i godzinę, który odpowiada żadnym elementem <paramref name="formats" />.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie są zgodne.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Second">
      <MemberSignature Language="C#" Value="public int Second { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Second" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Second" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Second As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Second { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Second : int" Usage="System.DateTime.Second" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik sekund daty reprezentowanym przez to wystąpienie.</summary>
        <value>Składnik sekund, wyrażony jako wartość z zakresu od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Second%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpecifyKind">
      <MemberSignature Language="C#" Value="public static DateTime SpecifyKind (DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime SpecifyKind(valuetype System.DateTime value, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SpecifyKind (value As DateTime, kind As DateTimeKind) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime SpecifyKind(DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="static member SpecifyKind : DateTime * DateTimeKind -&gt; DateTime" Usage="System.DateTime.SpecifyKind (value, kind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="value">Data i godzina.</param>
        <param name="kind">Jedna z wartości wyliczenia, które wskazuje, czy nowy obiekt reprezentuje czasu lokalnego, UTC lub nie.</param>
        <summary>Tworzy nowy <see cref="T:System.DateTime" /> obiektu, który ma taką samą liczbę znaczników jako określony <see cref="T:System.DateTime" />, ale jest wyznaczony jako czas lokalny, uniwersalny czas koordynowany (UTC) lub nie, wskazywany przez określony <see cref="T:System.DateTimeKind" /> wartość.</summary>
        <returns>Nowy obiekt, który ma taką samą liczbę znaczników jako obiekt reprezentowany przez <paramref name="value" /> parametru i <see cref="T:System.DateTimeKind" /> wartość określoną przez <paramref name="kind" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.DateTime> obiekt składa się z polem rodzaju, który wskazuje, czy wartość czasu jest na podstawie czasu lokalnego, uniwersalny czas koordynowany (UTC) lub ani i pole znaczniki, które zawiera wartość czasu mierzony w taktach 100-nanosekundowych. <xref:System.DateTime.SpecifyKind%2A> Metoda tworzy nowy <xref:System.DateTime> przy użyciu określonego `kind` parametr i oryginalne wartości godziny.  
  
> [!IMPORTANT]
>  Zwrócona <xref:System.DateTime> wartości nie reprezentuje takie same błyskawicznych w czasie, gdy `value` parametru i <xref:System.DateTime.SpecifyKind%2A> nie jest metodą konwersji strefy czasowej. Zamiast tego pozostawia przez czas określony `value` parametru bez zmian i zestawy <xref:System.DateTime.Kind%2A> właściwości `kind`. Aby uzyskać informacje o konwersji strefy czasowej, zobacz [Konwertowanie godzin między strefami czasowymi](~/docs/standard/datetime/converting-between-time-zones.md).  
  
 <xref:System.DateTime.SpecifyKind%2A> Metoda jest przydatne w scenariuszach współdziałanie otrzymywania <xref:System.DateTime> obiektu z polem rodzaju nieokreślony, ale można określić przez niezależny od oznacza, że pole znaczniki reprezentuje czas lokalny lub UTC.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metody, aby zademonstrować sposób <xref:System.DateTime.Kind%2A> wpływ właściwości <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określony czas lub czasu trwania z tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public TimeSpan Subtract (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan Subtract(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan Subtract(DateTime value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : DateTime -&gt; TimeSpan" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Wartość daty i czasu do odjęcia.</param>
        <summary>Odejmuje określoną datą i godziną z tego wystąpienia.</summary>
        <returns>Przedział czasu równą Data i czas reprezentowany przez to wystąpienie minus Data i czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.DateTime%29> — Metoda określa różnicę między dwoma datami. Aby zmniejszyć przedział czasu z bieżącego wystąpienia, należy wywołać <xref:System.DateTime.Subtract%28System.TimeSpan%29> metody. Aby zmniejszyć przedział czasu określonego w bieżącym wystąpieniu, wywołaj metodę, która dodaje tym przedziale czasu do bieżącej daty i podaj wartości ujemnej jako argument metody. Na przykład aby odjąć dwóch miesięcy od bieżącej daty, należy wywołać <xref:System.DateTime.AddMonths%28System.Int32%29> metody o wartości -2.  
  
 Jeśli jest wcześniejsza niż data i godzina bieżącego wystąpienia `value`, metoda zwraca <xref:System.TimeSpan> obiekt, który reprezentuje przedział czasu ujemna. Oznacza to, że wartości wszystkich właściwości inną niż zero (takich jak <xref:System.TimeSpan.Days%2A> lub <xref:System.TimeSpan.Ticks%2A>) jest ujemna.  
  
 <xref:System.DateTime.Subtract%28System.DateTime%29> — Metoda nie należy wziąć pod uwagę wartość <xref:System.DateTime.Kind%2A> właściwości dwóch <xref:System.DateTime> wartości podczas przeprowadzania odejmowania. Przed odjęcie <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują razy w tej samej strefie czasowej. W przeciwnym razie wynik będzie zawierać różnica między strefą czasową.  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29?displayProperty=nameWithType> Metody należy wziąć pod uwagę różnice między strefami czasowymi podczas wykonywania odejmowania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> — metoda i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynik jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public DateTime Subtract (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Subtract(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Subtract(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : TimeSpan -&gt; DateTime" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje podany czas trwania z tego wystąpienia.</summary>
        <returns>Obiekt, który jest taki sam, Data i czas reprezentowany przez to wystąpienie minus czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29> Metoda zwraca datę, która różnica interwał czasu z bieżącego wystąpienia. Aby określić interwał między dwoma datami, należy wywołać <xref:System.DateTime.Subtract%28System.DateTime%29> metody. Aby zmniejszyć przedział czasu określonego w bieżącym wystąpieniu, wywołaj metodę, która dodaje tym przedziale czasu do bieżącej daty i podaj wartości ujemnej jako argument metody. Na przykład aby odjąć dwóch miesięcy od bieżącej daty, należy wywołać <xref:System.DateTime.AddMonths%28System.Int32%29> metody o wartości -2.  
  
 Ta metoda nie zmienia wartości to <xref:System.DateTime>. Zamiast tego zwraca nową <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Zwykle <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> odejmuje metody <xref:System.TimeSpan> obiekt, który reprezentuje dodatni zakres czasu i zwraca <xref:System.DateTime> wartość, która jest wcześniejsza niż data i godzina bieżącego wystąpienia. Jednak jeśli <xref:System.TimeSpan> obiekt reprezentuje ujemna okres <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> metoda zwraca <xref:System.DateTime> wartość, która jest późniejsza niż data i godzina bieżącego wystąpienia.  
  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> Metoda służy do odejmowania przedział czasu, który składa się z więcej niż jednej jednostki czasu, takie jak (daną liczbę godzin) i daną liczbę minut. Aby zmniejszyć pojedynczą jednostkę czasu (na przykład lat, miesięcy lub dni) <xref:System.DateTime> wystąpienia, można przekazać ujemna wartość numeryczną jako parametr do żadnego z następujących metod:  
  
-   <xref:System.DateTime.AddYears%2A>, aby zmniejszyć określoną liczbę lat od bieżącej daty i godziny wystąpienia.  
  
-   <xref:System.DateTime.AddMonths%2A>, aby odjąć określoną liczbę miesięcy od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddDays%2A>, aby odjąć określoną liczbę dni od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddHours%2A>, aby odjąć określoną liczbę godzin od bieżącej daty i godziny wystąpienia.  
  
-   <xref:System.DateTime.AddMinutes%2A>, aby odjąć określonej liczby minut od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddSeconds%2A>, do odjęcia określoną liczbę sekund z bieżącym wystąpieniem daty i godziny.  
  
-   <xref:System.DateTime.AddMilliseconds%2A>, aby odjąć określoną liczbę milisekund z bieżącym wystąpieniem daty i godziny.  
  
-   <xref:System.DateTime.AddTicks%2A>, aby odjąć określoną liczbę znaczników z bieżącym wystąpieniem daty i godziny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> — metoda i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynik jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Zwraca bieżącą <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Bieżący obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Odpowiedniego typu.</param>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Konwertuje bieżący <see cref="T:System.DateTime" /> obiektu do obiektu określonego typu.</summary>
        <returns>Obiekt określony przez typ <paramref name="type" /> parametru z wartością odpowiednikiem bieżącego <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana dla <see cref="T:System.DateTime" /> typu.</exception>
        <altmember cref="T:System.Convert" />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda zgłasza <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt używany do wypełniania danymi.</param>
        <param name="context">Miejsce docelowe dla serializacji. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu o dane potrzebne do serializacji bieżącego <see cref="T:System.DateTime" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wypełnienie `info` parametr o <xref:System.DateTime.Ticks%2A> i <xref:System.DateTime.Kind%2A> wartości właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Ticks">
      <MemberSignature Language="C#" Value="public long Ticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Ticks" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Ticks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ticks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Ticks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Ticks : int64" Usage="System.DateTime.Ticks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaczników, które reprezentują daty i godziny tego wystąpienia.</summary>
        <value>Liczba Takty reprezentujących daty i godziny tego wystąpienia. Wartość jest między <see langword="DateTime.MinValue.Ticks" /> i <see langword="DateTime.MaxValue.Ticks" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeden znacznik reprezentuje nanosekundach sto lub co 10 milionowych sekundy. Brak 10 000 impulsów w milisekundy lub 10 milionów impulsów na sekundę.  
  
 Wartość ta właściwość reprezentuje liczbę 100-nanosekundowych interwałów, które upłynęły od północy 12:00:00 1 stycznia 0001 (0: 00:00 UTC 1 stycznia 0001, kalendarza gregoriańskiego), który reprezentuje <xref:System.DateTime.MinValue?displayProperty=nameWithType>. Nie ma liczbę znaczników, które są przypisane do leap sekund.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Ticks%2A> właściwości, aby wyświetlić liczbę znaczników, które upłynęły od początku wieku dwudziestego pierwszego i można utworzyć wystąpienia <xref:System.TimeSpan> obiektu. <xref:System.TimeSpan> Obiekt jest następnie używany do wyświetlania czas, który upłynął przy użyciu kilku odstępach czasu.  
  
 [!code-csharp[System.DateTime.Ticks#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Ticks/cs/Ticks.cs#1)]
 [!code-vb[System.DateTime.Ticks#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Ticks/vb/Ticks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeOfDay">
      <MemberSignature Language="C#" Value="public TimeSpan TimeOfDay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeOfDay" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.TimeOfDay" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfDay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeOfDay { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeOfDay : TimeSpan" Usage="System.DateTime.TimeOfDay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę dla tego wystąpienia.</summary>
        <value>Przedział czasu, który reprezentuje część dnia, który upłynął od północy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.DateTime.Date%2A> właściwości. która zwraca <xref:System.DateTime> wartość, która reprezentuje datę bez jego składnik czasu <xref:System.DateTime.TimeOfDay%2A> zwraca <xref:System.TimeSpan> wartość, która reprezentuje <xref:System.DateTime> składnik godziny z wartości.  
  
 Jeśli chcesz wyświetlić godzinę lub pobrać reprezentację ciągu godzina dnia <xref:System.DateTime> wartość, należy zamiast tego wywołania przeciążenia <xref:System.DateTime.ToString%2A> metodę, która ma `format` parametr lub użyj [złożone formatowanie ](~/docs/standard/base-types/composite-formatting.md) funkcji "t" lub "T" standardowego formatu ciągu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wartości <xref:System.DateTime.TimeOfDay%2A> właściwość tablicę <xref:System.DateTime> wartości. On również zachowanie różni się od wartości zwracanej długość ciągu zwróconego przez ciąg formatu standardowych "t" w złożonych operacji formatowania.  
  
 [!code-csharp[System.DateTime.TimeOfDay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.timeofday/cs/timeofday1.cs#1)]
 [!code-vb[System.DateTime.TimeOfDay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.timeofday/vb/timeofday1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="ToBinary">
      <MemberSignature Language="C#" Value="public long ToBinary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToBinary() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToBinary" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBinary () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToBinary();" />
      <MemberSignature Language="F#" Value="member this.ToBinary : unit -&gt; int64" Usage="dateTime.ToBinary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializuje bieżącego <see cref="T:System.DateTime" /> obiektu na wartość binarną 64-bitowym, który następnie może służyć do odtworzenia <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>64-bitowe liczby całkowite ze znakiem koduje <see cref="P:System.DateTime.Kind" /> i <see cref="P:System.DateTime.Ticks" /> właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować wartość bieżącej klasy <xref:System.DateTime> obiektu na wartość binarną. Następnie należy użyć wartości binarne i <xref:System.DateTime.FromBinary%2A> metodę, aby ponownie utworzyć oryginalną <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  W niektórych przypadkach <xref:System.DateTime> wartość zwrócona przez <xref:System.DateTime.FromBinary%2A> metoda nie jest taka sama jak oryginalny <xref:System.DateTime> wartość dostarczona do <xref:System.DateTime.ToBinary%2A> metody. Aby uzyskać więcej informacji zobacz następną sekcję, "Czas lokalny dopasowania".  
  
## <a name="local-time-adjustment"></a>Ustawianie czasu lokalnego  
 Czas lokalny, będący skoordynowanego czasu uniwersalnego dostosowana do lokalnej strefy czasowej, jest reprezentowana przez <xref:System.DateTime> struktury, którego <xref:System.DateTime.Kind%2A> właściwość ma wartość <xref:System.DateTimeKind.Local>. Podczas przywracania lokalnym <xref:System.DateTime> wartość binarna reprezentacja, który jest generowany przez <xref:System.DateTime.ToBinary%2A> metody <xref:System.DateTime.FromBinary%2A> — metoda może dostosować wartość do odtworzenia, dzięki czemu nie jest taki sam, jak oryginalna wartość. Taka sytuacja może wystąpić w następujących warunkach:  
  
-   Jeśli na komputerze lokalnym <xref:System.DateTime> serializowany jest obiekt w jednej strefie czasowej przez <xref:System.DateTime.ToBinary%2A> metody, a następnie deserializowany w innej strefie czasowej przez <xref:System.DateTime.FromBinary%2A> metoda, czas lokalny reprezentowany przez powstałe w ten sposób <xref:System.DateTime> obiektu jest automatycznie dostosowywany drugi strefę czasową.  
  
     Rozważmy na przykład <xref:System.DateTime> obiekt, który reprezentuje czasu lokalnego, o godzinie 3 Aplikacja, która jest wykonywany w Stanach Zjednoczonych Używa strefy czas pacyficzny <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować który <xref:System.DateTime> obiektu na wartość binarną. Inna aplikacja, który jest wykonywany w Stanach Zjednoczonych Używa strefy czasowej Wschodniej <xref:System.DateTime.FromBinary%2A> metodę, aby przekonwertować wartość binarną na nowy <xref:System.DateTime> obiektu. Wartość nowego <xref:System.DateTime> obiekt jest 18: 00, reprezentujący tego samego punktu w czasie, gdy oryginalne godzinie 3 wartość, ale jest dostosowana do czasu lokalnego w strefie czasowej Wschodniej.  
  
-   Jeśli reprezentacja binarna lokalnym <xref:System.DateTime> wartość reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej systemu, na którym <xref:System.DateTime.FromBinary%2A> jest wywoływana, czas jest uwzględniany, aby była nieprawidłowa.  
  
     Na przykład następuje przejście wsch. czas letni w Stanach Zjednoczonych Czas pacyficzny strefy na 14 marca 2010 o 2:00, gdy czas przechodzi przez godzinę, 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartości binarnej przez jest konwertowany ten zakres <xref:System.DateTime.ToBinary%2A> metody, a następnie przywróceniu przez <xref:System.DateTime.FromBinary%2A> metody oryginalnej wartości jest dostosowana do stają się czas ważności. Można określić, czy określoną datę i godzinę może podlegać modyfikacji, przekazując go do <xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType> metody, co w przykładzie przedstawiono.  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.DateTime> struktura składa się z pole private rodzaju, który wskazuje, czy określona wartość jest oparta na czas lokalny, uniwersalny czas koordynowany (UTC) lub nie oraz pole prywatne znaczniki które zawiera liczbę taktów 100-nanosekundowych, które Określ datę i godzinę. Pole znaczniki osi jest możliwy z <xref:System.DateTime.Ticks%2A> właściwość i pole rodzaju są dostępne z <xref:System.DateTime.Kind%2A> właściwości.  
  
 Przed programu .NET Framework 2.0, jeśli można serializować <xref:System.DateTime> obiektu zamiast ręcznie przy użyciu interfejsu serializacji, takich jak <xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>, potrzebne do serializacji danych znaczniki <xref:System.DateTime> struktury. Począwszy od wersji 2.0, należy również serializować rodzaju danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.FromBinary(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="Today">
      <MemberSignature Language="C#" Value="public static DateTime Today { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Today" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Today" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Today As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Today { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Today : DateTime" Usage="System.DateTime.Today" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą datę.</summary>
        <value>Obiekt, który ma ustawioną wartość dzisiaj, za pomocą składnika czas ustawiony na 00:00:00.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 2.0, jest zwracana wartość <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> zwraca właściwość <xref:System.DateTimeKind.Local>.  
  
 Ponieważ zwraca bieżącą datę bez bieżący czas <xref:System.DateTime.Today%2A> właściwości są odpowiednie do użycia w aplikacji współdziałających ze tylko daty. Aby uzyskać więcej informacji, zobacz [wybór pomiędzy DateTime, DateTimeOffset, TimeSpan i TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md). Z kolei <xref:System.DateTime.TimeOfDay%2A> właściwość zwraca bieżącą godzinę bez bieżącą datę i <xref:System.DateTime.Now%2A> właściwość zwraca zarówno bieżącą datę i bieżącym czasem.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Date%2A> właściwość, aby pobrać bieżącą datę. Ponadto przedstawiono sposób <xref:System.DateTime> wartość może być sformatowany przy użyciu niektóre standardowe ciągi daty i godziny format. Należy pamiętać, że dane wyjściowe są produkowane przez wywołanie trzeci <xref:System.DateTime.ToString%28System.String%29> metoda używa specyfikator formatu g uwzględnienie składnik czasu wynosi zero.  
  
 [!code-csharp[System.DateTime.Today#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Today/cs/Today1.cs#1)]
 [!code-vb[System.DateTime.Today#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Today/vb/Today1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Now" />
        <altmember cref="P:System.DateTime.TimeOfDay" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTime">
      <MemberSignature Language="C#" Value="public long ToFileTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTime () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTime();" />
      <MemberSignature Language="F#" Value="member this.ToFileTime : unit -&gt; int64" Usage="dateTime.ToFileTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiektu do czasu pliku systemu Windows.</summary>
        <returns>Wartość bieżącego <see cref="T:System.DateTime" /> obiektu wyrażona jako czas plików systemu Windows.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 <xref:System.DateTime.ToFileTime%2A> Używa metody <xref:System.DateTime.Kind%2A> umożliwia określenie, czy bieżący <xref:System.DateTime> obiekt jest czasu lokalnego, czasu UTC lub nieokreślona rodzaj czas, który jest traktowany jako czas lokalny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToFileTime%2A> metody.  
  
 [!code-cpp[DateTime.ToFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa czasu pliku będzie reprezentować datę i godzinę przed północy 12:00 1 stycznia 1601 r. N.E. UTC.</exception>
        <block subset="none" type="usage">
          <para>Zwykle <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> przywraca metody <see cref="T:System.DateTime" /> wartość, która została zapisana przez <see cref="M:System.DateTime.ToFileTime" /> metody. Jednak te dwie wartości mogą się różnić w następujących warunkach: — w przypadku serializacji i deserializacji <see cref="T:System.DateTime" /> wartość występują w różnych strefach czasowych. Na przykład jeśli <see cref="T:System.DateTime" /> wartości z godzina 12:00. w Stanach Zjednoczonych Strefa czasowa Wschodniej serializacji, a następnie deserializowany w Stanach Zjednoczonych Czas pacyficzny strefy, oryginalnej wartości o godzinie 12:30 jest dostosowywana do 9:30:00 odzwierciedlać różnicę między dwiema strefami czasowymi.  -Jeśli <see cref="T:System.DateTime" /> wartość, która jest serializowany reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej. W takim przypadku <see cref="M:System.DateTime.ToFileTime" /> metody dopasowuje przywróconej <see cref="T:System.DateTime" /> tak, aby reprezentuje prawidłową godzinę w lokalnej strefie czasowej.  Na przykład następuje przejście wsch. czas letni w Stanach Zjednoczonych Czas pacyficzny strefy na 14 marca 2010 o 2:00, gdy czas przechodzi przez godzinę, 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, że gdy czas, który mieści się w ten zakres jest przekonwertowana na wartość długich liczb całkowitych przez <see cref="M:System.DateTime.ToFileTime" /> metody, a następnie przywróceniu przez <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> metody oryginalnej wartości jest dostosowana do stają się czas ważności. Można określić, czy określoną datę i godzinę może podlegać modyfikacji, przekazując go do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, co w przykładzie przedstawiono.  [! code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [! code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToFileTimeUtc" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTimeUtc">
      <MemberSignature Language="C#" Value="public long ToFileTimeUtc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTimeUtc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTimeUtc" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTimeUtc () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTimeUtc();" />
      <MemberSignature Language="F#" Value="member this.ToFileTimeUtc : unit -&gt; int64" Usage="dateTime.ToFileTimeUtc " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiektu do czasu pliku systemu Windows.</summary>
        <returns>Wartość bieżącego <see cref="T:System.DateTime" /> obiektu wyrażona jako czas plików systemu Windows.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 <xref:System.DateTime.ToFileTimeUtc%2A> Używa metody <xref:System.DateTime.Kind%2A> umożliwia określenie, czy bieżący <xref:System.DateTime> obiekt jest czasu lokalnego, czasu UTC lub nieokreślona rodzaj czas, który jest traktowany jako czas UTC. Jeśli jest czasu lokalnego, Konwertuje czas UTC przed przeprowadzeniem konwersji na czas plików systemu Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa czasu pliku będzie reprezentować datę i godzinę przed północy 12:00 1 stycznia 1601 r. N.E. UTC.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToFileTimeUtc" /> Przekonwertować czasu lokalnego na czas UTC, a następnie przywróć ją po wywołaniu metody jest czasami używana <see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" /> metody następuje <see cref="M:System.DateTime.ToLocalTime" /> metody. Jednak jeśli oryginalna godzina reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej, te dwie wartości czasu lokalnego nie będzie taki sam. Aby uzyskać dodatkowe informacje, zobacz <see cref="M:System.DateTime.ToLocalTime" /> metody.</para>
        </block>
        <altmember cref="M:System.DateTime.ToFileTime" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToLocalTime">
      <MemberSignature Language="C#" Value="public DateTime ToLocalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToLocalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLocalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLocalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToLocalTime();" />
      <MemberSignature Language="F#" Value="member this.ToLocalTime : unit -&gt; DateTime" Usage="dateTime.ToLocalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiektu na czas lokalny.</summary>
        <returns>Obiekt których <see cref="P:System.DateTime.Kind" /> właściwość jest <see cref="F:System.DateTimeKind.Local" />, którego wartość jest odpowiednikiem wartości bieżącego czasu lokalnego <see cref="T:System.DateTime" /> obiekt, lub <see cref="F:System.DateTime.MaxValue" /> Jeżeli skonwertowana wartość jest za duża, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MinValue" /> Jeśli skonwertowana wartość jest za mały, aby mogła być przedstawiana jako <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas lokalny jest równa czas uniwersalny czas koordynowany (UTC) oraz przesunięcie czasu UTC. Aby uzyskać więcej informacji na temat przesunięcie czasu UTC, zobacz <xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>. Konwersja uwzględnia również zasady czasu letniego, która dotyczy czas reprezentowany przez bieżący <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów, <xref:System.DateTime.ToLocalTime%2A> metody rozpoznaje tylko bieżącej regule korekty podczas konwertowania czasu UTC na czas lokalny. W związku z tym konwersje dla okresów przed wprowadzenia bieżącej regule korekty może nie odzwierciedlają dokładnie różnica między czasem UTC i czasem lokalnym.  
  
 W programie .NET Framework w wersji 2.0, wartość zwracana przez <xref:System.DateTime.ToLocalTime%2A> metoda jest określana przez <xref:System.DateTime.Kind%2A> właściwości bieżącego <xref:System.DateTime> obiektu. W poniższej tabeli opisano możliwe rezultaty.  
  
|rodzaj|Wyniki|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|To wystąpienie <xref:System.DateTime> jest konwertowana na czas lokalny.|  
|<xref:System.DateTimeKind.Local>|Konwersja nie jest wykonywane.|  
|<xref:System.DateTimeKind.Unspecified>|To wystąpienie <xref:System.DateTime> zakłada, że czas UTC, konwersja jest przeprowadzane tak, jakby <xref:System.DateTime.Kind%2A> zostały <xref:System.DateTimeKind.Utc>.|  
  
> [!NOTE]
>  <xref:System.DateTime.ToLocalTime%2A> Metoda konwertuje <xref:System.DateTime> wartości od czasu UTC na czas lokalny. Aby przekonwertować czasu w dowolnej wyznaczonych strefy czasowej na czas lokalny, użyj <xref:System.TimeZoneInfo.ConvertTime%2A?displayProperty=nameWithType> metody.  
  
 Wartość zwracana przez konwersję jest <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> właściwość zawsze zwraca <xref:System.DateTimeKind.Local>. W rezultacie nieprawidłowy wynik zostanie zwrócony nawet wtedy, gdy <xref:System.DateTime.ToLocalTime%2A> zastosowano się wielokrotnie do tego samego <xref:System.DateTime>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLocalTime%2A> metody. Należy pamiętać, że dokładne dane wyjściowe zależy od bieżącej kultury i w lokalnej strefie czasowej systemu, na którym jest uruchomiona.  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metody, aby zademonstrować sposób <xref:System.DateTime.Kind%2A> wpływ właściwości <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Można użyć <see cref="M:System.DateTime.ToLocalTime" /> metoda przywracania lokalnego wartość daty i godziny przekonwertowanego na czas UTC przez <see cref="M:System.DateTime.ToUniversalTime" /> lub <see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" /> metody. Jednak jeśli oryginalna godzina reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej, nie będzie odpowiadała przywrócone wartości. Gdy <see cref="M:System.DateTime.ToLocalTime" /> metoda konwertuje godzinę w formacie UTC w lokalnej strefie czasowej, również można dostosować tak to jest prawidłowa godzina w lokalnej strefie czasowej.  Na przykład następuje przejście wsch. czas letni w Stanach Zjednoczonych Czas pacyficzny strefy na 14 marca 2010 o 2:00, gdy czas przechodzi przez godzinę, 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w UTC przez jest konwertowany ten zakres <see cref="M:System.DateTime.ToUniversalTime" /> metody, a następnie przywróceniu przez <see cref="M:System.DateTime.ToLocalTime" /> metody oryginalnej wartości jest dostosowana do stają się czas ważności. Można określić, czy określoną datę i godzinę może podlegać modyfikacji, przekazując go do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, co w przykładzie przedstawiono.  [! code-csharp[System.DateTime.ToLocalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolocaltime/cs/tolocaltime1.cs#1)] [! code-vb[System.DateTime.ToLocalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolocaltime/vb/tolocaltime1.vb#1)]</para>
        </block>
        <altmember cref="T:System.TimeZone" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.TimeZone.GetDaylightChanges(System.Int32)" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
      </Docs>
    </Member>
    <Member MemberName="ToLongDateString">
      <MemberSignature Language="C#" Value="public string ToLongDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongDateString();" />
      <MemberSignature Language="F#" Value="member this.ToLongDateString : unit -&gt; string" Usage="dateTime.ToLongDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu daty długiej równoważne.</summary>
        <returns>Ciąg zawierający reprezentację ciągu daty długiej bieżącego <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiekt jest sformatowany przy użyciu wzorca zdefiniowane przez <xref:System.Globalization.DateTimeFormatInfo.LongDatePattern%2A> właściwości skojarzonej z bieżącej kultury wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "D" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Długość ciągu zwróconego przez <xref:System.DateTime.ToLongDateString%2A> metoda jest zależne od kultury. Odzwierciedla wzorcowi określonemu przez bieżącej kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US wzorzec standardowa Data długa jest "rrrr dddd, MMMMdd,"; dla kultury de-DE jest "dddd, d. MMMMyyyy"; dla kultury ja-JP jest "yyyy"? " M "?" d'? ' ". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowych daty długiej.  
  
 Aby uzyskać więcej informacji o bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji na temat znaków format, format wzorców i dane wyjściowe, wygenerowanie, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji na temat zmieniania wzorzec formatu, skojarzone ze znakiem format, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLongDateString%2A> metody.  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToLongTimeString">
      <MemberSignature Language="C#" Value="public string ToLongTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToLongTimeString : unit -&gt; string" Usage="dateTime.ToLongTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne dużo czasu.</summary>
        <returns>Ciąg zawierający reprezentację ciągu długi czas bieżący <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiekt jest sformatowany przy użyciu wzorca zdefiniowane przez <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącej kultury wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "T" [standardowa Data i godzina ciąg formatu](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Długość ciągu zwróconego przez <xref:System.DateTime.ToLongTimeString%2A> metoda jest zależne od kultury. Odzwierciedla wzorcowi określonemu przez <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A> właściwości bieżącej kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US wzorzec standardowe długo jest "mm: ss"; dla kultury de-DE to "Hh: mm:"; kultura ja-JP jest ": mm: ss". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowych dużo czasu.  
  
 Aby uzyskać więcej informacji o bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji na temat znaków format, format wzorców i dane wyjściowe, wygenerowanie, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji na temat zmieniania wzorzec formatu, skojarzone ze znakiem format, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLongTimeString%2A> metody.  
  
 [!code-csharp[System.DateTime.ToLongTimeString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolongtimestring/cs/sls.cs#1)]
 [!code-vb[System.DateTime.ToLongTimeString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolongtimestring/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToOADate">
      <MemberSignature Language="C#" Value="public double ToOADate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 ToOADate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToOADate" />
      <MemberSignature Language="VB.NET" Value="Public Function ToOADate () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double ToOADate();" />
      <MemberSignature Language="F#" Value="member this.ToOADate : unit -&gt; double" Usage="dateTime.ToOADate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia odpowiednią datą automatyzacji OLE.</summary>
        <returns>Liczba zmiennoprzecinkowe podwójnej precyzji, która zawiera datę automatyzacji OLE odpowiednikiem wartość tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data automatyzacji są zaimplementowane jako liczba zmiennoprzecinkowa, którego integralnym składnikiem jest liczba dni przed lub po północy 30 grudnia 1899, i których ułamkowych części reprezentuje czas w danym dniu podzielona przez 24. Na przykład północy, 31 grudnia 1899 jest reprezentowana przez 1.0; Godziny 6: 00, 1 stycznia 1900 jest reprezentowana przez 2,25; północ, 29 grudnia 1899 jest reprezentowana przez -1,0; i godziny 6: 00, 29 grudnia 1899 jest reprezentowana przez-1.25.  
  
 OLE automatyzacji daty podstawowej oznacza północ, 30 grudnia 1899. Minimalna data automatyzacji OLE oznacza północ, 1 stycznia 0100. Maksymalna OLE automatyzacji Data jest taka sama jak <xref:System.DateTime.MaxValue?displayProperty=nameWithType>, w czasie ostatnich 31 grudnia 9999 r.  
  
 <xref:System.DateTime.ToOADate%2A> Metoda zgłasza <xref:System.OverflowException> Jeśli bieżące wystąpienie reprezentuje datę, która jest nowsza niż <xref:System.DateTime.MinValue> i wcześniej niż o północy January1, 0100. Jednak jeśli wartość bieżącego wystąpienia jest <xref:System.DateTime.MinValue>, metoda zwraca wartość 0.  
  
 Aby uzyskać więcej informacji na temat automatyzacji OLE, zobacz [biblioteki MSDN Library](http://go.microsoft.com/fwlink/?linkid=37118).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość tego wystąpienia nie może być reprezentowany jako datę automatyzacji OLE.</exception>
        <altmember cref="T:System.Double" />
        <altmember cref="M:System.DateTime.FromOADate(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ToShortDateString">
      <MemberSignature Language="C#" Value="public string ToShortDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortDateString();" />
      <MemberSignature Language="F#" Value="member this.ToShortDateString : unit -&gt; string" Usage="dateTime.ToShortDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu daty krótkiej równoważne.</summary>
        <returns>Ciąg zawierający reprezentację ciągu daty krótkiej bieżącego <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiekt jest sformatowany przy użyciu wzorca zdefiniowane przez <xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącej kultury wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "d" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Długość ciągu zwróconego przez <xref:System.DateTime.ToShortDateString%2A> metoda jest zależne od kultury. Odzwierciedla wzorcowi określonemu przez bieżącej kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US "M/d/rrrr"; jest wzorzec krótkiej daty standardowe dla kultury de-DE jest "dd. MM.yyyy"; kultura ja-JP jest "yyyy/M/d". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowych daty krótkiej.  
  
 Aby uzyskać więcej informacji o bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji na temat znaków format, format wzorców i dane wyjściowe, wygenerowanie, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji na temat zmieniania wzorzec formatu, skojarzone ze znakiem format, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToShortDateString%2A> metody. Zawiera także który wyniku wywołania metody <xref:System.DateTime.ToShortDateString%2A> metoda jest taki sam jak wywołanie <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metody za pomocą "d", jako parametr formatu.  
  
 [!code-csharp[System.DateTime.ToShortDateString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/cs/ToShortDateString.cs#1)]
 [!code-vb[System.DateTime.ToShortDateString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/vb/ToShortDateString.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToShortTimeString">
      <MemberSignature Language="C#" Value="public string ToShortTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToShortTimeString : unit -&gt; string" Usage="dateTime.ToShortTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne krótki czas.</summary>
        <returns>Ciąg zawierający reprezentację ciągu krótki czas bieżący <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiekt jest sformatowany przy użyciu wzorca zdefiniowane przez <xref:System.Globalization.DateTimeFormatInfo.ShortTimePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącej kultury wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "t" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Długość ciągu zwróconego przez <xref:System.DateTime.ToShortTimeString%2A> metoda jest zależne od kultury. Odzwierciedla wzorcowi określonemu przez bieżącej kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US wzorzec standardowe krótki czas jest "gg: mm"; dla kultury de-DE jest "Gg: mm"; kultura ja-JP jest "G: mm". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowych krótki czas.  
  
 Aby uzyskać więcej informacji o bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji na temat znaków format, format wzorców i dane wyjściowe, wygenerowanie, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji na temat zmieniania wzorzec formatu, skojarzone ze znakiem format, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToShortTimeString%2A> metody.  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dateTime.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne, przy użyciu konwencji formatowania bieżącej kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest sformatowany przy użyciu ogólnych daty i czasu specyfikator formatu (G). Aby sformatować go przy użyciu określonej daty i czasu specyfikatora formatu, należy wywołać <xref:System.DateTime.ToString%28System.String%29> metody. Aby sformatować go przy użyciu ogólnych daty i czasu specyfikator formatu (G) dla określonej kultury, należy wywołać <xref:System.DateTime.ToString%28System.IFormatProvider%29> metody. Aby sformatować go przy użyciu określonej daty i czasu specyfikator formatu i konwencje określoną kulturę, należy wywołać <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29> metody.  
  
 Metoda ta wykorzystuje informacje o formatowaniu pochodzące z bieżącej kultury. W szczególności łączy ciągi formatu niestandardowego zwrócony przez <xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A> i <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A> właściwości <xref:System.Globalization.DateTimeFormatInfo> obiektu zwróconego przez `Thread.CurrentThread.CurrentCulture.DateTimeFormat` właściwości. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>. Inne przeciążenia <xref:System.DateTime.ToString%2A> metody umożliwiają określenie kultury którego formatowanie do użycia oraz do definiowania struktury danych wyjściowych <xref:System.DateTime> wartość.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób reprezentację ciągu <xref:System.DateTime> wartość zwrócona przez <xref:System.DateTime.ToString> metoda zależy od bieżącej kultury wątku. Bieżącej kultury wątku z en US zmienia się fr-FR, aby ja-JP. w każdym przypadku wywołania <xref:System.DateTime.ToString> metoda zwraca reprezentację ciągu wartość daty i godziny przy użyciu tej kultury.  
  
 [!code-csharp[System.DateTime.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.DateTime.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez bieżącej kultury. Jeśli wartość bieżącej klasy <see cref="T:System.DateTime" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.HijriCalendar" /> klasy po bieżącej kultury arabski (Syria).  [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception2.cs# 2)] [! kodu języka vb [System.DateTime.ToString.ArgumentOutOfRangeException#2] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/ DateTime.toString.argumentoutofrangeexception2.VB#2)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="dateTime.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważny, korzystając z informacji zawartych w określonym formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest sformatowany przy użyciu ogólnych daty i specyfikator formatu czasu ("G"), które formatuje dane wyjściowe na podstawie wzoru krótkiej daty i długi czas.  
  
 Format daty krótkiej i długi czas wzorzec jest definiowana za `provider` parametru. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, na których Konwencji formatowania są zostaną odzwierciedlone w zwracany ciąg. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania zwracany ciąg.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> obiekt skojarzony z bieżącej kultury jest używany. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono reprezentację ciągu daty i godziny przy użyciu <xref:System.Globalization.CultureInfo> obiektów, które reprezentują pięciu różnych kultur.  
  
 [!code-csharp[System.DateTime.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString4.cs#3)]
 [!code-vb[System.DateTime.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest spoza zakresu dat obsługiwana przez używany kalendarz przez <paramref name="provider" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez kultury reprezentowany przez <paramref name="provider" /> parametru. Jego kalendarza jest definiowana za pomocą <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącej klasy <see cref="T:System.DateTime" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.JapaneseCalendar" /> klasy.  [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception1.cs# 1)] [! kodu języka vb [System.DateTime.ToString.ArgumentOutOfRangeException#1] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/ DateTime.toString.argumentoutofrangeexception1.VB#1)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="dateTime.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowych lub niestandardowych datę i godzinę.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne, przy użyciu określonego formatu i Konwencji formatowania bieżącej kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ToString%28System.String%29> Metoda zwraca reprezentację ciągu wartość daty i godziny w określonym formacie, który używa konwencji formatowania bieżącej kultury; Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
 `format` Parametr powinien zawierać albo znak specyfikator formatu pojedynczego (zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub wzorzec formatu niestandardowego (zobacz [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ) definiuje format zwracany ciąg. Jeśli `format` jest `null` lub ciąg pusty specyfikator formatu Ogólne, "G", jest używany.  
  
 Niektóre zastosowania tej metody obejmują:  
  
-   Pobieranie ciąg, który wyświetla datę i godzinę w format bieżącej kultury krótkiej daty i godziny. Aby to zrobić, należy użyć specyfikator formatu "G".  
  
-   Pobieranie ciąg, który zawiera tylko w miesiącu i roku. Aby to zrobić, należy użyć ciągu formatu "RRRR MM". Ciąg formatu, który używa separatora daty bieżącej kultury.  
  
-   Pobieranie ciąg, który zawiera datę i godzinę w określonym formacie. Na przykład "MM/dd/yyyyHH:mm" ciąg formatu wyświetla ciąg daty i godziny w ustalonym formacie takich jak "19 2013 / / 03/18:06". Ciąg formatu, który używa "/" jako separatora daty stałej niezależnie od ustawienia specyficzne dla kultury.  
  
-   Pobieranie na datę w formacie skrócone, które mogłyby zostać użyte do serializacji ciągu daty. Na przykład ciąg formatu "RRRRMMDD" Wyświetla czterocyfrowe następuje dwucyfrowe miesiąc i dzień dwucyfrowe bez separatora daty.  
  
 W poniższym przykładzie użyto te trzy ciągi formatu, aby wyświetlić wartość daty i godziny przy użyciu konwencji en US i fr-FR kultur.  
  
 [!code-csharp[System.DateTime.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring5.cs#5)]
 [!code-vb[System.DateTime.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring5.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto każda standardowa Data i godzina ciągi formatujące i wybór niestandardowe ciągi daty i godziny format można wyświetlić reprezentację ciągu <xref:System.DateTime> wartość. Kultury bieżącej wątku, na przykład jest en US.  
  
 [!code-csharp[System.DateTime.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString2.cs#2)]
 [!code-vb[System.DateTime.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> 1 i nie jest jednym z znaki specyfikatora formatu, które są zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  - lub - <paramref name="format" /> nie zawiera wzorca prawidłowy format niestandardowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.String)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez bieżącej kultury. Jeśli wartość bieżącej klasy <see cref="T:System.DateTime" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.HebrewCalendar" /> klasy po bieżącej kultury hebrajski (Izrael).  [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception3.cs# 3)] [! kodu języka vb [System.DateTime.ToString.ArgumentOutOfRangeException#3] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/ DateTime.toString.argumentoutofrangeexception3.VB#3)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="dateTime.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowych lub niestandardowych datę i godzinę.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiekt do reprezentacji ciągu równoważne, używając określonego formatu i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametr może zawierać albo znak specyfikator jeden format (zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub wzorzec formatu niestandardowego (zobacz [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)). Jeśli `format` jest `null` lub ciąg pusty (""), specyfikator formatu standardowych, "G", jest używany.  
  
 `provider` Parametr definiuje wzorzec, który odpowiada specyfikatory formatem oraz symbole i nazw składników daty i godziny. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, na których Konwencji formatowania są zostaną odzwierciedlone w zwracany ciąg. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania zwracany ciąg.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> skojarzone z bieżącej kultury jest używany. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto każdego ciągi formatu standardowy format daty czasu można wyświetlić reprezentację ciągu daty i godziny czterech różnych kultur.  
  
 [!code-csharp[System.DateTime.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring3.cs#4)]
 [!code-vb[System.DateTime.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring3.vb#4)]  
  
 W poniższym przykładzie pokazano różne sposoby formatowania <xref:System.DateTime> wartości przy użyciu obiektu <xref:System.Globalization.DateTimeFormatInfo>.  
  
 [!code-cpp[Classic DateTime.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DateTime.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic DateTime.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> 1 i nie jest jednym z znaki specyfikatora formatu, które są zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  - lub - <paramref name="format" /> nie zawiera wzorca prawidłowy format niestandardowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest spoza zakresu dat obsługiwana przez używany kalendarz przez <paramref name="provider" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez <paramref name="provider" /> parametru. Jego kalendarza jest definiowana za pomocą <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącej klasy <see cref="T:System.DateTime" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.UmAlQuraCalendar" /> klasy.  [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception4.cs# (4)] [! kodu języka vb [System.DateTime.ToString.ArgumentOutOfRangeException#4] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/ DateTime.toString.argumentoutofrangeexception4.VB#4)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToUniversalTime">
      <MemberSignature Language="C#" Value="public DateTime ToUniversalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToUniversalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToUniversalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUniversalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToUniversalTime();" />
      <MemberSignature Language="F#" Value="member this.ToUniversalTime : unit -&gt; DateTime" Usage="dateTime.ToUniversalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTime" /> obiektu uniwersalny czas koordynowany (UTC).</summary>
        <returns>Obiekt których <see cref="P:System.DateTime.Kind" /> właściwość jest <see cref="F:System.DateTimeKind.Utc" />, którego wartość jest odpowiednikiem wartości bieżącego UTC <see cref="T:System.DateTime" /> obiekt, lub <see cref="F:System.DateTime.MaxValue" /> Jeżeli skonwertowana wartość jest za duża, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MinValue" />Jeśli skonwertowana wartość jest za mały, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uniwersalny czas koordynowany (UTC) są takie same na czas lokalny minus przesunięcie czasu UTC. Aby uzyskać więcej informacji na temat przesunięcie czasu UTC, zobacz <xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>. Konwersja uwzględnia również zasady czasu letniego, która dotyczy czas reprezentowany przez bieżący <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów, <xref:System.DateTime.ToUniversalTime%2A> metody rozpoznaje tylko bieżącej regule korekty podczas konwertowania czasu lokalnego na czas UTC. W związku z tym konwersje dla okresów przed wprowadzenia bieżącej regule korekty może nie odzwierciedlają dokładnie różnica między czasem lokalnym i w formacie UTC.  
  
 W programie .NET Framework w wersji 2.0, wartość zwracana przez <xref:System.DateTime.ToUniversalTime%2A> metoda jest określana przez <xref:System.DateTime.Kind%2A> właściwości bieżącego <xref:System.DateTime> obiektu. W poniższej tabeli opisano możliwe rezultaty.  
  
|rodzaj|Wyniki|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|Konwersja nie jest wykonywane.|  
|<xref:System.DateTimeKind.Local>|Bieżący <xref:System.DateTime> obiektu jest konwertowana na czas UTC.|  
|<xref:System.DateTimeKind.Unspecified>|Bieżący <xref:System.DateTime> obiektu zakłada, że czasu lokalnego, a konwersja jest wykonywana tak, jakby <xref:System.DateTime.Kind%2A> zostały <xref:System.DateTimeKind.Local>.|  
  
> [!NOTE]
>  <xref:System.DateTime.ToUniversalTime%2A> Metoda konwertuje <xref:System.DateTime> wartość od lokalnego czasu na czas UTC. Aby przekonwertować czas w strefie czasu lokalnego na czas UTC, użyj <xref:System.TimeZoneInfo.ConvertTimeToUtc%28System.DateTime%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType> metody. Aby przekonwertować czasu, w których przesunięcie od czasu UTC jest znana, użyj <xref:System.DateTimeOffset.ToUniversalTime%2A> metody.  
  
 Jeśli wystąpienie wartość daty i godziny jest niejednoznaczny czas, ta metoda zakłada, że jej czas standardowy. (Niejednoznaczny czas to taki, który można zamapować na czas standardowy lub czas letni w lokalnej strefie czasowej) Jeśli wystąpienie wartość daty i godziny jest nieprawidłowa godzina, ta metoda po prostu odejmuje czas lokalny z przesunięcia do zwrócenia UTC UTC strefy czasu lokalnego. (Nieprawidłowa godzina jest taki, który nie istnieje z powodu stosowania czasu letniego reguł korygowania).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToUniversalTime%2A> metody.  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metody, aby zademonstrować sposób <xref:System.DateTime.Kind%2A> wpływ właściwości <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToUniversalTime" /> — Metoda jest czasami używana do konwertowania czasu lokalnego na czas UTC. <see cref="M:System.DateTime.ToLocalTime" /> Następnie wywoływana jest metoda, aby przywrócić oryginalne czasu lokalnego. Jednak jeśli oryginalna godzina reprezentuje nieprawidłową wartość czas w lokalnej strefie czasowej, te dwie wartości czasu lokalnego nie będzie taki sam. Aby uzyskać dodatkowe informacje i przykładem, zobacz <see cref="M:System.DateTime.ToLocalTime" /> metody.  Na [! Systemy include[WinXP](~/includes/WinXP-MD.MD)] <see cref="M:System.DateTime.ToUniversalTime" /> tylko bieżącej regule dopasowania na podstawie lokalnej strefy czasowej, która dotyczy wszystkich dat, łącznie z datami niskiego poziomu (czyli dat starsze niż data początkowa rozpoznaje — metoda Bieżąca reguła korekty). Aplikacje działające na [! INCLUDE[WinXP](~/includes/WinXP-MD.MD)] w przeszłości dokładne daty lokalne, które wymagają oraz obliczenia czasu musi obejścia tego problemu za pomocą <see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" /> metoda pobierania <see cref="T:System.TimeZoneInfo" /> obiektu odpowiadającego w lokalnej strefie czasowej i wywoływanie jej <see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" /> metody.  Poniższy przykład przedstawia różnice między <see cref="M:System.DateTime.ToUniversalTime" /> i <see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" /> metody [! System include[WinXP](~/includes/WinXP-MD.MD)] w Stanach Zjednoczonych Czas pacyficzny strefy. Pierwsze dwie metody wywołania dotyczą Data w 2006 (co poszło obowiązywać w 2007) reguła korekty bieżącej strefy czasowej. Bieżąca reguła korekty zapewnia przejścia do czasu, w drugą niedzielę marca; poprzednie reguły, które obowiązywały w 2006 dostępne w celu przejścia do czasu letniego występuje na pierwszą niedzielę kwietnia. Tylko trzeci wywołania metody, które wykonuje dokładnie tego historycznych Data i godzina konwersji.  [! code-csharp[System.DateTime.ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.touniversaltime/cs/touniversaltime.cs#1)] [! code-vb[System.DateTime.ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.touniversaltime/vb/touniversaltime.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToLocalTime" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="dateTime.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <altmember cref="Overload:System.DateTime.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <c>s</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> parametr jest <see langword="null" />, to ciąg pusty (""), lub nie zawiera prawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metoda jest podobna do <xref:System.DateTime.Parse%28System.String%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.  
  
 Ciąg `s` jest analizowana przy użyciu formatowania informacji w bieżącym <xref:System.Globalization.DateTimeFormatInfo> obiektu, który jest niejawnie dostarczonych przez bieżącej kultury wątku.  
  
 Ta metoda próbuje Ignoruj Nierozpoznane dane, jeśli to możliwe i wypełnia Brak dzień, miesiąc i rok informacji z bieżącą datą. Jeśli `s` zawiera wyłącznie data i czas bez, ta metoda zakłada czas północy 12:00. Jeśli `s` zawiera składnik Data z rokiem dwucyfrowym, zostanie przekonwertowane na roku w kalendarzu bieżącego bieżącej kultury, na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Wszelkie początku, wewnętrzne, lub na końcu biały znak w `s` jest ignorowana. Data i godzina może być oddzielona z parą początkowe i końcowe znaki znaku numeru ("#", U + 0023) i może trailed z jedną lub więcej wartości NULL znaków (U + 0000).  
  
 Ponieważ <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody podejmuje próbę przeanalizować reprezentacji ciągu daty i czasu przy użyciu reguły formatowania bieżącej kultury, próby przeprowadzenia analizy określonego ciągu w innych kultur może nie powieść lub zwraca różne wyniki. Jeśli określonych format daty i godziny będzie analizowany w różnych ustawień regionalnych, użyj <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody lub jednego z przeciążeń <xref:System.DateTime.TryParseExact%2A> — metoda i podaj specyfikator formatu.  
  
 Jeśli `s` jest reprezentację ciągu przestępnym dzień w roku przestępnym bieżącego kalendarza, analizuje metody `s` pomyślnie. Jeśli `s` jest reprezentację ciągu dnia przestępnego w innych niż — roku przestępnego w kalendarzu bieżącego bieżącej kultury, analizy kończy się niepowodzeniem i metoda zwraca `false`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, `result` zawiera <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> kiedy metoda zwraca. Jeśli ciąg do przeanalizowania zawiera informacje o strefie czasowej, `result` zawiera <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> kiedy metoda zwraca.  
  
   
  
## Examples  
 Poniższy przykład przekazuje liczba ciągów daty i godziny na <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[System.DateTime.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.TryParse/cpp/datetime.tryparse1.cpp#1)]
 [!code-csharp[System.DateTime.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/TryParse1.cs#1)]
 [!code-vb[System.DateTime.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/TryParse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Formatowanie ma wpływ właściwości bieżącego <see cref="T:System.Globalization.DateTimeFormatInfo" /> obiektu, które domyślnie są uzyskiwane z ** regionalnych i językowych opcje ** elementu w Panelu sterowania. <see cref="Overload:System.DateTime.TryParse" /> — Metoda mogą nieoczekiwanie zakończyć się niepowodzeniem i zwracać <see langword="False" /> Jeśli bieżące <see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" /> i <see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" /> właściwości są ustawione na tę samą wartość.</para>
        </block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia, który definiuje sposób interpretowania przeanalizowany daty w odniesieniu do bieżącej strefy czasowej lub bieżącą datę. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <c>s</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> parametr jest <see langword="null" />, to ciąg pusty (""), lub nie zawiera prawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne korzystając z informacji zawartych w określonym formacie specyficzne dla kultury formatowania stylu i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metody analizuje ciąg, który może zawierać informacje, datę, godzinę i strefę czasową. Jest on podobny do <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.  
  
 Ta metoda próbuje ignoruje Nierozpoznane dane i analizy `s` całkowicie. Jeśli `s` zawiera godzinę, ale bez daty, metody domyślnej substytuty bieżącą datę lub, jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault> flagę zastępuje `DateTime.Date.MinValue`. Jeśli `s` zawiera daty, ale nigdy nie północy jest używany jako domyślny czas 12:00. Jeśli występuje daty, ale jego składnik roku obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w `provider` parametru bieżącego kalendarza na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Wszelkie początkowe, wewnętrzne, lub końcowe znaki odstępu w `s` są ignorowane. Data i godzina może być oddzielona z parą początkowe i końcowe znaki znaku numeru ("#", U + 0023) i może trailed z jedną lub więcej wartości NULL znaków (U + 0000).  
  
 Określone prawidłowe formaty daty i czasu elementów, oraz nazw i symbole używane w daty i godziny, są definiowane przez `provider` parametr, który może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, którego formatowanie jest używany w `s` parametru. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania użytego w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje formatowania użytego w `s`.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje formatowania użytego w `s`.  
  
 Jeśli `provider` jest `null`, bieżącej kultury jest używany.  
  
 Jeśli `s` jest reprezentację ciągu przestępnym dzień w roku przestępnym bieżącego kalendarza, analizuje metody `s` pomyślnie. Jeśli `s` jest reprezentację ciągu dzień przestępnego w innych niż — roku przestępnego bieżącego kalendarza `provider`, analizy kończy się niepowodzeniem i metoda zwraca `false`.  
  
 `styles` Parametr definiuje dokładne interpretacji analizowany ciąg oraz sposób operacji analizowania obsługi go. Może być jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, zgodnie z opisem w poniższej tabeli.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC. Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Choć ważna, wartość ta jest ignorowana. Wewnętrzny biały znak jest dozwolony w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Choć ważna, wartość ta jest ignorowana. Wiodące biały znak jest dozwolona w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Choć ważna, wartość ta jest ignorowana. Końcowe biały znak jest dozwolony w elementach Data i godzina `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych. Jest to zachowanie domyślne. Nie można zastąpić podając bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wartości wyliczenia, takich jak <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.None>|Choć ważna, wartość ta jest ignorowana.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje konwersji ciąg daty i godziny, aby zapobiec <xref:System.DateTime> wartości z jej <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Zazwyczaj taki ciąg jest tworzony przez wywołanie metody <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metody używanie specyfikatorów formatu standardowych "o", "r" lub "u".|  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metoda zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> chyba że `styles` flaga wskazuje, w przeciwnym razie wartość. Jeśli `s` zawiera informacje przesunięcia strefy czasowej, lub strefy czasowej <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> — metoda wykonuje wszelkiej konwersji konieczne czasu i zwraca jedną z następujących czynności:  
  
-   A <xref:System.DateTime> których data i godzina uwzględnienia czasu lokalnego i których wartość <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
-   Lub, jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagę <xref:System.DateTime> odpowiada których data i Godzina UTC i których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 To zachowanie można przesłonić przy użyciu <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi.  
  
## <a name="parsing-custom-cultures"></a>Analizowanie niestandardowych kultur  
 Jeśli przeanalizować ciągu daty i godziny wygenerowany dla kulturą niestandardową, należy użyć <xref:System.DateTime.TryParseExact%2A> zamiast metody <xref:System.DateTime.TryParse%2A> metodę, aby zwiększyć prawdopodobieństwo, że operacja analizy zostanie wykonana pomyślnie. Ciąg daty i godziny kultura niestandardowa może być skomplikowane i trudne do analizy. <xref:System.DateTime.TryParse%2A> Metoda próbuje przeanalizować ciągu z kilku wzorców niejawne analizy, które może zakończyć się niepowodzeniem. Z kolei <xref:System.DateTime.TryParseExact%2A> metoda wymaga jawnie określić wzorce dokładne analizy, które prawdopodobnie powiodą się.  
  
 Aby uzyskać więcej informacji na temat kultury niestandardowej, zobacz <xref:System.Globalization.CultureAndRegionInfoBuilder?displayProperty=nameWithType> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.DateTime.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/tryparse2.cs#2)]
 [!code-vb[System.DateTime.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> nie jest prawidłową <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="provider" /> Określa kulturę neutralną i nie można użyć w operacji analizy.</exception>
        <block subset="none" type="usage">
          <para>Formatowanie ma wpływ właściwości bieżącego <see cref="T:System.Globalization.DateTimeFormatInfo" /> obiektu, który jest dostarczany przez <paramref name="provider" /> parametru. <see cref="Overload:System.DateTime.TryParse" /> — Metoda mogą nieoczekiwanie zakończyć się niepowodzeniem i zwracać <see langword="False" /> Jeśli bieżące <see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" /> i <see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" /> właściwości są ustawione na tę samą wartość.</para>
        </block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <altmember cref="Overload:System.DateTime.ParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="format">Wymagany format <c>s</c>.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>s</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia, wskazujące dozwolony format <c>s</c>.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <c>s</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli dowolny <c>s</c> lub <c>format</c> parametr jest <see langword="null" />, to ciąg pusty lub nie zawiera datę i godzinę, która odpowiada wzorcowi określone w <c>formatu </c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. Jest on podobny do <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.  
  
 `s` Parametr zawiera datę i godzinę, można przeanalizować i musi być w formacie zdefiniowane przez `format` parametru. Jeśli datę, godzinę i strefę czasową elementy znajdują się w `s`, musi również występować w kolejności określonej przez `format`. Jeśli `format` definiuje datę żaden element czas i analizy operacja zakończy się powodzeniem, powstałe w ten sposób <xref:System.DateTime> wartość ma czas północ (00: 00:00). Jeśli `format` definiuje czas, Brak elementu dat i analizy operacja zakończy się powodzeniem, powstałe w ten sposób <xref:System.DateTime> data ma wartość domyślną `DateTime.Now.Date`, lub ma daty `DateTime.MinValue.Date` Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> flagi. `style` Parametr określa, czy `s` parametr może zawierać wiodących, wewnętrzny lub końcowych białych znaków.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, które zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli s zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, w razie potrzeby i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi nie Konwertuj uniwersalny czas koordynowany (UTC) na czas lokalny i ustawić <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `format` Parametr zawiera wzorzec, który odpowiada oczekiwanym formatem `s` parametru. Wzorzec w `format` parametru składa się z co najmniej jeden specyfikatorów formatu niestandardowego z [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub pojedynczy standardowy specyfikatora formatu, identyfikujący wzorzec wstępnie zdefiniowane z [Standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, użyj Niezmienna kultura `provider` specyfikator formatu parametru i najszerszych formę każdej niestandardowej. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
> [!NOTE]
>  Zamiast które `s` zgodne z jednego formatu do pomyślnego operacji analizy, można wywołać <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody oraz określić wiele formatów dozwolonych. Dzięki temu operacji analizowania częściej powiodło się.  
  
 Określonej daty i czasu symbole i ciągi (na przykład nazwy dni tygodnia w określonym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładne format `s` Jeśli `format` jest standardowym formacie Specyfikator ciąg. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury sposób interpretowania `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, która określa, czy i w którym biały znak nie zdefiniowany przez `format` może występować w `s` i które kontrolują zachowanie dokładne operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC. Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może wystąpić między wszystkie daty lub czasu elementu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych nie jest zdefiniowany przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera czas bez informacje o dacie, Data zwracana wartość jest ustawiana `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametr jest analizowana przy użyciu wartości domyślnych. Nie białe innego niż się, że w `format` jest dozwolone. Jeśli `s` nie ma składnik daty Data zwróconego elementu <xref:System.DateTime> ma wartość 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje zapobiec konwersja <xref:System.DateTime> wartości z jej <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody. Należy pamiętać, że ciąg "2009-5-01 8:30 AM" nie może zostać przeanalizowany pomyślnie po `styles` parametr ma wartość <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType> ponieważ spacje początkowe nie są dozwolone w `format`. Ponadto ciąg "2009-5-01 09:00" nie może zostać przeanalizowany pomyślnie z `format` z "MM/dd/yyyyhh:mm", ponieważ ciąg daty nie poprzedza numer miesiąca z zerem, jako `format` wymaga.  
  
 [!code-csharp[System.DateTime.TryParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact1.cs#1)]
 [!code-vb[System.DateTime.TryParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> nie jest prawidłową <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTime.TryParseExact" /> metoda zwraca <see langword="false" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica dopuszczalne formaty <c>s</c>.</param>
        <param name="provider">Obiekt, który dostarcza informacji o formacie specyficzne dla kultury o <c>s</c>.</param>
        <param name="style">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>s</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <c>s</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>s</c> lub <c>formatów</c> jest <see langword="null" />, <c>s</c> lub element <c>formatów</c> jest ciągiem pustym lub format <c>s</c> nie jest określony przez co najmniej jeden format wzorców w <c>formatów</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTime" /> równoważne przy użyciu określonej tablicy formatów, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie co najmniej jedna z określonych formatów. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, który pasuje do jednej z wzorców przypisane do `formats` parametru. Przypomina to <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.DateTime.TryParseExact%2A> — metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.  
  
 `s` Parametr zawiera datę i godzinę, można przeanalizować. Jeśli `s` parametr zawiera tylko godzina i data nie jest używany bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślna data (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę, a nie czas, północ (00: 00:00) jest używany. `style` Określa również parametr czy `s` parametr może zawierać wiodących, wewnętrzny i końcowych białych znaków innych niż dozwolone przez jeden z ciągów formatu w `formats`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, które zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> jest właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli s zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, w razie potrzeby i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi nie Konwertuj uniwersalny czas koordynowany (UTC) na czas lokalny i ustawić <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `formats` Parametr zawiera tablicę wzorców, z których jedna `s` musi odpowiadać dokładnie w przypadku operacji analizowania powiodło się. Wzorce w `formats` parametru składają się z co najmniej jeden specyfikatorów formatu niestandardowego z [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub pojedynczy standardowy specyfikatora formatu, identyfikujący wzorzec wstępnie zdefiniowane z [Standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, użyj Niezmienna kultura `provider` specyfikator formatu parametru i najszerszych formę każdej niestandardowej. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
 Określonej daty i czasu symbole i ciągi (na przykład nazwy dni tygodnia w określonym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładne format `s` Jeśli `format` jest standardowym formacie Specyfikator ciąg. `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury sposób interpretowania `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, która określa, czy i w którym biały znak nie zdefiniowany przez `format` może występować w `s` i które kontrolują zachowanie dokładne operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` i, w razie potrzeby, konwertuje ją na czas UTC. Jeśli `s` obejmuje przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizuje ciąg połączenia <xref:System.DateTime.ToUniversalTime%2A> można skonwertować zwróconego <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagę metodę analizowania ciągu, wykonuje brak konwersji strefy czasowej na zwróconego <xref:System.DateTime> wartość i zestawy <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może wystąpić między wszystkie daty lub czasu elementu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak nie jest zdefiniowany przez `format` może występować na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać spacji wiodących, wewnętrzne i końcowych białych nie jest zdefiniowany przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować czasu lokalnego. O ile <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> ma wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma żadnych informacji o strefie czasowej, zakłada się reprezentować UTC. O ile nie <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, metoda konwertuje zwróconego <xref:System.DateTime> wartość od czasu UTC na czas lokalny i ustawia jej <xref:System.DateTime.Kind%2A> właściwości <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera czas bez informacje o dacie, Data zwracana wartość jest ustawiana `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametr jest analizowana przy użyciu wartości domyślnych. Nie białe innego niż się, że w `format` jest dozwolone. Jeśli `s` nie ma składnik daty Data zwróconego elementu <xref:System.DateTime> ma wartość 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> obiektu ma ustawioną wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje zapobiec konwersja <xref:System.DateTime> wartości z jej <xref:System.DateTime.Kind%2A> ustawioną właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody, aby upewnić się, że ciąg na wiele formatów możliwych można pomyślnie przeanalizować.  
  
 [!code-csharp[System.Datetime.TryParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact2.cs#2)]
 [!code-vb[System.Datetime.TryParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> nie jest prawidłową <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTime.TryParseExact" /> metoda zwraca <see langword="false" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnixEpoch">
      <MemberSignature Language="C#" Value="public static readonly DateTime UnixEpoch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime UnixEpoch" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.UnixEpoch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnixEpoch As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime UnixEpoch;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnixEpoch : DateTime" Usage="System.DateTime.UnixEpoch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcNow">
      <MemberSignature Language="C#" Value="public static DateTime UtcNow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime UtcNow" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.UtcNow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UtcNow As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime UtcNow { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcNow : DateTime" Usage="System.DateTime.UtcNow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> obiekt, który jest ustawiona na bieżącą datę i godzinę na tym komputerze, wyrażone jako uniwersalny czas koordynowany (UTC).</summary>
        <value>Obiekt, którego wartość jest bieżąca data i Godzina UTC.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozdzielczość tej właściwości jest zależna od czasomierz systemu, który jest zależny od systemu operacyjnego. Zwykle należeć do zakresu od 0,5 i 15 milisekund.

 W programie .NET Framework w wersji 2.0, jest zwracana wartość <xref:System.DateTime> których <xref:System.DateTime.Kind%2A> zwraca właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.

 Zamiast <xref:System.DateTime.UtcNow%2A> jest <xref:System.DateTimeOffset.UtcNow%2A?displayProperty=nameWithType>. Podczas pierwszej oznacza, że wartość daty i godziny jest uniwersalny czas koordynowany (UTC), przypisując <xref:System.DateTimeKind.Utc?displayProperty=nameWithType> do jego <xref:System.DateTime.Kind%2A> właściwości, drugie przypisuje datę i przesunięcie czasu UTC wartość czasu (równa <xref:System.TimeSpan.Zero?displayProperty=nameWithType>).
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metody, aby zademonstrować sposób <xref:System.DateTime.Kind%2A> wpływ właściwości <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcNow" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="Year">
      <MemberSignature Language="C#" Value="public int Year { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Year" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Year" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Year As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Year { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Year : int" Usage="System.DateTime.Year" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik roku o dacie reprezentowane przez to wystąpienie.</summary>
        <value>Rok, od 1 do 9999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Year%2A> Właściwość zwraca kalendarza gregoriańskiego year, bieżącego wystąpienia. Zwraca rok kalendarza domyślne bieżącej kultury. Aby pobrać roku w kalendarzu określonego, można wywołać tego kalendarza `GetYear` metody, jak przedstawiono na poniższym kodem.  
  
 [!code-csharp[System.DateTime.Year#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Year/cs/Year.cs#1)]
 [!code-vb[System.DateTime.Year#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Year/vb/Year.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Year%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
  </Members>
</Type>
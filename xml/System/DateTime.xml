<Type Name="DateTime" FullName="System.DateTime">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa3f7d4eee2778992089a62f7eef6c3dd4191614" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52599841" /></Metadata><TypeSignature Language="C#" Value="public struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DateTime extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.DateTime&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.DateTime&gt;, class System.IFormattable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.DateTime" />
  <TypeSignature Language="VB.NET" Value="Public Structure DateTime&#xA;Implements IComparable, IComparable(Of DateTime), IConvertible, IEquatable(Of DateTime), IFormattable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type DateTime = struct&#xA;    interface IFormattable&#xA;    interface IConvertible&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje moment w czasie, zwykle wyrażona jako datę i godzinę.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## <a name="quick-links-to-example-code"></a>Szybkie łącza do przykładowego kodu

[!INCLUDE[interactive-note](~/includes/csharp-interactive-with-utc-note.md)]

W tym artykule przedstawiono kilka przykładów, które używają `DateTime` typu:

**Przykłady inicjalizacji**      
- [Wywołaj Konstruktor](#initialization-01)
- [Wywoływanie niejawnego domyślnego konstruktora](#initialization-02)
- [Przypisanie z wartości zwracanej](#initialization-03)
- [Podczas analizowania ciągu, który reprezentuje datę i godzinę](#initialization-04)
- [Składnia języka Visual Basic można zainicjować daty i godziny](#initialization-05)

**Formatowanie `DateTime` obiekty jako ciągi**  
- [Użyj domyślnego format daty i godziny](#formatting-01)
- [Formatowanie daty i godziny, używając określonej kultury](#formatting-02)
- [Format daty godziny przy użyciu ciągu formatu standardowego lub niestandardowego](#formatting-03)
- [Określ zarówno ciąg formatu, jak i określonej kultury](#formatting-04)
- [Format daty godziny przy użyciu standardu ISO 8601 dla usług sieci web](#formatting-05)

**Analiza składniowa ciągów jako `DateTime` obiektów**  
- [Użyj `Parse` lub `TryParse` do przekonwertowania ciągu na datę i godzinę](#parsing-01)
- [Użyj `ParseExact` lub `TryParseExact` do przekonwertowania na ciąg w formacie znane](#parsing-02)
- [Przekonwertować z reprezentacji ciągu ISO 8601 do daty i godziny](#parsing-03)

**`DateTime` Rozdzielczość**  
- [Zapoznaj się z rozwiązania dla wartości daty i godziny](#resolution-01)
- [Porównanie dla równości w granicach tolerancji](#comparison-01)

**Kultura i kalendarze**  
- [Wyświetlanie wartości daty i godziny, używane kalendarze określonej kultury](#calendars-01)
- [Analizowanie ciągów zgodnie z określonym kalendarzu kultury](#calendars-02)
- [Inicjowanie datę i godzinę, z kalendarza określonej kultury](#calendars-03)
- [Uzyskiwanie dostępu do właściwości daty i godziny przy użyciu kalendarza określonej kultury](#calendars-04)
- [Trwa pobieranie tydzień roku, używane kalendarze określonej kultury](#calendars-05)

**Trwałość**  
- [Przechowywanie wartości daty i godziny jako ciągi w lokalnej strefie czasowej](#persistence-01)
- [Przechowywanie wartości daty i godziny jako ciąg w formacie niezmiennej kultury i godziny](#persistence-02)
- [Przechowywanie wartości daty i godziny jako liczby całkowite](#persistence-03)
- [Przechowywanie daty i godziny wartości przy użyciu `XmlSerializer`](#persistence-04)
- [Przechowywanie daty i godziny wartości przy użyciu `BinaryFormatter`](#persistence-05)
- [Przechowywanie wartości daty i godziny przy użyciu danych strefy czasowej](#persistence-06)

## <a name="quick-links-to-remarks-topics"></a>Szybkie linki do tematów uwagi.

Ta sekcja zawiera tematy dotyczące wielu typowych zastosowań `DateTime` struktury:
  
- [Inicjowanie `DateTime` obiektu](#initializing-a-datetime-object)
- [Wartości typu DateTime i ich reprezentacji ciągu](#datetime-values-and-their-string-representations)
- [Analizowanie wartości daty/godziny z ciągów](#parsing-datetime-values-from-strings)
- [Wartości daty/godziny](#datetime-values)
- [Operacje typu DateTime](#datetime-operations)
- [Data i godzina rozwiązania](#datetime-resolution)
- [Wartości daty/godziny i kalendarze](#datetime-values-and-calendars)
- [Przechowywanie wartości daty/godziny](#persisting-datetime-values)
- [Vs daty/godziny. Przedział czasu](#datetime-vs-timespan)
- [Porównanie dla równości w granicach tolerancji](#comparing-for-equality-within-tolerance)
- [Uwagi dotyczące współdziałania COM](#com-interop-considerations)
   
<xref:System.DateTime> Typ wartości reprezentuje daty i godziny z wartości z zakresu od 00:00:00 (północ), 1 stycznia 0001 Anno Domini (typowe Era) do 11:59:59 PM, — 31 grudzień 9999 r. (R). w kalendarzu gregoriańskim.  
  
Wartości typu Time są mierzone w jednostkach 100-nanosekundowych o nazwie taktów. Określonej daty jest liczbę znaczników, od momentu 12:00 w dniu, stycznia 1, 0001 (R). w <xref:System.Globalization.GregorianCalendar> kalendarza. Liczba nie obejmuje znaczniki, które zostaną dodane przez przestępnym sekund. Na przykład wartość impulsów, l 31241376000000000 reprezentuje datę piątek, 01 stycznia 0100, 12:00:00 w dniu. A <xref:System.DateTime> wartość zawsze jest wyrażona w ramach jawnego lub domyślnego kalendarza.  
  
> [!NOTE]
>  Jeśli pracujesz z wartość impulsów, że chcesz przekonwertować niektórych innych interwał czasu, takich jak minut i sekund, należy użyć <xref:System.TimeSpan.TicksPerDay?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerHour?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerMinute?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerSecond?displayProperty=nameWithType>, lub <xref:System.TimeSpan.TicksPerMillisecond?displayProperty=nameWithType> stała w celu wykonania konwersji. Na przykład, aby dodać liczbę sekund, reprezentowane przez określoną liczbę taktów do <xref:System.DateTime.Second%2A> składnika <xref:System.DateTime> wartości, można użyć wyrażenia `dateValue.Second + nTicks/Timespan.TicksPerSecond`.  

Źródło dla całego zestawu przykłady z tego artykułu można wyświetlić w jednym [języka Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/) lub [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/) z repozytorium dokumentów w witrynie GitHub.

> [!NOTE]
>  Alternatywa <xref:System.DateTime> struktury jest praca z wartości daty i godziny w szczególności stref czasowych <xref:System.DateTimeOffset> struktury. <xref:System.DateTimeOffset> Struktury przechowuje informacje o datę i godzinę w prywatnej <xref:System.DateTime> pola i liczbę minut, przez które, które daty i godziny różni się od czasu UTC w prywatnej <xref:System.Int16> pola. Dzięki temu możliwe <xref:System.DateTimeOffset> wartość, aby odzwierciedlić czas w określonej strefie czasowej, natomiast <xref:System.DateTime> wartość jednoznacznie może odzwierciedlać tylko czas UTC i godzinę w lokalnej strefie czasowej. Aby uzyskać informacje o tym, kiedy używać <xref:System.DateTime> struktury lub <xref:System.DateTimeOffset> struktury podczas pracy z wartości daty i godziny, zobacz [Wybieranie pomiędzy DateTime, DateTimeOffset, TimeSpan i TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md).  
  
### <a name="initializing-a-datetime-object"></a>Inicjowanie obiektu typu DateTime  

Początkowa wartość można przypisać do nowego `DateTime` wartości na wiele różnych sposobów:

- Wywołanie konstruktora, pojedynczo, gdzie możesz określić argumenty dla wartości, lub użyć niejawnego domyślnego konstruktora.
- Przypisywanie `DateTime` zwracana wartość właściwości lub metody.
- Podczas analizowania `DateTime` wartość z jego reprezentację ciągu.
- Używać funkcji języka specyficznego dla języka Visual Basic do utworzenia wystąpienia `DateTime`. 

Poniższe fragmenty kodu przedstawiają przykłady każdego z nich:

#### <a name="invoke-constructors"></a>Wywoływanie konstruktorów

Należy wywołać dowolną z przeciążeń <xref:System.DateTime> Konstruktor, który określa elementy wartości daty i godziny (np. rok, miesiąc i dzień lub liczby taktów). Poniższy kod tworzy w określonym dniu, w którym używana jest <xref:System.DateTime> konstruktora, określając rok, miesiąc, godzinę, minutę i sekundę.  

<a name="initialization-01"></a>  
[!code-vb[System.DateTime.Instantiation#1](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#1)]  
[!code-csharp-interactive[System.DateTime.Instantiation#1](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#1)]

Wywołuje się `DateTime` struktury niejawnego domyślnego konstruktora, jeśli chcesz `DateTime` zainicjowany do wartości domyślnej. (Aby uzyskać szczegółowe informacje na niejawnego domyślnego konstruktora typu wartości, zobacz [typów wartości](~/docs/csharp/language-reference/keywords/value-types.md).) Niektóre kompilatory obsługują także zadeklarowanie <xref:System.DateTime> wartości bez jawnie przypisywanie wartości do niego. Powoduje również utworzenie wartości bez Jawne inicjowanie wartość domyślną. W poniższym przykładzie pokazano <xref:System.DateTime> niejawnego domyślnego konstruktora w języku C# i Visual Basic, a także <xref:System.DateTime> deklaracja bez przypisania w języku Visual Basic.  

<a name="initialization-02"></a>  
[!code-vb[System.DateTime.Instantiation#5](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#5)]  
[!code-csharp-interactive[System.DateTime.Instantiation#5](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#5)]
    
#### <a name="assigning-a-computed-value"></a>Przypisywanie obliczona wartość

Możesz przypisać <xref:System.DateTime> obiekt zwracany przez właściwość lub metoda wartości daty i godziny. Poniższy przykład przypisuje bieżącą datę i czas, bieżącą datę uniwersalnego czasu koordynowanego (UTC) i czas i bieżącą datą trzy nowe <xref:System.DateTime> zmiennych.  

<a name="initialization-03"></a>  
[!code-vb[System.DateTime.Instantiation#3](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#3)]  
[!code-csharp[System.DateTime.Instantiation#3](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#3)]

#### <a name="parsing-a-string-that-represents-a-datetime"></a>Podczas analizowania ciągu, który reprezentuje wartość typu DateTime

<xref:System.DateTime.Parse%2A>, <xref:System.DateTime.ParseExact%2A>, <xref:System.DateTime.TryParse%2A>, I <xref:System.DateTime.TryParseExact%2A> wszystkie metody konwersji ciągu jego równoważna wartość daty i godziny. W poniższych przykładach używane <xref:System.DateTime.Parse%2A> i <xref:System.DateTime.ParseExact%2A> metody, aby przeanalizować ciąg i przekonwertować go pod kątem <xref:System.DateTime> wartość. Drugi format używa formularza obsługiwane przez [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard reprezentująca datę i godzinę w formacie ciągu. Taka reprezentacja standardowego jest często używane do przesyłania informacji o dacie w usługach sieci web.

<a name="initialization-04"></a>  
[!code-vb[System.DateTime.Instantiation#4](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#4)]  
[!code-csharp[System.DateTime.Instantiation#4](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#4)]

<xref:System.DateTime.TryParse%2A> i <xref:System.DateTime.TryParseExact%2A> metody wskazują, czy ciąg jest prawidłową reprezentacją <xref:System.DateTime> wartość, a jeśli tak jest, wykonuje konwersję.  

#### <a name="language-specific-syntax-for-visual-basic"></a>Składnia charakterystyczny dla języka Visual Basic

Inicjuje nowe wystąpienie następującą instrukcję języka Visual Basic <xref:System.DateTime> wartość.  

<a name="initialization-05"></a>  
[!code-vb[System.DateTime.Instantiation#2](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#2)]  

### <a name="datetime-values-and-their-string-representations"></a>Wartości typu DateTime i ich reprezentacji ciągu  

Wewnętrznie, wszystkie <xref:System.DateTime> wartości są reprezentowane jako liczbę tyknięć (Liczba 100-nanosekundowych interwałów), które upłynęły od północy 12:00:00, 1 stycznia 0001. Rzeczywiste <xref:System.DateTime> wartość jest niezależna od sposobu, w którym ta wartość pojawia się pojawi. Wygląd <xref:System.DateTime> wartość jest wynikiem operacji formatowania, który konwertuje wartość na jego reprezentację ciągu.  
  
Wyświetlanie wartości daty i godziny zależy od kultury, międzynarodowych standardów, wymagania dotyczące aplikacji i osobistych preferencji. <xref:System.DateTime> Struktura zapewnia elastyczność w formatowaniu wartości daty i godziny za pomocą przeciążenia <xref:System.DateTime.ToString%2A>. Wartość domyślna <xref:System.DateTime.ToString?displayProperty=nameWithType> metoda zwraca ciąg reprezentujący wartość daty i godziny przy użyciu bieżącej kultury daty krótkiej i wzorzec godziny długiej. W poniższym przykładzie użyto domyślnie <xref:System.DateTime.ToString?displayProperty=nameWithType> metody. Wyświetla datę i godzinę przy użyciu daty krótkiej i wzorzec godziny długiej dla bieżącej kultury. Kultury en US jest bieżącą kulturę na komputerze, na którym uruchomiono przykładu.  
  
<a name="formatting-01"></a>  
[!code-csharp-interactive[System.DateTime.Formatting#1](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#1)]
[!code-vb[System.DateTime.Formatting#1](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#1)]  

Może być konieczne do formatowania dat w określonej kultury do obsługi scenariuszy sieci web, gdzie serwer może być w innej kulturze od klienta. Określ, przy użyciu kultury <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę w celu utworzenia daty krótkiej i długi czas reprezentacji w określonej kultury. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby wyświetlić datę i godzinę przy użyciu daty krótkiej i wzorzec godziny długiej dla kultury fr-FR.  
  
<a name="formatting-02"></a>  
[!code-csharp-interactive[System.DateTime.Formatting#2](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#2)]
[!code-vb[System.DateTime.Formatting#2](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#2)]  

 Inne aplikacje mogą wymagać różnych ciągów reprezentujących daty. <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> Metoda zwraca ciąg reprezentujący zdefiniowane przez specyfikator formatu standardowego lub niestandardowego, przy użyciu konwencji formatowania bieżącej kultury. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metodę w celu wyświetlenia pełnej daty i godziny wzorzec en US kultury bieżącej kultury, na komputerze, na którym uruchomiono przykładu.  
  
<a name="formatting-03"></a>  
[!code-csharp-interactive[System.DateTime.Formatting#3](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#3)]
[!code-vb[System.DateTime.Formatting#3](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#3)]  

 Ponadto można określić kulturę i format za pomocą <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody. W poniższym przykładzie użyto <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodę w celu wyświetlenia pełnej daty i godziny wzorca dla kultury fr-FR.  

<a name="formatting-04"></a>  
[!code-csharp-interactive[System.DateTime.Formatting#4](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#4)]
[!code-vb[System.DateTime.Formatting#4](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#4)]  

<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> Przeciążenia można również za pomocą ciągu formatu niestandardowego, aby określić inne formaty. Poniższy przykład pokazuje, jak sformatować ciąg za pośrednictwem [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) formatu standardowego, często używany dla usług sieci web. Format Iso 8601 nie ma odpowiedniego standardowym ciągiem formatującym.

<a name="formatting-05"></a> [!code-csharp-interactive[System.DateTime.Formatting#5](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#5)]
[!code-vb[System.DateTime.Formatting#5](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#5)]  

Aby uzyskać więcej informacji na temat formatowania <xref:System.DateTime> wartości, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  

### <a name="parsing-datetime-values-from-strings"></a>Analizowanie wartości daty/godziny z ciągów

Analiza kodu konwertuje ciąg reprezentujący datę i godzinę na <xref:System.DateTime> wartość. Zazwyczaj ciągów daty i godziny mają dwa różne sposoby użycia w aplikacjach:  
  
-   Data i godzina przyjmuje wiele form i odzwierciedlają konwencje kultury bieżącej lub określonej kultury. Na przykład aplikacja umożliwia użytkownikowi którego bieżącą kulturą jest en US, aby wprowadzić wartość daty "12/15/2013" lub "15 grudnia 2013". Pozwala użytkownikowi, którego bieżącą kulturą jest en-gb wprowadzanie wartości daty "12/15/2013" lub "15 grudnia 2013."  
  
-   Data i godzina jest reprezentowana w wstępnie zdefiniowany format. Na przykład aplikacja wykonuje serializację daty w postaci "20130103", niezależnie od kultury, na którym działa aplikacja. Aplikacja może wymagać dat można wprowadzić w formatu daty krótkiej dla bieżącej kultury.
  
Możesz użyć <xref:System.DateTime.Parse%2A> lub <xref:System.DateTime.TryParse%2A> metody do przekonwertowania ciągu z jednego z typowych formatów daty i godziny używany przez kulturę do <xref:System.DateTime> wartości. Poniższy przykład pokazuje, jak można użyć <xref:System.DateTime.TryParse%2A> do konwersji ciągów daty w różnych formatach specyficzne dla kultury do <xref:System.DateTime> wartości. Bieżąca kultura jest zmieniana na język angielski (Wielka Brytania) i wywołuje <xref:System.DateTime.GetDateTimeFormats> metoda generuje tablicę ciągów daty i godziny. Następnie przekazuje każdego elementu w tablicy do <xref:System.DateTime.TryParse%2A> metody. Dane wyjściowe z przykładu przedstawia metodę analizowania mógł pomyślnie konwertować wszystkich specyficzne dla kultury ciągów daty i godziny.  
  
<a name="parsing-01"></a>  
[!code-csharp-interactive[System.DateTime.Parsing#1](~/samples/snippets/csharp/System.DateTime/Parsing.cs#1)]
[!code-vb[System.DateTime.Parsing#1](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#1)]  

Możesz użyć <xref:System.DateTime.ParseExact%2A> i <xref:System.DateTime.TryParseExact%2A> metody służące do konwersji ciągu, który musi być zgodny w określonym formacie lub formaty stosowane do <xref:System.DateTime> wartości. Należy określić jedną lub więcej ciągów daty i godziny format jako parametr do metody analizy. W poniższym przykładzie użyto <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metody do konwersji ciągów znaków, które muszą być w formacie "RRRRMMDD" lub "HHmmss" format <xref:System.DateTime> wartości.  
  
<a name="parsing-02"></a>  
[!code-csharp-interactive[System.DateTime.Parsing#2](~/samples/snippets/csharp/System.DateTime/Parsing.cs#2)]
[!code-vb[System.DateTime.Parsing#2](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#2)]  

Jeden typowym celem zastosowania <xref:System.DateTime.ParseExact%2A> polega na przekonwertowaniu reprezentację ciągu z usługi sieci web, zazwyczaj w [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) formatu standardowego. Poniższy kod przedstawia parametry poprawnego formatu do użycia:

<a name="parsing-03"></a>  
[!code-csharp-interactive[System.DateTime.Parsing#3](~/samples/snippets/csharp/System.DateTime/Parsing.cs#3)]
[!code-vb[System.DateTime.Parsing#3](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#3)]  

Jeśli nie można przeanalizować ciągu, <xref:System.DateTime.Parse%2A> i <xref:System.DateTime.ParseExact%2A> metody zgłoszenie wyjątku. <xref:System.DateTime.TryParse%2A> i <xref:System.DateTime.TryParseExact%2A> metody zwracają <xref:System.Boolean> wartość wskazującą, czy konwersja powiodła się, czy nie powiodło się. Należy używać <xref:System.DateTime.TryParse%2A> lub <xref:System.DateTime.TryParseExact%2A> metod w scenariuszach, w których wydajność jest ważna. Operacji analizowania ciągów daty i godziny, zwykle ma wysoki współczynnik błędów i wyjątków jest kosztowne. Użyj tych metod, jeśli ciągi są dane wejściowe przez użytkowników lub pochodzące z nieznanego źródła. 
  
Aby uzyskać więcej informacji na temat analizowania wartości daty i godziny, zobacz [ciągi analizy daty i godziny](~/docs/standard/base-types/parsing-datetime.md).  

### <a name="datetime-values"></a>Wartości typu DateTime

Opisy wartości czasu w <xref:System.DateTime> typu są często wyrażane przy użyciu standardu uniwersalnego czasu koordynowanego (UTC). Uniwersalny czas koordynowany to nazwa międzynarodowo czas uniwersalny Greenwich (GMT). Uniwersalny czas koordynowany to czas, mierzony o zerowej długości geograficznej stopni punktem początkowym UTC. Czas letni nie ma zastosowania względem czasu UTC.  
  
Czas lokalny jest określana względem daną strefę czasową. Strefa czasowa jest skojarzony z przesunięcia strefy czasowej. Przesunięcie strefy czasowej to przesunięcie strefy czasowej, mierzone w godzinach od punktu pochodzenia UTC. Ponadto czas lokalny, opcjonalnie dotyczy czasu letniego, która zwiększa lub zmniejsza Ustawianie interwału czasu. Czas lokalny jest obliczany przez dodanie przesunięcia strefy czasowej na UTC i dostosowywanie czasu w razie potrzeby. Przesunięcie strefy czasowej w miejscu pochodzenia UTC wynosi zero.  
  
Czas UTC jest odpowiednia dla obliczeń, porównań i przechowywania daty i godziny w plikach. Czas lokalny jest odpowiednia do wyświetlania w interfejsie użytkownika aplikacji komputerowych. Uwzględniających strefy czasowe aplikacje (takie jak wiele aplikacji sieci Web) muszą pracować z liczbą innych strefach czasowych.  
  
Jeśli <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, jest nieokreślony, w czy czas reprezentowany jest czasu lokalnego, czasu UTC lub czasu w innych strefach czasowych.  

### <a name="datetime-resolution"></a>Data i godzina rozwiązania
  
> [!NOTE]
>  Jako alternatywa dla wykonywania arytmetyka na daty i godziny <xref:System.DateTime> wartości, aby zmierzyć czas, który upłynął, możesz użyć <xref:System.Diagnostics.Stopwatch> klasy.  
  
<xref:System.DateTime.Ticks%2A> Właściwość wyraża wartości daty i godziny w jednostkach co 10 milionowych części sekundy. <xref:System.DateTime.Millisecond%2A> Właściwość zwraca tysięczne części sekundy w wartości daty i godziny. Za pomocą wielokrotnego wywołania <xref:System.DateTime.Now%2A?displayProperty=nameWithType> właściwości, aby zmierzyć czas jest zależny od zegara systemowego. Zegar systemowy w systemach Windows 7 i Windows 8 ma rozdzielczość około 15 milisekund. To rozwiązanie ma wpływ na przedziały czasu małych mniej niż 100 MS. 
  
Poniższy przykład ilustruje zależność wartości bieżącej daty i godziny od rozdzielczości zegara systemowego. W tym przykładzie zewnętrzna pętla powtarza 20 razy, a wewnętrzną pętlę służy do opóźnienia zewnętrzna pętla. Jeśli wartość licznika zewnętrzna pętla wynosi 10, wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody powoduje opóźnienia 5 milisekund. Poniższy kod przedstawia liczbę milisekund, zwracany przez `DateTime.Now.Milliseconds` zmiany właściwości dopiero po wywołaniu <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>.  

<a name="resolution-01"></a>  
[!code-csharp-interactive[System.DateTime.Resolution#1](~/samples/snippets/csharp/System.DateTime/Resolution.cs#1)]
[!code-vb[System.DateTime.Resolution#1](~/samples/snippets/visualbasic/System.DateTime/Resolution.vb#1)]  

### <a name="datetime-operations"></a>Operacje typu DateTime  

Za pomocą obliczeń <xref:System.DateTime> struktury, takich jak <xref:System.DateTime.Add%2A> lub <xref:System.DateTime.Subtract%2A>, nie modyfikuje wartości struktury. Zamiast tego zwraca nowy obliczenia <xref:System.DateTime> struktury, którego wartość jest wynikiem obliczenia.  
  
Operacje konwersji między strefami czasowymi (np. między czasem UTC i czasem lokalnym lub między strefami czasowymi, a drugi) uwzględnienia czasu letniego, ale nie obsługują operacje arytmetyczne i porównywania.  
  
<xref:System.DateTime> Struktura zapewnia ograniczoną obsługę do konwertowania z jednej strefie czasowej. Możesz użyć <xref:System.DateTime.ToLocalTime%2A> można użyć metody do konwersji czasu UTC na czas lokalny lub <xref:System.DateTime.ToUniversalTime%2A> metody konwersji z czasu lokalnego na UTC. Jednakże, pełny zestaw metody konwersji strefy czasowej jest dostępna w <xref:System.TimeZoneInfo> klasy. Czas w innych strefach czasowych, przy użyciu tych metod należy przekonwertować wartość czasu w jednym z stref czasowych na świecie.  
  
Obliczenia i porównania <xref:System.DateTime> obiekty mają znaczenie tylko wtedy, gdy obiekty reprezentują godziny w tej samej strefie czasowej. Możesz użyć <xref:System.TimeZoneInfo> obiektu do reprezentowania <xref:System.DateTime> tej wartości czasu podzielić na strefy, mimo że dwa są luźno powiązane. A <xref:System.DateTime> obiekt nie ma właściwości, która zwraca obiekt, który reprezentuje tej wartości daty i godziny w strefie czasowej. <xref:System.DateTime.Kind%2A> Wskazuje właściwość, jeśli `DateTime` reprezentuje UTC i czasem lokalnym lub jest nieokreślona. W aplikacji uwzględniających strefy czasowe, konieczne jest zastosowanie mechanizmu zewnętrznego, aby określić strefę czasową, w którym <xref:System.DateTime> został utworzony obiekt. Można użyć struktury, która otacza zarówno <xref:System.DateTime> wartość i <xref:System.TimeZoneInfo> obiekt, który reprezentuje <xref:System.DateTime> wartości strefy czasowej. Aby uzyskać szczegółowe informacje na temat przy użyciu czasu UTC w obliczeniach i porównania z wartością <xref:System.DateTime> wartości, zobacz [wykonywanie operacji arytmetycznych z datami i godzinami](~/docs/standard/datetime/performing-arithmetic-operations.md).  
  
Każdy <xref:System.DateTime> elementu członkowskiego niejawnie korzysta z kalendarza gregoriańskiego przeprowadzić jego działania. Wyjątki są metodami, które niejawnie określić kalendarz. Obejmują one konstruktorów, które określają kalendarza i metody z parametrem pochodną <xref:System.IFormatProvider>, takich jak <xref:System.Globalization.DateTimeFormatInfo?displayProperty=nameWithType>.  
  
Działania członków <xref:System.DateTime> typu wziąć pod uwagę szczegóły, takie jak przestępnego i liczbę dni w miesiącu.  

## <a name="datetime-values-and-calendars"></a>Wartości daty/godziny i kalendarze  

Biblioteka klas programu .NET Framework zawiera wiele klas kalendarza, które są uzyskiwane z <xref:System.Globalization.Calendar> klasy.  Są to:  
  
-   <xref:System.Globalization.ChineseLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.EastAsianLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.GregorianCalendar> Klasy.  
-   <xref:System.Globalization.HebrewCalendar> Klasy.  
-   <xref:System.Globalization.HijriCalendar> Klasy.  
-   <xref:System.Globalization.JapaneseCalendar> Klasy.  
-   <xref:System.Globalization.JapaneseLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.JulianCalendar> Klasy.  
-   <xref:System.Globalization.KoreanCalendar> Klasy.  
-   <xref:System.Globalization.KoreanLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.PersianCalendar> Klasy.  
-   <xref:System.Globalization.TaiwanCalendar> Klasy.  
-   <xref:System.Globalization.TaiwanLunisolarCalendar> Klasy.  
-   <xref:System.Globalization.ThaiBuddhistCalendar> Klasy.  
-   <xref:System.Globalization.UmAlQuraCalendar> Klasy.  
  
Każda kultura używa kalendarza domyślnego, zdefiniowane przez jej tylko do odczytu <xref:System.Globalization.CultureInfo.Calendar%2A?displayProperty=nameWithType> właściwości. Każda kultura może obsługiwać jednego lub wielu kalendarzy, zdefiniowane przez jej tylko do odczytu <xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType> właściwości. Kalendarz aktualnie używany przez konkretną <xref:System.Globalization.CultureInfo> obiekt jest zdefiniowany przez jego <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> właściwości. Musi być jednym z kalendarzy w <xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType> tablicy.  
  
Bieżący kalendarz kultury jest używany podczas wszystkich operacji formatowania dla tej kultury. Na przykład kalendarz domyślny kultury tajskiego jest Kalendarz tajski ery buddyjskiego, który jest reprezentowany przez <xref:System.Globalization.ThaiBuddhistCalendar> klasy.  Gdy <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę tajskiego jest używany w formatowania daty i godziny operacji, kalendarza tajski ery buddyjski jest używane domyślnie. Kalendarz gregoriański jest używana tylko wtedy, gdy kultury <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> zmienić właściwości, co ilustruje poniższy przykład:  

<a name="calendars-01"></a>  
[!code-csharp-interactive[System.DateTime.Calendar#1](~/samples/snippets/csharp/System.DateTime/Calendar.cs#1)]
[!code-vb[System.DateTime.Calendar#1](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#1)]  

Bieżący kalendarz kultury służy również we wszystkich operacjach analizy dla tej kultury, co ilustruje poniższy przykład.  
  
<a name="calendars-02"></a>  
[!code-csharp-interactive[System.DateTime.Calendar#2](~/samples/snippets/csharp/System.DateTime/Calendar.cs#2)]
[!code-vb[System.DateTime.Calendar#2](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#2)]  

Można utworzyć wystąpienia <xref:System.DateTime> wartości, korzystając z daty i godziny elementów (liczba rok, miesiąc i dzień) określonego kalendarza, wywołując [Konstruktor daty/godziny](xref:System.DateTime.%23ctor%2A) zawierającej `calendar` parametru i przekazanie do niej <xref:System.Globalization.CultureInfo.Calendar%2A>obiekt, który reprezentuje kalendarza. W poniższym przykładzie użyto elementy daty i godziny z <xref:System.Globalization.ThaiBuddhistCalendar> kalendarza.  
  
<a name="calendars-03"></a>  
[!code-csharp-interactive[System.DateTime.Calendar#3](~/samples/snippets/csharp/System.DateTime/Calendar.cs#3)]
[!code-vb[System.DateTime.Calendar#3](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#3)]  

<xref:System.DateTime> Konstruktory, które nie zawierają `calendar` parametru przyjęto założenie, że elementy daty i godziny są wyrażone jako liczba jednostek w kalendarzu gregoriańskim.  
  
Wszystkie inne <xref:System.DateTime> właściwości i metody należy użyć kalendarz gregoriański. Na przykład <xref:System.DateTime.Year%2A?displayProperty=nameWithType> właściwość zwraca rok w kalendarzu gregoriańskim, a <xref:System.DateTime.IsLeapYear%28System.Int32%29?displayProperty=nameWithType> metoda zakłada, że `year` parametr jest roku w kalendarzu gregoriańskim.  Każdy <xref:System.DateTime> elementu członkowskiego, który korzysta z kalendarza gregoriańskiego ma odpowiedni członkiem <xref:System.Globalization.CultureInfo.Calendar%2A> klasę, która korzysta z określonego kalendarza. Na przykład <xref:System.Globalization.Calendar.GetYear%2A?displayProperty=nameWithType> metoda zwraca wartość roku w kalendarzu określonej i <xref:System.Globalization.Calendar.IsLeapYear%2A?displayProperty=nameWithType> interpretuje metoda `year` parametr jako liczba roku w kalendarzu określonej. W poniższym przykładzie użyto obu <xref:System.DateTime> i odpowiednich członków <xref:System.Globalization.ThaiBuddhistCalendar> klasy.  
  
<a name="calendars-04"></a>  
[!code-csharp-interactive[System.DateTime.Calendar#4](~/samples/snippets/csharp/System.DateTime/Calendar.cs#4)]
[!code-vb[System.DateTime.Calendar#4](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#4)]  

<xref:System.DateTime> Struktura zawiera <xref:System.DateTime.DayOfWeek%2A> właściwość, która zwraca dzień tygodnia w kalendarzu gregoriańskim. Nie ma składowej, która umożliwia pobieranie numer tygodnia roku. Aby pobrać tydzień roku, należy wywołać kalendarzu programu <xref:System.Globalization.Calendar.GetWeekOfYear%2A?displayProperty=nameWithType> metody. Poniższy przykład stanowi ilustrację.  
  
<a name="calendars-05"></a>  
[!code-csharp-interactive[System.DateTime.Calendar#5](~/samples/snippets/csharp/System.DateTime/Calendar.cs#5)]
[!code-vb[System.DateTime.Calendar#5](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#5)]  

Aby uzyskać więcej informacji na temat daty i kalendarze, zobacz [Praca z kalendarzami](~/docs/standard/datetime/working-with-calendars.md).  
  
### <a name="persisting-datetime-values"></a>Przechowywanie wartości daty/godziny  

Jednak można utrwalić <xref:System.DateTime> wartości na cztery sposoby:  
  
-   Możesz [przekonwertowane na ciągi](#persisting-values-as-strings) tak długo, jak ciągi.  
-   Możesz [przekonwertować je na 64-bitowe wartości całkowite](#persisting-values-as-integers) (wartość <xref:System.DateTime.Ticks%2A> właściwości) i zachować liczby całkowite.  
-   Możesz [serializacji wartości daty/godziny](#serializing-dateTime-values).  
-   Możesz [serializacji wartości daty/godziny oraz informacje o strefie czasowej](#serializing-datetime-and-time-zone-data).  
  
Należy upewnić się, że procedura, która przywraca <xref:System.DateTime> wartości nie spowodować utratę danych lub zgłosić wyjątek, niezależnie od tego, w których technika wybierz. <xref:System.DateTime> wartości należy Rundy. Oznacza to, że wartością oryginalną a przywróconej wartość powinna być taka sama. Jeśli oryginalna <xref:System.DateTime> wartość reprezentuje pojedynczy chwili czasu, należy zidentyfikować, ten sam moment w czasie, po przywróceniu.  
  
#### <a name="persisting-values-as-strings"></a>Przechowywanie wartości jako ciągi  

Można pomyślne przywrócić <xref:System.DateTime> wartości, które są zachowywane jako ciągi, należy wykonać następujące czynności:  
  
-   Wprowadź ten sam założeń dotyczących formatowania specyficzne dla kultury, po przywróceniu ciągu jako utrwalone po. Aby upewnić się, że ciąg mogą być przywracane na komputerze, którego bieżącą kulturą jest inny niż kultura systemu, który został zapisany w, należy wywołać <xref:System.DateTime.ToString%2A> przeciążenia, aby zapisać ciąg przy użyciu konwencji niezmiennej kultury. Wywołaj <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> lub <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> przeciążenie, można przywrócić ciągu przy użyciu konwencji niezmiennej kultury. Nigdy nie używaj <xref:System.DateTime.ToString>, <xref:System.DateTime.Parse%28System.String%29>, lub <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29> przeciążeń, które używają Konwencji bieżącej kultury wątku.  
  
-   Jeśli data reprezentuje jeden moment w czasie, upewnij się, że stanowi ten sam moment w czasie, po przywróceniu, nawet w innej strefie czasowej. Konwertuj <xref:System.DateTime> wartości do uniwersalny czas koordynowany (UTC) przed zapisaniem zmian. Można również wykonać serializację wartości oraz informacje o strefie czasowej. Aby uzyskać więcej informacji na temat tego podejścia, zobacz [danych serializacji daty/godziny i strefy czasowej](#serializing-datetime-and-time-zone-data).  
  
 Najbardziej typowych błędów, wykonywane, gdy utrwalanie <xref:System.DateTime> jest zależą od konwencje formatowania bieżącej kultury lub domyślne wartości jako ciągi. Problemy, gdy bieżącą kulturą jest inny, gdy zapisywanie i przywracanie ciągi. Poniższy przykład ilustruje te problemy. Zapisuje pięć daty przy użyciu konwencji formatowania bieżącej kultury, w tym przypadku jest angielski (Stany Zjednoczone). Przywraca go daty przy użyciu konwencji formatowania kultury różne, w tym przypadku jest angielski (Wielka Brytania). Ponieważ Konwencji formatowania kultury dwa są różne, dwóch dat nie można przywrócić, a pozostałe trzy daty są interpretowane niepoprawnie. Ponadto jeśli oryginalne wartości daty i godziny reprezentuje pojedynczy momentów w czasie przywróconej razy są nieprawidłowe, ponieważ informacje o strefie czasowej zostaną utracone.  
  
<a name="persistence-01"></a>  
[!code-csharp[System.DateTime.Persistence#1](~/samples/snippets/csharp/System.DateTime/Persistence.cs#1)]
[!code-vb[System.DateTime.Persistence#1](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#1)]  

Aby obustronnie konwertować <xref:System.DateTime> wartości pomyślnie, wykonaj następujące kroki:  
  
1.  Jeśli wartość reprezentuje pojedynczy minut czasu, przekonwertować je od lokalnego czasu na czas UTC, wywołując <xref:System.DateTime.ToUniversalTime%2A> metody.  
1.  Przekonwertować ich ciągów reprezentujących daty, wywołując <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> przeciążenia. Użyć konwencji formatowania kultury niezmiennej, określając <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> jako `provider` argumentu. Określ wartość należy obustronne przy użyciu ciągu formatu standardowego "O" lub "R".  
  
Aby przywrócić utrwalonych <xref:System.DateTime> wartości bez utraty danych, wykonaj następujące kroki:  
  
1.  Przeanalizować dane, wywołując <xref:System.DateTime.ParseExact%2A> lub <xref:System.DateTime.TryParseExact%2A> przeciążenia. Określ <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> jako `provider` argumentu, a następnie użyj tego samego formatu standardowego ciągu użyte do `format` argument podczas konwersji. Obejmują <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> wartość w `styles` argumentu.  
1.  Jeśli <xref:System.DateTime> wartości reprezentują pojedynczego momenty w czasie, wywołanie <xref:System.DateTime.ToLocalTime%2A> metodę, aby przekonwertować przeanalizowana Data względem czasu UTC na czas lokalny.  
  
W poniższym przykładzie użyto Niezmienna kultura i ciąg formatu standardowego "O", aby upewnić się, że <xref:System.DateTime> wartości zapisywany i przywracany reprezentują ten sam moment w czasie, niezależnie od systemu, kultury i strefy czasowej z systemów źródłowych i docelowych.  
  
<a name="persistence-02"></a>  
[!code-csharp[System.DateTime.Persistence#2](~/samples/snippets/csharp/System.DateTime/Persistence.cs#2)]
[!code-vb[System.DateTime.Persistence#2](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#2)]  

#### <a name="persisting-values-as-integers"></a>Przechowywanie wartości jako liczby całkowite  

Jednak można utrwalić daty i godziny jako <xref:System.Int64> wartość, która reprezentuje liczbę znaczników. W takim przypadku nie trzeba wziąć pod uwagę kultury systemów <xref:System.DateTime> wartości są zachowywane i przywrócone na.  
  
Aby zachować <xref:System.DateTime> wartości jako liczby całkowitej:  
  
-   Jeśli <xref:System.DateTime> wartości reprezentują pojedynczego momenty w czasie, przekonwertować je na czas UTC, wywołując <xref:System.DateTime.ToUniversalTime%2A> metody.  
-   Pobieranie liczby taktów reprezentowany przez <xref:System.DateTime> wartość z jego <xref:System.DateTime.Ticks%2A> właściwości.  
  
Aby przywrócić <xref:System.DateTime> wartości, które zostały utrwalone w postaci liczby całkowitej:  
  
1.  Utwórz wystąpienie nowego <xref:System.DateTime> obiektu przez przekazanie <xref:System.Int64> wartość <xref:System.DateTime.%23ctor%28System.Int64%29> konstruktora.  
1.  Jeśli <xref:System.DateTime> wartość reprezentuje jeden moment w czasie, przekonwertuj go z czasu UTC na czas lokalny, wywołując <xref:System.DateTime.ToLocalTime%2A> metody.  
  
Poniższy przykład będzie się powtarzał tablicę <xref:System.DateTime> wartości jako liczby całkowite w systemie, w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego. Jej przywracania go w systemie w strefie UTC. Zawiera plik, który zawiera liczby całkowite <xref:System.Int32> wartość, która wskazuje łączną liczbę <xref:System.Int64> wartości, które natychmiast po nim.  
  
<a name="persistence-03"></a>  
[!code-csharp[System.DateTime.Persistence#3](~/samples/snippets/csharp/System.DateTime/Persistence.cs#3)]
[!code-vb[System.DateTime.Persistence#3](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#3)]  

#### <a name="serializing-datetime-values"></a>Serializacja wartości daty/godziny  

Jednak można utrwalić <xref:System.DateTime> wartości za pomocą serializacji do strumienia lub pliku, a następnie przywróć je do deserializacji. <xref:System.DateTime> Data jest serializowany w formacie niektóre określony obiekt. Obiekty te zostaną przywrócone, gdy są one deserializacji. Element formatujący lub serializator, takich jak <xref:System.Xml.Serialization.XmlSerializer> lub <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, obsługuje proces serializacji i deserializacji. Aby uzyskać więcej informacji o serializacji i typy serializacji obsługiwane przez program .NET Framework, zobacz [serializacji](~/docs/standard/serialization/index.md).
  
W poniższym przykładzie użyto <xref:System.Xml.Serialization.XmlSerializer> klasy do serializacji i deserializacji <xref:System.DateTime> wartości. Wartości reprezentują wszystkie dni w roku przestępnym w wieku dwudziestego pierwszego. Dane wyjściowe przedstawia wynik, jeśli ten przykład zostanie uruchomiony w systemie, którego bieżącą kulturą jest angielski (Wielka Brytania). Ponieważ została przeprowadzona <xref:System.DateTime> sam obiekt, kod nie musi obsługiwać różnic kulturowych w formaty daty i godziny.  
  
<a name="persistence-04"></a>  
[!code-csharp[System.DateTime.Persistence#4](~/samples/snippets/csharp/System.DateTime/Persistence.cs#4)]
[!code-vb[System.DateTime.Persistence#4](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#4)]  

Poprzedni przykład nie zawiera informacje o czasie. Jeśli <xref:System.DateTime> wartość reprezentuje moment w czasie i jest wyrażona jako czas lokalny, przekonwertuj go od czasu lokalnego na UTC, przed serializacji go przez wywołanie metody <xref:System.DateTime.ToUniversalTime%2A> metody. Po deserializacji go przekonwertować go z czasu UTC na czas lokalny, wywołując <xref:System.DateTime.ToLocalTime%2A> metody. W poniższym przykładzie użyto <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> klasy do serializacji <xref:System.DateTime> danych w systemie, w Stanach Zjednoczonych Pacyficznego standardowa strefy czasowej i zdeserializuj ją w systemie w Stanach Zjednoczonych Centralna strefy standardowej.  
  
<a name="persistence-05"></a>  
[!code-csharp[System.DateTime.Persistence#5](~/samples/snippets/csharp/System.DateTime/Persistence.cs#5)]
[!code-vb[System.DateTime.Persistence#5](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#5)]  

#### <a name="serializing-datetime-and-time-zone-data"></a>Serializacja danych daty/godziny i strefy czasowej  

Wszystkich poprzednich przykładach założono, że że <xref:System.DateTime> wartości są wyrażane jako czas lokalny. Kod przekonwertować wartości między czasem UTC i czasem lokalnym, więc odzwierciedlają one ten sam moment w czasie w systemach źródłowych i docelowych. <xref:System.DateTime> wartości mogą uwzględniać również momenty w czasie w strefie czasowej niż lokalne i czasem UTC. Ponieważ <xref:System.DateTime> struktura nie jest uwzględniających strefy czasowe, należy go serializować zarówno <xref:System.DateTime> wartość i <xref:System.TimeZoneInfo> obiekt, który reprezentuje jej strefy czasowej. Tworzenie typu, których pola zawiera zarówno <xref:System.DateTime> wartość i strefy czasowej. W poniższym przykładzie zdefiniowano `DateWithTimeZone` struktury.  
  
<a name="persistence-06"></a>  
[!code-csharp[System.DateTime.Persistence#6](~/samples/snippets/csharp/System.DateTime/DateWithTimeZone.cs#6)]
[!code-vb[System.DateTime.Persistence#6](~/samples/snippets/visualbasic/System.DateTime/DateWithTimeZone.vb#6)]  

> [!IMPORTANT]
>  `DateWithTimeZone` Struktura jest używana w dwóch następnych przykładach, w których serializacji i deserializacji, tablica `DateWithTimeZone` obiektów. Źródło dla całego zestawu przykłady z tego artykułu można wyświetlić w jednym [języka Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/) lub [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/) z repozytorium dokumentów w witrynie GitHub.
  
Za pomocą `DateWithTimeZone` struktury, można następnie zachować daty i godziny oraz informacje o strefie czasowej. W poniższym przykładzie użyto <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> klasy do serializacji tablicę `DateWithTimeZone` obiektów.  
  
[!code-csharp[System.DateTime.Persistence#7](~/samples/snippets/csharp/System.DateTime/Persistence.cs#7)]
[!code-vb[System.DateTime.Persistence#7](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#7)]  

Poniższy przykład następnie wywołuje <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType> metodę deserializacji go.  
  
[!code-csharp[System.DateTime.Persistence#8](~/samples/snippets/csharp/System.DateTime/Persistence.cs#8)]
[!code-vb[System.DateTime.Persistence#8](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#8)]  

### <a name="datetime-vs-timespan"></a>Vs daty/godziny. Przedział czasu  

<xref:System.DateTime> i <xref:System.TimeSpan> typy wartości różnią się w tym <xref:System.DateTime> reprezentuje moment w czasie, natomiast <xref:System.TimeSpan> reprezentuje przedział czasu. Należy odjąć jedno wystąpienie <xref:System.DateTime> z innego uzyskać <xref:System.TimeSpan> obiekt, który reprezentuje odstęp czasu między nimi. Możesz też dodać dodatnią <xref:System.TimeSpan> do bieżącego <xref:System.DateTime> uzyskać <xref:System.DateTime> wartość, która reprezentuje datę wypadającą w przyszłości.  
  
Możesz dodawać lub odejmować przedział czasu z <xref:System.DateTime> obiektu. Przedziały czasu może być dodatnia lub ujemna, i może być wyrażona w jednostkach, takich jak znaczniki, sekund, lub jako <xref:System.TimeSpan> obiektu.  

### <a name="comparing-for-equality-within-tolerance"></a>Porównanie dla równości w granicach tolerancji

Porównania równości dla <xref:System.DateTime> wartości są dokładne. Oznacza to, że dwie wartości muszą być wyrażone jako taką samą liczbę taktów, aby były uważane za równe. Dokładność jest często niepotrzebne lub nawet nieprawidłowe dla wielu aplikacji. Często chcesz sprawdzić, czy <xref:System.DateTime> obiekty są **przybliżeniu równa**. 

W poniższym przykładzie pokazano sposób porównywania w przybliżeniu równoważne <xref:System.DateTime> wartości. Podczas deklarowania je w taki sam, akceptuje małych margines różnica.  
  
<a name="comparison-01"></a> [!code-csharp[System.DateTime.Comparisons#1](~/samples/snippets/csharp/System.DateTime/DateTimeComparisons.cs#1)]
[!code-vb[System.DateTime.Comparisons#1](~/samples/snippets/visualbasic/System.DateTime/DateTimeComparisons.vb#1)]  

### <a name="com-interop-considerations"></a>Uwagi dotyczące współdziałania COM  

A <xref:System.DateTime> wartość, która jest przekazywana do aplikacji modelu COM, a następnie jest przenoszona z powrotem do aplikacji zarządzanej, jest nazywany przesyłania danych. Jednak <xref:System.DateTime> nie ma wartość, która określa tylko przez czas błądzenia, zgodnie z oczekiwaniami.  
  
Jeśli możesz Rundy tylko przez czas, np. w dniu 3, końcowej daty i godziny jest 30 grudnia 1899 r. o 3:00, zamiast, 1 stycznia 0001 r at 3:00 P.M. .NET Framework i COM założono domyślną datę, gdy określono tylko raz. Jednak COM system założy podstawowy data 30 grudnia 1899 r, gdy podstawowy dzień, 1 stycznia 0001 r przyjęto założenie, .NET Framework  
  
Tylko godzina jest przekazywany z programu .NET Framework modelowi COM, jest przetwarzana w specjalny jest przeprowadzane, Konwertuje czas na format używany przez model COM. Kiedy tylko godzina jest przekazywany z modelu COM do programu .NET Framework, brak specjalnego przetwarzania jest wykonywane, ponieważ, może dojść do uszkodzenia uzasadnione daty i godziny w lub przed 30 grudnia 1899. Jeśli wartość typu date rozpoczyna się jego przesyłania danych z modelu COM, .NET Framework i COM należy zachować daty.  
  
Zachowanie środowiska .NET Framework i COM oznacza, że jeśli rund Twojej aplikacji <xref:System.DateTime> określa tylko raz, aplikacja musi Pamiętaj, aby zmodyfikować lub zignorować błędne datę z końcowym <xref:System.DateTime> obiektu.  
     
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie tego typu są bezpieczne wątkowo. Elementy członkowskie, które na pierwszy rzut oka modyfikują stan wystąpienia, w rzeczywistości zwracają nowe wystąpienie zainicjowane z nową wartością. Podobnie jak w przypadku innych typów odczytywanie i zapisywanie w udostępnionej zmiennej, która zawiera wystąpienie tego typu, musi być chronione przez blokadę w celu zagwarantowania bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.DateTimeOffset" />
    <altmember cref="T:System.TimeSpan" />
    <altmember cref="T:System.Globalization.Calendar" />
    <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
    <altmember cref="T:System.TimeZoneInfo" />
    <related type="Article" href="~/docs/standard/datetime/choosing-between-datetime.md">Wybieranie pomiędzy elementem DateTime, DateTimeOffset, TimeSpan i TimeZoneInfo</related>
    <related type="Article" href="~/docs/standard/datetime/working-with-calendars.md">Praca z kalendarzami</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: .NET Framework 4 formatowanie narzędzia</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 -&gt; DateTime" Usage="new System.DateTime ticks" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ticks">Data i czas wyrażony w liczbie 100-nanosekundowych interwałów, które upłynęły od 1 stycznia 0001 na 00:00:00.000 w kalendarzu gregoriańskim.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury do określonej liczby taktów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano jeden z <xref:System.DateTime> konstruktorów.  
  
 [!code-cpp[datetime.ctor_Int64#1](~/samples/snippets/cpp/VS_Snippets_CLR/datetime.ctor_Int64/CPP/ticks.cpp#1)]
 [!code-csharp[datetime.ctor_Int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/datetime.ctor_Int64/CS/ticks.cs#1)]
 [!code-vb[datetime.ctor_Int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/datetime.ctor_Int64/VB/ticks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ticks" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (ticks, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="ticks">Data i czas wyrażony w liczbie 100-nanosekundowych interwałów, które upłynęły od 1 stycznia 0001 na 00:00:00.000 w kalendarzu gregoriańskim.</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje czy <paramref name="ticks" /> określa czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określoną liczbę taktów i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ticks" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc i dzień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje parametry `year`, `month`, i `day` jako rok, miesiąc i dzień w kalendarzu gregoriańskim. Aby utworzyć wystąpienie <xref:System.DateTime> wartości za pomocą rok, miesiąc i dzień w kalendarzu innym, wywołanie <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 Pora dnia dla wynikowych <xref:System.DateTime> oznacza północ (00: 00:00). <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość. W przykładzie pokazano również, że to przeciążenie tworzy <xref:System.DateTime> wartości, których składnik czasu równa się o północy (lub równa 0:00).  
  
 [!code-csharp[System.DateTime.Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#1)]
 [!code-vb[System.DateTime.Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.  
  
—lub— 
 <paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Rok (1 przez liczbę lat w <paramref name="calendar" />).</param>
        <param name="month">Miesiąc (1 przez liczbę miesięcy w <paramref name="calendar" />).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="calendar">Kalendarza, który jest używany do interpretacji <paramref name="year" />, <paramref name="month" />, i <paramref name="day" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> określony rok, miesiąc i dzień w kalendarzu określonej struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pora dnia dla wynikowych <xref:System.DateTime> oznacza północ (00: 00:00). <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` zależą od `calendar`. Wyjątek jest generowany, jeśli określonej daty i godziny nie można wyrazić za pomocą `calendar`.  
  
 <xref:System.Globalization> Przestrzeń nazw udostępnia kilka kalendarzy, w tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ kalendarz perski nie może być wyznaczony jako kalendarz domyślny dla kultury, wyświetlanie daty w kalendarzu Perskim wymaga poszczególnych wywołań dla jej <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Drugie wywołanie konstruktora tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ Hidżra jest kalendarz domyślny bieżącej kultury, <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody używane do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone), w tym przypadku) <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa bieżącej kultury domyślnego kalendarza gregoriańskiego do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample2.cs#2)]
 [!code-vb[System.DateTime.Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> nie jest poza zasięgiem obsługiwanym przez <paramref name="calendar" />.  
  
—lub— 
 <paramref name="month" /> jest mniejsza niż 1 lub większa niż liczba miesięcy <paramref name="calendar" />.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury określony rok, miesiąc, godziny, minuty i sekundy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Ten konstruktor interpretuje parametry`year`, `month`, i `day` jako rok, miesiąc i dzień w kalendarzu gregoriańskim. Aby utworzyć wystąpienie <xref:System.DateTime> wartości za pomocą rok, miesiąc i dzień w kalendarzu innym, wywołanie <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%2A> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#3)]
 [!code-vb[System.DateTime.Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.  
  
—lub— 
 <paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje czy <paramref name="year" />, <paramref name="month" />, <paramref name="day" />, <paramref name="hour" />, <paramref name="minute" /> i <paramref name="second" /> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> strukturę do określonego roku, miesiąc, dzień, godzinę, minuty, sekundy i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje parametry`year`, `month`, i `day` jako rok, miesiąc i dzień w kalendarzu gregoriańskim. Aby utworzyć wystąpienie <xref:System.DateTime> wartości za pomocą rok, miesiąc i dzień w kalendarzu innym, wywołanie <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> konstruktora.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#7)]
 [!code-vb[System.DateTime.Constructor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.  
  
—lub— 
 <paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Rok (1 przez liczbę lat w <paramref name="calendar" />).</param>
        <param name="month">Miesiąc (1 przez liczbę miesięcy w <paramref name="calendar" />).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="calendar">Kalendarza, który jest używany do interpretacji <paramref name="year" />, <paramref name="month" />, i <paramref name="day" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> strukturę do określonego roku, miesiąca, godziny, minuty i sekundy określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` zależą od `calendar`. Wyjątek jest generowany, jeśli określonej daty i godziny nie można wyrazić za pomocą `calendar`.  
  
 <xref:System.Globalization> Przestrzeń nazw udostępnia kilka kalendarzy, w tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ kalendarz perski nie może być wyznaczony jako kalendarz domyślny dla kultury, wyświetlanie daty w kalendarzu Perskim wymaga poszczególnych wywołań dla jej <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Drugie wywołanie konstruktora tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ Hidżra jest kalendarz domyślny bieżącej kultury, <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody używane do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone), w tym przypadku) <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa bieżącej kultury domyślnego kalendarza gregoriańskiego do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample4.cs#4)]
 [!code-vb[System.DateTime.Constructor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> nie jest poza zasięgiem obsługiwanym przez <paramref name="calendar" />.  
  
—lub— 
 <paramref name="month" /> jest mniejsza niż 1 lub większa niż liczba miesięcy <paramref name="calendar" />.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejsza niż 0 lub większa od 23 
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> strukturę do określonego roku, miesiąca, dnia, godziny, minuty, sekundy i milisekundy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje parametry`year`, `month`, i `day` jako rok, miesiąc i dzień w kalendarzu gregoriańskim. Aby utworzyć wystąpienie <xref:System.DateTime> wartości za pomocą rok, miesiąc i dzień w kalendarzu innym, wywołanie <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> konstruktora.  
  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#5)]
 [!code-vb[System.DateTime.Constructor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.  
  
—lub— 
 <paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="millisecond" /> jest mniejsza niż 0 lub większa od 999.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje czy <paramref name="year" />, <paramref name="month" />, <paramref name="day" />, <paramref name="hour" />, <paramref name="minute" />, <paramref name="second" />, i <paramref name="millisecond" /> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> struktury do określonego roku, miesiąca, dnia, godziny, minuty, sekundy, milisekund i uniwersalny czas koordynowany (UTC) lub czasu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje parametry`year`, `month`, i `day` jako rok, miesiąc i dzień w kalendarzu gregoriańskim. Aby utworzyć wystąpienie <xref:System.DateTime> wartości za pomocą rok, miesiąc i dzień w kalendarzu innym, wywołanie <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> konstruktora.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29> Konstruktor do tworzenia wystąpienia <xref:System.DateTime> wartość.  
  
 [!code-csharp[System.DateTime.Constructor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#8)]
 [!code-vb[System.DateTime.Constructor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.  
  
—lub— 
 <paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="millisecond" /> jest mniejsza niż 0 lub większa od 999.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">Rok (1 przez liczbę lat w <paramref name="calendar" />).</param>
        <param name="month">Miesiąc (1 przez liczbę miesięcy w <paramref name="calendar" />).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="calendar">Kalendarza, który jest używany do interpretacji <paramref name="year" />, <paramref name="month" />, i <paramref name="day" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> strukturę do określonego roku, miesiąca, dzień, godzinę, minutę, sekundy i milisekundy określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Kind%2A> Właściwość jest inicjowana do <xref:System.DateTimeKind.Unspecified>.  
  
 Dopuszczalne wartości dla `year`, `month`, i `day` zależą od `calendar`. Wyjątek jest generowany, jeśli określonej daty i godziny nie można wyrazić za pomocą `calendar`.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
 <xref:System.Globalization> Przestrzeń nazw udostępnia kilka kalendarzy, w tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ kalendarz perski nie może być wyznaczony jako kalendarz domyślny dla kultury, wyświetlanie daty w kalendarzu Perskim wymaga poszczególnych wywołań dla jej <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Drugie wywołanie konstruktora tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ Hidżra jest kalendarz domyślny bieżącej kultury, <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody używane do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone), w tym przypadku) <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa bieżącej kultury domyślnego kalendarza gregoriańskiego do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample6.cs#6)]
 [!code-vb[System.DateTime.Constructor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> nie jest poza zasięgiem obsługiwanym przez <paramref name="calendar" />.  
  
—lub— 
 <paramref name="month" /> jest mniejsza niż 1 lub większa niż liczba miesięcy <paramref name="calendar" />.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="millisecond" /> jest mniejsza niż 0 lub większa od 999.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar,System.DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">Rok (1 przez liczbę lat w <paramref name="calendar" />).</param>
        <param name="month">Miesiąc (1 przez liczbę miesięcy w <paramref name="calendar" />).</param>
        <param name="day">Dzień (1 przez liczbę dni w <paramref name="month" />).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="calendar">Kalendarza, który jest używany do interpretacji <paramref name="year" />, <paramref name="month" />, i <paramref name="day" />.</param>
        <param name="kind">Jedną z wartości wyliczenia, które wskazuje czy <paramref name="year" />, <paramref name="month" />, <paramref name="day" />, <paramref name="hour" />, <paramref name="minute" />, <paramref name="second" />, i <paramref name="millisecond" /> określić czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTime" /> strukturę do określonego roku, miesiąc, dzień, godzinę, minuty, sekundy, milisekund i uniwersalny czas koordynowany (UTC) lub czasu lokalnego do określonego kalendarza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopuszczalne wartości dla `year`, `month`, i `day` parametry są zależne od `calendar` parametru. Wyjątek jest generowany, jeśli określonej daty i godziny nie można wyrazić za pomocą `calendar`.  
  
 Dla aplikacji, w których przenośność danych daty i godziny lub ograniczone strefy czasowej ważne jest świadomość, można użyć odpowiedniego <xref:System.DateTimeOffset> konstruktora.  
  
 <xref:System.Globalization> Przestrzeń nazw udostępnia kilka kalendarzy, w tym <xref:System.Globalization.GregorianCalendar> i <xref:System.Globalization.JulianCalendar>.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29> Konstruktor dwa razy, aby utworzyć dwa wystąpienia <xref:System.DateTime> wartości. Pierwsze wywołanie tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.PersianCalendar> obiektu. Ponieważ kalendarz perski nie może być wyznaczony jako kalendarz domyślny dla kultury, wyświetlanie daty w kalendarzu Perskim wymaga poszczególnych wywołań dla jej <xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>, <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>, i <xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType> metody. Drugie wywołanie konstruktora tworzy <xref:System.DateTime> wartości za pomocą <xref:System.Globalization.HijriCalendar> obiektu. W tym przykładzie zmieniono bieżącą kulturę na Arabski (Syria) i kalendarz domyślny bieżącej kultury na kalendarz Hidżry. Ponieważ Hidżra jest kalendarz domyślny bieżącej kultury, <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody używane do formatowania daty. Po przywróceniu poprzedniej bieżącej kultury (która jest angielski (Stany Zjednoczone), w tym przypadku) <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metoda używa bieżącej kultury domyślnego kalendarza gregoriańskiego do formatowania daty.  
  
 [!code-csharp[System.DateTime.Constructor#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample9.cs#9)]
 [!code-vb[System.DateTime.Constructor#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> nie jest poza zasięgiem obsługiwanym przez <paramref name="calendar" />.  
  
—lub— 
 <paramref name="month" /> jest mniejsza niż 1 lub większa niż liczba miesięcy <paramref name="calendar" />.  
  
—lub— 
 <paramref name="day" /> jest mniejsza niż 1 lub większa niż liczba dni w <paramref name="month" />.  
  
—lub— 
 <paramref name="hour" /> jest mniejszy niż 0 lub większa od 23.  
  
—lub— 
 <paramref name="minute" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="second" /> jest mniejszy niż 0 lub większą niż 59.  
  
—lub— 
 <paramref name="millisecond" /> jest mniejsza niż 0 lub większa od 999.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> nie jest jednym z <see cref="T:System.DateTimeKind" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public DateTime Add (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Add(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Add(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Add(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Add : TimeSpan -&gt; DateTime" Usage="dateTime.Add value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">Przedział czasu dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> , dodaje wartość określonego <see cref="T:System.TimeSpan" /> wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i przedział czasu, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.DateTime.Add%2A> metodę, aby dodać więcej niż jeden rodzaj przedział czasu (dni, godziny, minuty, sekundy lub milisekund) w ramach jednej operacji. Zachowanie tej metody jest taka sama jak w przypadku operator dodawania. <xref:System.DateTime> Struktury obsługuje również metody dodawania specjalne (takie jak <xref:System.DateTime.AddDays%2A>, <xref:System.DateTime.AddHours%2A>, i <xref:System.DateTime.AddMinutes%2A>) dla każdego interwału czasu.  
  
 <xref:System.DateTime.Add%2A> Metoda przyjmuje przestępnego konta i liczbę dni w miesiącu przy wykonywanie operacji arytmetycznych daty.  
  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji. <xref:System.DateTime.Kind%2A> Właściwości nowej <xref:System.DateTime> wystąpienie jest taki sam jak bieżące wystąpienie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Add%2A> metody. Dzień tygodnia, w których jest 36 dni (864 godziny) od tej chwili jest obliczana.  
  
 [!code-cpp[DateTime.Add#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Add/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Add/CS/class1.cs#1)]
 [!code-vb[DateTime.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Add/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="M:System.TimeSpan.Add(System.TimeSpan)" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddDays">
      <MemberSignature Language="C#" Value="public DateTime AddDays (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddDays(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddDays(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDays (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddDays(double value);" />
      <MemberSignature Language="F#" Value="member this.AddDays : double -&gt; DateTime" Usage="dateTime.AddDays value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba dni całość lub część. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> określoną liczbę dni, dodaje wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę dni, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Część ułamkowa `value` jest ułamkową część dnia. Na przykład 4.5 jest odpowiednikiem 4 dni, 12 godzin, 0 minut 0 sekund, milisekund 0 i 0 taktów.  
  
 `value` Parametru jest zaokrąglana do najbliższej milisekundy.  
  
 <xref:System.DateTime.AddDays%2A> Metoda przyjmuje przestępnego konta i liczbę dni w miesiącu przy wykonywanie operacji arytmetycznych daty.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddDays%2A> metodę pozwala ustalić dzień tygodnia 36 dni po bieżącej dacie.  
  
 [!code-cpp[DateTime.AddDays#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.AddDays/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.AddDays#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.AddDays/CS/class1.cs#1)]
 [!code-vb[DateTime.AddDays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.AddDays/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddHours">
      <MemberSignature Language="C#" Value="public DateTime AddHours (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddHours(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddHours(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddHours (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddHours(double value);" />
      <MemberSignature Language="F#" Value="member this.AddHours : double -&gt; DateTime" Usage="dateTime.AddHours value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba godzin całość lub część. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> określoną liczbę godzin, która zwiększa wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę godzin, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji. <xref:System.DateTime.Kind%2A> Właściwości zwracanego <xref:System.DateTime> obiekt jest taki sam, jak w przypadku `value`.  
  
 Część ułamkowa `value` jest część ułamkową parametru godzinę. Na przykład 4.5 jest odpowiednikiem 4 godziny, 30 minut, 0 sekund, milisekund 0 i 0 taktów.  
  
 `value` Parametru jest zaokrąglana do najbliższej milisekundy.  
  
 Konwertowanie odstępami czasowymi krócej niż godzinę na ułamek może obejmować utratę dokładności, jeśli wynik jest powtarzanie niepowodujące wartości dziesiętnej. (Na przykład jedna minuta jest 0.016667 godzinę). Jeśli jest to problemem, możesz użyć <xref:System.DateTime.Add%2A> metody, która pozwala na określenie więcej niż jeden rodzaj przedział czasu w pojedynczym wywołaniu metody oraz eliminuje potrzebę można przekonwertować interwałów czasu na części ułamkowe godzinę.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddHours%2A> metody w celu dodania całość lub część wartości do daty i godziny. Ilustruje utratę dokładności spowodowana przekazaniem metody wartość, która zawiera składnik ułamkowe.  
  
 [!code-csharp[System.DateTime.AddHours#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.AddHours/cs/AddHours1.cs#1)]
 [!code-vb[System.DateTime.AddHours#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.AddHours/vb/AddHours1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddMilliseconds">
      <MemberSignature Language="C#" Value="public DateTime AddMilliseconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMilliseconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMilliseconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMilliseconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMilliseconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMilliseconds : double -&gt; DateTime" Usage="dateTime.AddMilliseconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba milisekund całość lub część. <paramref name="value" /> Parametr może być dodatnia lub ujemna. Należy pamiętać, że ta wartość jest zaokrąglana do najbliższej liczby całkowitej.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> , dodaje określoną liczbę milisekund do wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę milisekund, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Część ułamkowa `value` jest część ułamkową milisekundy. Na przykład 4.5 jest odpowiednikiem 4 milisekund, a 5000 znaczniki, gdy jedna milisekunda = 10000 taktów.  
  
 `value` Parametru jest zaokrąglana do najbliższej liczby całkowitej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddMilliseconds%2A> metodę, aby dodać jeden milisekund i 1,5 milisekund <xref:System.DateTime> wartość. Następnie wyświetla każdy nową wartość i jest wyświetlana różnica między nim a oryginalna wartość. Różnica jest wyświetlany zarówno jako przedział czasu, jak i w postaci liczby taktów. Przykład sprawia, że jasne, że jedna milisekunda równa 10 000 taktów. Pokazano także, że ułamkowe milisekund są zaokrąglane przed wykonaniem dodanie; <xref:System.DateTime> wartość będącą wynikiem dodawania 1,5 milisekund do pierwotna data jest późniejsza niż data oryginalnej 2 milisekund.  
  
 [!code-csharp[System.DateTime.AddMilliseconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmilliseconds/cs/addmilliseconds2.cs#1)]
 [!code-vb[System.DateTime.AddMilliseconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmilliseconds/vb/addmilliseconds2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddMinutes">
      <MemberSignature Language="C#" Value="public DateTime AddMinutes (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMinutes(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMinutes(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMinutes (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMinutes(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMinutes : double -&gt; DateTime" Usage="dateTime.AddMinutes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba minut całość lub część. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> określoną liczbę minut, dodaje wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę minut, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Część ułamkowa `value` jest część ułamkową minuty. Na przykład 4.5 jest odpowiednikiem 4 minut, 30 sekundach, milisekund 0 i 0 taktów.  
  
 `value` Parametru jest zaokrąglana do najbliższej milisekundy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddMinutes%2A> metody w celu dodania całość lub część wartości do daty i godziny.  
  
 [!code-cpp[System.DateTime.AddMinutes#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.addminutes/cpp/addminutes1.cpp#1)]
 [!code-csharp[System.DateTime.AddMinutes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addminutes/cs/addminutes1.cs#1)]
 [!code-vb[System.DateTime.AddMinutes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addminutes/vb/addminutes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddMonths">
      <MemberSignature Language="C#" Value="public DateTime AddMonths (int months);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMonths(int32 months) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMonths(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMonths (months As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMonths(int months);" />
      <MemberSignature Language="F#" Value="member this.AddMonths : int -&gt; DateTime" Usage="dateTime.AddMonths months" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="months" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="months">Liczba miesięcy. <paramref name="months" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> , dodaje określoną liczbę miesięcy do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i <paramref name="months" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime> obiektu. Zamiast tego zwraca nowy <xref:System.DateTime> obiektu, którego wartość jest wynikiem tej operacji.  
  
 <xref:System.DateTime.AddMonths%2A> Metoda oblicza wynikowy miesiąca i roku, biorąc pod uwagę przestępnego i liczbę dni w miesiącu, następnie dopasowuje część dnia wynikowy <xref:System.DateTime> obiektu. Jeśli wynikowe dzień nie jest prawidłowym dniem w miesiącu wynikowy, ostatni dzień prawidłowe miesiąca wynikowy jest używany. Na przykład 31 marca + 1 miesiąc = 30 kwietnia i 31 marca - 1 miesiąc = 28 lutego dla nie rokiem przestępnym i 29 lutego w roku przestępnym.  
  
 Część pory dnia wynikowy <xref:System.DateTime> obiektu pozostaje taki sam, jak to wystąpienie.  
  
   
  
## Examples  
 Poniższy przykład dodaje przedziału od 0 do piętnastu miesięcy do ostatniego dnia grudnia 2015 r. W tym przypadku metoda AddMonths zwraca datę ostatniego dnia każdego miesiąca i pomyślnie obsługuje przestępnego.  
  
 [!code-csharp[System.DateTime.AddMonths#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmonths/cs/addmonths1.cs#1)]
 [!code-vb[System.DateTime.AddMonths#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmonths/vb/addmonths1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.  
  
—lub— 
 <paramref name="months" /> jest mniejsza niż-120,000 lub większy niż 120 000.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddSeconds">
      <MemberSignature Language="C#" Value="public DateTime AddSeconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddSeconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddSeconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSeconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddSeconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddSeconds : double -&gt; DateTime" Usage="dateTime.AddSeconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba sekund całość lub część. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> określoną liczbę sekund, dodaje wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę sekund, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Część ułamkowa `value` jest część ułamkową sekund. Na przykład 4.5 jest odpowiednikiem 4 sekundy, 500 milisekund i znaczniki 0.  
  
 `value` Parametru jest zaokrąglana do najbliższej milisekundy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.AddSeconds%2A> metody w celu dodania 30 sekund i liczbę sekund w ciągu jednego dnia do <xref:System.DateTime> wartości. Następnie wyświetla każdy nową wartość i jest wyświetlana różnica między nim a oryginalna wartość. Różnica jest wyświetlany zarówno jako przedział czasu, jak i w postaci liczby taktów.  
  
 [!code-csharp[System.DateTime.AddSeconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addseconds/cs/addseconds1.cs#1)]
 [!code-vb[System.DateTime.AddSeconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addseconds/vb/addseconds1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddTicks">
      <MemberSignature Language="C#" Value="public DateTime AddTicks (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddTicks(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddTicks(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTicks (value As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddTicks(long value);" />
      <MemberSignature Language="F#" Value="member this.AddTicks : int64 -&gt; DateTime" Usage="dateTime.AddTicks value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Liczba taktów 100-nanosekundowych. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> , dodaje określoną liczbę taktów do wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="AddYears">
      <MemberSignature Language="C#" Value="public DateTime AddYears (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddYears(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddYears(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddYears (value As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddYears(int value);" />
      <MemberSignature Language="F#" Value="member this.AddYears : int -&gt; DateTime" Usage="dateTime.AddYears value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Kilka lat temu. <paramref name="value" /> Parametr może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTime" /> , dodaje określoną liczbę lat do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest sumą Data i godzina reprezentowana przez to wystąpienie i liczbę lat, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime> obiektu. Zamiast tego zwraca nowy <xref:System.DateTime> obiektu, którego wartość jest wynikiem tej operacji.  
  
 <xref:System.DateTime.AddYears%2A> Metoda oblicza wynikowy roku, biorąc pod uwagę przestępnego. Część miesiąca i pory dnia, wynikowe <xref:System.DateTime> obiektu pozostaje taki sam, jak to wystąpienie.  
  
 Jeśli bieżące wystąpienie reprezentuje przestępnym dzień w roku przestępnym, wartość zwracana jest zależna od Data docelowa:  
  
-   Jeśli `value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType> jest również dla roku przestępnego reprezentuje wartość zwracana na dzień tego roku przestępnym. Na przykład czterech lat jest dodawany do 29 lutego 2012 Data, zwracany jest do 29 lutego 2016.  
  
-   Jeśli `value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType> nie jest to rok przestępny, zwracana wartość reprezentuje dzień przed dniem przestępnym w danym roku. Na przykład rok jest dodawany do 29 lutego 2012 Data, zwracany jest 28 lutego 2013.  
  
 Poniższy przykład ilustruje użycie <xref:System.DateTime.AddYears%2A> metody z <xref:System.DateTime> wartość reprezentującą dzień roku przestępnym. Wyświetla datę dotyczące piętnastu lat w programach starszych niż program i 15 lat, które należy wykonać 29 lutego 2000.  
  
 [!code-csharp[System.DateTime.AddYears#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addyears/cs/addyears1.cs#1)]
 [!code-vb[System.DateTime.AddYears#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addyears/vb/addyears1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> lub wynikowy <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (t1 As DateTime, t2 As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Compare : DateTime * DateTime -&gt; int" Usage="System.DateTime.Compare (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Porównuje dwa wystąpienia <see cref="T:System.DateTime" /> i zwraca liczbę całkowitą, która wskazuje, czy pierwsze wystąpienie jest wcześniejsza niż takie same jak lub nowszej niż drugie wystąpienie.</summary>
        <returns>Liczba ze znakiem wskazująca wartości względne <paramref name="t1" /> i <paramref name="t2" />.  
  
 <list type="table"><listheader><term> Typ wartości 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="t1" /> jest starsza niż <paramref name="t2" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="t1" /> jest taka sama jak <paramref name="t2" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="t1" /> jest późniejsza niż <paramref name="t2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację `t1` do `t2`, <xref:System.DateTime.Compare%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwość `t1` i `t2` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Compare%2A> metody.  
  
 [!code-csharp[System.DateTime.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.compare/cs/compare1.cs#1)]
 [!code-vb[System.DateTime.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.compare/vb/compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje wartość tego wystąpienia określony <see cref="T:System.DateTime" /> wartości i wskazuje, czy to wystąpienie jest wcześniejsza niż takie same, jak lub nowszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa przeciążenia <xref:System.DateTime.CompareTo%2A> zwracany przez metodę liczba ze znakiem, która wskazuje względną wartość tego wystąpienia i `value` argumentu, jak pokazano w poniższej tabeli.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|Mniej niż zero|To wystąpienie jest wcześniejsza niż `value`.|  
|Zero|To wystąpienie jest taki sam jak `value`.|  
|Większe od zera|To wystąpienie jest późniejsza niż `value`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(DateTime value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : DateTime -&gt; int&#xA;override this.CompareTo : DateTime -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Porównuje wartość tego wystąpienia określony <see cref="T:System.DateTime" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie jest wcześniejsza niż takie same, jak lub nowszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <returns>Liczba ze znakiem wskazująca względne wartości tego wystąpienia i <paramref name="value" /> parametru.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie jest wcześniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest taki sam jak <paramref name="value" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest późniejsza niż <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację bieżącego wystąpienia do `value`, <xref:System.DateTime.CompareTo%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwości bieżącego wystąpienia i `value` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości.  Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepiej niż <xref:System.DateTime.CompareTo%28System.Object%29?displayProperty=nameWithType> metoda przeciążenia, ponieważ nie trzeba przekonwertować `value` parametr do obiektu.  
  
   
  
## Examples  
 Poniższy przykład tworzy trzy <xref:System.DateTime> obiektów, taki, który reprezentuje bieżącą datę, inny reprezentująca rok wcześniej, a trzeci, który reprezentuje rok w przyszłości. Następnie wywołuje <xref:System.DateTime.CompareTo%28System.DateTime%29> metody i wyświetla wynik porównania.  
  
 [!code-csharp[DateTime.CompareTo.2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo.2/CS/CompareTo_CS1_24564.cs#1)]
 [!code-vb[DateTime.CompareTo.2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo.2/VB/CompareTo_VB1_24564.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Spakowany obiekt do porównania lub <see langword="null" />.</param>
        <summary>Porównuje wartość tego wystąpienia określony obiekt, który zawiera określoną <see cref="T:System.DateTime" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy to wystąpienie jest wcześniejsza niż takie same, jak lub nowszej niż określona <see cref="T:System.DateTime" /> wartość.</summary>
        <returns>Liczba ze znakiem wskazująca względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> To wystąpienie jest wcześniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie jest taki sam jak <paramref name="value" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> To wystąpienie jest późniejsza niż <paramref name="value" />, lub <paramref name="value" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację bieżącego wystąpienia do `value`, <xref:System.DateTime.CompareTo%2A> metoda porównuje <xref:System.DateTime.Ticks%2A> właściwości bieżącego wystąpienia i `value` , ale ignoruje ich <xref:System.DateTime.Kind%2A> właściwości. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Dowolne wystąpienie <xref:System.DateTime>, niezależnie od jej wartość jest uznawany za większy niż `null`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.CompareTo%2A> metody.  
  
 [!code-cpp[DateTime.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.CompareTo/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo/CS/class1.cs#1)]
 [!code-vb[DateTime.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> nie jest <see cref="T:System.DateTime" />.</exception>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Date" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime" Usage="System.DateTime.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik daty z tego wystąpienia.</summary>
        <value>Nowy obiekt przy użyciu tego samego dnia, jak to wystąpienie i wartość czasu ustawiona na północ 12:00:00 (00: 00:00).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest taka sama, jak w przypadku bieżącego wystąpienia.  
  
 Ponieważ <xref:System.DateTime> typu reprezentuje zarówno daty i czas w jednego typu, jest ważne, aby uniknąć rozdzielnie datę zwracane przez <xref:System.DateTime.Date%2A> właściwość jako daty i godziny.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Date%2A> właściwość Wyodrębnij składnik daty z <xref:System.DateTime> wartość z jego składnik czasu, należy ustawić na zero (lub równa 0:00:00 lub północ). Również dwie, w zależności od tego, ciąg formatu używany podczas wyświetlania <xref:System.DateTime> składnik godziny wartości, można nadal pojawiają się w sformatowane wyniki.  
  
 [!code-cpp[System.DateTime.Date#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Date/cpp/date1.cpp#1)]
 [!code-csharp[System.DateTime.Date#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Date/cs/Date1.cs#1)]
 [!code-vb[System.DateTime.Date#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Date/vb/Date1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Day">
      <MemberSignature Language="C#" Value="public int Day { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Day" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Day" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Day As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Day { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Day : int" Usage="System.DateTime.Day" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień miesiąca, reprezentowane przez to wystąpienie.</summary>
        <value>Składnik dnia wyrażony jako wartość z zakresu od 1 do 31.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Day%2A> Właściwość zawsze zwraca wartość dnia miesiąca w kalendarzu gregoriańskim, nawet wtedy, gdy bieżący <xref:System.DateTime> wystąpienia wartości przy użyciu niektórych innych kalendarza lub jeśli bieżący wątek kalendarz domyślny kultury jest kalendarz gregoriański. Aby pobrać dzień miesiąca z określonej daty przy użyciu niektórych innych kalendarza, należy wywołać kalendarza <xref:System.Globalization.Calendar.GetDayOfMonth%2A?displayProperty=nameWithType> metody. W poniższym przykładzie użyto obu <xref:System.DateTime.Day%2A> właściwości i <xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType> metodę, która pobierze dzień miesiąca, <xref:System.DateTime> wartości, który zostanie uruchomiony przy użyciu kalendarz Hidżry.  
  
 [!code-csharp[System.DateTime.Day#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day1.cs#1)]
 [!code-vb[System.DateTime.Day#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day1.vb#1)]  
  
 Podobnie, w poniższym przykładzie użyto obu <xref:System.DateTime.Day%2A> właściwości i <xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType> metody do pobrania w dniu miesiąca, po ar-SA, który używa Hidżry jako jego kalendarz domyślny bieżącej kultury wątku.  
  
 [!code-csharp[System.DateTime.Day#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day2.cs#2)]
 [!code-vb[System.DateTime.Day#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day2.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Day%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfWeek">
      <MemberSignature Language="C#" Value="public DayOfWeek DayOfWeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DayOfWeek DayOfWeek" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfWeek" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfWeek As DayOfWeek" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DayOfWeek DayOfWeek { DayOfWeek get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfWeek : DayOfWeek" Usage="System.DateTime.DayOfWeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DayOfWeek</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień tygodnia, reprezentowany przez to wystąpienie.</summary>
        <value>Stała wyliczeniowa, który wskazuje dzień tygodnia to <see cref="T:System.DateTime" /> wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości stałe w <xref:System.DayOfWeek> wyliczenia zakresu od <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType> do <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>. Jeśli Rzutowanie na liczbę całkowitą, jego wartość należy do zakresu od zera (co oznacza <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>) 6 (co oznacza <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>).  
  
 <xref:System.DateTime.DayOfWeek%2A> Właściwość zwraca Stała wyliczeniowa; odzwierciedlają ustawienia regionalne i językowe systemu. By pobrać ciąg reprezentujący nazwę zlokalizowanej dzień tygodnia dla określonej daty, wywoływanie jednego z przeciążeń <xref:System.DateTime.ToString%2A> metodę, która obejmuje `format` parametru i przekazywać je albo `ddd` lub `dddd` ciągów formatu niestandardowego. Aby uzyskać więcej informacji, zobacz [porady: wyodrębnianie dnia tygodnia z określonej daty](~/docs/standard/base-types/how-to-extract-the-day-of-the-week-from-a-specific-date.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.DayOfWeek%2A> właściwości i <xref:System.DayOfWeek?displayProperty=nameWithType> wyliczenia.  
  
 [!code-cpp[DateTime.DayOfWeek#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DayOfWeek/CPP/dow.cpp#1)]
 [!code-csharp[DateTime.DayOfWeek#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DayOfWeek/CS/dow.cs#1)]
 [!code-vb[DateTime.DayOfWeek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DayOfWeek/VB/dow.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="DayOfYear">
      <MemberSignature Language="C#" Value="public int DayOfYear { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DayOfYear" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfYear" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfYear As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DayOfYear { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfYear : int" Usage="System.DateTime.DayOfYear" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień roku, reprezentowane przez to wystąpienie.</summary>
        <value>Dzień roku, wyrażony jako wartość z zakresu od 1 do 366.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DayOfYear%2A> Właściwość uwzględnia przestępnego podczas obliczania dzień roku. Wartość właściwości zawsze odzwierciedla dnia roku w kalendarzu gregoriańskim, niezależnie od bieżącego kalendarza bieżącej kultury wątku. Aby pobrać dnia roku w kalendarzu różne, należy wywołać <xref:System.Globalization.Calendar.GetDayOfYear%2A?displayProperty=nameWithType> metoda kalendarza.  
  
   
  
## Examples  
 Poniższy przykład wyświetla dzień roku 31 grudnia przez wiele lat 2020 roku 2010 w kalendarzu gregoriańskim. Należy pamiętać, że w przykładzie pokazano 31 grudnia jest 366th dzień roku przestępnego.  
  
 [!code-csharp[System.DateTime.DayOfYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.dayofyear/cs/dayofyear2.cs#1)]
 [!code-vb[System.DateTime.DayOfYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.dayofyear/vb/dayofyear2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.Calendar.GetDayOfYear(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="DaysInMonth">
      <MemberSignature Language="C#" Value="public static int DaysInMonth (int year, int month);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DaysInMonth(int32 year, int32 month) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.DaysInMonth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DaysInMonth (year As Integer, month As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DaysInMonth(int year, int month);" />
      <MemberSignature Language="F#" Value="static member DaysInMonth : int * int -&gt; int" Usage="System.DateTime.DaysInMonth (year, month)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok.</param>
        <param name="month">Miesiąc (liczba od 1 do 12).</param>
        <summary>Zwraca liczbę dni w określonym miesiącu i roku.</summary>
        <returns>Liczba dni w <paramref name="month" /> dla określonego <paramref name="year" />.  
  
Na przykład jeśli <paramref name="month" /> jest równa 2 lutego, wartość zwracana jest 28 lub 29 czy zależności <paramref name="year" /> jest rokiem przestępnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DaysInMonth%2A> Metody zawsze interpretuje `month` i `year` jako miesiąc i rok gregoriański kalendarza, nawet jeśli kalendarz gregoriański nie bieżącego kalendarza bieżącej kultury. Aby uzyskać liczbę dni w miesiącu określonym określonego kalendarza, należy wywołać kalendarza <xref:System.Globalization.Calendar.GetDaysInMonth%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.DateTime.DaysInMonth%2A> metodę, aby określić liczbę dni w lipcu 2001 lutego 1998 (innych niż roku przestępnym) i lutego 1996 roku (rok przestępny).  
  
 [!code-cpp[DateTime.DaysInMonth#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DaysInMonth/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DaysInMonth/CS/class1.cs#1)]
 [!code-vb[DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DaysInMonth/VB/class1.vb#1)]  
  
 Poniższy przykład wyświetla liczbę dni, w każdym miesiącu roku określony w tablicę liczb całkowitych.  
  
 [!code-csharp[System.DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.daysinmonth/cs/daysinmonth3.cs#1)]
 [!code-vb[System.DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.daysinmonth/vb/daysinmonth3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="month" /> jest mniejsza od 1 lub większa niż 12.  
  
—lub— 
 <paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.DateTime" /> obiektów, lub <see cref="T:System.DateTime" /> wystąpienia a innym obiektem, lub <see cref="T:System.DateTime" />, mają taką samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(DateTime value);" />
      <MemberSignature Language="F#" Value="override this.Equals : DateTime -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy wartość tego wystąpienia jest równa wartości określonej <see cref="T:System.DateTime" /> wystąpienia.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="value" /> parametr ma wartość wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące wystąpienie i `value` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są uwzględniane w teście pod kątem równości.  
  
 Ta metoda implementuje <xref:System.IEquatable%601?displayProperty=nameWithType> interfejs i wykonuje nieco lepiej niż <xref:System.DateTime.Equals%2A> metody ponieważ `value` parametru nie musiały zostać skonwertowane do obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.DateTime" /> i równości wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące wystąpienie i `value` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są uwzględniane w teście pod kątem równości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Equals : DateTime * DateTime -&gt; bool" Usage="System.DateTime.Equals (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.DateTime" /> wystąpienia mają taką samą wartość daty i godziny.</summary>
        <returns><see langword="true" /> Jeśli dwie wartości są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t1` i `t2` są takie same jeśli ich <xref:System.DateTime.Ticks%2A> wartości właściwości są takie same. Ich <xref:System.DateTime.Kind%2A> wartości właściwości nie są uwzględniane w teście pod kątem równości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Equals%2A> metody.  
  
 [!code-cpp[DateTime.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Equals/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Equals/CS/class1.cs#1)]
 [!code-vb[DateTime.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Equals/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FromBinary">
      <MemberSignature Language="C#" Value="public static DateTime FromBinary (long dateData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromBinary(int64 dateData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromBinary(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBinary (dateData As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromBinary(long dateData);" />
      <MemberSignature Language="F#" Value="static member FromBinary : int64 -&gt; DateTime" Usage="System.DateTime.FromBinary dateData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateData" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dateData">64-bitowa liczba całkowita ze znakiem koduje <see cref="P:System.DateTime.Kind" /> właściwość polem bitowym 2 i <see cref="P:System.DateTime.Ticks" /> właściwości w polu 62-bitowy.</param>
        <summary>Deserializuje wartość binarną 64-bitowych i zostaje odtworzony oryginalny serializacji <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Obiekt, który jest odpowiednikiem <see cref="T:System.DateTime" /> obiekt, który został wydany przy <see cref="M:System.DateTime.ToBinary" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować wartość bieżącej <xref:System.DateTime> obiektu na wartość binarną. Później, należy użyć wartości binarne i <xref:System.DateTime.FromBinary%2A> metodę, aby odtworzyć, oryginalnym <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  W niektórych przypadkach <xref:System.DateTime> wartość zwrócona przez obiekt <xref:System.DateTime.FromBinary%2A> metoda nie jest taka sama jak oryginalne <xref:System.DateTime> wartość dostarczona do <xref:System.DateTime.ToBinary%2A> metody. Aby uzyskać więcej informacji zobacz następną sekcję "Ustawianie czasu lokalnego".  
  
## <a name="local-time-adjustment"></a>Ustawianie czasu lokalnego  
 Czas lokalny, który jest uniwersalny czas koordynowany dostosowana do lokalnej strefy czasowej, jest reprezentowane przez <xref:System.DateTime> struktury, której <xref:System.DateTime.Kind%2A> właściwość ma wartość <xref:System.DateTimeKind.Local>. Podczas przywracania lokalnym <xref:System.DateTime> wartości z reprezentacji binarnej, który jest wytwarzany przez <xref:System.DateTime.ToBinary%2A> metody <xref:System.DateTime.FromBinary%2A> metoda może dostosować taniego wartość tak, aby nie równa się oryginalna wartość. Taka sytuacja może wystąpić w następujących warunkach:  
  
-   Jeśli lokalny <xref:System.DateTime> serializowany jest obiekt w jednej strefie czasowej, <xref:System.DateTime.ToBinary%2A> metody, a następnie wykonać deserializacji w innej strefie czasowej, <xref:System.DateTime.FromBinary%2A> metody, czasu lokalnego, reprezentowany przez wartość wynikowa <xref:System.DateTime> obiekt jest automatycznie dostosowywany drugi strefę czasową.  
  
     Na przykład, rozważmy <xref:System.DateTime> obiekt, który reprezentuje czas lokalny o godzinie 3 Aplikacja, która jest wykonywana w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego używa <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować który <xref:System.DateTime> obiektu na wartość binarną. Inna aplikacja, który jest wykonywany w Stanach Zjednoczonych Następnie używa strefy czasowej wschodni <xref:System.DateTime.FromBinary%2A> metodę, aby przekonwertować wartość binarną na nową <xref:System.DateTime> obiektu. Wartość nowego <xref:System.DateTime> obiekt jest 18: 00, który reprezentuje tego samego punktu w czasie, co oryginalny P.M. 3 wartość, ale jest dostosowywana do czasu lokalnego w strefie czasowej wschodni.  
  
-   Jeśli reprezentacja binarna zmiennej lokalnej <xref:System.DateTime> wartość reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej systemu, na którym <xref:System.DateTime.FromBinary%2A> jest wywoływana, czas jest uwzględniany tak, że jest on prawidłowy.  
  
     Na przykład przejście od czasu standardowego do czasu letniego występuje strefie czasu pacyficznego w Stanach Zjednoczonych w dniu 14 marca 2010 r. o 2:00, kiedy czas jest przesuwany o jedną godzinę — na 3:00:00 Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartości binarnej przez jest konwertowany ten zakres <xref:System.DateTime.ToBinary%2A> metody i następnie przywróceniu przez <xref:System.DateTime.FromBinary%2A> metody, pierwotna wartość jest dostosowywana do stają się prawidłową godzinę. Można określić, czy określoną wartość daty i godziny może podlegać modyfikacji przez przekazanie jej do <xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType> metody, jak pokazano na przykładzie.  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.DateTime> struktury składa się z prywatnych pól rodzaju, co wskazuje, czy określony czas jest czasu lokalnego, uniwersalny czas koordynowany (UTC) lub żadnego z tych celów, połączone do pola prywatnego, znaczniki, które zawiera liczbę 100-nanosekundowych znaczników, które Określ datę i godzinę. Liczbę znaczników można uzyskać dostęp za pomocą <xref:System.DateTime.Ticks%2A> właściwości i theKind pola można uzyskać dostęp za pomocą <xref:System.DateTime.Kind%2A> właściwości.  
  
 Przed programu .NET Framework 2.0, jeśli użytkownik Zserializowany <xref:System.DateTime> obiektu ręcznie, zamiast przy użyciu interfejsu serializacji, takich jak <xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>, potrzebne do serializacji danych tylko z taktów <xref:System.DateTime>. Począwszy od programu .NET Framework 2.0, należy również serializować rodzaju danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="dateData" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.ToBinary" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTime">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTime (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTime(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTime(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTime (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTime(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTime : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTime fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">Czas pliku Windows wyrażony w dziesięciomilionowych częściach sekundy.</param>
        <summary>Konwertuje określony czas pliku Windows odpowiedni czas lokalny.</summary>
        <returns>Obiekt, który reprezentuje czas lokalny odpowiednik Data i godzina reprezentowana przez <paramref name="fileTime" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 `fileTime` Parametr określa plik czasowy w 100-nanosekundowych taktów.  
  
 Począwszy od programu .NET Framework w wersji 2.0, zwracana jest wartość <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.FromFileTime%2A> metody.  
  
 [!code-cpp[DateTime.FromFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.FromFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.FromFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.FromFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileTime" /> jest mniejsza niż 0 lub reprezentuje czas przekracza <see cref="F:System.DateTime.MaxValue" />.</exception>
        <block subset="none" type="usage"><para>Zazwyczaj <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> przywraca metoda <see cref="T:System.DateTime" /> wartość, która została zapisana przez <see cref="M:System.DateTime.ToFileTime" /> metody. Jednak te dwie wartości mogą się różnić w następujących warunkach: 
-Jeśli serializacji i deserializacji obiektu <see cref="T:System.DateTime" /> wartość występuje w różnych strefach czasowych. Na przykład jeśli <see cref="T:System.DateTime" /> wartość z godziny 12:30:00 w Stanach Zjednoczonych Strefy czasowej wschodni jest serializowana, a następnie wykonać deserializacji w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego, oryginalnym wartość 12:30:00 jest dostosowywana do 9:30:00 Aby uwzględnić różnicę między dwiema strefami czasowymi.  
  
-Jeśli <see cref="T:System.DateTime" /> wartość, która jest serializowana reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej. W tym przypadku <see cref="M:System.DateTime.ToFileTime" /> metoda dostosowuje przywróconej <see cref="T:System.DateTime" /> wartości, tak aby reprezentuje prawidłową godzinę w lokalnej strefie czasowej.  
  
Na przykład następuje przejście od czasu standardowego do czasu letniego w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego w dniu 14 marca 2010 r. o 2:00, kiedy czas jest przesuwany o jedną godzinę — na 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartość Liczba całkowita typu long, jest konwertowany ten zakres <see cref="M:System.DateTime.ToFileTime" /> metody i następnie przywróceniu przez <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> metody, pierwotna wartość jest dostosowywana do stają się prawidłową godzinę. Można określić, czy określoną wartość daty i godziny może podlegać modyfikacji przez przekazanie jej do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, jak pokazano na przykładzie.  
  
[! code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [! kodu vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTimeUtc (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTimeUtc(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTimeUtc(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTimeUtc (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTimeUtc(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTimeUtc : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTimeUtc fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">Czas pliku Windows wyrażony w dziesięciomilionowych częściach sekundy.</param>
        <summary>Konwertuje określony czas pliku Windows odpowiedni czas UTC.</summary>
        <returns>Obiekt, który reprezentuje odpowiednik w czasie UTC Data i godzina reprezentowana przez <paramref name="fileTime" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 `fileTime` Parametr określa plik czasowy w 100-nanosekundowych taktów.  
  
 Począwszy od programu .NET Framework w wersji 2.0, zwracana jest wartość <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileTime" /> jest mniejsza niż 0 lub reprezentuje czas przekracza <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.DateTime.FromFileTime(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FromOADate">
      <MemberSignature Language="C#" Value="public static DateTime FromOADate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromOADate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromOADate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOADate (d As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromOADate(double d);" />
      <MemberSignature Language="F#" Value="static member FromOADate : double -&gt; DateTime" Usage="System.DateTime.FromOADate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty automatyzacji OLE.</param>
        <summary>Zwraca <see cref="T:System.DateTime" /> odpowiednikiem określonej OLE automatyzacji daty.</summary>
        <returns>Obiekt, który reprezentuje tę samą datę i godzinę jako <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `d` Parametr jest liczba zmiennoprzecinkowa podwójnej precyzji, która reprezentuje datę jako liczba dni przed lub po daty podstawowej, północy, 30 grudnia 1899. Logowanie i całkowitego część `d` kodowanie jako dzień dodatnie lub ujemne przesunięcie od 30 grudnia 1899, a wartość bezwzględna część ułamkowa `d` koduje godzinę jako ułamek przemieszczenia dnia, od północy. `d` musi być wartością z zakresu od ujemna 657435.0 za pośrednictwem 2958465.99999999 dodatnią.  
  
 Należy pamiętać, że ze względu na sposób, w jaki są zakodowane daty, są reprezentujący w dowolnym momencie dnia 30 grudnia 1899 na dwa sposoby. Na przykład -0,5 do 0,5 oznacza południe na 30 grudnia 1899, ponieważ przemieszczenia dzień, plus lub minus zero dni od daty podstawowej jest nadal daty podstawowej i przemieszczenia pół dnia, od północy południe.  
  
 Zobacz <xref:System.DateTime.ToOADate%2A> więcej informacji na temat automatyzacji OLE.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Daty nie jest prawidłową wartością daty automatyzacji OLE.</exception>
        <altmember cref="M:System.DateTime.ToOADate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDateTimeFormats">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez standardowy format daty i czasu specyfikatorów formatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nie należy zakładać, że wielu wywołań <xref:System.DateTime.GetDateTimeFormats%2A> przeciążenia zwróci identyczne dane. W zależności od określonego przeciążenia danych zwróconych przez tę metodę można zmienić, jeśli bieżące zmiany kultury użytkownik zastępuje poszczególne ustawienia kultury, lub aktualizacja odbywa się z danymi kultury systemu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : unit -&gt; string[]" Usage="dateTime.GetDateTimeFormats " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez standardowy format daty i czasu specyfikatorów formatu.</summary>
        <returns>Tablica ciągów, w którym każdy element posiada reprezentujący wartość tego wystąpienia jest sformatowany w jeden standardowy format daty i czasu specyfikatorów formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica ciągu, zwrócona przez <xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType> metoda jest równoważna do łączenia macierzy ciąg zwracany przez wywołań <xref:System.DateTime.GetDateTimeFormats%28System.Char%29?displayProperty=nameWithType> metody za pomocą "d", "D", "f", "F", "g", "G", "m", "o", "r", "s", "t", "T", "u", "U" i ciągi formatu standardowego "y". Aby uzyskać więcej informacji na temat specyfikatorów formatu standardowego, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartość zwracana jest formatowana przy użyciu informacji z bieżącej kultury. Aby uzyskać więcej informacji na temat specyficzne dla kultury informacje o formatowaniu dla bieżącej kultury, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z danych wrażliwych na kulturę, nie należy zakładać, że wiele wywołań do metody zwróci identyczne dane. Dane zwrócone przez tę metodę można zmienić, jeśli bieżące zmiany kultury użytkownik zastępuje poszczególne ustawienia kultury, lub aktualizacja odbywa się z danymi kultury systemu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType> metody. Wyświetla ciąg reprezentujący datę przy użyciu wszystkich możliwych standardowe formaty daty i godziny w komputerze bieżącej kultury, czyli w tym przypadku en US.  
  
 [!code-cpp[DateTime.GetDateTimeFormats#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.GetDateTimeFormats#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#1)]
 [!code-vb[DateTime.GetDateTimeFormats#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe:  
  
```  
7/28/2009  
7/28/09  
07/28/09  
07/28/2009  
09/07/28  
2009-07-28  
28-Jul-09  
Tuesday, July 28, 2009  
July 28, 2009  
Tuesday, 28 July, 2009  
28 July, 2009  
Tuesday, July 28, 2009 5:23 AM  
Tuesday, July 28, 2009 05:23 AM  
Tuesday, July 28, 2009 5:23  
Tuesday, July 28, 2009 05:23  
July 28, 2009 5:23 AM  
July 28, 2009 05:23 AM  
July 28, 2009 5:23  
July 28, 2009 05:23  
Tuesday, 28 July, 2009 5:23 AM  
Tuesday, 28 July, 2009 05:23 AM  
Tuesday, 28 July, 2009 5:23  
Tuesday, 28 July, 2009 05:23  
28 July, 2009 5:23 AM  
28 July, 2009 05:23 AM  
28 July, 2009 5:23  
28 July, 2009 05:23  
Tuesday, July 28, 2009 5:23:15 AM  
Tuesday, July 28, 2009 05:23:15 AM  
Tuesday, July 28, 2009 5:23:15  
Tuesday, July 28, 2009 05:23:15  
July 28, 2009 5:23:15 AM  
July 28, 2009 05:23:15 AM  
July 28, 2009 5:23:15  
July 28, 2009 05:23:15  
Tuesday, 28 July, 2009 5:23:15 AM  
Tuesday, 28 July, 2009 05:23:15 AM  
Tuesday, 28 July, 2009 5:23:15  
Tuesday, 28 July, 2009 05:23:15  
28 July, 2009 5:23:15 AM  
28 July, 2009 05:23:15 AM  
28 July, 2009 5:23:15  
28 July, 2009 05:23:15  
7/28/2009 5:23 AM  
7/28/2009 05:23 AM  
7/28/2009 5:23  
7/28/2009 05:23  
7/28/09 5:23 AM  
7/28/09 05:23 AM  
7/28/09 5:23  
7/28/09 05:23  
07/28/09 5:23 AM  
07/28/09 05:23 AM  
07/28/09 5:23  
07/28/09 05:23  
07/28/2009 5:23 AM  
07/28/2009 05:23 AM  
07/28/2009 5:23  
07/28/2009 05:23  
09/07/28 5:23 AM  
09/07/28 05:23 AM  
09/07/28 5:23  
09/07/28 05:23  
2009-07-28 5:23 AM  
2009-07-28 05:23 AM  
2009-07-28 5:23  
2009-07-28 05:23  
28-Jul-09 5:23 AM  
28-Jul-09 05:23 AM  
28-Jul-09 5:23  
28-Jul-09 05:23  
7/28/2009 5:23:15 AM  
7/28/2009 05:23:15 AM  
7/28/2009 5:23:15  
7/28/2009 05:23:15  
7/28/09 5:23:15 AM  
7/28/09 05:23:15 AM  
7/28/09 5:23:15  
7/28/09 05:23:15  
07/28/09 5:23:15 AM  
07/28/09 05:23:15 AM  
07/28/09 5:23:15  
07/28/09 05:23:15  
07/28/2009 5:23:15 AM  
07/28/2009 05:23:15 AM  
07/28/2009 5:23:15  
07/28/2009 05:23:15  
09/07/28 5:23:15 AM  
09/07/28 05:23:15 AM  
09/07/28 5:23:15  
09/07/28 05:23:15  
2009-07-28 5:23:15 AM  
2009-07-28 05:23:15 AM  
2009-07-28 5:23:15  
2009-07-28 05:23:15  
28-Jul-09 5:23:15 AM  
28-Jul-09 05:23:15 AM  
28-Jul-09 5:23:15  
28-Jul-09 05:23:15  
July 28  
July 28  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
5:23 AM  
05:23 AM  
5:23  
05:23  
5:23:15 AM  
05:23:15 AM  
5:23:15  
05:23:15  
2009-07-28 05:23:15Z  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15  
Tuesday, July 28, 2009 12:23:15  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15  
July 28, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15  
28 July, 2009 12:23:15  
July, 2009  
July, 2009  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char -&gt; string[]" Usage="dateTime.GetDateTimeFormats format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowego daty i godziny.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez określoną datą standardowe i specyfikator formatu godziny.</summary>
        <returns>Tablica ciągów, w którym każdy element posiada reprezentujący wartość tego wystąpienia sformatowany przy użyciu <paramref name="format" /> standardowy daty i godziny, specyfikator formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametru może być dowolny standardowy format daty i czasu specyfikatorów formatu. Obejmują one, d, D, f, F, g, G, M (lub m) O (lub o) R (lub r) s, t, T, u, U, a Y (lub y). Aby uzyskać więcej informacji, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartość zwracana jest formatowana przy użyciu informacji z bieżącej kultury. Aby uzyskać więcej informacji na temat specyficzne dla kultury informacje o formatowaniu dla bieżącej kultury, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z danych wrażliwych na kulturę, nie należy zakładać, że wiele wywołań do metody zwróci identyczne dane. Dane zwrócone przez tę metodę można zmienić, jeśli bieżące zmiany kultury użytkownik zastępuje poszczególne ustawienia kultury, lub aktualizacja odbywa się z danymi kultury systemu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.Char%29> metody. Wyświetla ciąg reprezentujący datę przy użyciu specyfikatora formatu daty długiej ("D") dla bieżącej kultury.  
  
 [!code-csharp[DateTime.GetDateTimeFormats#3](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#3)]
 [!code-vb[DateTime.GetDateTimeFormats#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> nie jest prawidłową datą standardowe i znak specyfikatora formatu czasu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu tego wystąpienia specyficzne dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwane przez standardowa Data i czas specyfikatorów formatu i określonego specyficzne dla kultury informacje o formatowaniu.</summary>
        <returns>Tablica ciągów, w którym każdy element posiada reprezentujący wartość tego wystąpienia jest sformatowany w jeden standardowy format daty i czasu specyfikatorów formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica ciągu, zwrócona przez <xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType> metoda jest równoważna do łączenia macierzy ciąg zwracany przez wywołań <xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody za pomocą "d", "D", "f", "F", "g", "G", "m", "o", "r", "s", "t", "T", "u", "U" i ciągi formatu standardowego "y". Aby uzyskać więcej informacji na temat specyfikatorów formatu standardowego, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartość zwracana jest formatowana przy użyciu informacji specyficznych dla kultury dostarczonych przez `provider`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z danych wrażliwych na kulturę, nie należy zakładać, że wiele wywołań do metody zwróci identyczne dane, chyba że `provider` jest <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje niezmienną kulturę. Dane zwrócone przez tę metodę można zmienić, jeśli użytkownik zastępuje poszczególne ustawienia kultury `provider` lub jeśli nastąpi aktualizacja dane kultury systemu `provider`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType> metody. Wyświetla ciąg reprezentujący datę przy użyciu wszystkich możliwych standardowe formaty daty i godziny dla kultury fr-FR.  
  
 [!code-cpp[DateTime.GetDateTimeFormats#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#2)]
 [!code-csharp[DateTime.GetDateTimeFormats#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#2)]
 [!code-vb[DateTime.GetDateTimeFormats#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#2)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe:  
  
```  
28/07/2009  
28/07/09  
28.07.09  
28-07-09  
2009-07-28  
mardi 28 juillet 2009  
28 juil. 09  
28 juillet 2009  
mardi 28 juillet 2009 05:23  
mardi 28 juillet 2009 5:23  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23  
28 juil. 09 5:23  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23  
28 juillet 2009 5:23  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
mardi 28 juillet 2009 05:23:15  
mardi 28 juillet 2009 5:23:15  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23:15  
28 juil. 09 5:23:15  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23:15  
28 juillet 2009 5:23:15  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
28/07/2009 05:23  
28/07/2009 5:23  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23  
28/07/09 5:23  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23  
28.07.09 5:23  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23  
28-07-09 5:23  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23  
2009-07-28 5:23  
2009-07-28 05.23  
2009-07-28 05 h 23  
28/07/2009 05:23:15  
28/07/2009 5:23:15  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23:15  
28/07/09 5:23:15  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23:15  
28.07.09 5:23:15  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23:15  
28-07-09 5:23:15  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23:15  
2009-07-28 5:23:15  
2009-07-28 05.23  
2009-07-28 05 h 23  
28 juillet  
28 juillet  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
05:23  
5:23  
05.23  
05 h 23  
05:23:15  
5:23:15  
05.23  
05 h 23  
2009-07-28 05:23:15Z  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12.23  
mardi 28 juillet 2009 12 h 23  
28 juil. 09 12:23:15  
28 juil. 09 12:23:15  
28 juil. 09 12.23  
28 juil. 09 12 h 23  
28 juillet 2009 12:23:15  
28 juillet 2009 12:23:15  
28 juillet 2009 12.23  
28 juillet 2009 12 h 23  
juillet 2009  
juillet 2009  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char, provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char * IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats (format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu daty i godziny.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu tego wystąpienia specyficzne dla kultury.</param>
        <summary>Konwertuje wartość tego wystąpienia reprezentacji ciągu obsługiwany przez określoną datą standardowe i specyfikator formatu godziny i informacje o formatowaniu specyficzne dla kultury.</summary>
        <returns>Tablica ciągów, w którym każdy element posiada reprezentujący wartość tego wystąpienia jest sformatowany w jeden standardowy format daty i czasu specyfikatorów formatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr formatu może być dowolną z standardowy format daty i czasu specyfikatorów formatu. Obejmują one, d, D, f, F, g, G, M (lub m) O (lub o) R (lub r) s, t, T, u, U, a Y (lub y). Aby uzyskać więcej informacji, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md).  
  
 Każdy element wartość zwracana jest formatowana przy użyciu informacji specyficznych dla kultury dostarczonych przez `provider`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda korzysta z danych wrażliwych na kulturę, nie należy zakładać, że wiele wywołań do metody zwróci identyczne dane, chyba że `provider` jest <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje niezmienną kulturę. Dane zwrócone przez tę metodę można zmienić, jeśli użytkownik zastępuje poszczególne ustawienia kultury `provider` lub jeśli nastąpi aktualizacja dane kultury systemu `provider`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29> metody. Wyświetla ciągów reprezentujących daty dla kultury fr-FR przy użyciu specyfikatora formatu daty krótkiej ("d").  
  
 [!code-csharp[DateTime.GetDateTimeFormats#4](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#4)]
 [!code-vb[DateTime.GetDateTimeFormats#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> nie jest prawidłową datą standardowe i znak specyfikatora formatu czasu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dateTime.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="dateTime.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.TypeCode" /> dla typu wartości <see cref="T:System.DateTime" />.</summary>
        <returns>Stała wyliczeniowa <see cref="F:System.TypeCode.DateTime" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hour">
      <MemberSignature Language="C#" Value="public int Hour { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Hour" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Hour" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hour As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Hour { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Hour : int" Usage="System.DateTime.Hour" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik godziny wartości daty, reprezentowane przez to wystąpienie.</summary>
        <value>Składnik godziny wyrażony jako wartość z zakresu od 0 do 23.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.DateTime.Hour%2A> właściwość zawsze jest wyrażona za pomocą zegara 24-godzinnego. Aby pobrać ciąg, który reprezentuje godzinę datę i godzinę 12-godzinnym, należy wywołać <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> lub <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu niestandardowego "h". Na przykład:  
  
 [!code-csharp[System.DateTime.Hour#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Hour/cs/Hour1.cs#1)]
 [!code-vb[System.DateTime.Hour#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Hour/vb/Hour1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Hour%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsDaylightSavingTime" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDaylightSavingTime () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime();" />
      <MemberSignature Language="F#" Value="member this.IsDaylightSavingTime : unit -&gt; bool" Usage="dateTime.IsDaylightSavingTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy to wystąpienie <see cref="T:System.DateTime" /> znajduje się w zakresie czasu letniego dla bieżącej strefy czasowej.</summary>
        <returns><see langword="true" /> Jeśli wartość <see cref="P:System.DateTime.Kind" /> właściwość <see cref="F:System.DateTimeKind.Local" /> lub <see cref="F:System.DateTimeKind.Unspecified" /> i wartość tego wystąpienia <see cref="T:System.DateTime" /> znajduje się w zakresie czasu letniego dla lokalnej strefy czasowej; <see langword="false" /> Jeśli <see cref="P:System.DateTime.Kind" /> jest <see cref="F:System.DateTimeKind.Utc" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy bieżący <xref:System.DateTime> wartość znajduje się w zakresie czasu letniego lokalnej strefy czasowej, która jest zwracana przez <xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType> właściwości. Można określić, czy strefa czasowa obsługuje czasu letniego, poprzez pobranie wartości jego <xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A?displayProperty=nameWithType> właściwości. Dla stref czasowych honorujących czasu letniego, należy określić, kiedy następuje przejście do i z czasu letniego pobierając <xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType> tablica zwrócona przez strefę czasową <xref:System.TimeZoneInfo.GetAdjustmentRules%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli bieżący <xref:System.DateTime> wartość reprezentuje niejednoznaczny lub nieprawidłową godzinę w lokalnej strefie czasowej, metoda zwraca `false`.  
  
 Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów <xref:System.DateTime.IsDaylightSavingTime%2A> metoda rozpoznaje tylko bieżącą regułę dopasowania podczas ustalania, czy bieżące wystąpienie jest czasu letniego. W wyniku metoda może dokładnie raportuje czy bieżące wystąpienie jest czasu letniego dla okresów przed bieżącą regułę dopasowania wprowadzenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="IsLeapYear">
      <MemberSignature Language="C#" Value="public static bool IsLeapYear (int year);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLeapYear(int32 year) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsLeapYear(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLeapYear (year As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLeapYear(int year);" />
      <MemberSignature Language="F#" Value="static member IsLeapYear : int -&gt; bool" Usage="System.DateTime.IsLeapYear year" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">Rok 4-cyfrowego.</param>
        <summary>Zwraca wskazanie, czy określony rok jest rokiem przestępnym.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="year" /> jest rokiem przestępnym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `year` jest określony jako podstawowy numer 10 4-cyfrowego; na przykład, 1996 roku.  
  
 `year` zawsze jest interpretowany jako rok w kalendarzu gregoriańskim. Aby ustalić, czy danego roku była w roku przestępnym w niektórych innych kalendarza, wywołanie tego obiektu kalendarza `IsLeapYear` metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.IsLeapYear%2A> metodę, aby określić, które lat między 1994 r. i 2014 są przestępnego. Ten przykład ilustruje wynik po <xref:System.DateTime.AddYears%2A> metoda jest używana do dodawania roku dniem przestępnym.  
  
 [!code-csharp[System.DateTime.IsLeapYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/cs/IsLeapYear1.cs#1)]
 [!code-vb[System.DateTime.IsLeapYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/vb/IsLeapYear1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> jest mniejsza od 1 lub większa niż 9999.</exception>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public DateTimeKind Kind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeKind Kind" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Kind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Kind As DateTimeKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTimeKind Kind { DateTimeKind get(); };" />
      <MemberSignature Language="F#" Value="member this.Kind : DateTimeKind" Usage="System.DateTime.Kind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy czas reprezentowany przez to wystąpienie jest oparta na czas lokalny, uniwersalny czas koordynowany (UTC) lub nie.</summary>
        <value>Jedna z wartości wyliczenia, które wskazuje na to, co reprezentuje bieżący czas. Wartość domyślna to <see cref="F:System.DateTimeKind.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można jawnie ustawić <xref:System.DateTime.Kind%2A> nową właściwość <xref:System.DateTime> wartość określonego <xref:System.DateTimeKind> wartość przez wywołanie metody <xref:System.DateTime.SpecifyKind%2A> metody.  
  
 <xref:System.DateTime.Kind%2A> Właściwość umożliwia <xref:System.DateTime> wartość wartość wyraźnie uniwersalnego czasu koordynowanego (UTC) lub czasu lokalnego. Z kolei <xref:System.DateTimeOffset> struktura może jednoznacznie odzwierciedlać ilekroć w dowolnej strefie czasowej jako pojedynczy punkt w czasie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metodę, aby zademonstrować sposób, w jaki <xref:System.DateTime.Kind%2A> czynników właściwość <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MaxValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxValue : DateTime" Usage="System.DateTime.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.DateTime" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest odpowiednikiem 23:59:59.9999999 czasu UTC, 31 grudnia 9999 r w kalendarzu gregoriańskim, dokładnie jeden znaczników 100-nanosekundowych przed UTC 00:00:00, 1 stycznia 10000.  
  
 Niektóre kalendarze i wiele, takich jak <xref:System.Globalization.ThaiBuddhistCalendar>, obsługują zakresu dat w prawym górnym, starszej niż <xref:System.DateTime.MaxValue>. W takich przypadkach próby uzyskania dostępu do <xref:System.DateTime.MaxValue> w i przypisania zmiennych lub formatowanie operacji analizowania może zgłosić <xref:System.ArgumentOutOfRangeException>. Zamiast pobierania wartości <xref:System.DateTime.MaxValue?displayProperty=nameWithType>, możesz pobrać wartość określonej kultury najnowsze prawidłowej wartości daty z <xref:System.Globalization.Calendar.MaxSupportedDateTime?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.DateTime> obiektu przez przekazanie jego konstruktorowi <xref:System.Int64> wartość, która reprezentuje liczbę znaczników. Przed wywołaniem konstruktora, przykład zapewnia, że ta wartość jest większa lub równa `DateTime.MinValue.Ticks` i mniejsza niż lub równa `DateTime.MaxValue.Ticks`. Jeśli nie, zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.DateTime.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Millisecond">
      <MemberSignature Language="C#" Value="public int Millisecond { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Millisecond" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Millisecond" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Millisecond As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Millisecond { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Millisecond : int" Usage="System.DateTime.Millisecond" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik milisekund daty reprezentowane przez to wystąpienie.</summary>
        <value>Składnik milisekund, wyrażony jako wartość z zakresu od 0 do 999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można wyświetlić reprezentację ciągu <xref:System.DateTime.Millisecond%2A> właściwości przy użyciu specyfikatora formatu "fff". Na przykład poniższy kod wyświetla ciąg, który zawiera liczbę milisekund w datę i godzinę na konsoli.  
  
 [!code-csharp[System.DateTime.Millisecond#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#1)]
 [!code-vb[System.DateTime.Millisecond#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#1)]  
  
 Można również wyświetlić składnik milisekund oraz inne składniki wartości daty i godziny przy użyciu specyfikatora formatu standardowego "o". Na przykład:  
  
 [!code-csharp[System.DateTime.Millisecond#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#2)]
 [!code-vb[System.DateTime.Millisecond#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#2)]  
  
 Specyfikator formatu "o" jest jednak przeznaczona mniej do wyświetlania niż Pełna zgodnooć wersji lub przechowywania <xref:System.DateTime> wartość. Można również wyświetlić milisekund wraz z innymi składnikami daty i godziny przy użyciu ciągu formatu niestandardowego, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.DateTime.Millisecond#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#3)]
 [!code-vb[System.DateTime.Millisecond#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Millisecond%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Minute">
      <MemberSignature Language="C#" Value="public int Minute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Minute" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Minute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minute As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Minute { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Minute : int" Usage="System.DateTime.Minute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik minuty z Data jest reprezentowana przez to wystąpienie.</summary>
        <value>Składnik minuty, wyrażony jako wartość z zakresu od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Minute%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MinValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MinValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinValue : DateTime" Usage="System.DateTime.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje najniższą możliwą wartość elementu <see cref="T:System.DateTime" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest odpowiednikiem 00:00:00.0000000 czasu UTC, 1 stycznia 0001 w kalendarzu gregoriańskim.  
  
 <xref:System.DateTime.MinValue> Określa datę i godzinę, która jest przypisana do niezainicjowanego <xref:System.DateTime> zmiennej. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.DateTime.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#1)]
 [!code-vb[System.DateTime.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#1)]  
  
 <xref:System.DateTime.MinValue> i <xref:System.DateTime.MaxValue> właściwości może służyć do zapewnienia, że wartość należy do obsługiwanego zakresu przed przekazaniem go do <xref:System.DateTime> konstruktora. Kod w sekcji przykład ilustruje użycie tych.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.DateTime> obiektu przez przekazanie jego konstruktorowi <xref:System.Int64> wartość, która reprezentuje liczbę znaczników. Przed wywołaniem konstruktora, przykład zapewnia, że ta wartość jest większa lub równa `DateTime.MinValue.Ticks` i mniejsza niż lub równa `DateTime.MaxValue.Ticks`. Jeśli nie, zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Month">
      <MemberSignature Language="C#" Value="public int Month { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Month" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Month" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Month As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Month { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Month : int" Usage="System.DateTime.Month" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik miesiąca z Data jest reprezentowana przez to wystąpienie.</summary>
        <value>Składnik miesiąca wyrażony jako wartość z zakresu od 1 do 12.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Month%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Now">
      <MemberSignature Language="C#" Value="public static DateTime Now { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Now" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Now" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Now As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Now { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Now : DateTime" Usage="System.DateTime.Now" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> obiekt, który jest ustawiona na bieżącą datę i godzinę na tym komputerze, który jest wyrażona jako czas lokalny.</summary>
        <value>Obiekt, którego wartość jest aktualnej lokalne daty i godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Now%2A> Właściwość zwraca <xref:System.DateTime> wartość, która reprezentuje bieżącą datę i godzinę, na komputerze lokalnym. Należy pamiętać, że różnica między <xref:System.DateTime> wartość, która reprezentuje liczbę znaczników, które upłynęły od północy 1 stycznia 0001, i reprezentację ciągu, który <xref:System.DateTime> wartości, który wyraża wartość daty i godziny w format określonej kultury. Aby uzyskać informacje o formatowaniu wartości daty i godziny, zobacz <xref:System.DateTime.ToString%2A> metody. Poniższy przykład wyświetla krótki ciąg daty i godziny w wielu formatach specyficzne dla kultury.  
  
 [!code-cpp[System.DateTime.Now#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now1.cpp#2)]
 [!code-csharp[System.DateTime.Now#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now1.cs#2)]
 [!code-vb[System.DateTime.Now#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now1.vb#2)]  
  
 Rozwiązania dla tej właściwości zależy od czasomierz systemowy, który jest zależny od zasadniczego systemu operacyjnego. Zwykle należeć do zakresu od 0,5 do 15 milisekund. W rezultacie wielokrotne wywołania <xref:System.DateTime.Now%2A> właściwość interwał krótki czas, takie jak w pętli, może zwrócić tę samą wartość.  
  
 <xref:System.DateTime.Now%2A> Jest często używana do pomiaru wydajności. Jednak ze względu na jej niskiej rozdzielczości, nie jest odpowiedni do użytku jako narzędzie porównawczych. Lepszą alternatywą jest użycie <xref:System.Diagnostics.Stopwatch> klasy.  
  
 Począwszy od programu .NET Framework w wersji 2.0, zwracana jest wartość <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość zwraca <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Można również użyć <xref:System.DateTimeOffset.Now%2A?displayProperty=nameWithType> właściwość służąca do pobierania aktualnej lokalne daty i godziny. Umożliwia ona czas lokalny wyrażane jednoznacznie jako pojedynczy punkt w czasie, co z kolei sprawia, że ta wartość czasu przenośne na komputerach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Now%2A> i <xref:System.DateTime.UtcNow%2A> właściwości, aby pobrać bieżącą lokalne daty i godziny i bieżący uniwersalny koordynowany Data i godzina (UTC). Następnie używa konwencji formatowania liczby kultur do wyświetlenia ciągów, wraz z wartościami ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Now#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now2.cpp#3)]
 [!code-csharp[System.DateTime.Now#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now2.cs#3)]
 [!code-vb[System.DateTime.Now#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.Now" />
        <altmember cref="P:System.DateTime.UtcNow" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static DateTime operator + (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Addition(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Addition(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator +(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( + ) : DateTime * TimeSpan -&gt; DateTime" Usage="d + t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty i godziny do dodania.</param>
        <param name="t">Przedział czasu do dodania.</param>
        <summary>Dodaje określony przedział czasu do określonej daty i godziny, reaguje na nową datę i godzinę.</summary>
        <returns>Obiekt, który jest sumą wartości <paramref name="d" /> i <paramref name="t" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.DateTime.Add%28System.TimeSpan%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano operator dodawania.  
  
 [!code-cpp[DateTime Operators#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#1)]
 [!code-csharp[DateTime Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#1)]
 [!code-vb[DateTime Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Equality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : DateTime * DateTime -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="d2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone wystąpienia elementu <see cref="T:System.DateTime" /> są takie same.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="d1" /> i <paramref name="d2" /> reprezentują tę samą datę i czas; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Equality%2A> Operator określa, czy dwa <xref:System.DateTime> wartości są równe, porównując ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano operatora równości.  
  
 [!code-cpp[DateTime Operators#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#2)]
 [!code-csharp[DateTime Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#2)]
 [!code-vb[DateTime Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy jeden określony <see cref="T:System.DateTime" /> jest nowsza niż inna określona <see cref="T:System.DateTime" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="t1" /> jest późniejsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThan%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy jeden określony <see cref="T:System.DateTime" /> reprezentuje datę i godzinę, która jest taka sama, wcześniejsza niż inny określony <see cref="T:System.DateTime" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="t1" /> jest taka sama jak lub późniejsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThanOrEqual%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Inequality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : DateTime * DateTime -&gt; bool" Usage="System.DateTime.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="d2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone wystąpienia elementu <see cref="T:System.DateTime" /> nie są takie same.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="d1" /> i <paramref name="d2" /> nie reprezentują tego samego Data i godzina; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Inequality%2A> Operator określa, czy dwa <xref:System.DateTime> wartości nie są równe, porównując ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy jeden określony <see cref="T:System.DateTime" /> jest starsza niż inny określony <see cref="T:System.DateTime" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="t1" /> jest starsza niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThan%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="t2">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy jeden określony <see cref="T:System.DateTime" /> reprezentuje datę i godzinę, która jest taka sama, jak lub wcześniej, niż inny określony <see cref="T:System.DateTime" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="t1" /> jest taka sama jak lub starszej niż <paramref name="t2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThanOrEqual%2A> Operator określa relację między dwiema <xref:System.DateTime> wartości przez porównanie ich liczbę taktów. Przed porównaniem <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. Można to zrobić przez porównanie wartości ich <xref:System.DateTime.Kind%2A> właściwości.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określoną <see cref="T:System.DateTime" /> lub<see cref="T:System.TimeSpan" /> z określonym <see cref="T:System.DateTime" />.</summary>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static TimeSpan operator - (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Subtraction(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As DateTime, d2 As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeSpan operator -(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * DateTime -&gt; TimeSpan" Usage="d1 - d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">Wartość daty i czasu do odjęcia od (odjemna).</param>
        <param name="d2">Wartość daty i godziny na potrzeby odejmowania (odjemnik).</param>
        <summary>Odejmuje określonej daty i czasu z innej określonej daty i godziny, a następnie zwraca przedział czasu.</summary>
        <returns>Odstęp czasu między <paramref name="d1" /> i <paramref name="d2" />, czyli <paramref name="d1" /> minus <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Subtraction%28System.DateTime%2CSystem.DateTime%29> Metody nie należy wziąć pod uwagę wartości <xref:System.DateTime.Kind%2A> właściwości dwóch <xref:System.DateTime> wartości podczas przeprowadzania odejmowania. Przed odjęcie <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. W przeciwnym razie wynik będzie zawierać różnica między strefami czasowymi.  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.op_Subtraction%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType> Metody należy wziąć pod uwagę różnice między strefami czasowymi podczas przeprowadzania odejmowania.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> metody i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static DateTime operator - (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Subtraction(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator -(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * TimeSpan -&gt; DateTime" Usage="d - t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">Wartość daty i czasu do odjęcia od.</param>
        <param name="t">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje określony przedział czasu od określonej daty i godziny i zwraca nową datę i godzinę.</summary>
        <returns>Obiekt, którego wartość jest wartością elementu <paramref name="d" /> minus wartość <paramref name="t" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odejmuje wartość impulsów `t` od wartości impulsów `d`.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> metody i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wynikowa <see cref="T:System.DateTime" /> jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="M:System.DateTime.Subtract(System.TimeSpan)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.TimeSpan" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
- [Która metoda zostanie wywołana?](#Tasks)
- [Ciąg do analizy](#StringToParse)
- [Konwencje analizy i kultury](#Culture)
- [Analizowanie i elementy stylu](#Styles)
- [Wartość zwracana i DateTime.Kind](#kind)
 
<a name="Tasks"></a>   
### <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Zadanie|Wywołania|  
|--------|----------|  
|Przeanalizować ciąg daty i godziny przy użyciu konwencji bieżącej kultury.|<xref:System.DateTime.Parse%28System.String%29> przeciążenie|  
|Przeanalizować ciąg daty i godziny przy użyciu Konwencji określonej kultury.|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> przeciążenia (zobacz [Konwencji kultury i analizowanie](#Culture))|  
|Analizuje ciąg zawierający datę i godzinę elementy stylu specjalne (takie jak odstępy czy żadne inne białe).|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenie|  
|Przeanalizować ciąg daty i godziny, który musi być w określonym formacie.|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> lub <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>|
|Przeanalizować ciąg daty i godziny, a następnie wykonać konwersję do czasu UTC, czy czas lokalny.|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenie|  
|Bez obsługi wyjątków, należy przeanalizować ciąg daty i godziny.|<xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> — Metoda|  
|Przywróć (Runda) wartości daty i godziny, utworzone przez operację formatowania.|Ciąg formatu standardowego "o" lub "r", aby przekazać <xref:System.DateTime.ToString%28System.String%29> metoda i wywołania <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia z <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>|  
|Przeanalizować ciąg daty i godziny w stałym formacie granice machine (i ewentualnie kultury).|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> lub <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> — metoda|  
  
<a name="StringToParse"></a>   
### <a name="the-string-to-parse"></a>Ciąg do analizy  
 <xref:System.DateTime.Parse%2A> Metoda podejmuje próbę przekonwertowania ciągu reprezentującego wartość daty i godziny w celu jego <xref:System.DateTime> równoważne. Próbuje przeanalizować ciągu wejściowego całkowicie bez niepotrzebnego <xref:System.FormatException> wyjątku.  
  
> [!IMPORTANT]
>  Jeśli podczas analizowania kończy się niepowodzeniem z powodu nierozpoznany format ciągu, <xref:System.DateTime.Parse%2A> metoda zgłasza wyjątek <xref:System.FormatException>, podczas gdy <xref:System.DateTime.TryParse%2A> metoda zwraca `false`. Ponieważ obsługa wyjątków może być kosztowne, należy używać <xref:System.DateTime.Parse%2A> podczas operacji analizowania może się powieść, ponieważ źródło danych wejściowych jest zaufany. <xref:System.DateTime.TryParse%2A> preferowane jest po prawdopodobnie błędy podczas analizowania, szczególnie w przypadku, ponieważ źródło danych wejściowych nie jest zaufany lub mają wartości domyślne uzasadnione, aby zastąpić ciągi, które nie pomyślnie przeanalizować.   

 Ciąg, który ma być analizowany, może mieć jedną z następujących form:  
  
-   Ciąg, datę i składnik czasu.  
  
-   Ciąg zawierający datę, ale nie składnika godziny. Jeśli składnik czasu jest nieobecne, metoda zakłada, 12:00 w dniu. Jeśli składnik daty dwucyfrowy rok, jest konwertowany na rok, na podstawie <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> bieżący kalendarz kultury bieżącej lub określonej kultury bieżącego kalendarza (Jeśli używasz przeciążenia z inną niż null `provider` argument).  
  
- Ciąg zawierający składnik daty, która zawiera tylko nazwę miesiąca i roku, ale nie składnik dni. Metoda zakłada się pierwszego dnia miesiąca.

- Ciąg zawierający składnik daty, która zawiera tylko nazwę miesiąca i dnia, ale nie składnik roku. Metoda zakłada bieżącego roku.

-   Ciąg zawierający czas, ale brak składnika daty. Metoda zakłada bieżącą datę, chyba że wywołanie <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia i obejmują <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> w `styles` argumentu, w którym przypadku metoda zakłada dnia 1 stycznia 0001.  

- Ciąg zawierający składnik czasu, który obejmuje tylko godzinę i oznaczenie AM/PM, za pomocą składnika nie daty. Metoda zakłada bieżącą datę i godzinę przy użyciu nie minuty i sekundy nie. To zachowanie można zmienić, wywołując <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenia i obejmują <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> w `styles` argumentu, w którym przypadku metoda zakłada dnia 1 stycznia 0001.

-   Ciąg, który zawiera informacje o strefie czasowej, a także są zgodne z ISO 8601. W poniższych przykładach pierwszy ciąg wyznacza uniwersalnego czasu koordynowanego (UTC), a drugi określa czas w strefie czasowej, który wynosi siedem godziny wcześniejszy niż UTC:  
  
    "2008-11-01T19:35:00.0000000Z"   
    "2008-11-01T19:35:00.0000000-07:00"  
  
-   Ciąg, który zawiera oznaczenie GMT i jest zgodny z formatem czasu RFC 1123; na przykład:  
  
     "SO 01 lis 2008 19:35:00 GMT"  
  
-   Ciąg zawierający datę i godzinę, wraz z informacjami przesunięcia strefy czasowej; na przykład:  
  
     "03/01/2009 05:42:00 -5:00"  

Poniższy przykład analizuje ciągów w każdym z tych formatów przy użyciu konwencji formatowania bieżącej kultury, czyli w tym przypadku kultury en US:

[!code-csharp-interactive[Default parsing](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse6.cs)]
[!code-vb[Default parsing](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse6.vb)]  
  
 Jeśli ciąg wejściowy reprezentuje przestępnym dnia w roku przestępnym kalendarz używany przez metodę analizowania (zobacz [konwencje analizy i kultury](#Culture)), <xref:System.DateTime.Parse%2A> metoda analizowania ciągu pomyślnie. Jeśli ciąg wejściowy reprezentuje dzień przestępnym w innych — rokiem przestępnym, metoda zgłasza <xref:System.FormatException>.  
  
 Ponieważ <xref:System.DateTime.Parse%2A> metoda podejmuje próbę przeanalizowania reprezentacji ciągu daty i godziny przy użyciu reguły formatowania bieżącej lub określonej kultury, próby przeprowadzenia analizy ciągu w różnych kulturach może zakończyć się niepowodzeniem. Można przeanalizować określonego format daty i godziny w różnych ustawień regionalnych, użyj jednego z przeciążeń <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> metody i podania specyfikatora formatu.  
  
<a name="Culture"></a>   
### <a name="parsing-and-cultural-conventions"></a>Konwencje analizy i kultury  
 Wszystkie przeciążenia <xref:System.DateTime.Parse%2A> metody są zależne od kultury chyba że ciąg można przeanalizować (reprezentowany przez `s` w poniższej tabeli) jest zgodna z wzorcem ISO 8601. Informacje o formatowaniu w korzysta z operacji analizowania <xref:System.Globalization.DateTimeFormatInfo> obiekt, który jest tworzony w następujący sposób:  
  
|Jeśli wywołasz|I `provider` jest|Informacje o formatowaniu jest tworzony na podstawie|  
|-----------------|-----------------------|--------------------------------------------|  
|<xref:System.DateTime.Parse%28System.String%29>|-|Bieżąca kultura wątku (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType> właściwości)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|Element <xref:System.Globalization.DateTimeFormatInfo> obiektu|Określony <xref:System.Globalization.DateTimeFormatInfo> obiektu|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|`null`|Bieżąca kultura wątku (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType> właściwości)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|Element <xref:System.Globalization.CultureInfo> obiektu|<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> Właściwości|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> lub <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|Niestandardowe <xref:System.IFormatProvider> implementacji|<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> — Metoda|  
  
 Gdy informacje o formatowaniu jest tworzony na podstawie <xref:System.Globalization.DateTimeFormatInfo> obiektu <xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType> właściwość definiuje kalendarz używany w operacji analizowania.  
  
 Jeśli przeanalizować ciąg daty i godziny przy użyciu <xref:System.Globalization.DateTimeFormatInfo> obiektu z dostosowane ustawienia, które różnią się od tych standardowej kultury, należy użyć <xref:System.DateTime.ParseExact%2A> zamiast metody <xref:System.DateTime.Parse%2A> metodę, aby zwiększyć prawdopodobieństwo pomyślnego konwersji. Niestandardowy ciąg daty i godziny może być skomplikowane i trudne do analizowania. <xref:System.DateTime.Parse%2A> Metoda próbuje przeanalizować składni ciągu wzorami kilka niejawnych analizy, które może zakończyć się niepowodzeniem. Z kolei <xref:System.DateTime.ParseExact%2A> metoda wymaga umożliwia jawne wyznaczanie wzorców dokładne analizy, które prawdopodobnie powiodą. Aby uzyskać więcej informacji, zobacz sekcję "DateTimeFormatInfo i dane dynamiczne" w <xref:System.Globalization.DateTimeFormatInfo> tematu.  
  
> [!IMPORTANT]
>  Należy pamiętać, że Konwencji formatowania określonej kultury są dynamiczne i może ulec zmianie. Oznacza to, że Określ analizy operacji, które są zależne od Konwencji formatowania (bieżącej) kultury domyślnej lub że <xref:System.IFormatProvider> obiekt, który reprezentuje kulturę, innym niż niezmiennej kultury może nieoczekiwanie się nie powieść dowolną z następujących sytuacji:  
>   
> -   Dane specyficzne dla kultury został zmieniony między wersjami mniejszym lub większym stopniu programu .NET Framework lub w wyniku aktualizacji do istniejącej wersji programu .NET Framework.  
> -   Dane specyficzne dla kultury odzwierciedlają preferencje użytkownika, które mogą się różnić od innego komputera lub sesjami.  
> -   Dane specyficzne dla kultury reprezentuje kulturę zastępczy, który zastępuje ustawienia standardowej kultury i kultury niestandardowej.  
>   
>  Aby zapobiec trudności podczas analizowania danych oraz czasu ciągów, które są skojarzone z zmiany w danych kultury, ciągów daty i godziny można analizować przy użyciu niezmiennej kultury, lub możesz wywołać <xref:System.DateTime.ParseExact%2A> lub <xref:System.DateTime.TryParseExact%2A> metody i określenia dokładnego formatu ciąg, który ma być analizowany. Czy są serializacja i Deserializacja danych daty i godziny, możesz użyć konwencji formatowania kultury niezmiennej, mogą serializacji i deserializacji <xref:System.DateTime> wartość w formacie binarnym.  
>   
>  Aby uzyskać więcej informacji, zobacz sekcję "dynamiczne dane kultury" w <xref:System.Globalization.CultureInfo> tematu i "wartości daty/godziny Persisting" sekcji <xref:System.DateTime> tematu.  
  
<a name="Styles"></a>   
### <a name="parsing-and-style-elements"></a>Analizowanie i elementy stylu  
 Wszystkie <xref:System.DateTime.Parse%2A> przeciążenia Ignoruj wiodących wewnętrzne i końcowe białe znaki do ciągu wejściowego (reprezentowany przez `s` w poniższej tabeli). Daty i godziny może być oddzielona z parą początkowe i końcowe znaki ZNAKIEM numeru ("#", U + 0023) i może być trailed przy użyciu jednego lub więcej wartości NULL (U + 0000).  
  
 Ponadto <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> przeciążenie ma `styles` parametr, który składa się z co najmniej jednego członka z <xref:System.Globalization.DateTimeStyles> wyliczenia. Ten parametr określa sposób `s` powinno być interpretowane i jak należy przekonwertować udanej operacji analizy `s` datę i godzinę. W poniższej tabeli opisano wpływ każdego <xref:System.Globalization.DateTimeStyles> elementu członkowskiego w operacji analizy.  
  
|Element członkowski DateTimeStyles|Wpływ na konwersji|  
|---------------------------|--------------------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC, w następujący sposób:<br /><br /> -Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość Czasem UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.<br />-Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.<br />-We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Ta wartość jest ignorowana. Wewnętrzny biały znak jest dozwolone w elementach daty i godziny zawsze `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Ta wartość jest ignorowana. Wiodący biały znak zawsze jest dozwolona w elementach daty i godziny `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Ta wartość jest ignorowana. Końcowe białe jest zawsze dozwolona w elementach daty i godziny `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki. Jest to zachowanie domyślne. Nie można zastąpić poprzez dostarczanie bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wartości wyliczenia, takie jak <xref:System.Globalization.DateTimeStyles.None>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie ma zakłada, że wszystkie informacje o strefie czasowej czasu lokalnego. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie ma zakłada, że wszystkie informacje o strefie czasowej UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.None>|Choć ważna, wartość ta jest ignorowana.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje konwersji ciągu daty i godziny, aby zapobiec <xref:System.DateTime> wartość, która reprezentuje czas lokalny z jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Zazwyczaj taki ciąg jest tworzony przez wywołanie <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metody i przy użyciu specyfikatora formatu standardowego "o", "r" lub "u".|  

<a name="kind"></a>   
### <a name="the-return-value-and-datetimekind"></a>Wartość zwracana i DateTime.Kind

`DateTime.Parse` Przeciążenia zwrócenia <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind> właściwość zawiera informacje o strefie czasowej. Można wskazać, że czas jest:

- Uniwersalny czas koordynowany (<xref:System.DateTimeKind.Utc?displayProperty=fullName>).
- Czas w lokalnej strefie czasowej (<xref:System.DateTimeKind.Local?displayProperty=fullName>).
- Czas w Nieznana strefa czasowa (xref:System.DateTimeKind.Unspecified?displayProperty=fullName >).
 
 Ogólnie rzecz biorąc <xref:System.DateTime.Parse%2A> metoda zwraca <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jednak <xref:System.DateTime.Parse%2A> metoda może także przeprowadzić konwersję strefę czasową oraz ustaw wartość <xref:System.DateTime.Kind%2A> właściwość różnie w zależności od wartości `s` i `styles` parametry:  
  
|IF|Konwersji strefy czasowej|Właściwość Kind|  
|--------|--------------------------|-------------------|  
|`s` zawiera informacje o strefie czasowej.|Data i godzina jest konwertowana na czas w lokalnej strefie czasowej.|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|`s` zawiera informacje o strefie czasowej, i `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagi.|Data i godzina jest konwertowana na uniwersalny czas koordynowany (UTC).|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`s` zawiera oznaczenie strefy czasowej Z lub czasu GMT i `styles` obejmuje <xref:System.Globalization.DateTimeStyles.RoundtripKind> flagi.|Data i godzina są interpretowane jako czas UTC.|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
  
 Poniższy przykład konwertuje ciągi daty, które zawierają informacje o strefie czasowej na czas w lokalnej strefie czasowej:  
  
 [!code-csharp-interactive[System.DateTime.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse2.cs#2)]
 [!code-vb[System.DateTime.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse2.vb#2)]  

  Można również zachowania wartości daty i czasu <xref:System.DateTime.Kind%2A> właściwości podczas formatowania i analizowania operacji za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi. W poniższym przykładzie pokazano sposób, w jaki <xref:System.Globalization.DateTimeStyles.RoundtripKind> flaga ma wpływ operacji analizowania na <xref:System.DateTime> wartości, które są konwertowane na ciągi przy użyciu specyfikatora formatu "o", "r" lub "u".  
  
 [!code-csharp-interactive[System.DateTime.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse5.cs#5)]
 [!code-vb[System.DateTime.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse5.vb#5)]  
  
### Examples

Liczne przykłady, które wywołują `DateTime.Parse` metoda rozmieszczonymi w [uwagi](#remarks) sekcji tego artykułu, w dokumentacji dotyczącej poszczególnych `DateTime.Parse` przeciążenia.

[!INCLUDE[interactive-note](~/includes/csharp-interactive-with-utc-note.md)]

Możesz również pobrać kompletny zestaw `DateTime.Parse` przykłady, które są zawarte w [projektu .NET Core 2.0 dla języka C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/DateTime.Parse.zip) i [projektu .NET Core 2.0 dla języka Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/DateTime.Parse.zip), z [dotnet / repozytorium GitHub Samples](https://github.com/dotnet/samples).

 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
        <altmember cref="Overload:System.DateTime.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; DateTime" Usage="System.DateTime.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg można przeanalizować](#StringToParse) Aby uzyskać więcej informacji.</param>
        <summary>Konwertuje ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne przy użyciu konwencji bieżącej kultury wątku.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Jeśli `s` zawiera informacje o strefie czasowej, Metoda ta zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> i konwertuje datę i godzinę w `s` na czas lokalny. W przeciwnym razie wykonuje bez konwersji strefy czasowej i zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.

To przeciążenie próbuje zanalizować `s` przy użyciu konwencji formatowania bieżącej kultury. Bieżąca kultura jest wskazywany przez <xref:System.Globalization.CultureInfo.CurrentCulture> właściwości. Aby przeanalizować ciąg przy użyciu konwencji formatowania określonej kultury, należy wywołać <xref:System.DateTime.Parse(System.String,System.IFormatProvider)> lub <xref:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)> przeciążenia.

To przeciążenie próbuje zanalizować `s` przy użyciu <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType> stylu.

## <a name="example"></a>Przykład

Poniższy przykład jest analizowany ciąg przedstawiając kilka wartości daty i godziny przez:

- Za pomocą domyślnego dostawcę formatu, który zapewnia konwencje formatowania bieżącej kultury wątku komputera używaną do generowania danych wyjściowych przykładu. Dane wyjściowe z tego przykładu odzwierciedla konwencje formatowania kultury en US.

- Użyta domyślna wartość stylu, który jest <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWIthType>. 

Obsługuje on <xref:System.FormatException> wyjątek, który jest generowany, gdy metoda podejmuje próbę przeanalizowania reprezentacji ciągu daty i godziny przy użyciu niektórych innych kultury użytkownika konwencje formatowania. Pokazano również, jak można pomyślnie przeanalizować wartości daty i godziny, która nie korzysta z Konwencji formatowania bieżącej kultury wątku.  
  
 [!code-csharp-interactive[System.DateTime.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.DateTime.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse1.vb#1)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> nie zawiera nieprawidłową reprezentacją ciągu daty i godziny.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg można przeanalizować](#StringToParse) Aby uzyskać więcej informacji.</param>
        <param name="provider">Obiekt, który dostarcza informacje specyficzne dla kultury formatu o <paramref name="s" />.  Zobacz [konwencje analizy i kultury](#Culture)</param>
        <summary>Konwertuje ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne przy użyciu informacji specyficznych dla kultury.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" /> zgodnie z określonym <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Jeśli `s` zawiera informacje o strefie czasowej, Metoda ta zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> i konwertuje datę i godzinę w `s` na czas lokalny. W przeciwnym razie wykonuje bez konwersji strefy czasowej i zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.

To przeciążenie próbuje zanalizować `s` przy użyciu <xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType> stylu.

## <a name="example"></a>Przykład

Poniższy przykład analizuje tablicę ciągów daty przy użyciu konwencji en US, fr-FR i kultur de-DE. Pokazuje, że ciągów reprezentujących pojedyncza Data może być interpretowana inaczej w różnych kulturach.  
  
[!code-csharp-interactive[System.DateTime.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse3.cs#3)]
[!code-vb[System.DateTime.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> nie zawiera nieprawidłową reprezentacją ciągu daty i godziny.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider = null, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional provider As IFormatProvider = null, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider, styles As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić. Zobacz [ciąg można przeanalizować](#StringToParse) Aby uzyskać więcej informacji.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <paramref name="s" />.  Zobacz [konwencje analizy i kultury](#Culture)</param>
        <param name="styles">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="s" /> dla analizy operacja została wykonana pomyślnie, a definiuje, jak interpretować przeanalizowaną datę w odniesieniu do bieżącej strefie czasowej lub daty bieżącej. To typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne przy użyciu informacji specyficznych dla kultury i styl formatowania.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" />, zgodnie z określonym <paramref name="provider" /> i <paramref name="styles" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Tego przeciążenia metody Konwertuje datę i godzinę w `s` i ustawia <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartości w następujący sposób:

|IF |Konwersji strefy czasowej|Właściwość Kind|   
|-----|-----|-----|  
|`s` zawiera informacje o strefie czasowej.|Brak.|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|
|`s` zawiera informacje o strefie czasowej.|Godzinę w lokalnej strefie czasowej|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|
|`s` zawiera informacje o strefie czasowej, i "zawiera style <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi.|Aby koordynowany uniwersalne godzina (UTC)|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|
|`s` zawiera oznaczenie strefy czasowej Z lub czasu GMT i `styles` obejmuje <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>.|Brak.|<xref:System.DateTimeKind.Utc>| 

## <a name="example"></a>Przykład

W poniższym przykładzie pokazano <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody i wyświetla wartość <xref:System.DateTime.Kind%2A> właściwość wynikowy <xref:System.DateTime> wartości.  
  
[!code-csharp-interactive[System.DateTime.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse4.cs#4)]
[!code-vb[System.DateTime.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> nie zawiera nieprawidłową reprezentacją ciągu daty i godziny.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-round-trip-date-and-time-values.md">Porady: obustronna konwersja wartości daty i godziny</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne. Format ciągu reprezentującego musi dokładnie pasować określonym formacie lub zostanie zgłoszony wyjątek.</summary>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="format">Specyfikator formatu, który definiuje wymagany format parametru <paramref name="s" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza informacje specyficzne dla kultury formatu o <paramref name="s" />.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> odpowiednika przy użyciu podanego formatu i informacji o formacie specyficzne dla kultury. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" />, zgodnie z określonym <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Metoda analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. Wymaga również, aby \<daty > i \<czas > elementy reprezentację ciągu daty i godziny są wyświetlane w kolejności określonej przez `format`oraz że `s` mają żadne inne białe innych niż dozwolone przez `format`. Jeśli `format` definiuje wartość typu date z żadnego elementu czasu i analizy operacja zakończy się powodzeniem, wynikowy <xref:System.DateTime> wartość ma czas od północy (00: 00:00). Jeśli `format` definiuje czas żaden element Data i analizy operacja zakończy się powodzeniem, wynikowy <xref:System.DateTime> wartość ma dzień `DateTime.Now.Date`.  
  
 Jeśli `s` nie reprezentują czas w określonej strefy czasowej i udanej operacji zakończy się powodzeniem, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli `s` reprezentują czas, w szczególności strefy czasowej i `format` umożliwia informacje o strefie czasowej obecności (na przykład, jeśli `format` jest równa "o", "r" lub specyfikatory formatu standardowego "u", lub jeśli zawiera "z", "zz" lub "zzz" specyfikatorów formatu niestandardowego) <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
 `format` Jest ciągiem, który zawiera jeden standardowy specyfikator formatu albo jednego lub więcej specyfikatorów formatu niestandardowego, które definiują wymagany format parametru `s`. Aby uzyskać szczegółowe informacje na temat prawidłowych kodów formatowania, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) lub [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
> [!NOTE]
>  Jeśli `format` to wzorzec formatu niestandardowego, który nie obejmują separatorów daty lub godziny (np. "yyyyMMddHHmm"), należy użyć niezmiennej kultury dla `provider` parametr i możliwie najszerszej formy dla każdego specyfikatora formatu. Na przykład jeśli chcesz określić godziny we wzorcu formatu, należy określić Użyj szerszej formy "Gg" zamiast węższej "H".  
  
 Określonej daty i godziny symbole i ciągi (takich jak nazwy dni tygodnia w danym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładny format `s` Jeśli `format` to standardowy format Specyfikator ciąg. `provider` Parametru może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę używaną do interpretacji parametru `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowanie w `s`.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> używany jest obiekt, który odpowiada bieżącej kulturze.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ParseExact%2A> metody.  
  
 [!code-csharp[System.DateTime.ParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/ParseExact1.cs#1)]
 [!code-vb[System.DateTime.ParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/ParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> lub <paramref name="format" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="s" /> nie zawiera datę i godzinę, która odnosi się do wzorca określonego w <paramref name="format" />.  
  
—lub— 
Składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie zgadza się.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza wyjątek <see cref="T:System.FormatException" /> ciąg można przeanalizować zawiera składnik godziny i oznaczenia AM/PM, które nie są w umowie. W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszych wersjach, oznaczenia AM/PM jest ignorowany.</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="format">Specyfikator formatu, który definiuje wymagany format parametru <paramref name="s" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <paramref name="s" />.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które zawiera dodatkowe informacje na temat <paramref name="s" />, temat elementy stylu, które mogą być obecne w <paramref name="s" />, lub o konwersji z <paramref name="s" /> do <see cref="T:System.DateTime" /> wartości. To typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> odpowiednika przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i stylu. Format ciągu reprezentującego musi dokładnie pasować określonego formatu lub jest zgłaszany wyjątek.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" />, zgodnie z określonym <paramref name="format" />, <paramref name="provider" />, i <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody jest analizowany ciąg przedstawiając daty, która musi być w formacie, który został zdefiniowany przez `format` parametru. Wymaga również, aby elementy daty i godziny w `s` są wyświetlane w kolejności określonej przez `format`. Jeśli `s` nie pasuje do wzorca z `format` parametrem żadnych zmian, zdefiniowane przez `style` parametr, metoda zgłasza <xref:System.FormatException>. Z kolei <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody jest analizowany ciąg przedstawiając datę w jednym z formatów rozpoznawany przez dostawcę formatu <xref:System.Globalization.DateTimeFormatInfo> obiektu. <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metoda umożliwia również elementy daty i godziny w `s` pojawią się w dowolnej kolejności.  
  
 Jeśli `s` parametr zawiera tylko godzina i data nie jest używane bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślną datę (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę i nie godziny, o północy (00: 00:00) jest używany. `style` Parametr określa również czy `s` parametru może zawierać wiodące, wewnętrzne lub końcowe białe znaki.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, jeśli to konieczne i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flaga nie Konwertuj uniwersalnego czasu koordynowanego (UTC) na czas lokalny i ustawienie <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `format` Parametr określa wymagany wzorzec `s` parametru. Może się składać z co najmniej jeden specyfikatorów formatu niestandardowego, z [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub jeden standardowy specyfikator formatu, który identyfikuje wzorzec wstępnie zdefiniowane z [standardowy format daty i Ciągi formatu godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, należy użyć niezmiennej kultury dla `provider` parametr i możliwie najszerszej formy dla każdego specyfikatora formatu. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
> [!NOTE]
>  Zamiast konieczności, `s` są zgodne z jednego formatu operacja analizy się powiodła, można wywołać <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metodę i określić wiele formatów dozwolonych. To sprawia, że operacja analizy, które najprawdopodobniej zakończyło się sukcesem.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenie, które określają, czy i gdzie biały znak Niezdefiniowany przez `format` może znajdować się w `s` i który precyzyjne sterowanie zachowaniem operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC. Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak Niezdefiniowany przez `format` mogą występować między wszystkie poszczególne elementem daty lub czasu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki niezdefiniowane przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas lokalny. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera godzinę bez informacji o dacie, Data zwracana wartość jest równa `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametru jest analizowany przy użyciu wartości domyślnych. Nie białe znaki niż ten w parametrze `format` jest dozwolone. Jeśli `s` nie ma składnika daty, Data zwracanego <xref:System.DateTime> wartość jest równa 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje uniknąć konwersji na <xref:System.DateTime> wartość daty i godziny przy użyciu jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
 Określonej daty i godziny symbole i ciągi (takich jak nazwy dni tygodnia w danym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładny format `s` Jeśli `format` to standardowy format Specyfikator ciąg. `provider` Parametru może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę używaną do interpretacji parametru `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowanie w `s`.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> używany jest obiekt, który odpowiada bieżącej kulturze.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29> metody. Należy pamiętać, że ciąg "5/01/2009 8:30:00" nie może zostać przeanalizowany pomyślnie po `styles` parametr ma wartość <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType> ponieważ spacje nie są dozwolone przez `format`. Ponadto ciąg "5/01/2009 09:00" nie można pomyślnie przeanalizować za pomocą `format` z "MM/dd/yyyyhh:mm", ponieważ ciąg daty nie poprzedza numer miesiąca z wiodącym zerem, jako `format` wymaga.  
  
 [!code-csharp[System.DateTime.ParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact2.cs#2)]
 [!code-vb[System.DateTime.ParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> lub <paramref name="format" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="s" /> nie zawiera datę i godzinę, która odnosi się do wzorca określonego w <paramref name="format" />.  
  
—lub— 
Składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie zgadza się.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza wyjątek <see cref="T:System.FormatException" /> ciąg można przeanalizować zawiera składnik godziny i oznaczenia AM/PM, które nie są w umowie. W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszych wersjach, oznaczenia AM/PM jest ignorowany.</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica dozwolone formaty <paramref name="s" />. Aby uzyskać więcej informacji, zobacz sekcję: Uwagi.</param>
        <param name="provider">Obiekt, który dostarcza informacje specyficzne dla kultury formatu o <paramref name="s" />.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca dozwolony format parametru <paramref name="s" />. To typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> odpowiednika przy użyciu określonej tablicy formatów, informacji o formacie specyficzne dla kultury i stylu. Format ciągu reprezentującego musi dokładnie co najmniej jednego ze wskazanych formatów lub zostanie zgłoszony wyjątek.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i godziny zawartej w elemencie <paramref name="s" />, zgodnie z określonym <paramref name="formats" />, <paramref name="provider" />, i <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody jest analizowany ciąg przedstawiając datę, która pasuje do jednej z wzorców przypisane do `formats` parametru. Jeśli ciąg `s` nie pasuje dowolny z tych wzorców dowolne zmiany, definiowane przez `styles` parametr, metoda zgłasza <xref:System.FormatException>. Oprócz porównanie `s` do wielu wzorców formatowania, zamiast do jednego wzorzec formatowania tego przeciążenia działa identycznie do <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody.  
  
 `s` Parametr zawiera datę i godzinę, które można przeanalizować. Jeśli `s` parametr zawiera tylko godzina i data nie jest używane bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślną datę (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę i nie godziny, o północy (00: 00:00) jest używany. `style` Parametr określa również czy `s` parametru może zawierać wiodące, wewnętrzne i końcowe białe znaki inne niż dozwolone przez jeden z ciągów formatu w `formats`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, jeśli to konieczne i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagę, aby nie Konwertuj uniwersalnego czasu koordynowanego (UTC) na czas lokalny i ustaw <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `formats` Parametr zawiera tablicę wzorców, z których jedna `s` musi być zgodna dokładnie tak, jeśli operacja analizy się powiodła się. Wzorce w `formats` parametru składa się z jednego lub więcej specyfikatorów formatu niestandardowego, z [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub jeden standardowy specyfikator formatu, który identyfikuje wzorzec wstępnie zdefiniowane z [Standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, należy użyć niezmiennej kultury dla `provider` parametr i możliwie najszerszej formy dla każdego specyfikatora formatu. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenie, które określają, czy i gdzie biały znak Niezdefiniowany przez `format` może znajdować się w `s` i który precyzyjne sterowanie zachowaniem operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC. Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak Niezdefiniowany przez `format` mogą występować między wszystkie poszczególne elementem daty lub czasu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki niezdefiniowane przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas lokalny. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera godzinę bez informacji o dacie, Data zwracana wartość jest równa `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametru jest analizowany przy użyciu wartości domyślnych. Nie białe znaki niż ten w parametrze `format` jest dozwolone. Jeśli `s` nie ma składnika daty, Data zwracanego <xref:System.DateTime> wartość jest równa 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje uniknąć konwersja na datę i godzinę przy użyciu jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
 Określonej daty i godziny symbole i ciągi (takich jak nazwy dni tygodnia w danym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładny format `s` Jeśli `format` to standardowy format Specyfikator ciąg. `provider` Parametru może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę używaną do interpretacji parametru `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowanie w `s`.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> używany jest obiekt, który odpowiada bieżącej kulturze.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metodę, aby upewnić się, że ciąg w wielu możliwych formatów może go pomyślnie przeanalizować.  
  
 [!code-csharp[System.Datetime.ParseExact#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact3.cs#3)]
 [!code-vb[System.Datetime.ParseExact#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> lub <paramref name="formats" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> jest ciągiem pustym.  
  
—lub— 
element <paramref name="formats" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="s" /> nie zawiera daty i godziny, który odpowiada żadnym elementem <paramref name="formats" />.  
  
—lub— 
Składnik godziny i oznaczenie AM/PM w <paramref name="s" /> nie zgadza się.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości. Na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <see cref="Overload:System.DateTime.ParseExact" /> metoda zgłasza wyjątek <see cref="T:System.FormatException" /> ciąg można przeanalizować zawiera składnik godziny i oznaczenia AM/PM, które nie są w umowie. W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszych wersjach, oznaczenia AM/PM jest ignorowany.</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="Second">
      <MemberSignature Language="C#" Value="public int Second { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Second" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Second" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Second As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Second { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Second : int" Usage="System.DateTime.Second" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik sekund daty reprezentowane przez to wystąpienie.</summary>
        <value>Składnik sekund wyrażony jako wartość z zakresu od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Second%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpecifyKind">
      <MemberSignature Language="C#" Value="public static DateTime SpecifyKind (DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime SpecifyKind(valuetype System.DateTime value, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SpecifyKind (value As DateTime, kind As DateTimeKind) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime SpecifyKind(DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="static member SpecifyKind : DateTime * DateTimeKind -&gt; DateTime" Usage="System.DateTime.SpecifyKind (value, kind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="value">Data i godzina.</param>
        <param name="kind">Jedna z wartości wyliczenia, które wskazuje, czy nowy obiekt reprezentuje czas lokalny, UTC lub żadnego z tych celów.</param>
        <summary>Tworzy nową <see cref="T:System.DateTime" /> obiekt, który ma taką samą liczbę taktów jako określony <see cref="T:System.DateTime" />, ale jest wyznaczona jako czas lokalny, uniwersalny czas koordynowany (UTC) lub żadnego z tych celów, wskazane przez określony <see cref="T:System.DateTimeKind" /> wartość.</summary>
        <returns>Nowy obiekt, który ma taką samą liczbę taktów jako obiekt reprezentowany przez <paramref name="value" /> parametru i <see cref="T:System.DateTimeKind" /> wartość określoną przez <paramref name="kind" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.DateTime> obiekt składa się z rodzaj pola, które wskazuje, czy wartość czasu opiera się na czas lokalny, uniwersalny czas koordynowany (UTC) lub żadna i pola Znaczniki, które zawiera wartość czasu mierzony w 100-nanosekundowych taktów. <xref:System.DateTime.SpecifyKind%2A> Metoda tworzy nowy <xref:System.DateTime> obiektu przy użyciu określonego `kind` parametru i oryginalne wartości czasu.  
  
> [!IMPORTANT]
>  Zwrócony <xref:System.DateTime> wartości nie reprezentuje takie same błyskawiczny w czasie, ponieważ `value` parametru i <xref:System.DateTime.SpecifyKind%2A> nie jest metodą konwersji strefy czasowej. Zamiast tego instalacja pozostawia w czasie określonym przez `value` parametru bez zmian i zestawów <xref:System.DateTime.Kind%2A> właściwość `kind`. Aby uzyskać informacji dotyczących konwersji strefy czasowej, zobacz [Konwertowanie godzin między strefami czasowymi](~/docs/standard/datetime/converting-between-time-zones.md).  
  
 <xref:System.DateTime.SpecifyKind%2A> Metodą jest przydatne w scenariuszach współpracy, sposób ich otrzymywania <xref:System.DateTime> obiektu z polem rodzaj nieokreślony, ale można określić przez niezależne od oznacza, że pole impulsów reprezentuje czas lokalny lub czasu UTC.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metodę, aby zademonstrować sposób, w jaki <xref:System.DateTime.Kind%2A> czynników właściwość <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">Współdziałanie COM w aplikacjach .NET Framework (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określoną godzinę lub czas trwania, z tym wystąpieniem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public TimeSpan Subtract (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan Subtract(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan Subtract(DateTime value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : DateTime -&gt; TimeSpan" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Wartość daty i czasu do odjęcia.</param>
        <summary>Odejmuje określoną datę i godzinę, z tym wystąpieniem.</summary>
        <returns>Przedział czasu, który jest taki sam, datę i czas reprezentowany przez to wystąpienie minus Data i godzina reprezentowana przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.DateTime%29> Metody określa różnicę między dwiema datami. Aby odjąć interwał czasu z bieżącego wystąpienia, należy wywołać <xref:System.DateTime.Subtract%28System.TimeSpan%29> metody. Aby odjąć przedział czasu określonego w bieżącym wystąpieniu, wywołaj metodę, która dodaje ten przedział czasu do bieżącej daty i podać wartość ujemną, jako argumentu metody. Na przykład na potrzeby odejmowania dwóch miesięcy od dnia, należy wywołać <xref:System.DateTime.AddMonths%28System.Int32%29> metoda o wartości od -2.  
  
 Jeśli jest wcześniejsza niż data i godzina bieżącego wystąpienia `value`, metoda zwraca <xref:System.TimeSpan> obiekt, który reprezentuje przedział czasu ujemna. Oznacza to, wartości wszystkich właściwości różna od zera (takie jak <xref:System.TimeSpan.Days%2A> lub <xref:System.TimeSpan.Ticks%2A>) ma wartość ujemną.  
  
 <xref:System.DateTime.Subtract%28System.DateTime%29> Metody nie należy wziąć pod uwagę wartości <xref:System.DateTime.Kind%2A> właściwości dwóch <xref:System.DateTime> wartości podczas przeprowadzania odejmowania. Przed odjęcie <xref:System.DateTime> obiektów, upewnij się, że obiekty reprezentują godziny w tej samej strefie czasowej. W przeciwnym razie wynik będzie zawierać różnica między strefami czasowymi.  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29?displayProperty=nameWithType> Metody należy wziąć pod uwagę różnice między strefami czasowymi podczas przeprowadzania odejmowania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> metody i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynik jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public DateTime Subtract (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Subtract(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Subtract(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : TimeSpan -&gt; DateTime" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje określonego czasu trwania z tego wystąpienia.</summary>
        <returns>Obiekt, który jest równy Data i godzina reprezentowana przez to wystąpienie pomniejszoną o przedział czasu, reprezentowane przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29> Metoda zwraca datę, która różnica interwału określonego czasu z bieżącego wystąpienia. Aby określić interwał czasu między dwiema datami, należy wywołać <xref:System.DateTime.Subtract%28System.DateTime%29> metody. Aby odjąć przedział czasu określonego w bieżącym wystąpieniu, wywołaj metodę, która dodaje ten przedział czasu do bieżącej daty i podać wartość ujemną, jako argumentu metody. Na przykład na potrzeby odejmowania dwóch miesięcy od dnia, należy wywołać <xref:System.DateTime.AddMonths%28System.Int32%29> metoda o wartości od -2.  
  
 Ta metoda nie zmienia wartość tego <xref:System.DateTime>. Zamiast tego zwraca nowy <xref:System.DateTime> którego wartość jest wynikiem tej operacji.  
  
 Zazwyczaj <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> metoda odejmuje <xref:System.TimeSpan> obiekt, który reprezentuje przedział czasu pozytywne i zwraca <xref:System.DateTime> wartość, która jest wcześniejsza niż data i godzina bieżącego wystąpienia. Jednak jeśli <xref:System.TimeSpan> obiekt reprezentuje przedział czasu ujemna, <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> metoda zwraca <xref:System.DateTime> wartość, która jest późniejsza niż data i godzina bieżącego wystąpienia.  
  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> Metoda umożliwia odjąć interwał czasu, który składa się z więcej niż jednej jednostki w okresach, takich jak (danego liczba godzin) i danej liczby minut. Aby odjąć pojedynczą jednostkę czasu (na przykład lat, miesięcy i dni) z <xref:System.DateTime> wystąpienia, można przekazać ujemną wartość liczbową jako parametr do żadnego z następujących metod:  
  
-   <xref:System.DateTime.AddYears%2A>, aby odjąć określoną liczbę lat od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddMonths%2A>, aby odjąć określoną liczbę miesięcy od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddDays%2A>, którą chcesz odjąć określoną liczbę dni od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddHours%2A>, którą chcesz odjąć określoną liczbę godzin od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddMinutes%2A>, aby odjąć określonej liczbie minut od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddSeconds%2A>, aby odjąć określonej liczbie sekund od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddMilliseconds%2A>, aby odjąć określoną liczbę milisekund od bieżącego wystąpienia daty i godziny.  
  
-   <xref:System.DateTime.AddTicks%2A>, aby odjąć określoną liczbę taktów z bieżącego wystąpienia daty i godziny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Subtract%2A> metody i operator odejmowania.  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynik jest mniejsza niż <see cref="F:System.DateTime.MinValue" /> lub większa niż <see cref="F:System.DateTime.MaxValue" />.</exception>
        <altmember cref="T:System.TimeSpan" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">Wykonywanie operacji arytmetycznych na wartościach dat i godzin</related>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Zwraca bieżącą <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Bieżący obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Żądany typ.</param>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Konwertuje aktualny <see cref="T:System.DateTime" /> obiektu do obiektu określonego typu.</summary>
        <returns>Obiekt o typie określonym przez <paramref name="type" /> parametru z wartością równoważne do bieżącego <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ta konwersja nie jest obsługiwana dla <see cref="T:System.DateTime" /> typu.</exception>
        <altmember cref="T:System.Convert" />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który implementuje <see cref="T:System.IFormatProvider" /> interfejsu. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Ta konwersja nie jest obsługiwana. Podjęto próbę użycia Ta metoda wyrzuca <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Nie jest używana zwracana wartość dla tego elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt używany do wypełniania danymi.</param>
        <param name="context">Miejsce docelowe dla serializacji. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z dane potrzebne do serializacji bieżącego <see cref="T:System.DateTime" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wypełni `info` parametrem <xref:System.DateTime.Ticks%2A> i <xref:System.DateTime.Kind%2A> wartości właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Ticks">
      <MemberSignature Language="C#" Value="public long Ticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Ticks" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Ticks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ticks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Ticks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Ticks : int64" Usage="System.DateTime.Ticks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaczników, które reprezentują datę i godzinę tego wystąpienia.</summary>
        <value>Liczba taktów, które reprezentują datę i godzinę tego wystąpienia. Wartość jest między <see langword="DateTime.MinValue.Ticks" /> i <see langword="DateTime.MaxValue.Ticks" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeden znacznik reprezentuje nanosekundach sto lub co 10 milionowych części sekundy. Istnieją 10 000 taktów milisekunda lub 10 milionów impulsów na sekundę.  
  
 Wartość tej właściwości reprezentuje liczbę 100-nanosekundowych interwałów, które upłynęły od północy 12:00:00, 1 stycznia 0001 (0: 00:00 UTC w dniu 1 stycznia 0001, w kalendarzu gregoriańskim), który reprezentuje <xref:System.DateTime.MinValue?displayProperty=nameWithType>. Nie ma liczbę znaczników, które są przypisane do leap sekund.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Ticks%2A> właściwości, aby wyświetlić liczbę znaczników, które upłynęły od początku wieku dwudziestego pierwszego, a do utworzenia wystąpienia <xref:System.TimeSpan> obiektu. <xref:System.TimeSpan> Obiekt jest następnie używany do wyświetlania czas za pomocą kilku odstępach czasu.  
  
 [!code-csharp[System.DateTime.Ticks#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Ticks/cs/Ticks.cs#1)]
 [!code-vb[System.DateTime.Ticks#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Ticks/vb/Ticks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeOfDay">
      <MemberSignature Language="C#" Value="public TimeSpan TimeOfDay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeOfDay" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.TimeOfDay" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfDay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeOfDay { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeOfDay : TimeSpan" Usage="System.DateTime.TimeOfDay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę dla tego wystąpienia.</summary>
        <value>Przedział czasu, który reprezentuje część dnia, który upłynął od północy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.DateTime.Date%2A> właściwości. Zwraca ona <xref:System.DateTime> wartość, która reprezentuje datę bez jego składnik czasu <xref:System.DateTime.TimeOfDay%2A> właściwość zwraca <xref:System.TimeSpan> wartość, która reprezentuje <xref:System.DateTime> składnik godziny wartości.  
  
 Jeśli chcesz wyświetlić porze dnia lub pobrać ciąg reprezentujący godzina dnia <xref:System.DateTime> wartość, możesz zamiast tego wywołania przeciążenia <xref:System.DateTime.ToString%2A> metody, która ma `format` parametr lub użyj [formatowania złożonego ](~/docs/standard/base-types/composite-formatting.md) funkcji przy użyciu ciągu formatu standardowego "T" lub "t".  
  
   
  
## Examples  
 Poniższy przykład wyświetla wartość <xref:System.DateTime.TimeOfDay%2A> właściwość tablicę <xref:System.DateTime> wartości. On również zachowanie różni się od wartości zwracanej ciągu zwracanego przez ciąg formatu standardowego "t" w operacji formatowania złożonego.  
  
 [!code-csharp[System.DateTime.TimeOfDay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.timeofday/cs/timeofday1.cs#1)]
 [!code-vb[System.DateTime.TimeOfDay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.timeofday/vb/timeofday1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="ToBinary">
      <MemberSignature Language="C#" Value="public long ToBinary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToBinary() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToBinary" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBinary () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToBinary();" />
      <MemberSignature Language="F#" Value="member this.ToBinary : unit -&gt; int64" Usage="dateTime.ToBinary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializuje bieżącego <see cref="T:System.DateTime" /> obiekt do 64-bitowych wartości binarnej, który później może służyć do odtworzenia <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>64-bitowa liczba całkowita ze znakiem koduje <see cref="P:System.DateTime.Kind" /> i <see cref="P:System.DateTime.Ticks" /> właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować wartość bieżącej <xref:System.DateTime> obiektu na wartość binarną. Później, należy użyć wartości binarne i <xref:System.DateTime.FromBinary%2A> metodę, aby odtworzyć, oryginalnym <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  W niektórych przypadkach <xref:System.DateTime> wartość zwrócona przez obiekt <xref:System.DateTime.FromBinary%2A> metoda nie jest taka sama jak oryginalne <xref:System.DateTime> wartość dostarczona do <xref:System.DateTime.ToBinary%2A> metody. Aby uzyskać więcej informacji zobacz następną sekcję "Ustawianie czasu lokalnego".  
  
## <a name="local-time-adjustment"></a>Ustawianie czasu lokalnego  
 Czas lokalny, który jest uniwersalny czas koordynowany dostosowana do lokalnej strefy czasowej, jest reprezentowane przez <xref:System.DateTime> struktury, której <xref:System.DateTime.Kind%2A> właściwość ma wartość <xref:System.DateTimeKind.Local>. Podczas przywracania lokalnym <xref:System.DateTime> wartości z reprezentacji binarnej, który jest wytwarzany przez <xref:System.DateTime.ToBinary%2A> metody <xref:System.DateTime.FromBinary%2A> metoda może dostosować taniego wartość tak, aby nie równa się oryginalna wartość. Taka sytuacja może wystąpić w następujących warunkach:  
  
-   Jeśli lokalny <xref:System.DateTime> serializowany jest obiekt w jednej strefie czasowej, <xref:System.DateTime.ToBinary%2A> metody, a następnie wykonać deserializacji w innej strefie czasowej, <xref:System.DateTime.FromBinary%2A> metody, czasu lokalnego, reprezentowany przez wartość wynikowa <xref:System.DateTime> obiekt jest automatycznie dostosowywany drugi strefę czasową.  
  
     Na przykład, rozważmy <xref:System.DateTime> obiekt, który reprezentuje czas lokalny o godzinie 3 Aplikacja, która jest wykonywana w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego używa <xref:System.DateTime.ToBinary%2A> metodę, aby przekonwertować który <xref:System.DateTime> obiektu na wartość binarną. Inna aplikacja, który jest wykonywany w Stanach Zjednoczonych Używa strefy czasowej wschodni <xref:System.DateTime.FromBinary%2A> metodę, aby przekonwertować wartość binarną na nową <xref:System.DateTime> obiektu. Wartość nowego <xref:System.DateTime> obiekt jest 18: 00, który reprezentuje tego samego punktu w czasie, co oryginalny P.M. 3 wartość, ale jest dostosowywana do czasu lokalnego w strefie czasowej wschodni.  
  
-   Jeśli reprezentacja binarna zmiennej lokalnej <xref:System.DateTime> wartość reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej systemu, na którym <xref:System.DateTime.FromBinary%2A> jest wywoływana, czas jest uwzględniany tak, że jest on prawidłowy.  
  
     Na przykład następuje przejście od czasu standardowego do czasu letniego w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego w dniu 14 marca 2010 r. o 2:00, kiedy czas jest przesuwany o jedną godzinę — na 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartości binarnej przez jest konwertowany ten zakres <xref:System.DateTime.ToBinary%2A> metody i następnie przywróceniu przez <xref:System.DateTime.FromBinary%2A> metody, pierwotna wartość jest dostosowywana do stają się prawidłową godzinę. Można określić, czy określoną wartość daty i godziny może podlegać modyfikacji przez przekazanie jej do <xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType> metody, jak pokazano na przykładzie.  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.DateTime> struktury składa się z prywatnego pola rodzaj, który wskazuje, czy wartość określonego czasu jest oparty na czas lokalny, uniwersalny czas koordynowany (UTC) lub żadna i pole private znaczniki, które zawiera liczbę 100-nanosekundowych znaczników, które Określ datę i godzinę. Pole impulsów jest możliwy za pomocą <xref:System.DateTime.Ticks%2A> właściwość i każde pole rodzaj jest możliwy za pomocą <xref:System.DateTime.Kind%2A> właściwości.  
  
 Przed programu .NET Framework 2.0, jeśli użytkownik Zserializowany <xref:System.DateTime> obiektu ręcznie, zamiast przy użyciu interfejsu serializacji, takich jak <xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>, potrzebna do serializowania danych taktów w <xref:System.DateTime> struktury. Począwszy od wersji 2.0, należy również serializować rodzaju danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.FromBinary(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="Today">
      <MemberSignature Language="C#" Value="public static DateTime Today { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Today" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Today" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Today As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Today { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Today : DateTime" Usage="System.DateTime.Today" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą datę.</summary>
        <value>Obiekt, który jest ustawiony na bieżącą datę przy użyciu składnika czas ustawiony na 00:00:00.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od programu .NET Framework w wersji 2.0, zwracana jest wartość <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość zwraca <xref:System.DateTimeKind.Local>.  
  
 Ponieważ zwraca bieżącą datę bez bieżący czas <xref:System.DateTime.Today%2A> właściwość jest odpowiedni do użytku w aplikacjach, współpracujących z tylko daty. Aby uzyskać więcej informacji, zobacz [Wybieranie pomiędzy DateTime, DateTimeOffset, TimeSpan i TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md). Z kolei <xref:System.DateTime.TimeOfDay%2A> właściwość zwraca bieżący czas bez bieżącą datę i <xref:System.DateTime.Now%2A> właściwość zwraca bieżącą datę i bieżący czas.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.Date%2A> właściwość, aby pobrać bieżącą datę. Ponadto przedstawiono sposób <xref:System.DateTime> wartość może być sformatowany przy użyciu niektóre standardowe ciągi daty i godziny formatu. Należy pamiętać, że dane wyjściowe generowane przez wywołanie trzeci <xref:System.DateTime.ToString%28System.String%29> metoda użyto specyfikatora formatu g obejmujący składnik czasu, który jest równy zero.  
  
 [!code-csharp[System.DateTime.Today#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Today/cs/Today1.cs#1)]
 [!code-vb[System.DateTime.Today#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Today/vb/Today1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Now" />
        <altmember cref="P:System.DateTime.TimeOfDay" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTime">
      <MemberSignature Language="C#" Value="public long ToFileTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTime () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTime();" />
      <MemberSignature Language="F#" Value="member this.ToFileTime : unit -&gt; int64" Usage="dateTime.ToFileTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na czas pliku Windows.</summary>
        <returns>Wartość bieżącego <see cref="T:System.DateTime" /> obiektu wyrażona jako czas pliku Windows.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 <xref:System.DateTime.ToFileTime%2A> Metoda używa <xref:System.DateTime.Kind%2A> właściwości, aby określić, czy bieżący <xref:System.DateTime> obiekt jest czasu lokalnego, czasu UTC lub nieokreślony czas, który jest traktowany jako czas lokalny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToFileTime%2A> metody.  
  
 [!code-cpp[DateTime.ToFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowy czas pliku reprezentuje datę i godzinę przed 12:00 w dniu 1 stycznia 1601 r. UTC.</exception>
        <block subset="none" type="usage"><para>Zazwyczaj <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> przywraca metoda <see cref="T:System.DateTime" /> wartość, która została zapisana przez <see cref="M:System.DateTime.ToFileTime" /> metody. Jednak te dwie wartości mogą się różnić w następujących warunkach: 
-Jeśli serializacji i deserializacji obiektu <see cref="T:System.DateTime" /> wartość występuje w różnych strefach czasowych. Na przykład jeśli <see cref="T:System.DateTime" /> wartość z godziny 12:30:00 w Stanach Zjednoczonych Strefy czasowej wschodni jest serializowana, a następnie wykonać deserializacji w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego, oryginalnym wartość 12:30:00 jest dostosowywana do 9:30:00 Aby uwzględnić różnicę między dwiema strefami czasowymi.  
  
-Jeśli <see cref="T:System.DateTime" /> wartość, która jest serializowana reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej. W tym przypadku <see cref="M:System.DateTime.ToFileTime" /> metoda dostosowuje przywróconej <see cref="T:System.DateTime" /> wartości, tak aby reprezentuje prawidłową godzinę w lokalnej strefie czasowej.  
  
Na przykład następuje przejście od czasu standardowego do czasu letniego w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego w dniu 14 marca 2010 r. o 2:00, kiedy czas jest przesuwany o jedną godzinę — na 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w wartość Liczba całkowita typu long, jest konwertowany ten zakres <see cref="M:System.DateTime.ToFileTime" /> metody i następnie przywróceniu przez <see cref="M:System.DateTime.FromFileTime(System.Int64)" /> metody, pierwotna wartość jest dostosowywana do stają się prawidłową godzinę. Można określić, czy określoną wartość daty i godziny może podlegać modyfikacji przez przekazanie jej do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, jak pokazano na przykładzie.  
  
[! code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [! kodu vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToFileTimeUtc" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTimeUtc">
      <MemberSignature Language="C#" Value="public long ToFileTimeUtc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTimeUtc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTimeUtc" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTimeUtc () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTimeUtc();" />
      <MemberSignature Language="F#" Value="member this.ToFileTimeUtc : unit -&gt; int64" Usage="dateTime.ToFileTimeUtc " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na czas pliku Windows.</summary>
        <returns>Wartość bieżącego <see cref="T:System.DateTime" /> obiektu wyrażona jako czas pliku Windows.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 <xref:System.DateTime.ToFileTimeUtc%2A> Metoda używa <xref:System.DateTime.Kind%2A> właściwości, aby określić, czy bieżący <xref:System.DateTime> obiekt jest czasu lokalnego, czasu UTC lub nieokreślony czas, który jest traktowany jako czas UTC. Jeśli czas lokalny, Konwertuje czas UTC przed przystąpieniem do wykonywania konwersji na czas pliku Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowy czas pliku reprezentuje datę i godzinę przed 12:00 w dniu 1 stycznia 1601 r. UTC.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToFileTimeUtc" /> Wykonanie konwersji czasu lokalnego na czas UTC, a następnie przywróć ją przez wywołanie metody jest czasami używana <see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" /> metody następuje <see cref="M:System.DateTime.ToLocalTime" /> metody. Jednak jeśli pierwotny czas reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej, dwie wartości czasu lokalnego nie będzie taki sam. Aby uzyskać więcej informacji, zobacz <see cref="M:System.DateTime.ToLocalTime" /> metody.</para></block>
        <altmember cref="M:System.DateTime.ToFileTime" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToLocalTime">
      <MemberSignature Language="C#" Value="public DateTime ToLocalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToLocalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLocalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLocalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToLocalTime();" />
      <MemberSignature Language="F#" Value="member this.ToLocalTime : unit -&gt; DateTime" Usage="dateTime.ToLocalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na czas lokalny.</summary>
        <returns>Obiekt którego <see cref="P:System.DateTime.Kind" /> właściwość jest <see cref="F:System.DateTimeKind.Local" />, i których wartość jest odpowiednikiem wartości bieżącego czasu lokalnego <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MaxValue" /> czy przekonwertowana wartość jest zbyt duży, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MinValue" /> czy przekonwertowana wartość jest zbyt mały, może być reprezentowana jako <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas lokalny jest równy czas uniwersalny czas koordynowany (UTC), a także przesunięcie czasu UTC. Aby uzyskać więcej informacji na temat przesunięcie czasu UTC, zobacz <xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>. Konwersja uwzględnia również regułę czasu letniego, która ma zastosowanie do czas reprezentowany przez bieżącą <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów <xref:System.DateTime.ToLocalTime%2A> metoda rozpoznaje tylko bieżącą regułę dopasowania podczas konwersji z czasu UTC na czas lokalny. W wyniku konwersji okresów przed bieżącą regułę dopasowania wprowadzenia może nie odzwierciedla precyzyjnie różnicę między czasem UTC i czasem lokalnym.  
  
 Począwszy od .NET Framework w wersji 2.0, wartość zwracana przez <xref:System.DateTime.ToLocalTime%2A> metoda jest określana przez <xref:System.DateTime.Kind%2A> właściwości bieżącego <xref:System.DateTime> obiektu. W poniższej tabeli opisano możliwe wyniki.  
  
|rodzaj|wyniki|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|To wystąpienie <xref:System.DateTime> jest konwertowana na czas lokalny.|  
|<xref:System.DateTimeKind.Local>|Konwersja nie jest wykonywane.|  
|<xref:System.DateTimeKind.Unspecified>|To wystąpienie <xref:System.DateTime> będzie traktowana jako czas UTC, i konwersja jest wykonywana jakby <xref:System.DateTime.Kind%2A> zostały <xref:System.DateTimeKind.Utc>.|  
  
> [!NOTE]
>  <xref:System.DateTime.ToLocalTime%2A> Konwertuje metody <xref:System.DateTime> wartość względem czasu UTC na czas lokalny. Aby przekonwertować wartość czasu w dowolnym wyznaczonym strefie czasowej na czas lokalny, należy użyć <xref:System.TimeZoneInfo.ConvertTime%2A?displayProperty=nameWithType> metody.  
  
 Wartość zwracana przez konwersję jest <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość zawsze zwraca <xref:System.DateTimeKind.Local>. W związku z tym, zwracany jest prawidłowy wynik nawet wtedy, gdy <xref:System.DateTime.ToLocalTime%2A> jest często stosowany do tej samej <xref:System.DateTime>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLocalTime%2A> metody. Należy pamiętać, że dokładne dane wyjściowe zależy od bieżącej kultury i lokalnej strefy czasowej systemu, na którym jest uruchomiona.  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metodę, aby zademonstrować sposób, w jaki <xref:System.DateTime.Kind%2A> czynników właściwość <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Możesz użyć <see cref="M:System.DateTime.ToLocalTime" /> metoda przywracania lokalne daty i wartości godziny, który został przekonwertowany na czas UTC przy <see cref="M:System.DateTime.ToUniversalTime" /> lub <see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" /> metody. Jednak jeśli pierwotny czas reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej, nie będzie ona zgodna z wartością przywróconej. Gdy <see cref="M:System.DateTime.ToLocalTime" /> metoda konwertuje godzinę w formacie UTC lokalnej strefy czasowej, również dostosowuje czas, więc to jest prawidłowa w lokalnej strefie czasowej.  
  
Na przykład następuje przejście od czasu standardowego do czasu letniego w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego w dniu 14 marca 2010 r. o 2:00, kiedy czas jest przesuwany o jedną godzinę — na 3:00:00. Ten interwał godzinowy jest nieprawidłowy, czyli jest to przedział czasu, który nie istnieje w danej strefie czasowej. W poniższym przykładzie pokazano, gdy czas, który mieści się w UTC, jest konwertowany ten zakres <see cref="M:System.DateTime.ToUniversalTime" /> metody i następnie przywróceniu przez <see cref="M:System.DateTime.ToLocalTime" /> metody, pierwotna wartość jest dostosowywana do stają się prawidłową godzinę. Można określić, czy określoną wartość daty i godziny może podlegać modyfikacji przez przekazanie jej do <see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" /> metody, jak pokazano na przykładzie.  
  
[! code-csharp[System.DateTime.ToLocalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolocaltime/cs/tolocaltime1.cs#1)] [! kodu vb[System.DateTime.ToLocalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolocaltime/vb/tolocaltime1.vb#1)]</para></block>
        <altmember cref="T:System.TimeZone" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.TimeZone.GetDaylightChanges(System.Int32)" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
      </Docs>
    </Member>
    <Member MemberName="ToLongDateString">
      <MemberSignature Language="C#" Value="public string ToLongDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongDateString();" />
      <MemberSignature Language="F#" Value="member this.ToLongDateString : unit -&gt; string" Usage="dateTime.ToLongDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważne daty długiej.</summary>
        <returns>Ciąg, który zawiera daty długiej ciąg reprezentujący bieżącą <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest formatowana przy użyciu wzorca określonego przez <xref:System.Globalization.DateTimeFormatInfo.LongDatePattern%2A> właściwości skojarzonej z bieżącą kulturą wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "D" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Ciąg zwracany przez <xref:System.DateTime.ToLongDateString%2A> metodą jest uwzględniana kultura. Odzwierciedla wzorca określonego przez bieżącą kulturę <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US, wzorzec daty długiej standard to "dddd, MMMMdd, yyyy"; dla kultury de-DE to "dddd, d. MMMMyyyy"; dla kultury ja-JP, to "yyyy"? " M "?" d'? ' ". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowego daty długiej.  
  
 Aby uzyskać więcej informacji na temat bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji dotyczących formatów znaków, wzorów i danych wyjściowych, utworzonych, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji o zmienianiu wzoru formatu skojarzonego z formatem znaku, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLongDateString%2A> metody.  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ToLongTimeString">
      <MemberSignature Language="C#" Value="public string ToLongTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToLongTimeString : unit -&gt; string" Usage="dateTime.ToLongTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważne dużo czasu.</summary>
        <returns>Ciąg zawierający reprezentację ciągu długi czas bieżący <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest formatowana przy użyciu wzorca określonego przez <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącą kulturą wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "T" [ciąg formatu standardowego daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Ciąg zwracany przez <xref:System.DateTime.ToLongTimeString%2A> metodą jest uwzględniana kultura. Odzwierciedla wzorca określonego przez <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A> właściwości bieżącej kultury <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US, wzorzec standardowa dużo czasu jest "ss tt"; dla kultury de-DE to "Hh: mm:"; dla kultury ja-JP jest "Ss". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowego dużo czasu.  
  
 Aby uzyskać więcej informacji na temat bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji dotyczących formatów znaków, wzorów i danych wyjściowych, utworzonych, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji o zmienianiu wzoru formatu skojarzonego z formatem znaku, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToLongTimeString%2A> metody.  
  
 [!code-csharp[System.DateTime.ToLongTimeString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolongtimestring/cs/sls.cs#1)]
 [!code-vb[System.DateTime.ToLongTimeString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolongtimestring/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ToOADate">
      <MemberSignature Language="C#" Value="public double ToOADate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 ToOADate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToOADate" />
      <MemberSignature Language="VB.NET" Value="Public Function ToOADate () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double ToOADate();" />
      <MemberSignature Language="F#" Value="member this.ToOADate : unit -&gt; double" Usage="dateTime.ToOADate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na równoważne daty automatyzacji OLE.</summary>
        <returns>Liczba zmiennoprzecinkowa podwójnej precyzji, która zawiera równoważne wartość tego wystąpienia daty automatyzacji OLE.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Daty automatyzacji OLE są zaimplementowane jako liczba zmiennoprzecinkowa, której integralny składnik to liczba dni przed lub po północy, 30 grudnia 1899, a których części ułamkowych reprezentuje czas danego dnia podzielona przez 24. Na przykład o północy, 31 grudnia 1899 jest reprezentowany przez 1.0; Godziny 6: 00, 1 stycznia 1900 jest reprezentowany przez 2,25; 29 grudnia 1899 północy, jest reprezentowane przez -1,0; i godzinie 6: 00, 29 grudnia 1899 jest reprezentowany przez-1.25.  
  
 Podstawowy OLE automatyzacji Data jest 30 grudnia 1899 północy. Minimalnej daty automatyzacji OLE jest północy 1 stycznia 0100. Maksymalna OLE automatyzacji Data jest taka sama jak <xref:System.DateTime.MaxValue?displayProperty=nameWithType>, ostatniej chwili 31 grudnia 9999 r.  
  
 <xref:System.DateTime.ToOADate%2A> Metoda zgłasza wyjątek <xref:System.OverflowException> Jeśli bieżące wystąpienie reprezentuje datę późniejszą niż <xref:System.DateTime.MinValue> i starszych niż o północy January1, 0100. Jednakże jeśli wartość bieżącego wystąpienia jest <xref:System.DateTime.MinValue>, metoda zwróci wartość 0.  
  
 Aby uzyskać więcej informacji na temat automatyzacji OLE, zobacz [biblioteki MSDN Library](https://go.microsoft.com/fwlink/?linkid=37118).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wartość tego wystąpienia nie może być reprezentowany jako datę automatyzacji OLE.</exception>
        <altmember cref="T:System.Double" />
        <altmember cref="M:System.DateTime.FromOADate(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ToShortDateString">
      <MemberSignature Language="C#" Value="public string ToShortDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortDateString();" />
      <MemberSignature Language="F#" Value="member this.ToShortDateString : unit -&gt; string" Usage="dateTime.ToShortDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważne daty krótkiej.</summary>
        <returns>Ciąg, który zawiera daty krótkiej ciąg reprezentujący bieżącą <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest formatowana przy użyciu wzorca określonego przez <xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącą kulturą wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "d" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Ciąg zwracany przez <xref:System.DateTime.ToShortDateString%2A> metodą jest uwzględniana kultura. Odzwierciedla wzorca określonego przez bieżącą kulturę <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład dla kultury en US "M/d/rrrr"; jest wzorzec daty krótkiej standardowe dla kultury de-DE to "dd. MM.yyyy"; dla kultury ja-JP to "yyyy/M/d". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowego daty krótkiej.  
  
 Aby uzyskać więcej informacji na temat bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji dotyczących formatów znaków, wzorów i danych wyjściowych, utworzonych, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji o zmienianiu wzoru formatu skojarzonego z formatem znaku, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToShortDateString%2A> metody. Ponadto pokazuje, że wyniku wywołania metody <xref:System.DateTime.ToShortDateString%2A> metody jest taka sama jak wywołania <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metody "d", jako parametr formatu.  
  
 [!code-csharp[System.DateTime.ToShortDateString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/cs/ToShortDateString.cs#1)]
 [!code-vb[System.DateTime.ToShortDateString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/vb/ToShortDateString.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ToShortTimeString">
      <MemberSignature Language="C#" Value="public string ToShortTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToShortTimeString : unit -&gt; string" Usage="dateTime.ToShortTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważne krótki czas.</summary>
        <returns>Ciąg, który zawiera krótki czas ciąg reprezentujący bieżącą <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest formatowana przy użyciu wzorca określonego przez <xref:System.Globalization.DateTimeFormatInfo.ShortTimePattern%2A?displayProperty=nameWithType> właściwości skojarzonej z bieżącą kulturą wątku. Zwracana wartość jest taka sama jak wartość zwracana przez określenie "t" [standardowy Ciąg formatujący DateTime](~/docs/standard/base-types/standard-date-and-time-format-strings.md) z <xref:System.DateTime.ToString%28System.String%29> metody.  
  
> [!IMPORTANT]
>  Ciąg zwracany przez <xref:System.DateTime.ToShortTimeString%2A> metodą jest uwzględniana kultura. Odzwierciedla wzorca określonego przez bieżącą kulturę <xref:System.Globalization.DateTimeFormatInfo> obiektu. Na przykład w przypadku kultury en US wzorzec standardowe godziny krótkiej jest "g: mm tt"; dla kultury de-DE to "Hh: mm"; dla kultury ja-JP jest "G: mm". Ciąg formatu określonego na określonym komputerze można również dostosować tak, aby różni się od ciągu formatu standardowego krótki czas.  
  
 Aby uzyskać więcej informacji na temat bieżącej kultury wątku, zobacz <xref:System.Threading.Thread.CurrentCulture%2A> właściwości. Aby uzyskać więcej informacji dotyczących formatów znaków, wzorów i danych wyjściowych, utworzonych, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md) tematu. Aby uzyskać więcej informacji o zmienianiu wzoru formatu skojarzonego z formatem znaku, zobacz <xref:System.Globalization.DateTimeFormatInfo> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToShortTimeString%2A> metody.  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dateTime.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu konwencji formatowania bieżącej kultury.</summary>
        <returns>Ciąg reprezentujący wartość bieżącej <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest sformatowana za pomocą ogólnego określonego dnia, specyfikator formatu godziny ("G"). Aby sformatować go przy użyciu określonej daty i godziny, specyfikator formatu, należy wywołać <xref:System.DateTime.ToString%28System.String%29> metody. Aby sformatować go przy użyciu ogólnych określonego dnia, specyfikator formatu godziny ("G") dla określonej kultury, należy wywołać <xref:System.DateTime.ToString%28System.IFormatProvider%29> metody. Aby sformatować go przy użyciu określonej daty i specyfikator formatu godziny i Konwencji określonej kultury, należy wywołać <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29> metody.  
  
 Metoda ta wykorzystuje informacje o formatowaniu pochodzące z bieżącej kultury. W szczególności łączy ciągi formatu niestandardowego zwracany przez <xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A> i <xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A> właściwości <xref:System.Globalization.DateTimeFormatInfo> obiektu zwróconego przez `Thread.CurrentThread.CurrentCulture.DateTimeFormat` właściwości. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>. Inne przeciążenia <xref:System.DateTime.ToString%2A> metody pozwalają na określenie kultury, której formatowanie do użycia i zdefiniowanie struktury danych wyjściowych <xref:System.DateTime> wartość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ciąg reprezentujący <xref:System.DateTime> wartość zwrócona przez obiekt <xref:System.DateTime.ToString> metoda zależy od bieżącej kultury wątku. Zmienia bieżącą kulturę wątku z en US na fr-FR, aby ja-JP. w każdym przypadku wywołania <xref:System.DateTime.ToString> metoda zwraca reprezentację ciągu wartości daty i godziny przy użyciu tej kultury.  
  
 [!code-csharp[System.DateTime.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.DateTime.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarz używany przez bieżącą kulturę. Jeśli wartość bieżącego <see cref="T:System.DateTime" /> wystąpienie jest wcześniejsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub późniejsza niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda zgłasza <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje sformatować datę, która jest poza zakresem <see cref="T:System.Globalization.HijriCalendar" /> klasy, gdy bieżącą kulturą jest arabski (Syria).  
  
[! code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception2.cs#2)] [! kodu vb[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception2.vb#2)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="dateTime.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważnego, korzystając z informacji zawartych w określonym formacie specyficzne dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość bieżącej <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bieżącego <xref:System.DateTime> obiektu jest formatowana przy użyciu ogólnych określonego dnia, specyfikator formatu godziny ("G"), które formatuje dane wyjściowe przy użyciu wzorca daty krótkiej i wzorzec dużo czasu.  
  
 Format daty krótkiej i wzorzec godziny długiej jest definiowany przez `provider` parametru. `provider` Parametru może być dowolną z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który reprezentuje kulturę, której konwencje formatowania mają zostać odzwierciedlone w zwracanym ciągu. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje formatowanie zwracanego ciągu.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> obiekt skojarzony z bieżącą kulturą jest używany. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład wyświetla reprezentację ciągu daty i godziny przy użyciu <xref:System.Globalization.CultureInfo> obiekty reprezentujące pięć różnych kultur.  
  
 [!code-csharp[System.DateTime.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString4.cs#3)]
 [!code-vb[System.DateTime.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez <paramref name="provider" />.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarz używany przez kulturę, reprezentowane przez <paramref name="provider" /> parametru. Jego kalendarz jest zdefiniowany przez <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącego <see cref="T:System.DateTime" /> wystąpienie jest wcześniejsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub późniejsza niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda zgłasza <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje sformatować datę, która jest poza zakresem <see cref="T:System.Globalization.JapaneseCalendar" /> klasy.  
  
[! code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception1.cs#1)] [! kodu vb[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception1.vb#1)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="dateTime.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowego lub niestandardowego daty i godziny.</param>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu podanego formatu i konwencje formatowania bieżącej kultury.</summary>
        <returns>Ciąg reprezentujący wartość bieżącej <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ToString%28System.String%29> Metoda zwraca ciąg reprezentujący wartość daty i godziny w określonym formacie, który używa konwencji formatowania bieżącej kultury; Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
 `format` Parametr musi zawierać albo pojedynczy znak specyfikatora formatu (zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub niestandardowy wzorzec formatu (zobacz [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ) definiuje formatowanie zwracanego ciągu. Jeśli `format` jest `null` lub pustym ciągiem, specyfikator formatu ogólnego, "G" jest używany.  
  
 Niektóre zastosowania tej metody obejmują:  
  
-   Wprowadzenie ciąg, który wyświetla datę i godzinę format godziny i daty krótkiej dla bieżącej kultury. Aby to zrobić, należy użyć specyfikatora formatu "G".  
  
-   Wprowadzenie ciąg, który zawiera tylko w miesiącu i roku. Aby to zrobić, należy użyć ciągu formatu "MM/yyyy". Ciąg formatu, który korzysta z bieżącej kultury, separator daty.  
  
-   Wprowadzenie ciąg, który zawiera datę i godzinę w określonym formacie. Na przykład "MM/dd/yyyyHH:mm" ciąg formatu zawiera ciąg daty i godziny w stałym formacie takich jak "19 2013 / / 03 / / 18:06". Używa ciągu formatu "/" jako separatora stałej dacie, niezależnie od ustawień specyficznych dla kultury.  
  
-   Wprowadzenie na datę w formacie skróconego, który może służyć do serializacji ciąg daty. Na przykład ciąg formatu "RRRRMMDD" przedstawia czterocyfrowy rok, następuje dwucyfrowy miesiąc i dzień dwucyfrowy bez separatorów daty.  
  
 W poniższym przykładzie użyto te trzy ciągi formatu, aby wyświetlić wartość daty i godziny przy użyciu konwencji kultury en US i fr-FR.  
  
 [!code-csharp[System.DateTime.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring5.cs#5)]
 [!code-vb[System.DateTime.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring5.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie użyto wszystkich standardowych ciągów daty i godziny format i wybór niestandardowych ciągów daty i godziny formatu, aby wyświetlić reprezentację ciągu <xref:System.DateTime> wartość. Bieżąca kultura wątku w przykładzie jest en US.  
  
 [!code-csharp[System.DateTime.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString2.cs#2)]
 [!code-vb[System.DateTime.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> 1 i nie jest jednym ze znaków specyfikatora formatu zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  
  
—lub— 
 <paramref name="format" /> nie zawiera prawidłowego wzoru formatu niestandardowego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.String)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarz używany przez bieżącą kulturę. Jeśli wartość bieżącego <see cref="T:System.DateTime" /> wystąpienie jest wcześniejsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub późniejsza niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda zgłasza <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje sformatować datę, która jest poza zakresem <see cref="T:System.Globalization.HebrewCalendar" /> klasy, gdy bieżącą kulturą jest hebrajski (Izrael).  
  
[! code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception3.cs#3)] [! kodu vb[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception3.vb#3)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="dateTime.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu standardowego lub niestandardowego daty i godziny.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu podanego formatu i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Ciąg reprezentujący wartość bieżącej <see cref="T:System.DateTime" /> obiekt określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametru może zawierać albo pojedynczy znak specyfikatora formatu (zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub niestandardowy wzorzec formatu (zobacz [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)). Jeśli `format` jest `null` ani być pustym ciągiem (""), specyfikator formatu standardowego "G" jest używany.  
  
 `provider` Parametr definiuje wzorzec, który odpowiada specyfikatory formatu standardowego, a także symboli i nazwy składników daty i godziny. `provider` Parametru może być dowolną z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który reprezentuje kulturę, której konwencje formatowania mają zostać odzwierciedlone w zwracanym ciągu. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje formatowanie zwracanego ciągu.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> skojarzone z bieżącej kultury jest używane. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto ciągi formatu czas standardowy format daty, aby wyświetlić ciąg reprezentujący datę i godzinę dla czterech różnych kultur.  
  
 [!code-csharp[System.DateTime.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring3.cs#4)]
 [!code-vb[System.DateTime.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring3.vb#4)]  
  
 W poniższym przykładzie pokazano różne sposoby formatowania <xref:System.DateTime> wartości przy użyciu niezmiennej <xref:System.Globalization.DateTimeFormatInfo>.  
  
 [!code-cpp[Classic DateTime.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DateTime.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic DateTime.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> 1 i nie jest jednym ze znaków specyfikatora formatu zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  
  
—lub— 
 <paramref name="format" /> nie zawiera prawidłowego wzoru formatu niestandardowego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez <paramref name="provider" />.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarz używany przez <paramref name="provider" /> parametru. Jego kalendarz jest zdefiniowany przez <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącego <see cref="T:System.DateTime" /> wystąpienie jest wcześniejsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub późniejsza niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda zgłasza <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje sformatować datę, która jest poza zakresem <see cref="T:System.Globalization.UmAlQuraCalendar" /> klasy.  
  
[! code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception4.cs#4)] [! kodu vb[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception4.vb#4)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: .NET Framework 4 formatowanie narzędzia</related>
      </Docs>
    </Member>
    <Member MemberName="ToUniversalTime">
      <MemberSignature Language="C#" Value="public DateTime ToUniversalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToUniversalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToUniversalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUniversalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToUniversalTime();" />
      <MemberSignature Language="F#" Value="member this.ToUniversalTime : unit -&gt; DateTime" Usage="dateTime.ToUniversalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącego <see cref="T:System.DateTime" /> obiektu do uniwersalnego czasu koordynowanego (UTC).</summary>
        <returns>Obiekt którego <see cref="P:System.DateTime.Kind" /> właściwość jest <see cref="F:System.DateTimeKind.Utc" />, i których wartość jest odpowiednikiem wartości bieżącego UTC <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MaxValue" /> czy przekonwertowana wartość jest zbyt duży, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu lub <see cref="F:System.DateTime.MinValue" />czy przekonwertowana wartość jest zbyt mały, aby mogły być reprezentowane przez <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uniwersalny czas koordynowany (UTC) jest równy czasowi lokalnemu minus przesunięcie czasu UTC. Aby uzyskać więcej informacji na temat przesunięcie czasu UTC, zobacz <xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>. Konwersja uwzględnia również regułę czasu letniego, która ma zastosowanie do czas reprezentowany przez bieżącą <xref:System.DateTime> obiektu.  
  
> [!IMPORTANT]
>  Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów <xref:System.DateTime.ToUniversalTime%2A> metoda rozpoznaje tylko bieżącą regułę dopasowania podczas konwertowania czasu lokalnego na UTC. W wyniku konwersji okresów przed bieżącą regułę dopasowania wprowadzenia może nie odzwierciedla precyzyjnie różnicę między czasem lokalnym i czasem UTC.  
  
 Począwszy od .NET Framework w wersji 2.0, wartość zwracana przez <xref:System.DateTime.ToUniversalTime%2A> metoda jest określana przez <xref:System.DateTime.Kind%2A> właściwości bieżącego <xref:System.DateTime> obiektu. W poniższej tabeli opisano możliwe wyniki.  
  
|rodzaj|wyniki|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|Konwersja nie jest wykonywane.|  
|<xref:System.DateTimeKind.Local>|Bieżący <xref:System.DateTime> obiekt jest konwertowany na czas UTC.|  
|<xref:System.DateTimeKind.Unspecified>|Bieżący <xref:System.DateTime> obiektu będzie traktowana jako czas lokalny i konwersja jest wykonywana jakby <xref:System.DateTime.Kind%2A> zostały <xref:System.DateTimeKind.Local>.|  
  
> [!NOTE]
>  <xref:System.DateTime.ToUniversalTime%2A> Konwertuje metody <xref:System.DateTime> wartości od czasu lokalnego do UTC. Aby przekonwertować wartość czasu w strefie czasowej niż lokalna względem czasu UTC, użyj <xref:System.TimeZoneInfo.ConvertTimeToUtc%28System.DateTime%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType> metody. Aby przekonwertować czasu, w których przesunięcie względem czasu UTC jest znana, użyj <xref:System.DateTimeOffset.ToUniversalTime%2A> metody.  
  
 Jeśli wystąpienie wartości daty i godziny jest niejednoznaczny czas, ta metoda zakłada, jest (czas standardowy). (Niejednoznaczny czas jest taki, który można mapować na czas standardowy lub do czasu letniego w lokalnej strefie czasowej) Jeśli wystąpienie wartości daty i godziny jest nieprawidłowy, ta metoda po prostu odejmuje czasu lokalnego z lokalnej strefy czasowej na przesunięcie czasu UTC do zwrócenia czasu UTC. (Nieprawidłowa godzina jest taki, który nie istnieje ze względu na stosowanie reguł dopasowania czasu letniego).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.ToUniversalTime%2A> metody.  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metodę, aby zademonstrować sposób, w jaki <xref:System.DateTime.Kind%2A> czynników właściwość <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToUniversalTime" /> Metoda jest czasami używana do konwersji czasu lokalnego na UTC. <see cref="M:System.DateTime.ToLocalTime" /> Następnie wywoływana jest metoda, aby przywrócić pierwotny czas lokalny. Jednak jeśli pierwotny czas reprezentuje nieprawidłową godzinę w lokalnej strefie czasowej, dwie wartości czasu lokalnego nie będzie taki sam. Aby uzyskać dodatkowe informacje i przykłady, zobacz <see cref="M:System.DateTime.ToLocalTime" /> metody.  
  
Na [!INCLUDE[winxp](~/includes/winxp-md.md)] systemów <see cref="M:System.DateTime.ToUniversalTime" /> metoda rozpoznaje tylko bieżącą regułę dopasowania dla lokalnej strefy czasowej, która dotyczy wszystkich dat, w tym niższego poziomu daty (czyli daty, które jest wcześniejsza niż data początkowa bieżącego korekty Reguła). Aplikacje działające na [!INCLUDE[winxp](~/includes/winxp-md.md)] wymagające w przeszłości dokładne lokalne daty i czasu obliczeń muszą obejść ten problem za pomocą <see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" /> metoda pobierania <see cref="T:System.TimeZoneInfo" /> obiekt, który odpowiada lokalnej strefy czasowej i wywoływania jego <see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" /> metody.  
  
Poniższy przykład ilustruje różnicę między <see cref="M:System.DateTime.ToUniversalTime" /> i <see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" /> metod [!INCLUDE[winxp](~/includes/winxp-md.md)] system w Stanach Zjednoczonych Strefa czasowa czasu pacyficznego. Pierwsze wywołania metody dwóch dotyczą datę w 2006 bieżącej reguły korekty strefy czasowej (w przypadku której zakończył obowiązywać w 2007). Przejście do czasu letniego w drugą niedzielę marca; zapewnia bieżącej reguły korekty regule, który był obowiązuje 2006, pod warunkiem przejścia do czasu letniego w pierwszej niedzieli kwietnia. Tylko trzecim wywołaniu metody dokładnie wykonuje tę datę historycznych i czasu konwersji.  
  
[! code-csharp[System.DateTime.ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.touniversaltime/cs/touniversaltime.cs#1)] [! kodu vb[System.DateTime.ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.touniversaltime/vb/touniversaltime.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToLocalTime" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="dateTime.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <altmember cref="Overload:System.DateTime.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <paramref name="s" />, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Jeśli konwersja nie powiedzie się <paramref name="s" /> parametr jest <see langword="null" />, jest pustym ciągiem (""), lub nie zawiera nieprawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metoda jest podobna do <xref:System.DateTime.Parse%28System.String%29?displayProperty=nameWithType> metody, chyba że <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29> metoda zgłasza wyjątku, jeśli konwersja nie powiedzie się.  
  
 Ciąg `s` jest analizowany przy użyciu informacji o formatowaniu zawartych w bieżącym <xref:System.Globalization.DateTimeFormatInfo> obiektu, który jest dostarczany niejawnie przez bieżącą kulturę wątku.  
  
 Ta metoda próbuje zignorować Nierozpoznane dane, jeśli to możliwe i wypełni brakujące dzień, miesiąc i rok informacji z bieżącą datą. Jeśli `s` zawiera tylko datę i krótkim czasie, Metoda ta zakłada, czas to 00:00 w dniu. Jeśli `s` zawiera składnik daty z dwucyfrowy rok, jest konwertowany na rok w bieżącego kalendarza bieżącej kultury, na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Wszystkie wiodące, wewnętrzne i końcowe biały znak w `s` jest ignorowana. Daty i godziny może być oddzielona z parą początkowe i końcowe znaki ZNAKIEM numeru ("#", U + 0023) i może być trailed przy użyciu jednego lub więcej wartości NULL (U + 0000).  
  
 Ponieważ <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> metoda podejmuje próbę przeanalizowania reprezentacji ciągu daty i godziny przy użyciu reguły formatowania bieżącej kultury, próby przeprowadzenia analizy określonego ciągu w różnych kulturach może zakończyć się niepowodzeniem lub zwracać różne wyniki. Jeśli określone format daty i godziny, zostanie przetworzona przez różnych ustawień regionalnych, użyj <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody lub jednego z przeciążeń <xref:System.DateTime.TryParseExact%2A> metody i podania specyfikatora formatu.  
  
 Jeśli `s` jest ciąg reprezentujący przestępnym dnia w roku przestępnym bieżący kalendarz, analizuje metoda `s` pomyślnie. Jeśli `s` jest ciąg reprezentujący dnia przestępnym w innych — rokiem przestępnym bieżącego kalendarza bieżącej kultury, operacja analizy zakończy się niepowodzeniem i metoda zwraca `false`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, `result` zawiera <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> gdy metoda ta zwraca. Jeśli ciąg, który ma być analizowany, zawiera informacje o strefie czasowej, `result` zawiera <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType> gdy metoda ta zwraca.  
  
   
  
## Examples  
 Poniższy przykład przekazuje liczbę ciągów daty i godziny do <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[System.DateTime.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.TryParse/cpp/datetime.tryparse1.cpp#1)]
 [!code-csharp[System.DateTime.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/TryParse1.cs#1)]
 [!code-vb[System.DateTime.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/TryParse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Formatowanie mają wpływ właściwości bieżącego <see cref="T:System.Globalization.DateTimeFormatInfo" /> obiektu, które domyślnie są uzyskiwane z **Opcje regionalne i językowe** w Panelu sterowania. <see cref="Overload:System.DateTime.TryParse" /> Metody mogą nieoczekiwanie zakończyć się niepowodzeniem i zwracać <see langword="False" /> Jeśli bieżące <see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" /> i <see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" /> właściwości są ustawiane na tę samą wartość.</para></block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Przykład: .NET Framework 4 formatowanie narzędzia</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <paramref name="s" />.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia, który definiuje sposób interpretowania przeanalizowaną datę w odniesieniu do bieżącej strefie czasowej lub daty bieżącej. To typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <paramref name="s" />, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Jeśli konwersja nie powiedzie się <paramref name="s" /> parametr jest <see langword="null" />, jest pustym ciągiem (""), lub nie zawiera nieprawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne przy użyciu informacji o określonym formacie specyficzne dla kultury i formatowania stylu i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metoda analizuje ciąg, który może zawierać informacje daty, godziny i strefy czasowej. Jest on podobny do <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, chyba że <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType> metoda zgłasza wyjątku, jeśli konwersja nie powiedzie się.  
  
 Ta metoda próbuje zignorować Nierozpoznane dane i analizy `s` całkowicie. Jeśli `s` zawiera godzinę, ale bez daty, metoda przez domyślne zastępuje bieżącą datę lub, jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault> flagi, zastępuje `DateTime.Date.MinValue`. Jeśli `s` zawiera wartość typu date, ale nie godziny 12:00 północ jest używany jako domyślny czas. Jeśli ma wartość typu date, ale jego składnik roku składa się z dwóch cyfr, jest konwertowany na rok w `provider` bieżący kalendarz parametru na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Wszystkie wiodące, wewnętrzne i końcowe białe znaki w `s` są ignorowane. Daty i godziny może być oddzielona z parą początkowe i końcowe znaki ZNAKIEM numeru ("#", U + 0023) i może być trailed przy użyciu jednego lub więcej wartości NULL (U + 0000).  
  
 Określone prawidłowe formaty daty i czasu elementów, tak jak nazwy oraz symbole używane w daty i godziny, są definiowane przez `provider` parametr, który może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę, której formatowanie jest używany w `s` parametru. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje formatowania użytego w `s`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który definiuje formatowania użytego w `s`.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Globalization.DateTimeFormatInfo> obiekt, który definiuje formatowania użytego w `s`.  
  
 Jeśli `provider` jest `null`, bieżąca kultura jest wykorzystywana.  
  
 Jeśli `s` jest ciąg reprezentujący przestępnym dnia w roku przestępnym bieżący kalendarz, analizuje metoda `s` pomyślnie. Jeśli `s` jest ciąg reprezentujący dzień przestępnym w innych — rokiem przestępnym w bieżącym kalendarzem obiektu `provider`udanej operacji zakończy się niepowodzeniem i metoda zwraca `false`.  
  
 `styles` Parametr określa dokładne interpretacji przeanalizowany ciąg oraz jak udanej operacji analizy należy go obsłużyć. Może to być jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenia, zgodnie z opisem w poniższej tabeli.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC. Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Choć ważna, wartość ta jest ignorowana. Wewnętrzny biały znak jest dozwolona w elementach daty i godziny `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Choć ważna, wartość ta jest ignorowana. Wiodący biały znak jest dozwolona w elementach daty i godziny `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Choć ważna, wartość ta jest ignorowana. Końcowe biały znak jest dozwolona w elementach daty i godziny `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki. Jest to zachowanie domyślne. Nie można zastąpić poprzez dostarczanie bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wartości wyliczenia, takie jak <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas lokalny. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.None>|Choć ważna, wartość ta jest ignorowana.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje konwersji ciągu daty i godziny, aby zapobiec <xref:System.DateTime> wartość z jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Zazwyczaj taki ciąg jest tworzony przez wywołanie <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatorów formatu standardowego "o", "r" lub "u".|  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metoda zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> chyba że `styles` flaga wskazuje, w przeciwnym razie. Jeśli `s` obejmuje strefy czasowej lub przesunięcia informacji o strefie czasowej <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metoda wykonuje żadnych konwersji czasu konieczne i zwraca jedną z następujących czynności:  
  
-   A <xref:System.DateTime> wartości, których data i godzina odzwierciedlają czas lokalny i których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
-   Lub, jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AdjustToUniversal> flagi <xref:System.DateTime> odpowiada których data i Godzina UTC i których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 To zachowanie można przesłonić przy użyciu <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagi.  
  
## <a name="parsing-custom-cultures"></a>Analizowanie niestandardowych kultur  
 Jeśli możesz przeanalizować ciąg daty i godziny, generowany dla kultury niestandardowej, należy użyć <xref:System.DateTime.TryParseExact%2A> zamiast metody <xref:System.DateTime.TryParse%2A> metodę, aby zwiększyć prawdopodobieństwo, że operacja analizy zostanie wykonane pomyślnie. Ciąg kultury niestandardowej daty i godziny może być skomplikowane i trudne do analizowania. <xref:System.DateTime.TryParse%2A> Metoda próbuje przeanalizować składni ciągu wzorami kilka niejawnych analizy, które może zakończyć się niepowodzeniem. Z kolei <xref:System.DateTime.TryParseExact%2A> metoda wymaga umożliwia jawne wyznaczanie wzorców dokładne analizy, które prawdopodobnie powiodą.  
  
 Aby uzyskać więcej informacji na temat niestandardowych kultur, zobacz <xref:System.Globalization.CultureAndRegionInfoBuilder?displayProperty=nameWithType> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.DateTime.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/tryparse2.cs#2)]
 [!code-vb[System.DateTime.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> nie jest prawidłowym <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  
  
—lub— 
 <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="provider" /> to kultura neutralna i nie można używać podczas operacji analizowania.</exception>
        <block subset="none" type="usage"><para>Formatowanie mają wpływ właściwości bieżącego <see cref="T:System.Globalization.DateTimeFormatInfo" /> obiektu, który jest dostarczany przez <paramref name="provider" /> parametru. <see cref="Overload:System.DateTime.TryParse" /> Metody mogą nieoczekiwanie zakończyć się niepowodzeniem i zwracać <see langword="False" /> Jeśli bieżące <see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" /> i <see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" /> właściwości są ustawiane na tę samą wartość.</para></block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> równoważne. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <altmember cref="Overload:System.DateTime.ParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę konwersji.</param>
        <param name="format">Wymagany format parametru <paramref name="s" />.</param>
        <param name="provider">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <paramref name="s" />.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które wskazują dozwolony format parametru <paramref name="s" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <paramref name="s" />, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <paramref name="s" /> lub <paramref name="format" /> parametr jest <see langword="null" />, to ciąg pusty lub nie zawiera daty i godziny, który odpowiada wzorcowi, określone w <paramref name="format" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> odpowiednika przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i stylu. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="s" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metoda analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. Jest on podobny do <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, chyba że <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metoda zgłasza wyjątku, jeśli konwersja nie powiedzie się.  
  
 `s` Parametr zawiera datę i godzinę, które można przeanalizować i musi być w formacie, zdefiniowane przez `format` parametru. Jeśli elementy daty, godziny i strefy czasowej są obecne w `s`, również musi znajdować się w kolejności określonej przez `format`. Jeśli `format` definiuje wartość typu date z żadnego elementu czasu i analizy operacja zakończy się powodzeniem, wynikowy <xref:System.DateTime> wartość ma czas od północy (00: 00:00). Jeśli `format` definiuje czas żaden element Data i analizy operacja zakończy się powodzeniem, wynikowy <xref:System.DateTime> wartość domyślna ma dzień `DateTime.Now.Date`, lub ma on dzień `DateTime.MinValue.Date` Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> flagi. `style` Parametr określa, czy `s` parametru może zawierać wiodące, wewnętrzne lub końcowe białe znaki.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli s zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, jeśli to konieczne i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagę, aby nie Konwertuj uniwersalnego czasu koordynowanego (UTC) na czas lokalny i ustaw <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `format` Parametr zawiera wzorzec, który odpowiada z oczekiwanym formatem `s` parametru. Wzorzec w `format` parametru składa się z jednego lub więcej specyfikatorów formatu niestandardowego, z [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub jeden standardowy specyfikator formatu, który identyfikuje wzorzec wstępnie zdefiniowane z [Standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, należy użyć niezmiennej kultury dla `provider` parametr i możliwie najszerszej formy dla każdego specyfikatora formatu. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
> [!NOTE]
>  Zamiast konieczności, `s` są zgodne z jednego formatu operacja analizy się powiodła, można wywołać <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metodę i określić wiele formatów dozwolonych. To sprawia, że operacja analizy, które najprawdopodobniej zakończyło się sukcesem.  
  
 Określonej daty i godziny symbole i ciągi (takich jak nazwy dni tygodnia w danym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładny format `s` Jeśli `format` to standardowy format Specyfikator ciąg. `provider` Parametru może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę używaną do interpretacji parametru `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowanie w `s`.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> używany jest obiekt, który odpowiada bieżącej kulturze.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenie, które określają, czy i gdzie biały znak Niezdefiniowany przez `format` może znajdować się w `s` i który precyzyjne sterowanie zachowaniem operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC. Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak Niezdefiniowany przez `format` mogą występować między wszystkie poszczególne elementem daty lub czasu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki niezdefiniowane przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas lokalny. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera godzinę bez informacji o dacie, Data zwracana wartość jest równa `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametru jest analizowany przy użyciu wartości domyślnych. Nie białe znaki niż ten w parametrze `format` jest dozwolone. Jeśli `s` nie ma składnika daty, Data zwracanego <xref:System.DateTime> wartość jest równa 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje uniknąć konwersji na <xref:System.DateTime> wartość z jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metody. Należy pamiętać, że ciąg "5/01/2009 8:30:00" nie może zostać przeanalizowany pomyślnie po `styles` parametr ma wartość <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType> ponieważ spacje nie są dozwolone przez `format`. Ponadto ciąg "5/01/2009 09:00" nie można pomyślnie przeanalizować za pomocą `format` z "MM/dd/yyyyhh:mm", ponieważ ciąg daty nie poprzedza numer miesiąca z wiodącym zerem, jako `format` wymaga.  
  
 [!code-csharp[System.DateTime.TryParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact1.cs#1)]
 [!code-vb[System.DateTime.TryParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> nie jest prawidłowym <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  
  
—lub— 
 <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <see cref="Overload:System.DateTime.TryParseExact" /> metoda zwraca <see langword="false" /> ciąg można przeanalizować zawiera składnik godziny i oznaczenia AM/PM, które nie są w umowie. W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszych wersjach, oznaczenia AM/PM jest ignorowany.</para></block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica dozwolone formaty <paramref name="s" />.</param>
        <param name="provider">Obiekt, który dostarcza informacje specyficzne dla kultury formatu o <paramref name="s" />.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca dozwolony format parametru <paramref name="s" />. To typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.DateTime" /> odpowiednikiem daty i godziny zawartej w wartości <paramref name="s" />, jeśli konwersja powiodła się, lub <see cref="F:System.DateTime.MinValue" /> Jeśli konwersja nie powiodła się. Jeśli konwersja nie powiedzie się <paramref name="s" /> lub <paramref name="formats" /> jest <see langword="null" />, <paramref name="s" /> lub jej elementu <paramref name="formats" /> jest ciągiem pustym ani format <paramref name="s" /> nie jest określony przez co najmniej jednym z wzorców formatu w <paramref name="formats" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określony ciąg reprezentujący datę i godzinę na jego <see cref="T:System.DateTime" /> odpowiednika przy użyciu określonej tablicy formatów, informacji o formacie specyficzne dla kultury i stylu. Format ciągu reprezentującego musi dokładnie co najmniej jednego ze wskazanych formatów. Metoda zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="s" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> Metody jest analizowany ciąg przedstawiając datę, która pasuje do jednej z wzorców przypisane do `formats` parametru. Jest on podobny do <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.DateTime.TryParseExact%2A> metoda zgłasza wyjątku, jeśli konwersja nie powiedzie się.  
  
 `s` Parametr zawiera datę i godzinę, które można przeanalizować. Jeśli `s` parametr zawiera tylko godzina i data nie jest używane bieżącą datę, chyba że `style` zawiera parametr <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> Flaga, w którym to przypadku domyślną datę (`DateTime.Date.MinValue`) jest używany. Jeśli `s` parametr zawiera tylko datę i nie godziny, o północy (00: 00:00) jest używany. `style` Parametr określa również czy `s` parametru może zawierać wiodące, wewnętrzne i końcowe białe znaki inne niż dozwolone przez jeden z ciągów formatu w `formats`.  
  
 Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> Flaga, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, lub za pomocą <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, która zwraca <xref:System.DateTime> wartości, których <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli s zawiera informacje o strefie czasowej, godzina jest konwertowana na czas lokalny, jeśli to konieczne i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. To zachowanie można zmienić za pomocą <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType> flagę, aby nie Konwertuj uniwersalnego czasu koordynowanego (UTC) na czas lokalny i ustaw <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 `formats` Parametr zawiera tablicę wzorców, z których jedna `s` musi być zgodna dokładnie tak, jeśli operacja analizy się powiodła się. Wzorce w `formats` parametru składają się z jednego lub więcej specyfikatorów formatu niestandardowego, z [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) tabeli lub jeden standardowy specyfikator formatu, który identyfikuje wzorzec wstępnie zdefiniowane z [Standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) tabeli.  
  
 Jeśli nie używasz separatorów daty lub godziny we wzorcu formatu niestandardowego, należy użyć niezmiennej kultury dla `provider` parametr i możliwie najszerszej formy dla każdego specyfikatora formatu. Jeśli chcesz określić na przykład godziny we wzorcu, użyj szerszej formy „GG” zamiast węższej „G”.  
  
 Określonej daty i godziny symbole i ciągi (takich jak nazwy dni tygodnia w danym języku) używane w `s` są definiowane przez `provider` parametru, ponieważ jest dokładny format `s` Jeśli `format` to standardowy format Specyfikator ciąg. `provider` Parametru może być dowolną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę używaną do interpretacji parametru `s`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowanie w `s`.  
  
-   Element <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format danych daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca albo <xref:System.Globalization.CultureInfo> obiektu lub <xref:System.Globalization.DateTimeFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> używany jest obiekt, który odpowiada bieżącej kulturze.  
  
 `styles` Parametr zawiera jeden lub więcej członków <xref:System.Globalization.DateTimeStyles> wyliczenie, które określają, czy i gdzie biały znak Niezdefiniowany przez `format` może znajdować się w `s` i który precyzyjne sterowanie zachowaniem operacji analizy. W poniższej tabeli opisano, jak każdy członek <xref:System.Globalization.DateTimeStyles> wyliczenie ma wpływ na działanie <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29> metody.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `s` oraz, w razie potrzeby konwertuje go na UTC. Jeśli `s` zawiera przesunięcie strefy czasowej, lub jeśli `s` nie zawiera żadnych informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType> flagi, metoda analizowania ciągu wywołuje <xref:System.DateTime.ToUniversalTime%2A> do konwersji zwracanej <xref:System.DateTime> wartość na czas UTC i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. Jeśli `s` wskazuje, że reprezentuje UTC, lub jeśli `s` nie zawiera informacji o strefie czasowej, ale `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> flagi, metoda analizuje ciąg, wykonuje bez konwersji strefy czasowej na zwracanego <xref:System.DateTime> wartość i ustawia <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>. We wszystkich innych przypadkach flaga nie wywiera żadnego wpływu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Określa, że biały znak Niezdefiniowany przez `format` mogą występować między wszystkie poszczególne elementem daty lub czasu.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na początku `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Określa, że biały znak Niezdefiniowany przez `format` może znajdować się na końcu `s`.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Określa, że `s` może zawierać wiodące, wewnętrzne i końcowe białe znaki niezdefiniowane przez `format`.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas lokalny. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flaga jest obecny, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> wartość jest równa <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Określa, że jeśli `s` nie posiada żadnych informacji o strefie czasowej, zakłada się, reprezentuje czas UTC. Chyba że <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> flagi, Metoda ta konwertuje zwracane <xref:System.DateTime> wartość względem czasu UTC na czas lokalny i ustawia jego <xref:System.DateTime.Kind%2A> właściwość <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|Jeśli `s` zawiera godzinę bez informacji o dacie, Data zwracana wartość jest równa `DateTime.MinValue.Date`.|  
|<xref:System.Globalization.DateTimeStyles.None>|`s` Parametru jest analizowany przy użyciu wartości domyślnych. Nie białe znaki niż ten w parametrze `format` jest dozwolone. Jeśli `s` nie ma składnika daty, Data zwracanego <xref:System.DateTime> wartość jest równa 1/1/0001. Jeśli `s` nie zawiera żadnych informacji o strefie czasowej, <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jeśli informacje o strefie czasowej znajduje się w `s`, godzina jest konwertowana na czas lokalny i <xref:System.DateTime.Kind%2A> właściwości zwracanego <xref:System.DateTime> obiekt jest ustawiony na <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ciągi, które zawierają informacje o strefie czasowej, próbuje uniknąć konwersji na <xref:System.DateTime> wartość z jego <xref:System.DateTime.Kind%2A> właściwością <xref:System.DateTimeKind.Local?displayProperty=nameWithType>. Ta flaga zapobiega przede wszystkim konwersji czasu UTC na czas lokalny.|  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType> metodę, aby upewnić się, że ciąg w wielu możliwych formatów może go pomyślnie przeanalizować.  
  
 [!code-csharp[System.Datetime.TryParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact2.cs#2)]
 [!code-vb[System.Datetime.TryParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> nie jest prawidłowym <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  
  
—lub— 
 <paramref name="styles" /> zawiera nieprawidłową kombinację <see cref="T:System.Globalization.DateTimeStyles" /> wartości (na przykład zarówno <see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> i <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />).</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <see cref="Overload:System.DateTime.TryParseExact" /> metoda zwraca <see langword="false" /> ciąg można przeanalizować zawiera składnik godziny i oznaczenia AM/PM, które nie są w umowie. W [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] i wcześniejszych wersjach, oznaczenia AM/PM jest ignorowany.</para></block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">Analizowanie ciągów daty i godziny w programie .NET Framework</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
      </Docs>
    </Member>
    <Member MemberName="UnixEpoch">
      <MemberSignature Language="C#" Value="public static readonly DateTime UnixEpoch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime UnixEpoch" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.UnixEpoch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnixEpoch As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime UnixEpoch;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnixEpoch : DateTime" Usage="System.DateTime.UnixEpoch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcNow">
      <MemberSignature Language="C#" Value="public static DateTime UtcNow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime UtcNow" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.UtcNow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UtcNow As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime UtcNow { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcNow : DateTime" Usage="System.DateTime.UtcNow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> obiekt, który jest ustawiona na bieżącą datę i godzinę na tym komputerze, wyrażone jako uniwersalny czas koordynowany (UTC).</summary>
        <value>Obiekt, którego wartość jest bieżąca data i Godzina UTC.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozwiązania dla tej właściwości zależy od czasomierz systemowy, który jest zależny od zasadniczego systemu operacyjnego. Zwykle należeć do zakresu od 0,5 do 15 milisekund.

 Począwszy od programu .NET Framework w wersji 2.0, zwracana jest wartość <xref:System.DateTime> którego <xref:System.DateTime.Kind%2A> właściwość zwraca <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.

 Alternatywa dla użycia <xref:System.DateTime.UtcNow%2A> jest <xref:System.DateTimeOffset.UtcNow%2A?displayProperty=nameWithType>. Podczas pierwszej oznacza, że wartość daty i godziny jest uniwersalny czas koordynowany (UTC), przypisując <xref:System.DateTimeKind.Utc?displayProperty=nameWithType> do jego <xref:System.DateTime.Kind%2A> właściwość, jego przypisuje datę i przesunięcie czasu UTC wartość czasu (równe <xref:System.TimeSpan.Zero?displayProperty=nameWithType>).
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTime.SpecifyKind%2A> metodę, aby zademonstrować sposób, w jaki <xref:System.DateTime.Kind%2A> czynników właściwość <xref:System.DateTime.ToLocalTime%2A> i <xref:System.DateTime.ToUniversalTime%2A> metody konwersji.  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcNow" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="Year">
      <MemberSignature Language="C#" Value="public int Year { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Year" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Year" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Year As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Year { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Year : int" Usage="System.DateTime.Year" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik roku od daty reprezentowane przez to wystąpienie.</summary>
        <value>Rok od 1 do 9999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Year%2A> Właściwość zwraca rok z bieżącym wystąpieniem w kalendarzu gregoriańskim. Nie zwraca rok za pomocą kalendarz domyślny bieżącej kultury. Aby pobrać roku przy użyciu określonego kalendarza, można wywołać tego kalendarza `GetYear` metody, jak w poniższym kodzie.  
  
 [!code-csharp[System.DateTime.Year#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Year/cs/Year.cs#1)]
 [!code-vb[System.DateTime.Year#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Year/vb/Year.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.DateTime.Year%2A> właściwości.  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="AccessViolationException" FullName="System.AccessViolationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb360adfc3670886a06c5f3ab2daa2470318896a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30743789" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class AccessViolationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit AccessViolationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.AccessViolationException" />
  <TypeSignature Language="VB.NET" Value="Public Class AccessViolationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class AccessViolationException : SystemException" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyjątek zgłaszany, gdy jest próba odczytu lub zapisu chronione pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Naruszenie zasad dostępu występuje w kodu niezarządzanego lub niebezpieczny, gdy kod podejmuje próbę odczytu lub zapisu w pamięci, która nie została przydzielona, lub do których nie ma dostępu. Najczęstszą przyczyną wskaźnik ma nieprawidłowe wartości. Nie wszystkie zapisuje lub odczytuje za pośrednictwem nieprawidłowe wskaźniki prowadzić do naruszenia zasad dostępu, więc naruszenia zasad dostępu zwykle wskazuje, że wystąpiły kilka odczytów i zapisów przez nieprawidłowe wskaźniki i pamięci, może być uszkodzony. W związku z tym naruszenia zasad dostępu prawie zawsze wskazują poważne błędy programowania. <xref:System.AccessViolationException> Jasno identyfikuje tych błędów.  
  
 W programach składające się wyłącznie z weryfikowalny kod zarządzany wszystkie odwołania jest nieprawidłowy lub ma wartość null, a naruszenia zasad dostępu jest niemożliwe. Wszelkie operacje, który próbuje odwołać odwołanie o wartości null w zgłasza weryfikowalny kod <xref:System.NullReferenceException> wyjątku. <xref:System.AccessViolationException> Występuje tylko gdy weryfikowalny kod zarządzany wchodzi w interakcję z kodem niezarządzanym lub niebezpiecznego kodu zarządzanego.  
  
## <a name="troubleshooting-accessviolationexception-exceptions"></a>Rozwiązywanie problemów z wyjątkami accessviolationexception —  
 <xref:System.AccessViolationException> Wyjątek może wystąpić tylko w niebezpiecznego kodu zarządzanego lub gdy zarządzany weryfikowalny kod współdziała z kodem niezarządzanym:  
  
-   Naruszenia zasad dostępu występujący w niebezpieczny kod zarządzany może zostać wyrażona jako <xref:System.NullReferenceException> wyjątek lub <xref:System.AccessViolationException> wyjątku, w zależności od platformy.  
  
-   Naruszenia zasad dostępu za pomocą kodu niezarządzanego, które propaguje do kodu zarządzanego zawsze jest ujęte w <xref:System.AccessViolationException> wyjątku.  
  
 W obu przypadkach można zidentyfikować i rozwiązać przyczynę <xref:System.AccessViolationException> wyjątek w następujący sposób:  
  
 Upewnij się, przydzielono pamięci, który próbujesz uzyskać dostęp.  
 <xref:System.AccessViolationException> Jest zawsze wyjątek przy próbie uzyskania dostępu do chronionej pamięci — to znaczy, aby uzyskiwać dostęp do pamięci nie jest przydzielony ani nie posiada przez proces.  
  
 Automatyczne zarządzanie pamięcią jest jednym z usług, które udostępnia środowisko uruchomieniowe języka wspólnego. Kod zarządzany zapewnia te same funkcje co kodu unmanagede, warto przejdź do kodu zarządzanego, aby móc korzystać z tej funkcji. Aby uzyskać więcej informacji, zobacz [automatyczne zarządzanie pamięcią](~/docs/standard/automatic-memory-management.md).  
  
 Upewnij się, że są próby uzyskania dostępu do pamięci nie jest uszkodzony.  
 Jeśli kilka odczytu lub zapisu wystąpiły za pośrednictwem nieprawidłowe wskaźniki, pamięci może być uszkodzony. Ten błąd zazwyczaj występuje podczas odczytywania lub zapisywania adresów poza wstępnie zdefiniowanych buforu.  
  
## <a name="accessviolationexception-and-trycatch-blocks"></a>Bloki accessviolationexception — i try/catch  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.AccessViolationException> wyjątków zgłaszanych przez środowisko uruchomieniowe języka wspólnego nie są obsługiwane przez `catch` instrukcji programu obsługi wyjątków strukturalnych, jeśli wystąpi wyjątek poza pamięć zarezerwowana przez języka wspólnego środowisko uruchomieniowe. Do obsługi takich <xref:System.AccessViolationException> wyjątek, należy zastosować <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atrybut do metody jest wyjątek. Ta zmiana nie wpływa na <xref:System.AccessViolationException> wyjątków zgłaszanych przez kod użytkownika, które mogą w dalszym ciągu podlegać `catch` instrukcji. Dla kodu napisanego dla wcześniejszych wersji programu .NET Framework, która ma zostać ponownie skompilować i uruchomić bez żadnych modyfikacji na [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], możesz dodać [ \<legacycorruptedstateexceptionspolicy — >](~/docs/framework/configure-apps/file-schema/runtime/legacycorruptedstateexceptionspolicy-element.md) elementu do użytkownika plik konfiguracji aplikacji. Należy pamiętać, że można również odbierać powiadomienia wyjątki Jeśli zdefiniowano funkcję obsługi <xref:System.AppDomain.FirstChanceException?displayProperty=nameWithType> lub <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> zdarzeń.  
  
## <a name="version-information"></a>Informacje o wersji  
 Ten wyjątek w programie .NET Framework 2.0 i nowszych wersjach. We wcześniejszych wersjach programu .NET Framework, naruszenia zasad dostępu w kodu niezarządzanego lub niebezpieczny kod zarządzany jest reprezentowana przez <xref:System.NullReferenceException> w kodzie zarządzanym. A <xref:System.NullReferenceException> jest również element zgłaszany, gdy odwołanie o wartości null jest wyłuskiwany w kodzie zarządzanym weryfikowalny, wystąpienie, które nie obejmują uszkodzenia danych, a nie istnieje sposób odróżnienie dwie sytuacje, w wersji 1.0 lub 1.1.  
  
 Administratorzy mogą umożliwić wybranych aplikacji powrócić do zachowania programu .NET Framework w wersji 1.1. Umieść następujący wiersz w [ &lt;środowiska uruchomieniowego&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sekcji pliku konfiguracji aplikacji:  
  
```  
<legacyNullReferenceExceptionPolicy enabled = "1"/>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AccessViolationException" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AccessViolationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AccessViolationException" /> używając dostarczany przez system komunikatu opisującego błąd.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia dostarczony przez system komunikat, który opisuje błąd, takich jak "podjęto próbę odczytu lub zapisu pamięci chronionej. Jest to często wskazanie, że inna pamięć została uszkodzona." Ten komunikat uwzględnia bieżącą kulturę systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.AccessViolationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Zlokalizowany ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AccessViolationException(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje wyjątek. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AccessViolationException" /> klasy z określony komunikat zawierający opis błędu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.AccessViolationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Ciąg z komunikatem o określonych w `message`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AccessViolationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AccessViolationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Zawierający dane zserializowanego obiektu.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Zawierający informacje kontekstowe dotyczące źródła lub miejsca docelowego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AccessViolationException" /> z zserializowanymi danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML i serializacji SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AccessViolationException(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje wyjątek. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku. Jeśli <c>innerException</c> parametr nie jest <see langword="null" />, bieżący wyjątek jest zgłaszany w <see langword="catch" /> bloku, który obsługuje wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.AccessViolationException" /> z określonego komunikatu o błędzie i odwołania do wyjątek wewnętrzny będący przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek zgłaszany bezpośrednio w wyniku poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca tę samą wartość, która została przekazana do konstruktora, lub `null` Jeśli <xref:System.Exception.InnerException%2A> właściwości nie dostarcza do konstruktora wartości wyjątku wewnętrznego.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.AccessViolationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|Ciąg z komunikatem o określonych w `message`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
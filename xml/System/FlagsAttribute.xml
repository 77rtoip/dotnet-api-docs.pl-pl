<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b4a43daf94141e166fdacae6f0ba6f4be584c7b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30743753" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że wyliczenie może być traktowana jako pole bitowe; oznacza to, że zestaw flag.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pola bitowe są zazwyczaj używane do listę elementów, które mogą wystąpić w połączeniu, podczas gdy wyliczenie stałe są zazwyczaj używane do listy elementów wykluczają się wzajemnie. W związku z tym pól bitowych są przeznaczone do można łączyć z operacji lub do generowania wartości bez nazwy, nie są stałych wyliczeniowych. Języki różnią się w ich użyciem pól bitowych w porównaniu do wyliczenia stałe.  
  
## <a name="attributes-of-the-flagsattribute"></a>Atrybuty FlagsAttribute  
 <xref:System.AttributeUsageAttribute> jest stosowany do tej klasy, a jego <xref:System.AttributeUsageAttribute.Inherited%2A> określa właściwości `false`. Ten atrybut można stosować tylko do wyliczenia.  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>Wytyczne dotyczące FlagsAttribute i wyliczenia  
  
-   Użyj <xref:System.FlagsAttribute> atrybutu niestandardowego wyliczania tylko wtedy, gdy operacja bitowa (AND, OR wyłączne lub) ma zostać wykonane na wartość liczbową.  
  
-   Zdefiniuj wyliczenie stałe w potęgami liczby dwa, oznacza to, 1, 2, 4, 8 i tak dalej. Oznacza to, że indywidualne flagi w stałych Scalonej wyliczenia nie mogą się pokrywać.  
  
-   Należy rozważyć utworzenie wyliczany stała dla często używanych flagi kombinacji. Na przykład, jeśli masz wyliczenie używane dla operacji We/Wy pliku zawierającego stałych wyliczeniowych `Read = 1` i `Write = 2`, należy rozważyć utworzenie Stała wyliczeniowa `ReadWrite = Read OR Write`, który łączy `Read` i `Write` flagi. Ponadto używane do łączenia z flagami operacji lub może zostać uznane za zaawansowane koncepcji w pewnych okolicznościach, które nie powinny być wymagane dla prostych zadań.  
  
-   Należy zachować ostrożność, jeśli zdefiniować liczbą ujemną jako stała wyliczenia flag, ponieważ wielu pozycji flagi może być ustawiony na 1, co może zwiększyć mylące kodu i zachęca błędy kodowania.  
  
-   Jest to wygodny sposób sprawdzić, czy ustawiono flagę w wartość liczbową do wykonania operacji i między wartość liczbową i stała wyliczenia flagi, ustawiająca wszystkie bity w wartość liczbową na zero, które nie odpowiadają flagi , następnie sprawdzić, czy wynik tej operacji jest równa stała wyliczenia flagi.  
  
-   Użyj `None` jako nazwa flagi wyliczyć stała, którego wartość wynosi zero. Nie można użyć `None` stała wyliczenia w operacji i do testowania dla flagi, ponieważ wynik to zawsze zero. Jednak można wykonać operatorów logicznych, nie bitowe, porównania wartości liczbowych i `None` stała wyliczany można określić, czy wszystkie bity w wartość liczbową zostały ustawione.  
  
     Jeśli tworzysz wyliczenia wartości, zamiast wyliczenia flag, warto nadal można utworzyć `None` stała wyliczenia. Przyczyną jest to, że domyślnie pamięć używana na potrzeby wyliczenia ustawiana jest wartość zero przez środowisko uruchomieniowe języka wspólnego. W związku z tym jeśli nie zostanie zdefiniowana stałą, którego wartość wynosi zero, wyliczenia będzie zawierać niedozwoloną wartość, po jego utworzeniu.  
  
     Jeśli domyślny oczywisty przypadek aplikacji musi reprezentować, rozważ użycie stała wyliczenia, którego wartość wynosi zero, aby reprezentować wartość domyślna. Jeśli nie ma żadnych domyślne działanie case, należy rozważyć użycie stała wyliczenia, którego wartość wynosi zero, który oznacza przypadek, który nie jest reprezentowany przez żaden z innych stałych wyliczeniowych.  
  
-   Definiuje wartości wyliczenia wyłącznie w celu utworzenia duplikatów stan wyliczenia sam. Na przykład nie definiują wyliczany stałą, której jedynie oznacza koniec wyliczenia. Jeśli trzeba określić ostatniej wartości wyliczenia, sprawdź jawnie dla tej wartości. Ponadto można wykonać sprawdzania zakresu stała wyliczenia imię i nazwisko, jeśli wszystkie wartości w zakresie są prawidłowe.  
  
-   Nie określaj wyliczone stałe, które są zarezerwowane do użytku w przyszłości.  
  
-   Podczas definiowania metody lub właściwości, która ma stałą wyliczone jako wartość, należy wziąć pod uwagę sprawdzania poprawności wartości. Dzieje się tak można rzutować wartość liczbową na typ wyliczeniowy nawet, jeśli nie zdefiniowano wartości numerycznych w wyliczeniu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `FlagsAttribute` atrybutu i pokazuje wpływ na <xref:System.Enum.ToString%2A> przy użyciu metody `FlagsAttribute` na <xref:System.Enum> deklaracji.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 W poniższym przykładzie zdefiniowano dwa wyliczenia dotyczące kolorów `SingleHue` i `MultiHue`. Ma to drugie `FlagsAttribute` atrybutu; poprzednie nie. W przykładzie przedstawiono różnice w zachowaniu, gdy zakres liczb całkowitych, w tym liczby całkowite, które nie reprezentują wartości podstawowych typu wyliczenia są Rzutowanie na typ wyliczeniowy i ich oświadczenia ciąg wyświetlany.   Na przykład, należy pamiętać, że 3 nie może być reprezentowany jako `SingleHue` wartości, ponieważ 3 nie jest odpowiednia wartość dowolnego `SingleHue` elementu członkowskiego, natomiast `FlagsAttribute` atrybutu umożliwia reprezentują 3 jako `MultiHue` wartość `Black, Red`.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.FlagsAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie zdefiniowano `PhoneService` wyliczenie reprezentujące form komunikacji dostarczone przez firmę telefonu. Inicjuje trzy zmienne reprezentujący świadczoną na trzy różne domowych i wskazuje, które domowych mieć żadnej usługi, które domowych mają tylko telefon komórkowy usługi i które domowych zarówno telefonu komórkowego, jak i ziemi usługi wiersza. Na koniec niejawnie wywołuje <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> metodę, aby wyświetlić typy usługi dla każdego gospodarstwa domowego.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 Poniższy przykład przedstawia użycie `FlagsAttribute` atrybutu i pokazuje wpływ na <xref:System.Enum.ToString%2A> przy użyciu metody `FlagsAttribute` na <xref:System.Enum> deklaracji.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FlagsAttribute.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b4a43daf94141e166fdacae6f0ba6f4be584c7b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b4a43daf94141e166fdacae6f0ba6f4be584c7b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.FlagsAttribute">
          <source>Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</source>
          <target state="translated">Wskazuje, że wyliczenie może być traktowana jako pole bitowe; oznacza to, że zestaw flag.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</source>
          <target state="translated">Pola bitowe są zazwyczaj używane do listę elementów, które mogą wystąpić w połączeniu, podczas gdy wyliczenie stałe są zazwyczaj używane do listy elementów wykluczają się wzajemnie.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</source>
          <target state="translated">W związku z tym pól bitowych są przeznaczone do można łączyć z operacji lub do generowania wartości bez nazwy, nie są stałych wyliczeniowych.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Languages vary in their use of bit fields compared to enumeration constants.</source>
          <target state="translated">Języki różnią się w ich użyciem pól bitowych w porównaniu do wyliczenia stałe.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Attributes of the FlagsAttribute</source>
          <target state="translated">Atrybuty FlagsAttribute</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> is applied to this class, and its <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> property specifies <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> jest stosowany do tej klasy, a jego <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> określa właściwości <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This attribute can only be applied to enumerations.</source>
          <target state="translated">Ten atrybut można stosować tylko do wyliczenia.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Guidelines for FlagsAttribute and Enum</source>
          <target state="translated">Wytyczne dotyczące FlagsAttribute i wyliczenia</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use the <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> atrybutu niestandardowego wyliczania tylko wtedy, gdy operacja bitowa (AND, OR wyłączne lub) ma zostać wykonane na wartość liczbową.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</source>
          <target state="translated">Zdefiniuj wyliczenie stałe w potęgami liczby dwa, oznacza to, 1, 2, 4, 8 i tak dalej.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This means the individual flags in combined enumeration constants do not overlap.</source>
          <target state="translated">Oznacza to, że indywidualne flagi w stałych Scalonej wyliczenia nie mogą się pokrywać.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consider creating an enumerated constant for commonly used flag combinations.</source>
          <target state="translated">Należy rozważyć utworzenie wyliczany stała dla często używanych flagi kombinacji.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, if you have an enumeration used for file I/O operations that contains the enumerated constants <ph id="ph1">`Read = 1`</ph> and <ph id="ph2">`Write = 2`</ph>, consider creating the enumerated constant <ph id="ph3">`ReadWrite = Read OR Write`</ph>, which combines the <ph id="ph4">`Read`</ph> and <ph id="ph5">`Write`</ph> flags.</source>
          <target state="translated">Na przykład, jeśli masz wyliczenie używane dla operacji We/Wy pliku zawierającego stałych wyliczeniowych <ph id="ph1">`Read = 1`</ph> i <ph id="ph2">`Write = 2`</ph>, należy rozważyć utworzenie Stała wyliczeniowa <ph id="ph3">`ReadWrite = Read OR Write`</ph>, który łączy <ph id="ph4">`Read`</ph> i <ph id="ph5">`Write`</ph> flagi.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</source>
          <target state="translated">Ponadto używane do łączenia z flagami operacji lub może zostać uznane za zaawansowane koncepcji w pewnych okolicznościach, które nie powinny być wymagane dla prostych zadań.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</source>
          <target state="translated">Należy zachować ostrożność, jeśli zdefiniować liczbą ujemną jako stała wyliczenia flag, ponieważ wielu pozycji flagi może być ustawiony na 1, co może zwiększyć mylące kodu i zachęca błędy kodowania.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</source>
          <target state="translated">Jest to wygodny sposób sprawdzić, czy ustawiono flagę w wartość liczbową do wykonania operacji i między wartość liczbową i stała wyliczenia flagi, ustawiająca wszystkie bity w wartość liczbową na zero, które nie odpowiadają flagi , następnie sprawdzić, czy wynik tej operacji jest równa stała wyliczenia flagi.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use <ph id="ph1">`None`</ph> as the name of the flag enumerated constant whose value is zero.</source>
          <target state="translated">Użyj <ph id="ph1">`None`</ph> jako nazwa flagi wyliczyć stała, którego wartość wynosi zero.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>You cannot use the <ph id="ph1">`None`</ph> enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</source>
          <target state="translated">Nie można użyć <ph id="ph1">`None`</ph> stała wyliczenia w operacji i do testowania dla flagi, ponieważ wynik to zawsze zero.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>However, you can perform a logical, not a bitwise, comparison between the numeric value and the <ph id="ph1">`None`</ph> enumerated constant to determine whether any bits in the numeric value are set.</source>
          <target state="translated">Jednak można wykonać operatorów logicznych, nie bitowe, porównania wartości liczbowych i <ph id="ph1">`None`</ph> stała wyliczany można określić, czy wszystkie bity w wartość liczbową zostały ustawione.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a <ph id="ph1">`None`</ph> enumerated constant.</source>
          <target state="translated">Jeśli tworzysz wyliczenia wartości, zamiast wyliczenia flag, warto nadal można utworzyć <ph id="ph1">`None`</ph> stała wyliczenia.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</source>
          <target state="translated">Przyczyną jest to, że domyślnie pamięć używana na potrzeby wyliczenia ustawiana jest wartość zero przez środowisko uruchomieniowe języka wspólnego.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</source>
          <target state="translated">W związku z tym jeśli nie zostanie zdefiniowana stałą, którego wartość wynosi zero, wyliczenia będzie zawierać niedozwoloną wartość, po jego utworzeniu.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</source>
          <target state="translated">Jeśli domyślny oczywisty przypadek aplikacji musi reprezentować, rozważ użycie stała wyliczenia, którego wartość wynosi zero, aby reprezentować wartość domyślna.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</source>
          <target state="translated">Jeśli nie ma żadnych domyślne działanie case, należy rozważyć użycie stała wyliczenia, którego wartość wynosi zero, który oznacza przypadek, który nie jest reprezentowany przez żaden z innych stałych wyliczeniowych.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not define an enumeration value solely to mirror the state of the enumeration itself.</source>
          <target state="translated">Definiuje wartości wyliczenia wyłącznie w celu utworzenia duplikatów stan wyliczenia sam.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, do not define an enumerated constant that merely marks the end of the enumeration.</source>
          <target state="translated">Na przykład nie definiują wyliczany stałą, której jedynie oznacza koniec wyliczenia.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you need to determine the last value of the enumeration, check for that value explicitly.</source>
          <target state="translated">Jeśli trzeba określić ostatniej wartości wyliczenia, sprawdź jawnie dla tej wartości.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</source>
          <target state="translated">Ponadto można wykonać sprawdzania zakresu stała wyliczenia imię i nazwisko, jeśli wszystkie wartości w zakresie są prawidłowe.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not specify enumerated constants that are reserved for future use.</source>
          <target state="translated">Nie określaj wyliczone stałe, które są zarezerwowane do użytku w przyszłości.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>When you define a method or property that takes an enumerated constant as a value, consider validating the value.</source>
          <target state="translated">Podczas definiowania metody lub właściwości, która ma stałą wyliczone jako wartość, należy wziąć pod uwagę sprawdzania poprawności wartości.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</source>
          <target state="translated">Dzieje się tak można rzutować wartość liczbową na typ wyliczeniowy nawet, jeśli nie zdefiniowano wartości numerycznych w wyliczeniu.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">`FlagsAttribute`</ph> atrybutu i pokazuje wpływ na <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> przy użyciu metody <ph id="ph3">`FlagsAttribute`</ph> na <ph id="ph4">&lt;xref:System.Enum&gt;</ph> deklaracji.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example defines two color-related enumerations, <ph id="ph1">`SingleHue`</ph> and <ph id="ph2">`MultiHue`</ph>.</source>
          <target state="translated">W poniższym przykładzie zdefiniowano dwa wyliczenia dotyczące kolorów <ph id="ph1">`SingleHue`</ph> i <ph id="ph2">`MultiHue`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The latter has the <ph id="ph1">`FlagsAttribute`</ph> attribute; the former does not.</source>
          <target state="translated">Ma to drugie <ph id="ph1">`FlagsAttribute`</ph> atrybutu; poprzednie nie.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</source>
          <target state="translated">W przykładzie przedstawiono różnice w zachowaniu, gdy zakres liczb całkowitych, w tym liczby całkowite, które nie reprezentują wartości podstawowych typu wyliczenia są Rzutowanie na typ wyliczeniowy i ich oświadczenia ciąg wyświetlany.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, note that 3 cannot be represented as a <ph id="ph1">`SingleHue`</ph> value because 3 is not the underlying value of any <ph id="ph2">`SingleHue`</ph> member, whereas the <ph id="ph3">`FlagsAttribute`</ph> attribute makes it possible to represent 3 as a <ph id="ph4">`MultiHue`</ph> value of <ph id="ph5">`Black, Red`</ph>.</source>
          <target state="translated">Na przykład, należy pamiętać, że 3 nie może być reprezentowany jako <ph id="ph1">`SingleHue`</ph> wartości, ponieważ 3 nie jest odpowiednia wartość dowolnego <ph id="ph2">`SingleHue`</ph> elementu członkowskiego, natomiast <ph id="ph3">`FlagsAttribute`</ph> atrybutu umożliwia reprezentują 3 jako <ph id="ph4">`MultiHue`</ph> wartość <ph id="ph5">`Black, Red`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.FlagsAttribute.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example defines a <ph id="ph1">`PhoneService`</ph> enumeration that represents forms of communication provided by a telephone company.</source>
          <target state="translated">W poniższym przykładzie zdefiniowano <ph id="ph1">`PhoneService`</ph> wyliczenie reprezentujące form komunikacji dostarczone przez firmę telefonu.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</source>
          <target state="translated">Inicjuje trzy zmienne reprezentujący świadczoną na trzy różne domowych i wskazuje, które domowych mieć żadnej usługi, które domowych mają tylko telefon komórkowy usługi i które domowych zarówno telefonu komórkowego, jak i ziemi usługi wiersza.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>Finally, it implicitly calls the <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method to display the types of service provided to each household.</source>
          <target state="translated">Na koniec niejawnie wywołuje <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> metodę, aby wyświetlić typy usługi dla każdego gospodarstwa domowego.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">`FlagsAttribute`</ph> atrybutu i pokazuje wpływ na <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> przy użyciu metody <ph id="ph3">`FlagsAttribute`</ph> na <ph id="ph4">&lt;xref:System.Enum&gt;</ph> deklaracji.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
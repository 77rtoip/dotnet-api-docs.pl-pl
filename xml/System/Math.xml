<Type Name="Math" FullName="System.Math">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="970ae0c5f91215de9486dadb6303edc951885e7b" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911301" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia stałe i metod statycznych dla trygonometryczne logarytmicznej i inne typowe funkcje matematyczne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto kilka funkcje matematyczne i trygonometryczne z <xref:System.Math> klasy do obliczenia wewnętrzny kąty trapezu.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość bezwzględną podanej liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Liczby, która jest większa niż lub równa <see cref="F:System.Decimal.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Decimal.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby <see cref="T:System.Decimal" /> numer.</summary>
        <returns>Liczby dziesiętnej, x, że x ≤ 0 ≤<see cref="F:System.Decimal.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Decimal> jest jego wartość liczbową bez znaku. Na przykład wartość bezwzględna 1.2 i -1,2 jest 1.2.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Decimal%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Decimal> wartości.  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczby, która jest większa niż lub równa <see cref="F:System.Double.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Double.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczby zmiennoprzecinkowe podwójnej precyzji x, że x ≤ 0 ≤<see cref="F:System.Double.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Double> jest jego wartość liczbową bez znaku. Na przykład 1.2e03 ma wartość bezwzględna 1.2e03 i - 1.2e03.  
  
 Jeśli `value` jest równa <xref:System.Double.NegativeInfinity> lub <xref:System.Double.PositiveInfinity>, jest zwracana wartość <xref:System.Double.PositiveInfinity>. Jeśli `value` jest równa <xref:System.Double.NaN>, jest zwracana wartość <xref:System.Double.NaN>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Double%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Double> wartości.  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która jest większa niż <see cref="F:System.Int16.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int16.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>16-bitową liczbę całkowitą ze znakiem, x, że x ≤ 0 ≤<see cref="F:System.Int16.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Int16> jest jego wartość liczbową bez znaku. Na przykład 123 ma wartość bezwzględna 123 i-123.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int16%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int16> wartości.  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> Equals <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która jest większa niż <see cref="F:System.Int32.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby całkowita 32-bitowych.</summary>
        <returns>32-bitowe podpisane liczby całkowite, x, że x ≤ 0 ≤<see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Int32> jest jego wartość liczbową bez znaku. Na przykład 123 ma wartość bezwzględna 123 i-123.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int32%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int32> wartości.  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> Equals <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która jest większa niż <see cref="F:System.Int64.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Int64.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>64-bitowych podpisane liczby całkowite, x, że x ≤ 0 ≤<see cref="F:System.Int64.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Int64> jest jego wartość liczbową bez znaku. Na przykład 123 ma wartość bezwzględna 123 i-123.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Int64%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Int64> wartości.  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> Equals <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która jest większa niż <see cref="F:System.SByte.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.SByte.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby 8-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>8-bitową liczbę całkowitą ze znakiem, x, że x ≤ 0 ≤<see cref="F:System.SByte.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna bajtu ze znakiem jest jego wartość liczbową bez znaku. Na przykład 12 ma wartość bezwzględna 12 i -12.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.SByte%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.SByte> wartości.  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> Equals <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Liczby, która jest większa niż lub równa <see cref="F:System.Single.MinValue" />, ale mniejsze niż lub równe <see cref="F:System.Single.MaxValue" />.</param>
        <summary>Zwraca wartość bezwzględną liczby zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Liczba zmiennoprzecinkowa pojedynczej precyzji, x, że x ≤ 0 ≤<see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna <xref:System.Single> jest jego wartość liczbową bez znaku. Na przykład wartość bezwzględna zarówno 1.2e-03 i - 1.2e03 jest 1.2e03.  
  
 Jeśli `value` jest równa <xref:System.Single.NegativeInfinity> lub <xref:System.Single.PositiveInfinity>, jest zwracana wartość <xref:System.Single.PositiveInfinity>. Jeśli `value` jest równa <xref:System.Single.NaN>, jest zwracana wartość <xref:System.Single.NaN>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Abs%28System.Single%29> metodę, aby uzyskać wartość bezwzględną liczby <xref:System.Single> wartości.  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba reprezentująca cosinus, gdzie <c>d</c> musi być większa niż lub równy -1, ale mniejsze niż lub równa 1.</param>
        <summary>Zwraca kąt, którego cosinus jest równy podanej liczbie.</summary>
        <returns>Kąt, θ mierzony w radianach, tak, aby 0 ≤θ≤π  
  
 —lub—  
  
 <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> &lt; -1 lub <paramref name="d" /> &gt; 1 lub <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Acos%2A> metodę, aby ułatwić obliczenia wewnętrzny kąty danego Trapez.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba reprezentująca sinusa, gdzie <c>d</c> musi być większa niż lub równy -1, ale mniejsze niż lub równa 1.</param>
        <summary>Zwraca kąt, którego sinus jest równy podanej liczbie.</summary>
        <returns>Kąt, θ mierzony w radianach, tak, aby ≤θ≤π - π/2/2  
  
 —lub—  
  
 <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> &lt; -1 lub <paramref name="d" /> &gt; 1 lub <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodatnia wartość zwracany reprezentuje kątowi od osi x; zwracane wartości ujemnej reprezentuje kąt do ruchu wskazówek zegara.  
  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Asin%2A> ułatwiających obliczenia wewnętrzny kąty danego Trapez.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba reprezentująca stycznej.</param>
        <summary>Zwraca kąt, którego tangens jest równy podanej liczbie.</summary>
        <returns>Kąt, θ mierzony w radianach, tak, aby ≤θ≤π - π/2/2.  
  
 —lub—  
  
 <see cref="F:System.Double.NaN" /> Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" />, - π/2 zaokrąglana do podwójnej precyzji (-1.5707963267949), jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NegativeInfinity" />, lub π/2 zaokrąglana do podwójnej precyzji (1.5707963267949), jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodatnia wartość zwracany reprezentuje kątowi od osi x; zwracane wartości ujemnej reprezentuje kąt do ruchu wskazówek zegara.  
  
 Należy pomnożyć wartość zwracaną przez 180 /<xref:System.Math.PI?displayProperty=nameWithType> aby z radianów w stopniach.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób obliczania wartości arcus tangens i wyświetl ją do konsoli.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">Współrzędna y punktu.</param>
        <param name="x">Współrzędna x punktu.</param>
        <summary>Zwraca kąt, którego tangens jest równy ilorazowi dwóch podanych liczb.</summary>
        <returns>Kąt, θ mierzony w radianach, tak, aby - π≤θ≤π i tan(θ) = <paramref name="y" />  /  <paramref name="x" />, gdzie (<paramref name="x" />, <paramref name="y" />) jest punktem w płaszczyźnie kartezjański. Sprawdź następujące czynności:  
  
-   Aby uzyskać (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 1, 0 &lt; θ &lt; π/2.  
  
-   Aby uzyskać (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 2, π/2 &lt; θ≤π.  
  
-   Aby uzyskać (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 3, - π &lt; θ &lt; - π/2.  
  
-   Aby uzyskać (<paramref name="x" />, <paramref name="y" />) w wiązania kwadrantu 4, - π/2 &lt; θ &lt; 0.  
  
 Dla punktów na granice ćwiartkach zwracana wartość jest następująca:  
  
-   Jeśli y ma wartość 0 i x jest nie ujemną, θ = 0.  
  
-   Jeśli y wynosi 0 i x ma wartość ujemną, θ = π.  
  
-   Jeśli y jest dodatnia, jak i x ma wartość 0, θ = π/2.  
  
-   Jeśli y jest ujemna, a x ma wartość 0, θ = - π/2.  
  
-   Jeśli y wynosi 0 i x ma wartość 0, θ = 0.  
  
 Jeśli <paramref name="x" /> lub <paramref name="y" /> jest <see cref="F:System.Double.NaN" />, lub jeśli <paramref name="x" /> i <paramref name="y" /> są <see cref="F:System.Double.PositiveInfinity" /> lub <see cref="F:System.Double.NegativeInfinity" />, metoda zwraca <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana jest kąt płaszczyźnie kartezjański utworzone przez osi x i wektor uruchamianie ze źródła (0,0) oraz przerywanie punktu, (x, y).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób obliczania tangens kąta i wektora. Wartość wynikową jest wyświetlana w konsoli.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy liczbę Aby pomnożyć.</param>
        <param name="b">Druga liczba do wielokrotnie.</param>
        <summary>Zwraca pełny iloczyn dwóch liczb 32-bitowych.</summary>
        <returns>Liczba zawierający produktu podanych liczb.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Math.BigMul%2A> metodę obliczania iloczyn dwóch wartości całkowite.  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca najmniejszą wartość całkowitą, większa lub równa podanej liczbie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna.</param>
        <summary>Zwraca najmniejszą wartość całkowitą, która jest większa niż lub równa określonej liczby dziesiętnej.</summary>
        <returns>Najmniejsza wartość całkowitą, którą jest większa niż lub równa <paramref name="d" />. Należy pamiętać, że ta metoda zwraca <see cref="T:System.Decimal" /> zamiast typ całkowity.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność. Innymi słowy Jeśli `d` jest dodatnia, obecności dowolnej przyczyny ułamkowych części `d` ma zostać zaokrąglona do następną największą liczbę całkowitą. Jeśli `d` jest ujemna, zaokrąglania operacja powoduje dowolnego składnika ułamkowych `d` być odrzucony. Operacja ta metoda różni się od <xref:System.Math.Floor%28System.Decimal%29> metodę, która obsługuje zaokrąglania kierunku nieskończoności ujemnej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Floor%28System.Decimal%29> metody.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca najmniejszą wartość całkowitą, która jest większa niż lub równa podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Najmniejsza wartość całkowitą, którą jest większa niż lub równa <paramref name="a" />. Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość. Należy pamiętać, że ta metoda zwraca <see cref="T:System.Double" /> zamiast typ całkowity.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku plus nieskończoność. Innymi słowy Jeśli `a` jest dodatnia, obecności dowolnej przyczyny ułamkowych części `a` ma zostać zaokrąglona do następną największą liczbę całkowitą. Jeśli `a` jest ujemna, zaokrąglania operacja powoduje dowolnego składnika ułamkowych `a` być odrzucony. Operacja ta metoda różni się od <xref:System.Math.Floor%28System.Double%29> metodę, która obsługuje zaokrąglania kierunku nieskończoności ujemnej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Floor%28System.Double%29> metody.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Kąt wyrażony w radianach.</param>
        <summary>Zwraca cosinus odpowiadający podanemu kątowi.</summary>
        <returns>Cosinus <paramref name="d" />. Jeśli <paramref name="d" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `d`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
 Dopuszczalne wartości `d` z zakresu od około-9223372036854775295 do około 9223372036854775295. Dla wartości poza tym zakresem <xref:System.Math.Cos%2A> metoda zwraca `d` niezmienione zamiast zgłaszać wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Cos%2A> do oceny niektórych trygonometryczne tożsamości dla wybranych kątów.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Kąt wyrażony w radianach.</param>
        <summary>Zwraca cosinus hiperboliczny podanemu kątowi.</summary>
        <returns>Cosinus hiperboliczny liczby <paramref name="value" />. Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" /> lub <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> jest zwracany. Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `value`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Cosh%2A> do oceny niektórych hiperboliczny tożsamości dla wybranych wartości.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza iloraz dwóch liczb, a także zwraca resztę do parametru output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">Dzielna.</param>
        <param name="b">Dzielnik.</param>
        <param name="result">Pozostałe.</param>
        <summary>Oblicza iloraz dwóch liczb całkowitych ze znakiem 32-bitowe i również zwraca resztę do parametru output.</summary>
        <returns>Iloraz podanych liczb.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozostała jest obliczana przy użyciu operacji modułu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> metody.  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> wynosi zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">Dzielna.</param>
        <param name="b">Dzielnik.</param>
        <param name="result">Pozostałe.</param>
        <summary>Oblicza iloraz dwóch liczb całkowitych ze znakiem 64-bitowe i również zwraca resztę do parametru output.</summary>
        <returns>Iloraz podanych liczb.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozostała jest obliczana przy użyciu operacji modułu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> metody.  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> wynosi zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>Reprezentuje podstawa logarytmu naturalnego, określony przez wartość stałej, <see langword="e" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest 2.7182818284590452354.  
  
   
  
## Examples  
 Poniższy przykład porównuje <xref:System.Math.E> z wartością obliczoną na podstawie serii zasilania.  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba określająca potęgi.</param>
        <summary>Zwraca <see langword="e" /> podniesionej do potęgi określonej.</summary>
        <returns>Liczba <see langword="e" /> podniesionej do potęgi <paramref name="d" />. Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NaN" /> lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość. Jeśli <paramref name="d" /> jest równe <see cref="F:System.Double.NegativeInfinity" />, zwracany jest 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` jest stałe matematyczne, którego wartość wynosi około 2.71828.  
  
 Użyj <xref:System.Math.Pow%2A> metodę obliczania uprawnień innych typów podstawowych.  
  
 <xref:System.Math.Exp%2A> jest odwrotność <xref:System.Math.Log%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Exp%2A> do oceny niektórych wykładniczej i logarytmicznej tożsamości dla wybranych wartości.  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca największą wartość całkowitą mniejszą niż określona liczba.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna.</param>
        <summary>Zwraca największą wartość całkowitą mniejszą niż określona liczba dziesiętna.</summary>
        <returns>Całkowite największą wartość mniejsza lub równa <paramref name="d" />.  Należy pamiętać, że ta metoda zwraca wartość całkowitą typu <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność. Innymi słowy Jeśli `d` jest dodatnia, dowolny składnik ułamkowych zostały obcięte. Jeśli `d` jest ujemna, obecności ułamkowych części powoduje ona ma zostać zaokrąglona na mniejszą liczbę całkowitą. Operacja ta metoda różni się od <xref:System.Math.Ceiling%2A> metodę, która obsługuje zaokrąglania kierunku nieskończoności dodatniej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Ceiling%28System.Decimal%29> metody.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba zmiennoprzecinkowa podwójnej precyzji.</param>
        <summary>Zwraca największą wartość całkowitą mniejszą lub równą podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Całkowite największą wartość mniejsza lub równa <paramref name="d" />. Jeśli <paramref name="d" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, jest zwracana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tej metody jest zgodne ze standardem IEEE 754, sekcja 4. Tego rodzaju zaokrąglenie jest czasami nazywane zaokrąglaniem kierunku minus nieskończoność. Innymi słowy Jeśli `d` jest dodatnia, dowolny składnik ułamkowych zostały obcięte. Jeśli `d` jest ujemna, obecności ułamkowych części powoduje ona ma zostać zaokrąglona na mniejszą liczbę całkowitą. Operacja ta metoda różni się od <xref:System.Math.Ceiling%2A> metodę, która obsługuje zaokrąglania kierunku nieskończoności dodatniej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> metody różnic między go przy użyciu <xref:System.Math.Ceiling%28System.Double%29> metody.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Dzielna.</param>
        <param name="y">Dzielnik.</param>
        <summary>Zwraca resztę z dzielenia liczby określonej przez inną podany numer.</summary>
        <returns>Liczby równej <paramref name="x" /> -(<paramref name="y" /> Q), gdzie Q jest równy ilorazowi <paramref name="x" />  /  <paramref name="y" /> zaokrąglona do najbliższej liczby całkowitej (Jeśli <paramref name="x" />  /  <paramref name="y" /> znajduje się w połowie między dwie liczb całkowitych, parzystej liczby całkowitej zwrócił).  
  
 Jeśli <paramref name="x" /> -(<paramref name="y" /> Q) jest zero, wartość + 0 jest zwracany, jeśli <paramref name="x" /> jest dodatni lub — jeśli 0 <paramref name="x" /> jest ujemna.  
  
 Jeśli <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja jest zgodny z pozostałą operacji zdefiniowanej w sekcji 5.1 754-1985 ANSI/IEEE Std; Standard IEEE binarne arytmetyczne zmiennoprzecinkowe; Institute of prądu i Electronics Engineers, Inc.; 1985.  
  
 <xref:System.Math.IEEERemainder%2A> Metoda nie jest taka sama jak operator modulo. Mimo że zwrócą resztę po dzielenia formuły używane są różne. Formuła <xref:System.Math.IEEERemainder%2A> metoda jest:  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 Z kolei dla operatora modulo jest:  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 Poniższy przykład zachowanie różni się od pozostałej zwrócony przez <xref:System.Math.IEEERemainder%2A> metody pozostałych zwracanych przez operator dzielenie modulo.  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość logarytmu określonej liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="d" /> Parametr  
  
 </term><description> Wartość zwracana  
  
 </description></listheader><item><term> Dodatnią  
  
 </term><description> Logarytm naturalny <paramref name="d" />; oznacza to, ln <paramref name="d" />, lub dziennika e <paramref name="d" /></description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Ujemna  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Równa <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> równe <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `d` jest określony jako podstawowy numer 10.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Math.Log%2A> metody.  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Liczba, której logarytm ma zostać znaleziona.</param>
        <param name="newBase">Podstawa logarytmu.</param>
        <summary>Zwraca logarytm o określonej liczby w określonej podstawy.</summary>
        <returns>Jedna z wartości w tabeli poniżej. (+ Oznacza nieskończoność <see cref="F:System.Double.PositiveInfinity" />, - oznacza nieskończoność <see cref="F:System.Double.NegativeInfinity" />, i określa NaN <see cref="F:System.Double.NaN" />.)  
  
 <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Wartość zwracana  
  
 </description></listheader><item><term><paramref name="a" />&gt; 0  
  
 </term><description> (0 &lt; <paramref name="newBase" /> &lt; 1) - lub -(<paramref name="newBase" /> &gt; 1)  
  
 </description><description> lognewBase(a)  
  
 </description></item><item><term><paramref name="a" />&lt; 0  
  
 </term><description> (wartości)  
  
 </description><description> NaN  
  
 </description></item><item><term> (wartości)  
  
 </term><description><paramref name="newBase" />&lt; 0  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> != 1  
  
 </term><description><paramref name="newBase" /> = + Infinity  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> = NaN  
  
 </term><description> (wartości)  
  
 </description><description> NaN  
  
 </description></item><item><term> (wartości)  
  
 </term><description><paramref name="newBase" /> = NaN  
  
 </description><description> NaN  
  
 </description></item><item><term> (wartości)  
  
 </term><description><paramref name="newBase" /> = 1  
  
 </description><description> NaN  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description> + Infinity  
  
 </description></item><item><term><paramref name="a" /> = 0  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description> — Infinity  
  
 </description></item><item><term><paramref name="a" /> = + Infinity  
  
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1  
  
 </description><description> — Infinity  
  
 </description></item><item><term><paramref name="a" /> = + Infinity  
  
 </term><description><paramref name="newBase" />&gt; 1  
  
 </description><description> + Infinity  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" /> = 0  
  
 </description><description> 0  
  
 </description></item><item><term><paramref name="a" /> = 1  
  
 </term><description><paramref name="newBase" /> = + Infinity  
  
 </description><description> 0  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Log%2A> do oceny niektórych logarytmicznej tożsamości dla wybranych wartości.  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba, której logarytm ma zostać znaleziona.</param>
        <summary>Zwraca logarytm 10 podanej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="d" /> Parametr  
  
 </term><description> Wartość zwracana  
  
 </description></listheader><item><term> Dodatnią  
  
 </term><description> Dziennik podstawowej 10 <paramref name="d" />; Zaloguj się 10<paramref name="d" />.  
  
 </description></item><item><term> Zero  
  
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Ujemna  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Równa <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> równe <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `d` jest określony jako podstawowy numer 10.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Log10%2A> metoda zwraca logarytm 10 dla wybranych wartości.  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca większych dwóch podanych liczb.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca większy dwie liczb całkowitych bez znaku 8-bitową.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb dziesiętnych do porównania.</param>
        <param name="val2">Drugi dwóch liczb dziesiętnych do porównania.</param>
        <summary>Zwraca większych dwóch liczb dziesiętnych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb zmiennoprzecinkowych podwójnej precyzji do porównania.</param>
        <param name="val2">Drugi dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</param>
        <summary>Zwraca większych dwie liczb zmiennoprzecinkowych podwójnej precyzji.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy. Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca większego z dwóch 16-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 32-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwa 32-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca większego z dwóch 32-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca większego z dwóch 64-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca większego z dwóch 8-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="val2">Drugi dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca większych dwie liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy. Jeśli <paramref name="val1" />, lub <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca większy dwie liczb całkowitych bez znaku 16-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 32-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwa 32-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca większy dwie liczb całkowitych bez znaku 32-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca większy dwie liczb całkowitych bez znaku 64-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Max%2A> metody, aby wrócić i wyświetlić większa niż dwie zmienne.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca mniejszy z dwóch liczb.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 8-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb całkowitych bez znaku 8-bitową.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb dziesiętnych do porównania.</param>
        <param name="val2">Drugi dwóch liczb dziesiętnych do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb dziesiętnych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb zmiennoprzecinkowych podwójnej precyzji do porównania.</param>
        <param name="val2">Drugi dwie liczby zmiennoprzecinkowe podwójnej precyzji do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczby zmiennoprzecinkowe podwójnej precyzji.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza. Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 16-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca mniejszy z dwóch 16-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 32-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwa 32-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca mniejszy z dwóch 32-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 64-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca mniejszy z dwóch 64-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <param name="val2">Drugi dwóch 8-bitowych liczb całkowitych ze znakiem do porównania.</param>
        <summary>Zwraca mniejszy z dwóch 8-bitowych liczb całkowitych ze znakiem.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwsze dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <param name="val2">Drugi dwie liczb zmiennoprzecinkowych pojedynczej precyzji do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb zmiennoprzecinkowych pojedynczej precyzji.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza. Jeśli <paramref name="val1" />, <paramref name="val2" />, lub obie <paramref name="val1" /> i <paramref name="val2" /> są równe <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 16-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb całkowitych bez znaku 16-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 32-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwa 32-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb całkowitych bez znaku 32-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">Pierwszy z dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</param>
        <param name="val2">Drugi dwóch 64-bitowych liczb całkowitych bez znaku do porównania.</param>
        <summary>Zwraca mniejszy z dwóch liczb całkowitych bez znaku 64-bitowych.</summary>
        <returns>Parametr <paramref name="val1" /> lub <paramref name="val2" />, w zależności od jest mniejsza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Min%2A> metody, aby wrócić i wyświetlić mniejszy z dwóch zmiennych.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>Reprezentuje stosunek obwodu koło jego średnicy, określony przez wartość stałej, π.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest 3.14159265358979323846.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.PI> ułatwiających obliczenia wewnętrzny kąty danego Trapez.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Liczba zmiennoprzecinkowa podwójnej precyzji do podniesione do potęgi.</param>
        <param name="y">Liczba zmiennoprzecinkowe podwójnej precyzji, która określa potęgi.</param>
        <summary>Zwraca określoną liczbę podniesioną do wskazanej potęgi.</summary>
        <returns>Liczba <paramref name="x" /> podniesionej do potęgi <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono wartość zwracana, gdy określono dla różnych wartości lub wartości `x` i `y` parametrów. Aby uzyskać więcej informacji, zobacz <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
|Parametry|Wartość zwracana|  
|----------------|------------------|  
|`x` lub `y`  =  `NaN`.|`NaN`|  
|`x` = Wszystkie wartości z wyjątkiem `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` jest nieparzysta dodatnią liczbą całkowitą.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` jest dodatnia, ale nie nieparzystą liczbą całkowitą.|`PositiveInfinity`|  
|`x` < 0, ale nie `NegativeInfinity`; `y` nie jest liczbą całkowitą `NegativeInfinity`, lub `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y`  =  `NegativeInfinity` lub `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` < wartość -1 lub `x` > 1; `y` = `NegativeInfinity`.|0|  
|`x` < wartość -1 lub `x` > 1; `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` jest dowolną wartością, z wyjątkiem `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Pow%2A> metody do obliczenia wartości będące wynikiem wywoływanie 2 do potęgi od 0 do 32.  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zaokrągla wartość do najbliższej liczby całkowitej lub do określonej liczby cyfr ułamkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej sekcji:  
  
 [Przeciążona metoda składni](#Syntax)   
 [Parametry](#Params)   
 [Wartość zwracana](#Returns)   
 [Wyjątki](#Exceptions)   
 [Która metoda zostanie wywołana?](#Tasks)   
 [Środkowy wartości i konwencje zaokrąglania](#Midpoint)   
 [Zaokrąglanie i dokładność](#Precision)   
 [Zaokrąglania i pojedynczej precyzji wartości zmiennoprzecinkowych](#Single)   
 Przykłady:   
 [Math.Round(Decimal)](#Round1_Example)  
 [Math.Round(Double)](#Round2_Example)  
 [Math.round — (dziesiętna, Int32)](#Round3_Example)  
 [Math.round — (dziesiętna, MidpointRounding)](#Round4_Example)  
 [Math.round — (o podwójnej precyzji, Int32)](#Round5_Example)  
 [Math.round — (o podwójnej precyzji, MidpointRounding)](#Round6_Example)  
 [Math.round — (Decimal, Int32, MidpointRounding)](#Round7_Example)  
 [Math.round — (MidpointRounding o podwójnej precyzji, Int32)](#Round8_Example)  
[Informacje o wersji](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a>Przeciążona metoda składni  
 Aby uzyskać dodatkowe wskazówki dotyczące wybierania przeciążenia, zobacz [która metoda zostanie wywołana?](#Tasks)  
  
 `Decimal Math.Round(Decimal` `d` `)`  
 Powoduje zaokrąglenie do najbliższej liczby całkowitej wartości dziesiętnej, a punkt środkowy Zaokrągla do najbliższej parzystej liczby ([przykład](#Round1_Example)).  
  
 `Double Math.Round(Double` `a` `)`  
 Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round2_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`  
 Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round3_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `)`  
 Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji i zaokrągla środkowego do najbliższej parzystej liczby ([przykład](#Round4_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`  
 Powoduje zaokrąglenie do najbliższej liczby całkowitej wartość dziesiętna i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round5_Example)).  
  
 `Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`  
 Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round6_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`  
 Zaokrągla wartość dziesiętną do określonej liczby cyfr ułamkowych i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round7_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`  
 Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji i używa konwencji zaokrąglania określonej wartości punkt środkowy ([przykład](#Round8_Example)).  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametry  
 Jest to pełna lista parametrów <xref:System.Math.Round%2A> metody. Dla parametrów używanych przez każde przeciążenie, zobacz powyżej temat dotyczący składni przeciążenia.  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|Liczbę do zaokrąglenia.|  
|`a`<br /><br /> —lub—<br /><br /> `value`|<xref:System.Double>|Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.|  
|`decimals`<br /><br /> —lub—<br /><br /> `digits`|<xref:System.Int32>|Liczba cyfr ułamkowych w wartości zwracanej. Aby uzyskać <xref:System.Decimal> wartości, go może należeć do zakresu od 0 do 28. Aby uzyskać <xref:System.Double> wartości, go może należeć do zakresu od 0 do 15. Należy pamiętać, że 15 jest maksymalna liczba cyfr z zaokrągleń obsługiwane przez <xref:System.Double> typu.<br /><br /> Wartość domyślna: 0, co powoduje zaokrąglenie do liczby całkowitej.|  
|`mode`|<xref:System.MidpointRounding>|Flaga określająca Konwencji do użycia na potrzeby zaokrąglania środkowego wartości. Zobacz [wartości punkt środkowy i konwencje zaokrąglania](#Midpoint).<br /><br /> Wartość domyślna: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a>Wartość zwracana  
 Typ: <xref:System.Decimal> lub <xref:System.Double>, w zależności od typu wartości, które ma zostać zaokrąglona.   
Wartość numeryczna tego samego typu co `d`, `a`, lub `value`, ale zaokrąglone do liczby całkowitej lub do określonej liczby miejsc po przecinku. Zobacz [wartości punkt środkowy i konwencje zaokrąglania](#Midpoint) informacji o zaokrąglanie liczb z wartościami środkową.  
  
> [!WARNING]
>  Gdy zaokrąglanie wartości punkt środkowy, algorytm zaokrąglania wykonuje testu równości. Z powodu problemów binarna reprezentacja i dokładność format liczb zmiennoprzecinkowych może być nieoczekiwane wartość zwrócona przez metodę. Aby uzyskać więcej informacji, zobacz [zaokrąglanie i dokładność](#Precision).  
  
 Jeśli przeciążenia z <xref:System.Double> parametru jest wywoływana z <xref:System.Double.NaN?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>. Jeśli zostanie wywołany z <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>odpowiednio.  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Wyjątki  
  
|Wyjątek|Warunek|Generowane przez|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|Wynik jest poza zakresem <xref:System.Decimal> typu.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|`decimals` jest mniejsza niż 0 lub większą niż 28.<br /><br /> —lub—<br /><br /> `digits` jest mniejsza niż 0 lub większą niż 15.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|`mode` nie jest prawidłową wartością <xref:System.MidpointRounding>.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Jaką metodę wywołać?  
  
|Do|Wywołania|  
|--------|----------|  
|Zaokrągla liczbę do wartości całkowitej przy użyciu zaokrąglenie do najbliższej Konwencji.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> —lub—<br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|Zaokrąglij liczbę na liczbę całkowitą przy użyciu określonej zaokrąglania Konwencji.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> —lub—<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|Zaokrągla liczbę do określonej liczby cyfr ułamkowych przy użyciu zaokrąglenie do najbliższej Konwencji.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> —lub—<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|Zaokrąglij liczbę do określonej liczby cyfr ułamkowych przy użyciu określonej zaokrąglania Konwencji.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> —lub—<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|ROUND <xref:System.Single> wartości do określonej liczby cyfr ułamkowych przy użyciu określonego zaokrąglania Konwencji i minimalizując utratę dokładności.|Konwertuj <xref:System.Single> do <xref:System.Decimal> i Wywołaj <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.|  
|Zaokrągla liczbę do określonej liczby cyfr ułamkowych przy jednoczesnym zmniejszeniu problemów dokładności zaokrąglania środkowego wartości.|Wywołaj metodę zaokrąglania, która implementuje porównania "większe niż lub równa około". Zobacz [zaokrąglanie i dokładność](#Precision).|  
|Zaokrąglij wartość ułamkową, na liczbę całkowitą, która jest większa niż wartość ułamkową. Na przykład okrągłe 3.1 do 4.|<xref:System.Math.Ceiling%2A>|  
|Zaokrąglij wartość ułamkową, na liczbę całkowitą jest mniejsza niż wartość ułamkową. Na przykład okrągłe 3.9 do 3.|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a>Wartości punktu środkowego i konwencje zaokrąglania  
 Zaokrąglanie polega na konwertowaniu wartość liczbową z dokładnością do określonej do najbliższej wartości z mniej dokładności. Na przykład można użyć <xref:System.Math.Round%28System.Double%29> metody zostać zaokrąglona wartość 3.4 do 3.0 i <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> metody zostać zaokrąglona wartość 3,579 do 3.58.  
  
 Wartość środkowego wartość po najmniej znaczący cyfr w wyniku jest dokładnie połowy między dwiema liczbami. Na przykład 3.47500 jest wartość punkt środkowy, jeśli ma zostać zaokrąglona dwoma miejscami dziesiętnymi, a 7.500 jest wartością środkową, jeśli jest zaokrąglana do liczby całkowitej. W takich przypadkach najbliższej wartości nie można łatwo zidentyfikować bez konwencją zaokrąglania.  
  
 <xref:System.Math.Round%2A> Metoda obsługuje dwa konwencje zaokrąglania obsługi środkowego wartości:  
  
 **Zaokrąglanie w kierunku od zera.**  
 Środkowy wartości są zaokrąglane do następnej liczby w kierunku od zera. Na przykład 3,75 powoduje zaokrąglenie do 3.8, 3.85 zaokrąglenie do 3.9,-3.75 powoduje zaokrąglenie do-3.8, i-3.85 powoduje zaokrąglenie do-3.9. Ten formularz zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> element członkowski wyliczenia.  
  
 Zaokrąglanie w kierunku od zera jest powszechnie znane formularza zaokrąglania.  
  
 **Zaokrąglenie do najbliższej lub zaokrąglenie kwot**  
 Środkowy wartości są zaokrąglane do najbliższej parzystej liczby. Na przykład zarówno 3,75 i 3.85 zaokrąglona do 3.8, a jednocześnie-3.75 i-3.85 zaokrąglona do-3.8. Ten formularz zaokrąglania jest reprezentowana przez <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> element członkowski wyliczenia.  
  
 Zaokrąglenie do najbliższej to standardowy formularz zaokrąglania w operacjach finansowych i statystycznych. Odpowiada 754 Standard IEEE, sekcji 4. W wielu operacjach zaokrąglania powoduje zmniejszenie zaokrąglania błąd jest spowodowany przez spójnie zaokrąglanie wartości punkt środkowy w jednym kierunku. W niektórych przypadkach może być istotne ten błąd zaokrąglania.  
  
 Poniższy przykład przedstawia odchylenia, które mogą być wynikiem spójnie zaokrąglanie wartości punkt środkowy w jednym kierunku. Przykład oblicza średnią wartość true tablicy <xref:System.Decimal> wartości, a następnie oblicza średnią po wartości w tablicy są zaokrąglane przy użyciu dwóch Konwencji. W tym przykładzie średnią wartość true i oznaczają, że gdy zaokrąglenie do najbliższej są takie same. Jednak oznaczają, że gdy zaokrąglania w kierunku od zera różni się o.05 (lub 3,6%) z średnią wartość true.  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 Domyślnie <xref:System.Math.Round%2A> metoda używa zaokrąglenie do najbliższej Konwencji. W poniższej tabeli wymieniono przeciążeń <xref:System.Math.Round%2A> — metoda i zaokrąglania Konwencji każda używa.  
  
|Przeciążenia|Zaokrąglanie Konwencji|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|Ustaleniami `mode` parametru.|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|Ustaleniami `mode` parametru|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|Ustaleniami `mode` parametru|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|Ustaleniami `mode` parametru|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a>Zaokrąglenia i dokładność  
 W celu ustalenia, czy operacja zaokrąglania obejmuje wartością środkową <xref:System.Math.Round%2A> metody mnoży oryginalna wartość ma zostać zaokrąglona przez 10<sup>n</sup>, gdzie *n* jest odpowiednią liczbę ułamkowych cyfr w zwracanej wartości, a następnie określa, czy pozostałej części ułamkowych wartość jest większa niż lub równa.5. Jest to niewielkie zmiany w teście równości i jak opisano w sekcji "Testowania dla równości" <xref:System.Double> temat referencyjny testy równości z wartości zmiennoprzecinkowych mogą powodować problemy ze względu na format zmiennoprzecinkowy problemy z plikiem binarnym Reprezentacja i dokładność. Oznacza to, że wszystkie ułamkową część liczby, która może nieco przekraczać.5 (ze względu na zmniejszenie precyzji) nie są zaokrąglane w górę.  
  
 Poniższy przykład ilustruje ten problem. Wielokrotnie dodaje.1 do 11.0 i zaokrągla wynik do najbliższej liczby całkowitej. Niezależnie od konwencji zaokrąglania 11.5 powinien zaokrąglona do 12. Jednak jako dane wyjściowe w przykładzie pokazano, nie. W przykładzie użyto "R" [ciągu standardowego formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) do wyświetlenia zmiennoprzecinkowy pełnej dokładności wartości i pokazuje, że wartość ma zostać zaokrąglona utracił dokładności podczas powtarzane dodatków i jej wartość jest rzeczywiście 11.499999999999998. Ponieważ.499999999999998 jest mniejsza niż.5, wartość nie jest zaokrąglana do następną największą liczbę całkowitą. Jako przykład przedstawiono również, ten problem nie występuje, jeśli firma Microsoft po prostu Przypisz wartości stałej 11.5 do <xref:System.Double> zmiennej.  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 Problemy dokładności zaokrąglania środkowego wartości są najbardziej prawdopodobne w następujących warunkach:  
  
-   Jeśli wartość ułamkową, nie można wyrazić dokładnie w formacie binarnym typie zmiennoprzecinkowym.  
  
-   Gdy ma zostać zaokrąglona wartość jest obliczana na podstawie jednego lub więcej operacji zmiennoprzecinkowych.  
  
-   Gdy ustawiona wartość ma zostać zaokrąglona to <xref:System.Single> zamiast <xref:System.Double> lub <xref:System.Decimal>. Aby uzyskać więcej informacji, zobacz następną sekcję, [zaokrąglanie i wartości zmiennoprzecinkowych pojedynczej precyzji](#Single).  
  
 W przypadku braku dokładności zaokrąglając operacji problem należy wykonać następujące:  
  
-   Jeśli zaokrąglania operacji wywołania przeciążenia, które zaokrągla <xref:System.Double> wartości, można zmienić <xref:System.Double> do <xref:System.Decimal> wartości i wywoływać przeciążenia zaokrągla <xref:System.Decimal> jest wartość. Mimo że <xref:System.Decimal> — typ danych ma również problemy z reprezentacji i zmniejszenie precyzji, te problemy występują znacznie mniej.  
  
-   Zdefiniuj niestandardowe algorytm zaokrąglania, który przeprowadza test "prawie równe", aby określić, czy wartość ma zostać zaokrąglona prawidłowo jest blisko wartości punkt środkowy. W poniższym przykładzie zdefiniowano `RoundApproximate` metodę, która sprawdza, czy wartość ułamkową jest wystarczająco blisko wartość środkowego podlegać zaokrąglania punkt środkowy. Jak dane wyjściowe w przykładzie pokazano, rozwiązuje problem zaokrąglania w poprzednim przykładzie.  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a>Zaokrąglenia i pojedyncza precyzja wartości zmiennoprzecinkowych  
 <xref:System.Math.Round%2A> Metoda zawiera przeciążenia, które akceptują argumentów typu <xref:System.Decimal> i <xref:System.Double>. Metodami nie zaokrąglanie wartości typu <xref:System.Single>. W przypadku przekazania <xref:System.Single> wartość do jednego z przeciążeń <xref:System.Math.Round%2A> metody jest rzutowanie (C#) lub przekonwertować (w języku Visual Basic) <xref:System.Double>i odpowiadający mu <xref:System.Math.Round%2A> przeciążenia z <xref:System.Double> nosi nazwę parametru. Choć to konwersję rozszerzającą często spowodowałoby utratę dokładności, jak pokazano w poniższym przykładzie. Gdy <xref:System.Single> wartość 16.325 jest przekazywana do <xref:System.Math.Round%2A> — metoda i zaokrąglona do dwóch miejsc po przecinku przy użyciu zaokrąglenie do najbliższej Konwencji, wynikiem jest wynik 16.33 i nie oczekiwano 16.32.  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 Jest to nieoczekiwany wynik z powodu utraty dokładności konwersji <xref:System.Single> do wartości <xref:System.Double>. Ponieważ powstałe w ten sposób <xref:System.Double> wartość 16.325000762939453 nie jest wartością środkową i jest większy niż 16.325, jest zawsze zaokrąglona w górę.  
  
 W wielu przypadkach, jak pokazano w przykładzie utratę dokładności można zminimalizowane lub usunięte przez rzutowania lub konwersji <xref:System.Single> do wartości <xref:System.Decimal>. Należy pamiętać, że, ponieważ jest to konwersji zawężającej, wymaga przy użyciu operatora rzutowania lub wywołanie metody konwersji.  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a>Przykład Math.Round(Decimal)  
 W poniższym przykładzie pokazano <xref:System.Math.Round%28System.Decimal%29> metody. Należy pamiętać, że <xref:System.Decimal> wartość 4.5 powoduje zaokrąglenie do 4, a nie 5, ponieważ to przeciążenie używa domyślnej <xref:System.MidpointRounding.ToEven> Konwencji.  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a>Przykład Math.Round(Double)  
 W poniższym przykładzie pokazano zaokrąglenie do najbliższej wartości całkowitej.  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a>Przykład Math.Round (Decimal, Int32)  
 Poniższy przykład powoduje zaokrąglenie wartości dziesiętnych z dwóch cyfr ułamkowych do wartości, które mają pojedynczą cyfrą ułamkową.  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a>Przykład Math.Round (podwójny, Int32)  
 Poniższy przykład zaokrągla dwa razy z dwóch cyfr ułamkowych na symulacyjnych mające pojedynczą cyfrą ułamkową.  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a>Przykład Math.Round (Decimal, MidpointRounding)  
 W poniższym przykładzie przedstawiono wartości zwracanych przez <xref:System.Math.Round%28System.Decimal%29> metody <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.ToEven>i <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a>Przykład Math.Round (Double, MidpointRounding)  
 W poniższym przykładzie przedstawiono wartości zwracanych przez <xref:System.Math.Round%28System.Double%29> metody <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.ToEven>i <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> metody z `mode` argument <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a>Przykład Math.Round (Decimal, Int32, MidpointRounding)  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Round%2A> metody z <xref:System.MidpointRounding> wyliczenia.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a>Przykład Math.Round (Double, Int32, MidpointRounding)  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> metody z <xref:System.MidpointRounding> wyliczenia.  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a>Informacje o wersji  
 .NET Framework  
 Overloads bez <xref:System.MidpointRounding> parametru są obsługiwane w: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
Overloads z <xref:System.MidpointRounding> parametru są obsługiwane w: 4.5, 4, 3.5, 3.0, 2.0  
  
 .NET Framework Client Profile  
 Wszystkie przeciążenia są obsługiwane w wersjach: 4, 3.5 z dodatkiem SP1  
  
 Biblioteka klas przenośnych  
 Obsługiwane są wszystkie przeciążenia  
  
 Środowisko .NET dla aPLikacji do Sklepu Windows  
 Wszystkie przeciążenia są obsługiwane w systemie Windows 8  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna ma zostać zaokrąglona.</param>
        <summary>Zaokrągla wartość dziesiętną do najbliższej wartości całkowitej.</summary>
        <returns>Liczba całkowita najbliższej parametru <paramref name="d" />. Jeśli część ułamkowa <paramref name="d" /> jest w połowie między i innych nietypowych dwie liczb całkowitych, z których jeden jest parzysta, zwracany jest parzystą liczbą. Należy pamiętać, że ta metoda zwraca <see cref="T:System.Decimal" /> zamiast typ całkowity.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</param>
        <summary>Powoduje zaokrąglenie do najbliższej wartości całkowitych wartości zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba całkowita najbliższej <paramref name="a" />. Jeśli część ułamkowa <paramref name="a" /> jest w połowie między dwie liczb całkowitych, z których jeden jest parzysta i innych nietypowych, zwracana jest parzystą liczbą. Należy pamiętać, że ta metoda zwraca <see cref="T:System.Double" /> zamiast typ całkowity.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej liczby całkowitej. W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa.1 nie ma skończonego binarne reprezentacji, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metoda o wartości 11.5 zwraca 11 zamiast 12.  
  
 [!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)]
 [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna ma zostać zaokrąglona.</param>
        <param name="decimals">Liczba miejsc dziesiętnych w wartości zwracanej.</param>
        <summary>Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości dziesiętnej.</summary>
        <returns>Liczba najbliżej do <paramref name="d" /> zawierający liczba cyfr ułamkowych równa <paramref name="decimals" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> jest mniejsza niż 0 lub większą niż 28.</exception>
        <exception cref="T:System.OverflowException">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna ma zostać zaokrąglona.</param>
        <param name="mode">Specyfikacja sposobu zaokrąglona <c>d</c> przypadku pośrodku dwie inne liczby.</param>
        <summary>Zaokrągla wartość dziesiętną do najbliższej liczby całkowitej. Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</summary>
        <returns>Liczba całkowita najbliższej <paramref name="d" />. Jeśli <paramref name="d" /> następnie jest w połowie między dwóch liczb, z których jeden jest parzysta i innych nietypowych <paramref name="mode" /> określa dwóch zwrócony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</param>
        <param name="digits">Liczba cyfr ułamkowych w wartości zwracanej.</param>
        <summary>Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba najbliżej do <paramref name="value" /> zawierający liczba cyfr ułamkowych równa <paramref name="digits" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> jest mniejsza niż 0 lub większą niż 15.</exception>
        <block subset="none" type="usage">
          <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.Int32)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej wartości w <paramref name="digits" /> dziesiętnego. Jest to zilustrowane w poniższym przykładzie, w którym 2.135 jest zaokrąglana do 2.13 zamiast 2.14. Dzieje się tak dlatego wewnętrznie mnoży metody <paramref name="value" /> przez 10<sup>cyfr</sup>, i operacja mnożenia w takim przypadku odczuwa utratę dokładności.  
  
 [!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)]
 [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</param>
        <param name="mode">Specyfikacja sposobu zaokrąglona <c>wartość</c> przypadku pośrodku dwie inne liczby.</param>
        <summary>Zaokrągla wartość zmiennoprzecinkową podwójnej precyzji dla najbliższej liczby całkowitej. Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</summary>
        <returns>Liczba całkowita najbliższej <paramref name="value" />. Jeśli <paramref name="value" /> następnie jest w połowie między dwie liczb całkowitych, z których jeden jest parzysta i innych nietypowych <paramref name="mode" /> określa dwóch zwrócony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> zostać zaokrąglona środkowego wartości nie może występować — metoda najbliższej parzystej liczby całkowitej. W poniższym przykładzie, ponieważ wartość zmiennoprzecinkowa.1 nie ma skończonego binarne reprezentacji, pierwsze wywołanie <see cref="M:System.Math.Round(System.Double)" /> metoda o wartości 11.5 zwraca 11 zamiast 12.  
  
 [!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)]
 [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Liczba dziesiętna ma zostać zaokrąglona.</param>
        <param name="decimals">Liczba miejsc dziesiętnych w wartości zwracanej.</param>
        <param name="mode">Specyfikacja sposobu zaokrąglona <c>d</c> przypadku pośrodku dwie inne liczby.</param>
        <summary>Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości dziesiętnej. Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</summary>
        <returns>Liczba najbliżej do <paramref name="d" /> zawierający liczba cyfr ułamkowych równa <paramref name="decimals" />. Jeśli <paramref name="d" /> ma mniejszą liczbę cyfr ułamkowych niż <paramref name="decimals" />, <paramref name="d" /> zwróceniu niezmieniona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> jest mniejsza niż 0 lub większą niż 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">Wynik jest poza zakresem <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zmiennoprzecinkowa podwójnej precyzji, która ma zostać zaokrąglona.</param>
        <param name="digits">Liczba cyfr ułamkowych w wartości zwracanej.</param>
        <param name="mode">Specyfikacja sposobu zaokrąglona <c>wartość</c> przypadku pośrodku dwie inne liczby.</param>
        <summary>Zaokrągla liczbę do określonej liczby cyfr ułamkowych wartości zmiennoprzecinkowej podwójnej precyzji. Parametr określa sposób zaokrąglania wartości, jeśli jest w połowie między dwiema liczbami.</summary>
        <returns>Liczba najbliżej do <paramref name="value" /> mający liczba cyfr ułamkowych równa <paramref name="digits" />. Jeśli <paramref name="value" /> ma mniejszą liczbę cyfr ułamkowych niż <paramref name="digits" />, <paramref name="value" /> zwróceniu niezmieniona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Przykłady i informacje o użyciu kompleksowe dotyczących tego i innych przeciążeń `Round` metody, zobacz <xref:System.Math.Round%2A> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> jest mniejsza niż 0 lub większą niż 15.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> nie jest prawidłową wartością <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Ze względu na zmniejszenie precyzji, która może wynikać z reprezentujący wartości dziesiętnej jako liczby zmiennoprzecinkowe lub wykonywanie operacji arytmetycznych na wartości zmiennoprzecinkowe w niektórych przypadkach <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> zostać zaokrąglona środkowego wartości określonych nie może występować — metoda przez <paramref name="mode" /> parametru. Jest to zilustrowane w poniższym przykładzie, w którym 2.135 jest zaokrąglana do 2.13 zamiast 2.14. Dzieje się tak dlatego wewnętrznie mnoży metody <paramref name="value" /> przez 10<sup>cyfr</sup>, i operacja mnożenia w takim przypadku odczuwa utratę dokładności.  
  
 [!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)]
 [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Podpisem liczbą dziesiętną.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak liczby dziesiętnej.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Decimal%29> metodę, aby określić znak <xref:System.Decimal> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Double%29> metodę, aby określić znak <xref:System.Double> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int16%29> metodę, aby określić znak <xref:System.Int16> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak całkowita 32-bitowych.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int32%29> metodę, aby określić znak <xref:System.Int32> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Int64%29> metodę, aby określić znak <xref:System.Int64> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak 8-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.SByte%29> metodę, aby określić znak <xref:System.SByte> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Liczba oznaczona.</param>
        <summary>Zwraca liczbę całkowitą, która wskazuje znak liczby zmiennoprzecinkowej pojedynczej precyzji.</summary>
        <returns>Liczba, która określa znak <paramref name="value" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Znaczenie  
  
 </description></listheader><item><term> -1  
  
 </term><description><paramref name="value" /> jest mniejsza od zera.  
  
 </description></item><item><term> 0  
  
 </term><description><paramref name="value" /> jest równa zero.  
  
 </description></item><item><term> 1  
  
 </term><description><paramref name="value" /> jest większa niż zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Math.Sign%28System.Single%29> metodę, aby określić znak <xref:System.Single> wartość i wyświetl ją do konsoli.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> jest równa <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Kąt wyrażony w radianach.</param>
        <summary>Zwraca sinus określonego kąta.</summary>
        <returns>Sinus <paramref name="a" />. Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `a`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
 Dopuszczalne wartości `a` z zakresu od około-9223372036854775295 do około 9223372036854775295. Dla wartości poza tym zakresem <xref:System.Math.Sin%2A> metoda zwraca `a` niezmienione zamiast zgłaszać wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Sin%2A> do oceny niektórych trygonometryczne tożsamości dla wybranych kątów.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Kąt wyrażony w radianach.</param>
        <summary>Zwraca sinus hiperboliczny podanemu kątowi.</summary>
        <returns>Sinus hiperboliczny <paramref name="value" />. Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, lub <see cref="F:System.Double.NaN" />, ta metoda zwraca <see cref="T:System.Double" /> równa <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `value`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Sinh%2A> do oceny niektórych hiperboliczny tożsamości dla wybranych wartości.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba, której pierwiastek kwadratowy ma zostać znaleziona.</param>
        <summary>Zwraca pierwiastek kwadratowy z podanej liczby.</summary>
        <returns>Jedna z wartości w tabeli poniżej.  
  
 <list type="table"><listheader><term><paramref name="d" /> Parametr  
  
 </term><description> Wartość zwracana  
  
 </description></listheader><item><term> Zero lub dodatnie  
  
 </term><description> Dodatnia pierwiastek kwadratowy liczby <paramref name="d" />.  
  
 </description></item><item><term> Ujemna  
  
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equals <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> jest równe <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Pierwiastek kwadratowy obszaru kwadrat reprezentuje długość boków kwadratu. Poniższy przykład przedstawia obszaru niektórych miastach w Stanach Zjednoczonych i daje wyobrażenie o rozmiarze każdemu miastu, jeśli były reprezentowane przez kwadrat.  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Kąt wyrażony w radianach.</param>
        <summary>Zwraca tangens odpowiadający podanemu kątowi.</summary>
        <returns>Tangens <paramref name="a" />. Jeśli <paramref name="a" /> jest równa <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `a`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób Oblicz tangens kąta i wyświetl ją do konsoli.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Kąt wyrażony w radianach.</param>
        <summary>Zwraca tangens hiperboliczny podanemu kątowi.</summary>
        <returns>Tangens hiperboliczny liczby <paramref name="value" />. Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NegativeInfinity" />, ta metoda zwraca wartość -1. Jeśli wartość jest równa <see cref="F:System.Double.PositiveInfinity" />, ta metoda zwraca wartość 1. Jeśli <paramref name="value" /> jest równa <see cref="F:System.Double.NaN" />, ta metoda zwraca <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kąt `value`, musi być podany w radianach. Mnożenie przez <xref:System.Math.PI?displayProperty=nameWithType>/180 do Konwertuj stopnie na radiany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Math.Tanh%2A> do oceny niektórych tangens hiperboliczny tożsamości wybranych wartości.  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza integralną część liczby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba jest zaokrąglana do najbliższej liczby całkowitej w kierunku zera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Liczba obcięcia.</param>
        <summary>Oblicza integralną częścią określony liczbą dziesiętną.</summary>
        <returns>Integralną częścią <paramref name="d" />; oznacza to, liczba który pozostaje po wszelkich cyfr ułamkowych zostały odrzucone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A> Zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Math.Truncate%28System.Decimal%29> metody obcięcia zarówno pozytywnych i ujemny <xref:System.Decimal> wartość.  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Liczba obcięcia.</param>
        <summary>Oblicza integralną częścią podanej liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Integralną częścią <paramref name="d" />; oznacza to, liczba który pozostaje po wszelkich cyfr ułamkowych zostały odrzucone lub jedna z wartości wymienionych w poniższej tabeli.  
  
 <list type="table"><listheader><term><paramref name="d" /></term><description> Wartość zwracana  
  
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A> Zaokrągla `d` do najbliższej liczby całkowitej w kierunku zera.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Math.Truncate%28System.Double%29> metody obcięcia zarówno pozytywnych i ujemny <xref:System.Double> wartość.  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>